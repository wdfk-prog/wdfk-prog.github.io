<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>gpio | wdfk-prog的个人博客</title><meta name="author" content="Liya Huang"><meta name="copyright" content="Liya Huang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[TOC] drivers&#x2F;gpio GPIO子系统(General Purpose Input&#x2F;Output) 内核与硬件I&#x2F;O引脚交互的通用框架历史与背景这项技术是为了解决什么特定问题而诞生的？GPIO（通用输入&#x2F;输出）子系统是为了在Linux内核中创建一个统一、抽象、可移植的框架来管理和控制硬件的GPIO引脚而诞生的。 在此框架出现之前，对GPIO的操">
<meta property="og:type" content="article">
<meta property="og:title" content="gpio">
<meta property="og:url" content="https://wdfk-prog.space/posts/ba76d4d1/index.html">
<meta property="og:site_name" content="wdfk-prog的个人博客">
<meta property="og:description" content="[TOC] drivers&#x2F;gpio GPIO子系统(General Purpose Input&#x2F;Output) 内核与硬件I&#x2F;O引脚交互的通用框架历史与背景这项技术是为了解决什么特定问题而诞生的？GPIO（通用输入&#x2F;输出）子系统是为了在Linux内核中创建一个统一、抽象、可移植的框架来管理和控制硬件的GPIO引脚而诞生的。 在此框架出现之前，对GPIO的操">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wdfk-prog.space/images/covers/08.jpg">
<meta property="article:published_time" content="2025-10-03T01:01:49.000Z">
<meta property="article:modified_time" content="2025-10-03T09:23:28.173Z">
<meta property="article:author" content="Liya Huang">
<meta property="article:tag" content="drivers">
<meta property="article:tag" content="linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wdfk-prog.space/images/covers/08.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "gpio",
  "url": "https://wdfk-prog.space/posts/ba76d4d1/",
  "image": "https://wdfk-prog.space/images/covers/08.jpg",
  "datePublished": "2025-10-03T01:01:49.000Z",
  "dateModified": "2025-10-03T09:23:28.173Z",
  "author": [
    {
      "@type": "Person",
      "name": "Liya Huang",
      "url": "https://github.com/wdfk-prog"
    }
  ]
}</script><link rel="shortcut icon" href="/images/favicon.png"><link rel="canonical" href="https://wdfk-prog.space/posts/ba76d4d1/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//static.cloudflareinsights.com"/><link rel="preconnect" href="//www.clarity.ms"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxxxxx"/><meta name="baidu-site-verification" content="xxxxxxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-3978542742563797',
  enable_page_level_ads: 'true'
});</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?3c49dd4913ab43efb1bfc8d12b1cded9";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-PF2CVP2PL4"></script><script>window.dataLayer = window.dataLayer || []
function gtag(){dataLayer.push(arguments)}
gtag('js', new Date())
gtag('config', 'G-PF2CVP2PL4')
btf.addGlobalFn('pjaxComplete', () => {
  gtag('config', 'G-PF2CVP2PL4', {'page_path': window.location.pathname})
}, 'google_analytics')
</script><script defer="defer" data-pjax="data-pjax" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;17ff914b5e28493597b7dc19f3356022&quot;}"></script><script>(function(c,l,a,r,i,t,y){
    c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
    t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
    y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
})(window, document, "clarity", "script", "tkaenn1tjv");
</script><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
"https://www.googletagmanager.com/gtm.js?id="+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-MF3J339H');
btf.addGlobalFn('pjaxComplete', () => {
  dataLayer.push({'event': 'pjaxComplete', 'page_title': document.title, 'page_location': location.href, 'page_path': window.location.pathname})
}, 'google_tag_manager')</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":false,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'gpio',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.0.0"><link rel="alternate" href="/atom.xml" title="wdfk-prog的个人博客" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (true) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(/images/subtle-texture.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/avatar.png" onerror="this.onerror=null;this.src='/images/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">417</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">49</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">53</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book-open"></i><span> 页面</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fas fa-quote-left"></i><span> 说说</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 示例</span></a></li></ul></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/songs/"><i class="fa-fw fas fa-music"></i><span> 歌曲</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/images/covers/08.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/my-logo.png" alt="Logo"><span class="site-name">wdfk-prog的个人博客</span></a><a class="nav-page-title" href="/"><span class="site-name">gpio</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book-open"></i><span> 页面</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fas fa-quote-left"></i><span> 说说</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 示例</span></a></li></ul></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/songs/"><i class="fa-fw fas fa-music"></i><span> 歌曲</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">gpio<a class="post-edit-link" href="null_posts/linux/drivers/gpio.md" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-10-03T01:01:49.000Z" title="发表于 2025-10-03 09:01:49">2025-10-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-03T09:23:28.173Z" title="更新于 2025-10-03 17:23:28">2025-10-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/linux/">linux</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/linux/drivers/">drivers</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">51.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>182分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/ba76d4d1/#post-comment"><span class="gitalk-comment-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;已经过了&quot;,&quot;messageNext&quot;:&quot;自上次更新以来，文章的内容可能已经过时&quot;,&quot;postUpdate&quot;:&quot;2025-10-03 17:23:28&quot;}" hidden></div><p>[TOC]</p>
<h1 id="drivers-gpio-GPIO子系统-General-Purpose-Input-Output-内核与硬件I-O引脚交互的通用框架"><a href="#drivers-gpio-GPIO子系统-General-Purpose-Input-Output-内核与硬件I-O引脚交互的通用框架" class="headerlink" title="drivers&#x2F;gpio GPIO子系统(General Purpose Input&#x2F;Output) 内核与硬件I&#x2F;O引脚交互的通用框架"></a>drivers&#x2F;gpio GPIO子系统(General Purpose Input&#x2F;Output) 内核与硬件I&#x2F;O引脚交互的通用框架</h1><h3 id="历史与背景"><a href="#历史与背景" class="headerlink" title="历史与背景"></a>历史与背景</h3><h4 id="这项技术是为了解决什么特定问题而诞生的？"><a href="#这项技术是为了解决什么特定问题而诞生的？" class="headerlink" title="这项技术是为了解决什么特定问题而诞生的？"></a>这项技术是为了解决什么特定问题而诞生的？</h4><p>GPIO（通用输入&#x2F;输出）子系统是为了在Linux内核中创建一个<strong>统一、抽象、可移植的框架</strong>来管理和控制硬件的GPIO引脚而诞生的。 在此框架出现之前，对GPIO的操作是混乱且与平台高度绑定的。每个SoC（片上系统）或主板都有自己独特的GPIO控制方式，驱动程序必须编写大量特定于硬件的代码才能操作一个引脚。</p>
<p>该子系统的诞生解决了以下核心问题：</p>
<ul>
<li><strong>消除平台特定代码</strong>：为内核提供一个标准的API，使得驱动程序（称为“消费者”）可以不用关心底层GPIO控制器（称为“提供者”或<code>gpio_chip</code>）的具体实现，就能请求、配置和读写一个GPIO引脚。</li>
<li><strong>资源管理与冲突避免</strong>：一个GPIO引脚在系统中是独占性资源。 该框架提供了一套请求（<code>request</code>）和释放（<code>free</code>）机制，确保一个引脚在同一时间只能被一个驱动程序使用，从而避免了硬件冲突。</li>
<li><strong>抽象硬件差异</strong>：不同的GPIO控制器功能各异（例如，有些支持中断，有些支持开漏&#x2F;开源配置等）。GPIO子系统通过统一的接口抽象了这些差异，为上层驱动提供了一致的行为。</li>
<li><strong>与设备树集成</strong>：随着设备树（Device Tree）的普及，GPIO子系统需要一种方法来解析设备树中描述的GPIO连接关系，使得驱动程序能够动态地获取其所需的引脚，而不是在代码中硬编码。</li>
</ul>
<h4 id="它的发展经历了哪些重要的里程碑或版本迭代？"><a href="#它的发展经历了哪些重要的里程碑或版本迭代？" class="headerlink" title="它的发展经历了哪些重要的里程碑或版本迭代？"></a>它的发展经历了哪些重要的里程碑或版本迭代？</h4><p>GPIO子系统的发展经历了从简单的数字命名空间到更安全、更强大的描述符模型的演进。</p>
<ul>
<li><strong>早期的整数命名空间（Legacy API）</strong>：最初，所有GPIO引脚都被映射到一个全局的、从0开始的整数命名空间中。 驱动通过一个整数（如 <code>gpio_request(23, ...)</code>）来请求引脚。这种方式的主要缺点是：<ul>
<li><strong>脆弱性</strong>：GPIO编号不是稳定的，它会因为内核配置或硬件平台的改变而改变，导致代码不可移植。</li>
<li><strong>不安全</strong>：任何驱动都可以伪造一个整数来尝试控制一个它不拥有的引-脚。</li>
</ul>
</li>
<li><strong>描述符接口的引入（Descriptor-based API）</strong>：这是一个决定性的里程碑。新的API不再使用不稳定的全局整数，而是引入了一个不透明的句柄——<code>struct gpio_desc *</code>（GPIO描述符）。<ul>
<li>驱动程序必须通过 <code>gpiod_get()</code> 等函数从设备（<code>struct device</code>）或通过设备树获取描述符。</li>
<li>这种方式更安全，因为描述符不能被伪造，并且其生命周期由内核管理。</li>
<li>它还更好地处理了“低电平有效”（active-low）的逻辑，驱动可以设置或读取逻辑值（0&#x2F;1），而由框架来处理物理电平的翻转。</li>
<li>所有新的内核驱动都被强烈推荐使用这个以 <code>gpiod_*</code> 为前缀的新接口。</li>
</ul>
</li>
<li><strong>用户空间接口的演进</strong>：<ul>
<li><strong>Sysfs接口（已废弃）</strong>：早期提供了一个通过<code>/sys/class/gpio</code>的接口，允许用户空间通过读写文件来控制GPIO。该接口因其效率低下、设计缺陷以及与旧的整数模型绑定等原因，从Linux 4.8版本开始被<strong>废弃</strong>。</li>
<li><strong>字符设备接口（Chardev ABI）</strong>：为了取代sysfs，内核引入了一个基于字符设备（<code>/dev/gpiochipN</code>）的新用户空间接口。 它更高效（可以通过一次<code>ioctl</code>调用操作多个引脚）、更安全（资源生命周期与文件句柄绑定），并由<code>libgpiod</code>库提供了易于使用的封装。</li>
</ul>
</li>
</ul>
<h4 id="目前该技术的社区活跃度和主流应用情况如何？"><a href="#目前该技术的社区活跃度和主流应用情况如何？" class="headerlink" title="目前该技术的社区活跃度和主流应用情况如何？"></a>目前该技术的社区活跃度和主流应用情况如何？</h4><p>GPIO子系统是所有嵌入式Linux系统和许多服务器硬件平台的核心基础组件。它非常稳定，但仍在积极维护以支持新的硬件特性。</p>
<ul>
<li><strong>主流应用</strong>：几乎所有的嵌入式设备驱动都会用到GPIO。内核中已经包含了大量使用GPIO的子系统级驱动，例如<code>gpio-keys</code>（按键输入）、<code>leds-gpio</code>（LED控制）、<code>gpio-fan</code>（风扇控制）等，这些驱动为常见的硬件模式提供了标准化的内核接口。</li>
<li><strong>社区规范</strong>：社区强烈推荐所有新代码使用基于描述符的<code>gpiod_*</code>内核API，并使用<code>libgpiod</code>库与字符设备进行用户空间交互。</li>
</ul>
<h3 id="核心原理与设计"><a href="#核心原理与设计" class="headerlink" title="核心原理与设计"></a>核心原理与设计</h3><h4 id="它的核心工作原理是什么？"><a href="#它的核心工作原理是什么？" class="headerlink" title="它的核心工作原理是什么？"></a>它的核心工作原理是什么？</h4><p>GPIO子系统的核心是<strong>生产者&#x2F;消费者模型</strong>，由一个通用的中间层（称为<code>gpiolib</code>）进行协调。</p>
<ol>
<li><p><strong>生产者（Provider &#x2F; <code>gpio_chip</code>）</strong>：</p>
<ul>
<li>硬件GPIO控制器的驱动程序（例如，某个SoC的GPIO模块驱动）会实现一个<code>struct gpio_chip</code>。</li>
<li>这个结构体包含了一组函数指针，用于实现具体的操作，如设置方向（<code>.direction_input</code>&#x2F;<code>.direction_output</code>）、读值（<code>.get</code>）、写值（<code>.set</code>）以及请求中断等。</li>
<li>驱动通过 <code>gpiochip_add_data()</code> 将其实例注册到<code>gpiolib</code>中。</li>
</ul>
</li>
<li><p><strong>消费者（Consumer）</strong>：</p>
<ul>
<li>需要使用GPIO的设备驱动程序（例如，一个Wi-Fi模块驱动需要控制电源使能引脚）被称为消费者。</li>
<li>消费者通过调用 <code>gpiod_get()</code> 或 <code>devm_gpiod_get()</code>，并提供设备指针和在设备树中定义的名字（如<code>&quot;enable-gpios&quot;</code>），来向<code>gpiolib</code>请求一个GPIO描述符。</li>
<li><code>gpiolib</code>根据设备树的连接关系，找到对应的<code>gpio_chip</code>，并返回一个有效的描述符。</li>
</ul>
</li>
<li><p><strong>gpiolib（核心层）</strong>：</p>
<ul>
<li>位于<code>drivers/gpio/gpiolib.c</code>等文件中，是连接生产者和消费者的桥梁。</li>
<li>它管理着所有注册的<code>gpio_chip</code>，维护一个GPIO描述符池，并处理资源的请求和释放。</li>
<li>当消费者的驱动调用 <code>gpiod_set_value()</code> 时，<code>gpiolib</code>会找到该描述符对应的<code>gpio_chip</code>，并调用其<code>.set()</code>回调函数，从而最终操作硬件。</li>
</ul>
</li>
</ol>
<h4 id="它的主要优势体现在哪些方面？"><a href="#它的主要优势体现在哪些方面？" class="headerlink" title="它的主要优势体现在哪些方面？"></a>它的主要优势体现在哪些方面？</h4><ul>
<li><strong>抽象和解耦</strong>：完全将设备驱动与具体的GPIO控制器硬件分离。</li>
<li><strong>安全性</strong>：基于描述符的API防止了资源的误用，并确保了所有权。</li>
<li><strong>标准化</strong>：为内核和用户空间提供了稳定且功能丰富的API。</li>
<li><strong>可扩展性</strong>：新的GPIO控制器可以很容易地通过实现<code>gpio_chip</code>接口接入到系统中。</li>
</ul>
<h4 id="它存在哪些已知的劣势、局限性或在特定场景下的不适用性？"><a href="#它存在哪些已知的劣势、局限性或在特定场景下的不适用性？" class="headerlink" title="它存在哪些已知的劣势、局限性或在特定场景下的不适用性？"></a>它存在哪些已知的劣势、局限性或在特定场景下的不适用性？</h4><ul>
<li><strong>性能</strong>：对于需要极高速率（MHz级别）进行位操作（Bit-banging）的场景，通过<code>gpiolib</code>的函数调用路径可能会引入不可接受的延迟。这种场景通常应使用硬件SPI或I2C控制器，而不是用GPIO模拟。</li>
<li><strong>非通用功能</strong>：GPIO子系统只处理通用的数字输入&#x2F;输出。 对于引脚的复用（Pin Muxing）、电气特性配置（如上&#x2F;下拉、驱动强度）等更复杂的功能，则由<strong>Pinctrl子系统</strong>负责。</li>
</ul>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><h4 id="在哪些具体的业务或技术场景下，它是首选解决方案？请举例说明。"><a href="#在哪些具体的业务或技术场景下，它是首选解决方案？请举例说明。" class="headerlink" title="在哪些具体的业务或技术场景下，它是首选解决方案？请举例说明。"></a>在哪些具体的业务或技术场景下，它是首选解决方案？请举例说明。</h4><p>GPIO子系统是任何需要直接控制或读取硬件数字信号线的标准解决方案。</p>
<ul>
<li><strong>硬件使能&#x2F;复位</strong>：一个MMC&#x2F;SD卡驱动，通过GPIO来检测卡槽中是否有卡插入（输入），以及控制SD卡的电源使能（输出）。</li>
<li><strong>LED状态指示</strong>：系统通过一个<code>leds-gpio</code>驱动来控制多个LED灯的亮灭，以指示网络活动、存储状态等。</li>
<li><strong>按键输入</strong>：使用<code>gpio-keys</code>驱动，将连接到GPIO的物理按键转换为标准的内核输入事件，这样用户空间的程序就能像读取键盘一样读取按键。</li>
<li><strong>中断触发</strong>：一个触摸屏控制器，通过一个GPIO引脚在有触摸事件发生时向CPU发送中断信号。<code>gpiolib</code>能够将GPIO中断转换为标准的Linux IRQ号。</li>
</ul>
<h4 id="是否有不推荐使用该技术的场景？为什么？"><a href="#是否有不推荐使用该技术的场景？为什么？" class="headerlink" title="是否有不推荐使用该技术的场景？为什么？"></a>是否有不推荐使用该技术的场景？为什么？</h4><ul>
<li><strong>引脚复用配置</strong>：当一个引脚需要被配置为特定硬件模块（如UART、I2C控制器）的功能引脚时，不应使用GPIO子系统。这项工作必须由<strong>Pinctrl子系统</strong>完成，它负责将引脚从“GPIO模式”切换到“UART_TX模式”等。</li>
<li><strong>高速串行总线模拟</strong>：如上所述，模拟SPI或I2C总线对于<code>gpiolib</code>来说开销太大，性能很差。应优先使用专用的硬件控制器。</li>
<li><strong>模拟PWM或音频信号</strong>：虽然可以通过软件快速翻转GPIO来模拟PWM，但其精度和稳定性远不如硬件PWM控制器。</li>
</ul>
<h3 id="对比分析"><a href="#对比分析" class="headerlink" title="对比分析"></a>对比分析</h3><h4 id="请将其-与-其他相似技术-进行详细对比。"><a href="#请将其-与-其他相似技术-进行详细对比。" class="headerlink" title="请将其 与 其他相似技术 进行详细对比。"></a>请将其 与 其他相似技术 进行详细对比。</h4><p>在Linux内核中，与GPIO子系统关系最密切、最容易混淆的是<strong>Pinctrl（Pin Control）子系统</strong>。</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">GPIO Subsystem</th>
<th align="left">Pinctrl Subsystem</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>核心功能</strong></td>
<td align="left"><strong>控制引脚的逻辑状态</strong>：设置为输入或输出，读取高&#x2F;低电平，写入高&#x2F;低电平，处理中断。</td>
<td align="left"><strong>配置引脚的“身份”和电气特性</strong>：决定一个引脚是作为GPIO、UART、I2C还是其他功能，以及配置其上&#x2F;下拉、驱动强度、转换速率等。</td>
</tr>
<tr>
<td align="left"><strong>操作对象</strong></td>
<td align="left">已经处于<strong>GPIO模式</strong>下的引脚。</td>
<td align="left">系统中的所有<strong>物理引脚（Pins）</strong>。</td>
</tr>
<tr>
<td align="left"><strong>抽象层次</strong></td>
<td align="left">较高层，面向<strong>逻辑功能</strong>。一个GPIO是一个可以读写的数字信号线。</td>
<td align="left">较低层，面向<strong>硬件物理属性</strong>。一个Pin是一个需要被复用和配置的物理实体。</td>
</tr>
<tr>
<td align="left"><strong>交互关系</strong></td>
<td align="left"><strong>依赖于Pinctrl</strong>。一个引脚必须首先被Pinctrl子系统配置为GPIO模式，然后才能被GPIO子系统使用。</td>
<td align="left"><strong>为GPIO提供基础</strong>。Pinctrl负责“搭台”，GPIO负责“唱戏”。</td>
</tr>
<tr>
<td align="left"><strong>典型API</strong></td>
<td align="left">内核：<code>gpiod_get()</code>, <code>gpiod_direction_output()</code>, <code>gpiod_set_value()</code></td>
<td align="left">内核：<code>pinctrl_get()</code>, <code>pinctrl_lookup_state()</code>, <code>pinctrl_select_state()</code></td>
</tr>
<tr>
<td align="left"><strong>总结</strong></td>
<td align="left">回答“<strong>这个信号线是高电平还是低电平？</strong>”</td>
<td align="left">回答“<strong>这个物理引脚现在应该做什么用？（是当GPIO还是当UART用？）</strong>”</td>
</tr>
</tbody></table>
<h1 id="include-linux-gpio-driver-h"><a href="#include-linux-gpio-driver-h" class="headerlink" title="include&#x2F;linux&#x2F;gpio&#x2F;driver.h"></a>include&#x2F;linux&#x2F;gpio&#x2F;driver.h</h1><h2 id="for-each-gpiochip-node-遍历GPIO控制器节点"><a href="#for-each-gpiochip-node-遍历GPIO控制器节点" class="headerlink" title="for_each_gpiochip_node 遍历GPIO控制器节点"></a>for_each_gpiochip_node 遍历GPIO控制器节点</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> for_each_gpiochip_node(dev, child)					\</span></span><br><span class="line"><span class="meta">	device_for_each_child_node(dev, child)					\</span></span><br><span class="line"><span class="meta">		for_each_if(fwnode_property_present(child, <span class="string">&quot;gpio-controller&quot;</span>))</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">gpiochip_node_count</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fwnode_handle</span> *<span class="title">child</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	for_each_gpiochip_node(dev, child)</span><br><span class="line">		count++;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="drivers-gpio-gpiolib-of-c"><a href="#drivers-gpio-gpiolib-of-c" class="headerlink" title="drivers&#x2F;gpio&#x2F;gpiolib-of.c"></a>drivers&#x2F;gpio&#x2F;gpiolib-of.c</h1><h2 id="of-get-named-gpiod-flags-of-gpio-flags-quirks"><a href="#of-get-named-gpiod-flags-of-gpio-flags-quirks" class="headerlink" title="of_get_named_gpiod_flags &amp; of_gpio_flags_quirks"></a>of_get_named_gpiod_flags &amp; of_gpio_flags_quirks</h2><p>这两个函数是Linux内核中<strong>从设备树(Device Tree)解析GPIO属性的最终执行者</strong>。<code>of_get_named_gpiod_flags</code>是负责处理单个、具名GPIO属性的核心工作引擎, 而<code>of_gpio_flags_quirks</code>则是一个专门的辅助函数, 用于处理各种历史遗留的、非标准的设备树绑定(“怪癖”)。</p>
<hr>
<h3 id="of-get-named-gpiod-flags-The-Core-Device-Tree-GPIO-Property-Parser"><a href="#of-get-named-gpiod-flags-The-Core-Device-Tree-GPIO-Property-Parser" class="headerlink" title="of_get_named_gpiod_flags: The Core Device Tree GPIO Property Parser"></a><code>of_get_named_gpiod_flags</code>: The Core Device Tree GPIO Property Parser</h3><p>此函数是<code>of_find_gpio</code>在确定了要查找的<strong>具体属性名称</strong>(例如, <code>&quot;enable-gpios&quot;</code>)后调用的底层核心引擎。它的原理是执行一个精确的、分阶段的流程, 将设备树中一个GPIO描述符(phandle + specifier)完全转化为一个内核可以使用的、包含了正确标志的<code>gpio_desc</code>句柄。</p>
<p><strong>工作流程详解:</strong></p>
<ol>
<li><p><strong>解析Phandle和参数 (<code>of_parse_phandle_with_args_map</code>)</strong>: 这是第一步, 也是最关键的一步。此函数负责解析设备树属性值, 例如 <code>&lt;&amp;gpioA 5 GPIO_ACTIVE_LOW&gt;</code>。</p>
<ul>
<li>它从属性中提取出<code>phandle</code> (指向GPIO控制器节点, 如<code>&amp;gpioA</code>)。</li>
<li>它根据GPIO控制器节点中的<code>#gpio-cells</code>属性, 确定后面有多少个参数(specifier)。</li>
<li>它将<code>phandle</code>和所有参数(<code>5</code>, <code>GPIO_ACTIVE_LOW</code>)打包到一个<code>of_phandle_args</code>结构体(<code>gpiospec</code>)中。</li>
</ul>
</li>
<li><p><strong>查找提供者驱动 (<code>of_find_gpio_device_by_xlate</code>)</strong>: 有了指向GPIO控制器节点的<code>phandle</code>, 此函数会在内核中查找是否已经有驱动程序为该节点注册了一个<code>gpio_device</code>。</p>
<ul>
<li><strong>这是处理驱动依赖关系的核心点</strong>: 如果GPIO控制器驱动(例如STM32的pinctrl&#x2F;gpio驱动)尚未初始化, 查找就会失败。在这种情况下, 此函数会正确地返回<code>-EPROBE_DEFER</code>, 从而安全地推迟当前消费者驱动的探测, 等待依赖就绪。</li>
</ul>
</li>
<li><p><strong>翻译与获取 (<code>of_xlate_and_get_gpiod_flags</code>)</strong>: 找到GPIO控制器驱动后, 此函数会调用该驱动的<code>of_xlate</code>回调函数。</p>
<ul>
<li><code>xlate</code> (translate) 的作用是将设备树中特定于硬件的参数 (如 <code>5 GPIO_ACTIVE_LOW</code>) “翻译”成驱动内部可以理解的本地硬件引脚号, 并解析出标准的内核GPIO标志。</li>
<li>翻译完成后, 它就从该GPIO控制器驱动管理的<code>gpio_chip</code>中获取代表该特定引脚的<code>gpio_desc</code>句柄。</li>
</ul>
</li>
<li><p><strong>应用”怪癖” (<code>of_gpio_flags_quirks</code>)</strong>: 在基本标志解析完成后, 它会调用<code>of_gpio_flags_quirks</code>函数, 对标志进行可能的修正, 以处理各种非标准的历史遗留绑定。</p>
</li>
<li><p><strong>资源管理</strong>: 在函数结束前, 它必须调用<code>of_node_put</code>来释放对GPIO控制器节点的引用计数, 这是Linux内核中标准的资源管理实践。</p>
</li>
</ol>
<hr>
<h4 id="of-gpio-flags-quirks-The-Legacy-Binding-Compatibility-Handler"><a href="#of-gpio-flags-quirks-The-Legacy-Binding-Compatibility-Handler" class="headerlink" title="of_gpio_flags_quirks: The Legacy Binding Compatibility Handler"></a><code>of_gpio_flags_quirks</code>: The Legacy Binding Compatibility Handler</h4><p>此函数本身不执行任何标准的查找, 它的唯一作用是<strong>充当一个”兼容性补丁”集合</strong>。它包含了许多针对特定设备或旧版设备树绑定的特殊处理逻辑, 用于修正或补充从设备树中解析出来的GPIO标志。</p>
<p><strong>原理</strong>:<br>它是一个大型的<code>if/else if</code>条件判断集合, 每一个条件块都对应一个已知的”怪癖”。</p>
<ul>
<li><strong>通用修正</strong>: 它首先调用一些通用的修复函数, 如<code>of_gpio_try_fixup_polarity</code>, 来处理一些常见的极性定义问题。</li>
<li><strong>固定电压调节器怪癖</strong>: 它检查设备是否是一个<code>&quot;reg-fixed-voltage&quot;</code>。如果是, 它会去查找一个<strong>额外的、非标准的</strong>布尔属性<code>&quot;gpio-open-drain&quot;</code>。在现代设备树中, “open-drain”标志应该直接写在<code>gpios</code>属性的参数里, 这个检查是为了兼容那些将此标志放在别处的旧设备树。</li>
<li><strong>SPI芯片选择怪癖</strong>: 这是一个更复杂的例子。对于SPI的<code>&quot;cs-gpios&quot;</code>属性, 其”高电平有效”或”低电平有效”的极性, 按照旧的绑定规范, 不是定义在<code>cs-gpios</code>属性本身, 而是定义在SPI master节点的<strong>子节点</strong>中的一个<code>&quot;spi-cs-high&quot;</code>布尔属性里。此函数包含了遍历子节点、匹配片选索引、并根据<code>spi-cs-high</code>属性来修正极性标志的完整逻辑。</li>
<li><strong>STMMAC以太网怪癖</strong>: 它为STMMAC驱动的复位引脚<code>&quot;snps,reset-gpio&quot;</code>检查一个名为<code>&quot;snps,reset-active-low&quot;</code>的独立布尔属性, 以此来确定复位信号的极性。</li>
</ul>
<p>在STM32H750的现代设备树文件中, 这些怪癖通常不会被触发。然而, <code>of_gpio_flags_quirks</code>的存在是Linux内核能够无缝支持横跨十几年、数千种不同硬件设计的关键因素之一, 它将处理历史遗留问题的代码集中在一个地方, 使得核心的解析逻辑(<code>of_get_named_gpiod_flags</code>)能够保持干净和标准化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * of_gpio_flags_quirks - 处理GPIO标志的特殊情况和历史遗留问题.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">of_gpio_flags_quirks</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np,</span></span><br><span class="line"><span class="params">				 <span class="type">const</span> <span class="type">char</span> *propname,</span></span><br><span class="line"><span class="params">				 <span class="keyword">enum</span> of_gpio_flags *flags,</span></span><br><span class="line"><span class="params">				 <span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// ... (调用通用极性修正函数)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 怪癖1: 固定电压调节器的历史遗留开漏(open drain)标志处理.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_REGULATOR) &amp;&amp;</span><br><span class="line">	    of_device_is_compatible(np, <span class="string">&quot;reg-fixed-voltage&quot;</span>) &amp;&amp;</span><br><span class="line">	    of_property_read_bool(np, <span class="string">&quot;gpio-open-drain&quot;</span>)) &#123;</span><br><span class="line">		<span class="comment">/* 如果找到非标准的 &quot;gpio-open-drain&quot; 属性, 手动添加开漏标志. */</span></span><br><span class="line">		*flags |= (OF_GPIO_SINGLE_ENDED | OF_GPIO_OPEN_DRAIN);</span><br><span class="line">		pr_info(<span class="string">&quot;%s uses legacy open drain flag - update the DTS if you can\n&quot;</span>,</span><br><span class="line">			of_node_full_name(np)); <span class="comment">// 打印一条信息, 建议用户更新设备树.</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 怪癖2: SPI芯片选择(cs-gpios)的历史遗留极性处理.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_SPI_MASTER) &amp;&amp; !<span class="built_in">strcmp</span>(propname, <span class="string">&quot;cs-gpios&quot;</span>) &amp;&amp;</span><br><span class="line">	    of_property_present(np, <span class="string">&quot;cs-gpios&quot;</span>)) &#123;</span><br><span class="line">		<span class="comment">// ... (复杂的逻辑: 遍历SPI master的子节点)</span></span><br><span class="line">		for_each_child_of_node_scoped(np, child) &#123;</span><br><span class="line">			<span class="comment">// ... (匹配片选索引 `cs == index`)</span></span><br><span class="line">			<span class="keyword">if</span> (cs == index) &#123;</span><br><span class="line">				<span class="comment">/* 检查子节点中是否存在 &quot;spi-cs-high&quot; 属性来决定极性. */</span></span><br><span class="line">				<span class="type">bool</span> active_high = of_property_read_bool(child, <span class="string">&quot;spi-cs-high&quot;</span>);</span><br><span class="line">				of_gpio_quirk_polarity(child, active_high, flags);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 怪癖3: STMMAC以太网驱动的历史遗留复位极性处理.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_STMMAC_ETH) &amp;&amp;</span><br><span class="line">	    !<span class="built_in">strcmp</span>(propname, <span class="string">&quot;snps,reset-gpio&quot;</span>) &amp;&amp;</span><br><span class="line">	    of_property_read_bool(np, <span class="string">&quot;snps,reset-active-low&quot;</span>))</span><br><span class="line">		<span class="comment">/* 如果找到非标准的 &quot;snps,reset-active-low&quot; 属性, 手动添加低电平有效标志. */</span></span><br><span class="line">		*flags |= OF_GPIO_ACTIVE_LOW;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * of_get_named_gpiod_flags() - 获取具名GPIO的描述符和标志.</span></span><br><span class="line"><span class="comment"> * (核心解析引擎)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> gpio_desc *<span class="title function_">of_get_named_gpiod_flags</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np,</span></span><br><span class="line"><span class="params">		     <span class="type">const</span> <span class="type">char</span> *propname, <span class="type">int</span> index, <span class="keyword">enum</span> of_gpio_flags *flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">of_phandle_args</span> <span class="title">gpiospec</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">desc</span>;</span></span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 1. 解析 phandle 和参数 */</span></span><br><span class="line">	ret = of_parse_phandle_with_args_map(np, propname, <span class="string">&quot;gpio&quot;</span>, index,</span><br><span class="line">					     &amp;gpiospec);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		<span class="comment">// ... (错误处理)</span></span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(ret);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 2. 查找提供者驱动 (gpio_device) */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_device</span> *<span class="title">gdev</span> __<span class="title">free</span>(<span class="title">gpio_device_put</span>) =</span></span><br><span class="line">				of_find_gpio_device_by_xlate(&amp;gpiospec);</span><br><span class="line">	<span class="keyword">if</span> (!gdev) &#123;</span><br><span class="line">		<span class="comment">/* 如果驱动未就绪, 返回 EPROBE_DEFER */</span></span><br><span class="line">		desc = ERR_PTR(-EPROBE_DEFER);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 3. 翻译参数并获取最终的 gpio_desc */</span></span><br><span class="line">	desc = of_xlate_and_get_gpiod_flags(gpio_device_get_chip(gdev),</span><br><span class="line">					    &amp;gpiospec, flags);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(desc))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 4. 如果需要, 应用 &quot;怪癖&quot; 修正标志 */</span></span><br><span class="line">	<span class="keyword">if</span> (flags)</span><br><span class="line">		of_gpio_flags_quirks(np, propname, flags, index);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ... (调试打印)</span></span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="comment">/* 5. 释放对GPIO控制器节点的引用 */</span></span><br><span class="line">	of_node_put(gpiospec.np);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="of-find-gpio-The-Device-Tree-GPIO-Lookup-Engine-with-Quirk-Support"><a href="#of-find-gpio-The-Device-Tree-GPIO-Lookup-Engine-with-Quirk-Support" class="headerlink" title="of_find_gpio: The Device Tree GPIO Lookup Engine with Quirk Support"></a>of_find_gpio: The Device Tree GPIO Lookup Engine with Quirk Support</h2><p>此函数是Linux内核<code>gpiod</code>子系统中专门负责<strong>解析设备树(Device Tree)以查找GPIO</strong>的后端核心引擎。它的主要作用是根据消费者驱动提供的功能名称(<code>con_id</code>), 在设备树节点(<code>np</code>)中寻找匹配的GPIO属性, 并返回一个代表该GPIO的内核句柄(<code>struct gpio_desc</code>)。</p>
<p>该函数的核心原理是一种<strong>健壮且可扩展的两阶段查找策略</strong>, 旨在同时支持标准的设备树绑定规范和各种非标准的、特定于硬件的”怪癖”(Quirks)。</p>
<p><strong>工作流程详解:</strong></p>
<ol>
<li><p><strong>阶段一: 标准化查找 (The Standard Path)</strong></p>
<ul>
<li>此阶段遵循Linux设备树绑定的官方规范。它使用<code>for_each_gpio_property_name</code>宏, 这是一个巧妙的工具, 它会根据输入的功能名<code>con_id</code>自动生成两个标准的属性名进行尝试。例如, 如果<code>con_id</code>是<code>&quot;enable&quot;</code>, 这个宏会依次生成:<ol>
<li><code>&quot;enable-gpios&quot;</code> (复数形式, 用于可能包含多个GPIO的功能)</li>
<li><code>&quot;enable-gpio&quot;</code> (单数形式, 向后兼容)</li>
</ol>
</li>
<li>对于每一个生成的属性名, 它会调用<code>of_get_named_gpiod_flags</code>。这个底层函数负责执行实际的设备树解析工作: 它在设备树节点中查找该属性, 读取其值(通常是一个指向GPIO控制器节点的<code>phandle</code>和一些参数), 并返回一个初始的GPIO描述符。</li>
<li>如果<code>of_get_named_gpiod_flags</code>成功找到了GPIO(或者返回了除<code>-ENOENT</code>之外的任何”真实”错误, 如<code>-EBUSY</code>), 查找过程就会立即停止并进入最后阶段。</li>
</ul>
</li>
<li><p><strong>阶段二: “怪癖”查找 (The Quirk Path)</strong></p>
<ul>
<li><strong>只有当第一阶段完全没有找到任何匹配的属性时</strong>, 才会进入此阶段。这体现了”标准优先”的原则。</li>
<li>它会遍历一个名为<code>of_find_gpio_quirks</code>的全局函数指针数组。数组中的每一个函数都是一个专门的”怪癖处理器”, 用于解决某个特定硬件平台或旧版设备树绑定不遵循标准规范的问题。</li>
<li>例如:<ul>
<li><code>of_find_gpio_rename</code>: 可能用于处理那些使用了非标准属性名的旧绑定。</li>
<li><code>of_find_mt2701_gpio</code>: 这是一个非常具体的例子, 专门用于处理联发科(MediaTek) MT2701 SoC上的一种特殊GPIO绑定。</li>
</ul>
</li>
<li>函数会依次调用数组中的每一个怪癖处理器, 让它们尝试用自己的特殊逻辑去查找GPIO。只要其中任何一个怪癖处理器成功找到, 查找就会停止。</li>
</ul>
</li>
<li><p><strong>最后阶段: 标志转换与返回</strong></p>
<ul>
<li>在通过标准或怪癖路径成功找到GPIO描述符后, 它会调用<code>of_convert_gpio_flags</code>。这是一个重要的翻译步骤, 它将设备树中定义的标志(如<code>OF_GPIO_ACTIVE_LOW</code>)转换为<code>gpiod</code>子系统内部使用的通用标志(如<code>GPIO_ACTIVE_LOW</code>)。</li>
<li>最终, 它返回一个包含了正确硬件信息和标志的、可供上层函数使用的<code>gpio_desc</code>指针。</li>
</ul>
</li>
</ol>
<p>在STM32H750这样的现代嵌入式平台上, 其设备树绑定通常遵循官方标准。因此, 在绝大多数情况下, <code>of_find_gpio</code>函数会在<strong>第一阶段</strong>就成功找到所需的GPIO, 而不会进入第二阶段的怪癖处理流程。然而, 这个怪癖处理机制是Linux内核保持对大量不同硬件(包括那些有历史遗留问题的硬件)的广泛兼容性的关键所在, 体现了内核设计的灵活性和向后兼容性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义一个函数指针类型 of_find_gpio_quirk.</span></span><br><span class="line"><span class="comment"> * 这种类型的函数接收设备树节点、功能ID、索引和OF标志指针作为参数, 返回一个gpio_desc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *(*<span class="title">of_find_gpio_quirk</span>)(<span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span>,</span></span><br><span class="line"><span class="class">						<span class="title">const</span> <span class="title">char</span> *<span class="title">con_id</span>,</span></span><br><span class="line"><span class="class">						<span class="title">unsigned</span> <span class="title">int</span> <span class="title">idx</span>,</span></span><br><span class="line"><span class="class">						<span class="title">enum</span> <span class="title">of_gpio_flags</span> *<span class="title">of_flags</span>);</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义一个静态的、常量类型的函数指针数组.</span></span><br><span class="line"><span class="comment"> * 这个数组包含了所有已注册的 &quot;怪癖&quot; 处理器函数.</span></span><br><span class="line"><span class="comment"> * 内核会依次调用它们来处理非标准的设备树绑定.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> of_find_gpio_quirk of_find_gpio_quirks[] = &#123;</span><br><span class="line">	of_find_gpio_rename, <span class="comment">// 处理重命名或别名</span></span><br><span class="line">	of_find_mt2701_gpio, <span class="comment">// 处理MT2701 SoC的特殊情况</span></span><br><span class="line">	of_find_trigger_gpio, <span class="comment">// 处理中断触发相关的特殊情况</span></span><br><span class="line">	<span class="literal">NULL</span> <span class="comment">// 数组的结束标记</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * of_find_gpio - 在设备树节点中查找GPIO.</span></span><br><span class="line"><span class="comment"> * @np: 要搜索的设备树节点.</span></span><br><span class="line"><span class="comment"> * @con_id: GPIO的功能名称, 如 &quot;enable&quot;.</span></span><br><span class="line"><span class="comment"> * @idx: 在多GPIO功能中的索引.</span></span><br><span class="line"><span class="comment"> * @flags: (输出参数) 返回转换后的gpiod标志.</span></span><br><span class="line"><span class="comment"> * @return: 成功时返回gpio_desc, 失败时返回错误指针.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> gpio_desc *<span class="title function_">of_find_gpio</span><span class="params">(<span class="keyword">struct</span> device_node *np, <span class="type">const</span> <span class="type">char</span> *con_id,</span></span><br><span class="line"><span class="params">			       <span class="type">unsigned</span> <span class="type">int</span> idx, <span class="type">unsigned</span> <span class="type">long</span> *flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> propname[<span class="number">32</span>]; <span class="comment">/* 属性名的最大长度为32个字符 */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">of_gpio_flags</span> <span class="title">of_flags</span> =</span> <span class="number">0</span>; <span class="comment">// 初始化设备树专用的标志</span></span><br><span class="line">	<span class="type">const</span> of_find_gpio_quirk *q;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">desc</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* --- 阶段一: 标准查找 --- */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * for_each_gpio_property_name 是一个宏, 它会根据 con_id 生成标准的属性名.</span></span><br><span class="line"><span class="comment">	 * 例如, 如果 con_id 是 &quot;reset&quot;, 它会先将 propname 设置为 &quot;reset-gpios&quot;,</span></span><br><span class="line"><span class="comment">	 * 然后在下一次迭代中设置为 &quot;reset-gpio&quot;.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	for_each_gpio_property_name(propname, con_id) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * of_get_named_gpiod_flags 是实际的解析函数, 它在np节点中查找名为propname的属性.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		desc = of_get_named_gpiod_flags(np, propname, idx, &amp;of_flags);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * gpiod_not_found(desc) 检查返回值是否是 -ENOENT (未找到).</span></span><br><span class="line"><span class="comment">		 * !gpiod_not_found(desc) 的意思是 &quot;如果找到了, 或者返回了除&#x27;未找到&#x27;之外的其他错误&quot;.</span></span><br><span class="line"><span class="comment">		 * 在这两种情况下, 我们都应该停止搜索.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!gpiod_not_found(desc))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* --- 阶段二: &quot;怪癖&quot;查找 --- */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 这个循环的条件是: 1. 标准查找没有找到 (gpiod_not_found(desc)为真) 2. 还有未尝试的怪癖处理器 (*q不为NULL)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (q = of_find_gpio_quirks; gpiod_not_found(desc) &amp;&amp; *q; q++)</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 调用当前怪癖处理器函数 (*q), 让它尝试用自己的特殊逻辑去查找GPIO.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		desc = (*q)(np, con_id, idx, &amp;of_flags);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 检查最终结果是否是一个错误 (除了-ENOENT, 因为它可能已被怪癖处理器修正) */</span></span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(desc))</span><br><span class="line">		<span class="keyword">return</span> desc;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* --- 阶段三: 标志转换 --- */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * of_convert_gpio_flags 将从设备树中解析出的 of_flags</span></span><br><span class="line"><span class="comment">	 * (如 OF_GPIO_ACTIVE_LOW) 转换为 gpiod 子系统内部使用的通用标志 (*flags).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	*flags = of_convert_gpio_flags(of_flags);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 返回最终找到的GPIO描述符 */</span></span><br><span class="line">	<span class="keyword">return</span> desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="drivers-gpio-gpiolib-c"><a href="#drivers-gpio-gpiolib-c" class="headerlink" title="drivers&#x2F;gpio&#x2F;gpiolib.c"></a>drivers&#x2F;gpio&#x2F;gpiolib.c</h1><h2 id="gpiochip-setup-dev-为单个GPIO控制器完成设备和接口的注册"><a href="#gpiochip-setup-dev-为单个GPIO控制器完成设备和接口的注册" class="headerlink" title="gpiochip_setup_dev: 为单个GPIO控制器完成设备和接口的注册"></a>gpiochip_setup_dev: 为单个GPIO控制器完成设备和接口的注册</h2><p>此函数的核心职责是接收一个代表GPIO控制器（如STM32的GPIOA）的内核对象<code>gdev</code>，并完成以下三件关键事情：</p>
<ol>
<li><strong>初始化设备对象</strong>: 确保<code>gdev</code>中的<code>struct device</code>成员被正确初始化。</li>
<li><strong>创建字符设备</strong>: 在<code>/dev</code>目录下创建对应的<code>gpiochipN</code>字符设备节点，使用户空间程序可以通过文件I&#x2F;O操作来访问GPIO。</li>
<li><strong>创建<code>sysfs</code>接口</strong>: 在<code>/sys/class/gpio</code>目录下创建对应的<code>gpiochipN</code>目录和属性文件，提供一种基于文件的、用于管理和调试GPIO的接口。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * gpiochip_setup_dev: 对一个gpio_device进行设置.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @gdev: 指向要设置的 gpio_device 结构体的指针.</span></span><br><span class="line"><span class="comment"> * @return: 成功时返回0, 失败时返回负值的错误码.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpiochip_setup_dev</span><span class="params">(<span class="keyword">struct</span> gdevice *gdev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * fwnode: 指向与此设备关联的固件节点(Firmware Node)的句柄.</span></span><br><span class="line"><span class="comment">	 * 在基于设备树的系统(如STM32)上, 这通常指向设备树中对应的节点</span></span><br><span class="line"><span class="comment">	 * (例如, &amp;gpioa 节点). dev_fwnode() 是获取这个句柄的标准函数.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fwnode_handle</span> *<span class="title">fwnode</span> =</span> dev_fwnode(&amp;gdev-&gt;dev);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * ret: 用于存储函数调用的返回值.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 调用 device_initialize(), 对 gdev 中内嵌的 struct device 对象进行初始化.</span></span><br><span class="line"><span class="comment">	 * 这一步会设置好设备的引用计数、锁等内部状态, 为后续的注册做准备.</span></span><br><span class="line"><span class="comment">	 * 如果这个 gdev 之前已经注册过, 这一步可以确保其状态被重置.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	device_initialize(&amp;gdev-&gt;dev);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 这是一个处理固件节点状态的特殊情况.</span></span><br><span class="line"><span class="comment">	 * 如果固件节点存在, 并且它还没有被关联到任何一个&#x27;struct device&#x27;上,</span></span><br><span class="line"><span class="comment">	 * 那么我们就安全地清除它的&quot;已初始化&quot;标志.</span></span><br><span class="line"><span class="comment">	 * 这确保了设备可以被重新初始化和探测.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (fwnode &amp;&amp; !fwnode-&gt;dev)</span><br><span class="line">		fwnode_dev_initialized(fwnode, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 第一步: 注册字符设备.</span></span><br><span class="line"><span class="comment">	 * gcdev_register() 是一个辅助函数, 它的核心工作是:</span></span><br><span class="line"><span class="comment">	 * 1. 从 gpio_devt (在gpiolib_dev_init中分配的设备号范围)中获取一个可用的次设备号.</span></span><br><span class="line"><span class="comment">	 * 2. 使用这个主/次设备号, 调用 cdev_add() 将这个 gdev 注册为一个字符设备.</span></span><br><span class="line"><span class="comment">	 * 3. 调用 device_add() 将 gdev-&gt;dev 这个设备对象正式添加到内核的设备模型中.</span></span><br><span class="line"><span class="comment">	 *    device_add() 会触发用户空间的udev/mdev, 在/dev目录下创建对应的&#x27;gpiochipN&#x27;节点.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ret = gcdev_register(gdev, gpio_devt);</span><br><span class="line">	<span class="keyword">if</span> (ret) <span class="comment">/* 检查注册是否成功. */</span></span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 第二步: 注册sysfs接口.</span></span><br><span class="line"><span class="comment">	 * gpiochip_sysfs_register() 负责在 /sys/class/gpio/ 目录下创建对应的接口.</span></span><br><span class="line"><span class="comment">	 * 它会创建一个名为 &#x27;gpiochipN&#x27; (N是GPIO的基准号, 如gpiochip0)的目录.</span></span><br><span class="line"><span class="comment">	 * 在这个目录下, 它会创建几个属性文件, 例如:</span></span><br><span class="line"><span class="comment">	 *  - &#x27;base&#x27;:  只读, 显示这个gpiochip的起始GPIO编号.</span></span><br><span class="line"><span class="comment">	 *  - &#x27;label&#x27;: 只读, 显示这个gpiochip的标签 (通常来自设备树).</span></span><br><span class="line"><span class="comment">	 *  - &#x27;ngpio&#x27;: 只读, 显示这个gpiochip管理的GPIO数量 (例如, 16个).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ret = gpiochip_sysfs_register(gdev);</span><br><span class="line">	<span class="keyword">if</span> (ret) <span class="comment">/* 检查注册是否成功. */</span></span><br><span class="line">		<span class="keyword">goto</span> err_remove_device; <span class="comment">/* 如果失败, 跳转到错误处理. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 使用 dev_dbg() 打印一条调试级别的日志, 宣告注册成功.</span></span><br><span class="line"><span class="comment">	 * 日志会包含GPIO的编号范围和标签, 这对于调试非常有帮助.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	dev_dbg(&amp;gdev-&gt;dev, <span class="string">&quot;registered GPIOs %u to %u on %s\n&quot;</span>, gdev-&gt;base,</span><br><span class="line">		gdev-&gt;base + gdev-&gt;ngpio - <span class="number">1</span>, gdev-&gt;label);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 所有操作成功, 返回0.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 错误处理标签.</span></span><br><span class="line"><span class="comment"> * 当sysfs注册失败时, 代码会跳转到这里.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">err_remove_device:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 必须执行清理操作, 注销之前成功注册的字符设备,</span></span><br><span class="line"><span class="comment">	 * 以保持系统状态的一致性.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	gcdev_unregister(gdev);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 返回sysfs注册失败时产生的错误码.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="gpiochip-setup-devs-为已注册的GPIO控制器设置设备节点"><a href="#gpiochip-setup-devs-为已注册的GPIO控制器设置设备节点" class="headerlink" title="gpiochip_setup_devs: 为已注册的GPIO控制器设置设备节点"></a>gpiochip_setup_devs: 为已注册的GPIO控制器设置设备节点</h2><p>此函数的核心作用是<strong>遍历当前系统中所有已经注册的GPIO控制器（<code>gpio_device</code>），并为每一个控制器调用<code>gpiochip_setup_dev</code>函数来完成其设备节点的最终设置</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * gpiochip_setup_devs: 为(一个或多个)gpio设备进行设置.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">gpiochip_setup_devs</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * gdev: 一个指向 gpio_device 结构体的指针, 用作循环变量.</span></span><br><span class="line"><span class="comment">	 *       gpio_device 是内核中代表一个完整GPIO控制器(如STM32的GPIOA)的核心对象.</span></span><br><span class="line"><span class="comment">	 * ret:  用于存储函数调用的返回值.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_device</span> *<span class="title">gdev</span>;</span></span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * guard(srcu)(&amp;gpio_devices_srcu):</span></span><br><span class="line"><span class="comment">	 * 这是一个C++风格的RAII (Resource Acquisition Is Initialization) 宏,</span></span><br><span class="line"><span class="comment">	 * 在内核中用于简化锁的管理. 它在这里的作用是:</span></span><br><span class="line"><span class="comment">	 * 1. 在进入这个作用域时, 自动获取 gpio_devices_srcu 的 SRCU 读锁.</span></span><br><span class="line"><span class="comment">	 *    SRCU (Sleepable Read-Copy-Update) 是一种特殊的读写锁, 它允许读端临界区睡眠.</span></span><br><span class="line"><span class="comment">	 *    在这里加锁是为了安全地遍历全局的 gpio_devices 链表.</span></span><br><span class="line"><span class="comment">	 * 2. 在退出这个作用域时 (无论函数是正常返回还是中途退出), 自动释放这个读锁.</span></span><br><span class="line"><span class="comment">	 * 这就避免了忘记解锁导致死锁的问题.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	guard(srcu)(&amp;gpio_devices_srcu);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * list_for_each_entry_srcu: 这是一个专门用于在SRCU保护下安全遍历链表的宏.</span></span><br><span class="line"><span class="comment">	 * @ gdev:           循环变量.</span></span><br><span class="line"><span class="comment">	 * @ &amp;gpio_devices:  要遍历的全局链表的头部.</span></span><br><span class="line"><span class="comment">	 * @ list:           链表节点在 gdev 结构体中的成员名.</span></span><br><span class="line"><span class="comment">	 * @ srcu_read_lock_held(...): 一个条件, 用于静态检查或在调试时断言我们确实持有了锁.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 这行代码会遍历 gpio_devices 链表中的每一个 gpio_device (即每一个已注册的GPIO控制器).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	list_for_each_entry_srcu(gdev, &amp;gpio_devices, <span class="built_in">list</span>,</span><br><span class="line">				 srcu_read_lock_held(&amp;gpio_devices_srcu)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 对链表中的每一个 gdev, 调用 gpiochip_setup_dev 函数.</span></span><br><span class="line"><span class="comment">		 * gpiochip_setup_dev (未在此处显示) 是真正干活的函数. 它的主要工作包括:</span></span><br><span class="line"><span class="comment">		 * 1. 检查这个gdev是否已经被设置过, 如果是, 就直接返回.</span></span><br><span class="line"><span class="comment">		 * 2. 使用之前分配的字符设备主设备号和动态分配的次设备号,</span></span><br><span class="line"><span class="comment">		 *    调用 device_create() 函数.</span></span><br><span class="line"><span class="comment">		 * 3. device_create() 会触发用户空间的 udev/mdev, 在 /dev 目录下</span></span><br><span class="line"><span class="comment">		 *    创建一个对应的字符设备节点, 例如 /dev/gpiochip0.</span></span><br><span class="line"><span class="comment">		 * 4. 它还会设置好 gdev-&gt;dev 这个设备对象, 将其与驱动模型完全集成.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		ret = gpiochip_setup_dev(gdev);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 检查 gpiochip_setup_dev 是否成功.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * 如果失败, 使用 dev_err() 打印一条错误日志.</span></span><br><span class="line"><span class="comment">			 * &amp;gdev-&gt;dev 是与这个 gdev 关联的设备对象,</span></span><br><span class="line"><span class="comment">			 * dev_err 会自动在日志中包含设备名, 方便调试.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			dev_err(&amp;gdev-&gt;dev,</span><br><span class="line">				<span class="string">&quot;Failed to initialize gpio device (%d)\n&quot;</span>, ret);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="gpiolib-dev-init-初始化GPIO设备库"><a href="#gpiolib-dev-init-初始化GPIO设备库" class="headerlink" title="gpiolib_dev_init: 初始化GPIO设备库"></a>gpiolib_dev_init: 初始化GPIO设备库</h2><p>此函数在内核启动的早期阶段被调用，其核心职责是<strong>建立Linux内核GPIO子系统的设备驱动模型框架</strong>。它本身不注册任何具体的GPIO硬件，而是搭建一个“舞台”，让后续具体的GPIO控制器驱动（如STM32的GPIO驱动）能够在这个舞台上注册自己，并以一种标准化的方式向用户空间暴露接口。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义一个静态的 &#x27;device_driver&#x27; 结构体实例, 名为 gpio_stub_drv.</span></span><br><span class="line"><span class="comment"> * 这是一个 &quot;存根驱动&quot; (stub driver). 它的作用是在没有真正的GPIO设备注册时,</span></span><br><span class="line"><span class="comment"> * 作为一个占位符存在于GPIO总线上. 这有助于简化总线管理逻辑.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> <span class="title">gpio_stub_drv</span> =</span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * .name: 驱动的名称. 这个名字会出现在 sysfs 中.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	.name = <span class="string">&quot;gpio_stub_drv&quot;</span>,</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * .bus: 指定这个驱动属于哪个总线. 这里它被绑定到 gpio_bus_type.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	.bus = &amp;gpio_bus_type,</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * .probe: 当一个设备与这个驱动匹配时, 内核会调用 .probe 函数.</span></span><br><span class="line"><span class="comment">	 * (gpio_stub_drv_probe 的定义不在此处, 但它通常只做少量工作或什么都不做).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	.probe = gpio_stub_drv_probe,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * gpiolib_dev_init: GPIO设备库的初始化函数.</span></span><br><span class="line"><span class="comment"> * 标记为 __init, 表示它仅在内核启动期间执行.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">gpiolib_dev_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * ret: 用于存储函数调用的返回值.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 第一步: 注册GPIO总线类型.</span></span><br><span class="line"><span class="comment">	 * bus_register() 会在 /sys/bus/ 目录下创建一个名为 &quot;gpio&quot; 的新目录.</span></span><br><span class="line"><span class="comment">	 * 这就创建了一条虚拟的 &quot;GPIO总线&quot;. 所有后续的GPIO控制器设备和驱动,</span></span><br><span class="line"><span class="comment">	 * 都会被 &quot;挂载&quot; 到这条总线上. 这是建立标准设备模型的第一步.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ret = bus_register(&amp;gpio_bus_type);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123; <span class="comment">/* 检查注册是否成功. */</span></span><br><span class="line">		<span class="comment">/* 如果失败, 打印错误日志. */</span></span><br><span class="line">		pr_err(<span class="string">&quot;gpiolib: could not register GPIO bus type\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 第二步: 注册GPIO存根驱动.</span></span><br><span class="line"><span class="comment">	 * driver_register() 会将我们上面定义的 gpio_stub_drv 注册到内核中,</span></span><br><span class="line"><span class="comment">	 * 并将其与 gpio_bus_type 关联.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ret = driver_register(&amp;gpio_stub_drv);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123; <span class="comment">/* 检查注册是否成功. */</span></span><br><span class="line">		pr_err(<span class="string">&quot;gpiolib: could not register GPIO stub driver\n&quot;</span>);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 如果失败, 必须执行清理操作: 注销之前成功注册的总线,</span></span><br><span class="line"><span class="comment">		 * 以保持系统状态的一致性.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		bus_unregister(&amp;gpio_bus_type);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 第三步: 为GPIO字符设备分配一个主次设备号范围.</span></span><br><span class="line"><span class="comment">	 * 现代Linux内核推荐使用字符设备接口(/dev/gpiochipN)来访问GPIO.</span></span><br><span class="line"><span class="comment">	 * alloc_chrdev_region() 会向内核申请一段连续的、未被使用的设备号.</span></span><br><span class="line"><span class="comment">	 * @ &amp;gpio_devt: 用于存储分配到的起始设备号 (主设备号+次设备号).</span></span><br><span class="line"><span class="comment">	 * @ 0:           起始的次设备号, 0表示由内核动态选择.</span></span><br><span class="line"><span class="comment">	 * @ GPIO_DEV_MAX: 希望分配的设备号数量, 即最多支持多少个GPIO控制器.</span></span><br><span class="line"><span class="comment">	 * @ GPIOCHIP_NAME: 与这个设备号范围关联的名称 (通常是 &quot;gpio&quot;).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ret = alloc_chrdev_region(&amp;gpio_devt, <span class="number">0</span>, GPIO_DEV_MAX, GPIOCHIP_NAME);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123; <span class="comment">/* 检查分配是否成功. */</span></span><br><span class="line">		pr_err(<span class="string">&quot;gpiolib: failed to allocate char dev region\n&quot;</span>);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 如果失败, 必须按相反的顺序执行清理操作.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		driver_unregister(&amp;gpio_stub_drv);</span><br><span class="line">		bus_unregister(&amp;gpio_bus_type);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 设置一个全局标志, 表示GPIO库的核心基础设施已经初始化完毕.</span></span><br><span class="line"><span class="comment">	 * 其他部分的代码可能会检查这个标志.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	gpiolib_initialized = <span class="literal">true</span>;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 调用 gpiochip_setup_devs(), 这个函数会进一步设置字符设备接口</span></span><br><span class="line"><span class="comment">	 * 所需的类(class)等, 准备好动态创建/dev/gpiochipN节点的条件.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	gpiochip_setup_devs();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这部分代码用于处理动态设备树(Dynamic Device Tree)的通知.</span></span><br><span class="line"><span class="comment"> * 它允许在系统运行时, 如果设备树中的GPIO相关节点发生变化(例如通过overlay),</span></span><br><span class="line"><span class="comment"> * GPIO子系统能够收到通知并做出相应的调整.</span></span><br><span class="line"><span class="comment"> * 这对于像树莓派这样支持DT overlay的系统很重要, 对于固件固定的STM32系统则不太常用.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> IS_ENABLED(CONFIG_OF_DYNAMIC) &amp;&amp; IS_ENABLED(CONFIG_OF_GPIO)</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 注册一个通知回调函数(gpio_of_notifier),</span></span><br><span class="line"><span class="comment">	 * 当设备树发生重新配置时, 内核会调用它.</span></span><br><span class="line"><span class="comment">	 * WARN_ON 确保如果注册失败, 会打印一个警告, 因为这通常不应该发生.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	WARN_ON(of_reconfig_notifier_register(&amp;gpio_of_notifier));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_OF_DYNAMIC &amp;&amp; CONFIG_OF_GPIO */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 返回0或最后一次成功的操作的返回值, 表示初始化成功.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用 core_initcall() 将 gpiolib_dev_init 注册为一个核心初始化调用.</span></span><br><span class="line"><span class="comment"> * 这确保了GPIO的基础设施会在所有具体的GPIO控制器驱动(如STM32的GPIO驱动)</span></span><br><span class="line"><span class="comment"> * 尝试注册自己之前, 就已经准备就绪.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">core_initcall(gpiolib_dev_init);</span><br></pre></td></tr></table></figure>

<h2 id="gpiolib-总线与设备类型定义"><a href="#gpiolib-总线与设备类型定义" class="headerlink" title="gpiolib 总线与设备类型定义"></a><code>gpiolib</code> 总线与设备类型定义</h2><p>此代码片段定义了Linux内核<code>gpiolib</code>子系统用于融入内核标准<strong>设备模型(Device Model)<strong>的两个核心数据结构。它的核心原理是</strong>创建一个名为 “gpio” 的逻辑总线(logical bus)</strong>, 并为所有注册的GPIO控制器(gpio_chip)定义一个统一的设备类型(<code>gpio_chip</code>)。这使得内核可以将每一个GPIO控制器都视为一个标准化的”设备”, 并通过一个虚拟的”总线”来管理它们, 从而能够复用设备模型提供的所有成熟机制, 如驱动绑定、电源管理和<code>sysfs</code>接口。</p>
<hr>
<h3 id="gpio-dev-type-GPIO芯片的设备类型"><a href="#gpio-dev-type-GPIO芯片的设备类型" class="headerlink" title="gpio_dev_type: GPIO芯片的设备类型"></a><code>gpio_dev_type</code>: GPIO芯片的设备类型</h3><p>这是一个<code>struct device_type</code>实例, 它为所有由<code>gpiolib</code>创建的<code>struct gpio_device</code>对象提供了一组通用的属性。</p>
<p><strong>原理与作用</strong>:<br><code>device_type</code>的主要作用是为一类设备提供共享的特性, 最重要的是<strong>统一的释放(release)回调函数</strong>。</p>
<ul>
<li><code>.name = &quot;gpio_chip&quot;</code>: 为这类设备指定了一个内部名称 “gpio_chip”。这个名字主要用于调试和内核内部识别。</li>
<li><code>.release = gpiodev_release</code>: 这是此结构体最关键的部分。它指定了一个回调函数<code>gpiodev_release</code>。当一个<code>gpio_device</code>对象的最后一个引用被释放(其引用计数降为0)时, 内核的设备模型会自动调用这个函数。<code>gpiodev_release</code>函数内部会负责清理和释放与该<code>gpio_device</code>对象相关的所有内存和资源。这是一种健壮的、自动化的资源管理机制, 对于防止内存泄漏至关重要, 在像STM32H750这样内存资源宝贵的嵌入式系统中尤其重要。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义一个静态的、常量类型的 struct device_type 实例.</span></span><br><span class="line"><span class="comment"> * &quot;static&quot;表示其作用域仅限于当前文件. &quot;const&quot;表示其内容在编译后是只读的.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">device_type</span> <span class="title">gpio_dev_type</span> =</span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * .name: 指定此设备类型的名称为 &quot;gpio_chip&quot;.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	.name = <span class="string">&quot;gpio_chip&quot;</span>,</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * .release: 指定一个回调函数 gpiodev_release.</span></span><br><span class="line"><span class="comment">	 * 当内核要销毁一个此类型的设备对象时, 这个函数会被自动调用以释放资源.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	.release = gpiodev_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="gpio-bus-match-GPIO总线的匹配规则"><a href="#gpio-bus-match-GPIO总线的匹配规则" class="headerlink" title="gpio_bus_match: GPIO总线的匹配规则"></a><code>gpio_bus_match</code>: GPIO总线的匹配规则</h3><p>这是一个自定义的<code>match</code>函数, 它定义了在”gpio”总线上, 一个设备和一个驱动程序应该如何被视为”兼容”的。</p>
<p><strong>原理与作用</strong>:<br>标准的总线(如I2C, SPI)通常根据设备和驱动的名称或ID来进行匹配。但”gpio”总线是一个逻辑上的虚拟总线, 其匹配规则也比较特殊。</p>
<ul>
<li><code>struct fwnode_handle *fwnode = dev_fwnode(dev);</code>: 获取与设备<code>dev</code>关联的固件节点(通常是设备树节点)。</li>
<li><code>if (fwnode &amp;&amp; fwnode-&gt;dev != dev)</code>: 这是匹配的核心逻辑。一个物理GPIO控制器在内核中可能对应多个<code>struct device</code>对象(例如, 一个<code>platform_device</code>和<code>gpiolib</code>创建的<code>gpio_device</code>)。<code>fwnode-&gt;dev</code>通常指向最主要的那个设备对象(即<code>platform_device</code>)。这个判断的意图是: <strong>只有当这个<code>gpio_device</code>是其固件节点所代表的主要设备时, 才允许匹配</strong>。它防止了通用的”gpio总线驱动”错误地绑定到一个已经被更具体的平台驱动所拥有的硬件上, 是一种避免潜在逻辑冲突的保护机制。</li>
<li><code>return 1;</code> 表示匹配成功。</li>
<li><code>return 0;</code> 表示匹配失败。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * gpio_bus_match: &quot;gpio&quot;总线的自定义匹配函数.</span></span><br><span class="line"><span class="comment"> * @dev: 要进行匹配的设备.</span></span><br><span class="line"><span class="comment"> * @drv: 要进行匹配的驱动.</span></span><br><span class="line"><span class="comment"> * @return: 1 表示匹配成功, 0 表示失败.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_bus_match</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">const</span> <span class="keyword">struct</span> device_driver *drv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 获取设备的固件节点句柄 (fwnode). */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fwnode_handle</span> *<span class="title">fwnode</span> =</span> dev_fwnode(dev);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 这是一个特殊的匹配逻辑, 用于处理一个硬件节点可能对应多个设备对象的情况.</span></span><br><span class="line"><span class="comment">	 * 如果该固件节点存在, 并且它关联的主要设备不是当前正在匹配的这个设备,</span></span><br><span class="line"><span class="comment">	 * 那么就认为不匹配.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (fwnode &amp;&amp; fwnode-&gt;dev != dev)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 在其他情况下, 都认为匹配成功. */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="gpio-bus-type-“gpio”-逻辑总线"><a href="#gpio-bus-type-“gpio”-逻辑总线" class="headerlink" title="gpio_bus_type: “gpio” 逻辑总线"></a><code>gpio_bus_type</code>: “gpio” 逻辑总线</h3><p>这是一个<code>struct bus_type</code>实例, 它在内核中注册了一个全新的、名为”gpio”的总线。</p>
<p><strong>原理与作用</strong>:<br>注册这个结构体会在<code>sysfs</code>中创建<code>/sys/bus/gpio/</code>目录。所有被<code>gpiolib</code>注册的GPIO控制器都会作为设备出现在这个总线上。这提供了一个统一的场所来管理和查看系统中的所有GPIO控制器。</p>
<ul>
<li><code>.name = &quot;gpio&quot;</code>: 定义了总线的名称, 这也是<code>sysfs</code>中目录的名称。</li>
<li><code>.match = gpio_bus_match</code>: 将上面定义的自定义匹配函数<code>gpio_bus_match</code>指定为本总线的官方匹配规则。当任何驱动或设备尝试在此总线上进行绑定时, 内核都会调用这个函数来做决定。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义一个静态的、常量类型的 struct bus_type 实例, 用于描述 &quot;gpio&quot; 总线.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> <span class="title">gpio_bus_type</span> =</span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * .name: 总线的名称, 将会创建 /sys/bus/gpio 目录.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	.name = <span class="string">&quot;gpio&quot;</span>,</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * .match: 指定此总线的设备-驱动匹配函数.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	.match = gpio_bus_match,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="gpiochip-find-base-unlocked-动态查找可用的GPIO编号基地址"><a href="#gpiochip-find-base-unlocked-动态查找可用的GPIO编号基地址" class="headerlink" title="gpiochip_find_base_unlocked: 动态查找可用的GPIO编号基地址"></a>gpiochip_find_base_unlocked: 动态查找可用的GPIO编号基地址</h2><p>此函数是Linux内核<code>gpiolib</code>子系统中<strong>实现GPIO控制器编号动态分配的核心算法</strong>。当一个新的GPIO控制器驱动请求动态分配其GPIO编号基地址时(<code>gpio_chip-&gt;base = -1</code>), <code>gpiochip_add_data</code>函数会在持有锁的情况下调用此函数。它的核心原理是<strong>以一种”贪心算法”(Greedy Algorithm)的思路, 线性扫描一个全局的、已注册的GPIO设备链表, 以寻找第一个足够大的、未被占用的连续编号”空隙”</strong>。</p>
<p><strong>工作流程详解:</strong></p>
<ol>
<li><strong>初始化</strong>: 函数从一个预定义的动态分配起始点<code>GPIO_DYNAMIC_BASE</code>开始搜索。这个值通常足够大, 以避开为特殊硬件静态预留的低地址编号。</li>
<li><strong>遍历已注册设备链表</strong>: 它使用<code>list_for_each_entry_srcu</code>宏来安全地遍历<code>gpio_devices</code>这个全局链表。这个链表按照GPIO基地址从小到大的顺序维护了所有已注册的GPIO控制器。<code>_srcu</code>版本的宏使用了”读-拷贝-更新”(Read-Copy-Update)的变体, 即使在遍历过程中有其他CPU在并发地修改链表(虽然此函数被调用时已持有锁, 但这个宏是通用的), 也能保证遍历的安全性。</li>
<li><strong>寻找空隙 (核心算法)</strong>: 在循环的每一步, 它会比较当前搜索的起始点<code>base</code>和正在检查的已注册设备<code>gdev</code>的范围:<ul>
<li><strong>找到空隙 (成功)</strong>: 如果当前<code>gdev</code>的基地址 (<code>gdev-&gt;base</code>) 大于或等于 <code>base + ngpio</code> (当前搜索点 + 需要的引脚数量), 这意味着在<code>base</code>和<code>gdev</code>之间有一个足够大的空隙。循环立即<code>break</code>。</li>
<li><strong>未找到空隙 (继续搜索)</strong>: 如果没有找到空隙, 函数会将搜索的起始点<code>base</code>更新为<strong>当前<code>gdev</code>范围的末尾之后</strong> (<code>base = gdev-&gt;base + gdev-&gt;ngpio;</code>)。然后继续下一次循环, 检查这个新的<code>base</code>与下一个已注册设备之间的关系。</li>
</ul>
</li>
<li><strong>边界检查</strong>: 在每次更新<code>base</code>后, 都会检查新的<code>base</code>是否超出了预定义的动态分配的最大范围<code>GPIO_DYNAMIC_MAX</code>。如果超出, 说明不可能再找到空隙了, 循环也会<code>break</code>。</li>
<li><strong>返回结果</strong>:<ul>
<li>如果循环结束后, <code>base</code>仍然在有效的动态分配范围内, 说明找到了一个可用的基地址, 函数将其返回。</li>
<li>如果超出了范围, 说明GPIO编号空间已满, 函数返回<code>-ENOSPC</code>(“设备上没有空间”)错误。</li>
</ul>
</li>
</ol>
<p><strong>为什么这个机制很重要?</strong><br>在早期的Linux内核中, GPIO控制器的基地址通常由驱动程序或板级文件静态硬编码。这种方式非常容易导致冲突, 特别是在一个平台上集成了来自不同供应商的、可热插拔的模块化硬件时。动态分配机制彻底解决了这个问题。它使得内核可以像DHCP服务器分配IP地址一样, 自动地为新加入的GPIO控制器找到一个不与任何现有设备冲突的、唯一的编号范围。这对于构建可扩展、可维护的嵌入式Linux系统, 尤其是在STM32这样拥有众多GPIO端口的平台上, 是至关重要的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * gpiochip_find_base_unlocked: 在未锁定的上下文中(但调用者必须持有锁), 动态地查找GPIO基地址.</span></span><br><span class="line"><span class="comment"> * @ngpio: 新的GPIO控制器需要的引脚数量.</span></span><br><span class="line"><span class="comment"> * @return: 成功时返回一个可用的基地址, 失败时返回 -ENOSPC.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpiochip_find_base_unlocked</span><span class="params">(u16 ngpio)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 从预定义的动态GPIO编号起始地址开始搜索.</span></span><br><span class="line"><span class="comment">	 * 这个值通常是256或512, 以避开静态分配的低地址区域.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> base = GPIO_DYNAMIC_BASE;</span><br><span class="line">	<span class="comment">/* 定义一个gdev指针, 用于遍历已注册的GPIO设备. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_device</span> *<span class="title">gdev</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 安全地遍历全局的 gpio_devices 链表. 这个链表按照基地址排序.</span></span><br><span class="line"><span class="comment">	 * lockdep_is_held() 是一个锁调试断言, 确保调用此函数时确实持有了 gpio_devices_lock.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	list_for_each_entry_srcu(gdev, &amp;gpio_devices, <span class="built_in">list</span>,</span><br><span class="line">				 lockdep_is_held(&amp;gpio_devices_lock)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 核心的空隙查找逻辑:</span></span><br><span class="line"><span class="comment">		 * 检查当前已注册设备 gdev 的基地址, 是否大于等于 (我们当前寻找的基地址 base + 我们需要的数量 ngpio).</span></span><br><span class="line"><span class="comment">		 * 如果是, 说明在 base 和 gdev-&gt;base 之间有一个足够大的空隙.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (gdev-&gt;base &gt;= base + ngpio)</span><br><span class="line">			<span class="keyword">break</span>; <span class="comment">/* 找到了, 跳出循环. */</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 如果没有找到空隙, 更新我们的搜索起点:</span></span><br><span class="line"><span class="comment">		 * 将 base 设置为当前设备 gdev 占用范围的末尾之后.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		base = gdev-&gt;base + gdev-&gt;ngpio;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 确保我们的搜索起点不会回退到动态范围的起始点之下. */</span></span><br><span class="line">		<span class="keyword">if</span> (base &lt; GPIO_DYNAMIC_BASE)</span><br><span class="line">			base = GPIO_DYNAMIC_BASE;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 检查更新后的 base 是否还有可能容纳 ngpio 个引脚而不超出最大范围. */</span></span><br><span class="line">		<span class="keyword">if</span> (base &gt; GPIO_DYNAMIC_MAX - ngpio)</span><br><span class="line">			<span class="keyword">break</span>; <span class="comment">/* 不可能了, 跳出循环. */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 循环结束后, 检查最终的 base 是否仍在合法范围内.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (base &lt;= GPIO_DYNAMIC_MAX - ngpio) &#123;</span><br><span class="line">		pr_debug(<span class="string">&quot;%s: found new base at %d\n&quot;</span>, __func__, base);</span><br><span class="line">		<span class="keyword">return</span> base; <span class="comment">/* 成功, 返回找到的基地址. */</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;%s: cannot find free range\n&quot;</span>, __func__);</span><br><span class="line">		<span class="keyword">return</span> -ENOSPC; <span class="comment">/* 失败, 返回&quot;无可用空间&quot;错误. */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="gpiodev-add-to-list-unlocked-将GPIO设备插入全局排序列表"><a href="#gpiodev-add-to-list-unlocked-将GPIO设备插入全局排序列表" class="headerlink" title="gpiodev_add_to_list_unlocked: 将GPIO设备插入全局排序列表"></a>gpiodev_add_to_list_unlocked: 将GPIO设备插入全局排序列表</h2><p>此函数是Linux内核<code>gpiolib</code>子系统内部一个至关重要的列表管理函数。它的核心原理是<strong>以一种原子性的、保证排序的方式, 将一个新初始化的GPIO设备(<code>gdev</code>)插入到一个全局的、按GPIO编号基地址排序的设备链表(<code>gpio_devices</code>)中</strong>。在插入的同时, 它还必须严格执行<strong>冲突检测</strong>, 确保新设备的GPIO编号范围不会与任何已存在的设备发生重叠。</p>
<p>这个函数是GPIO控制器能够被内核动态、安全地添加和管理的基础。它的命名后缀<code>_unlocked</code>是一个明确的约定, 意味着<strong>调用此函数的代码必须已经持有了保护该链表的<code>gpio_devices_lock</code>锁</strong>, <code>lockdep_assert_held</code>宏在函数开头就强制检查了这一前提条件。</p>
<p><strong>工作流程与算法详解:</strong></p>
<p>该函数的算法是一个为链表插入优化的”寻找间隙”过程:</p>
<ol>
<li><p><strong>空列表处理 (最快路径)</strong>: 如果全局链表<code>gpio_devices</code>是空的, 说明这是第一个被注册的GPIO控制器。函数直接将其添加到链表尾部并成功返回。</p>
</li>
<li><p><strong>头部插入优化 (次快路径)</strong>: 函数检查新设备<code>gdev</code>是否可以被完整地插入到链表的最前端。它比较<code>gdev</code>的结束地址与链表中第一个设备<code>next</code>的起始地址。如果<code>gdev</code>的范围在<code>next</code>之前且无重叠, 就将其插入到链表头部。</p>
</li>
<li><p><strong>尾部插入优化 (次快路径)</strong>: 类似地, 函数检查<code>gdev</code>是否可以被完整地插入到链表的最后端。它比较<code>gdev</code>的起始地址与链表中最后一个设备<code>prev</code>的结束地址。如果<code>gdev</code>的范围在<code>prev</code>之后且无重叠, 就将其插入到链表尾部。<strong>这两种优化(头部和尾部)覆盖了系统启动时设备按顺序注册的绝大多数情况, 避免了昂贵的完整链表遍历。</strong></p>
</li>
<li><p><strong>中间插入 (通用路径)</strong>: 如果以上优化都不适用, 函数就必须遍历整个链表来寻找一个可以容纳<code>gdev</code>的”间隙”。它使用<code>list_for_each_entry_safe</code>同时追踪前一个节点<code>prev</code>和下一个节点<code>next</code>, 并检查是否存在一个位置, 使得<code>gdev</code>的范围恰好在<code>prev</code>之后且在<code>next</code>之前。如果找到这样的间隙, 就执行插入并成功返回。</p>
</li>
<li><p><strong>冲突检测与失败</strong>: 如果函数遍历完整个链表都没有找到任何可以插入的间隙(即不满足上述任何一个插入条件), 这就<strong>确定地</strong>意味着<code>gdev</code>的GPIO编号范围与一个或多个已存在的设备发生了重叠。在这种情况下, 函数不会执行任何插入操作, 而是直接返回<code>-EBUSY</code>错误码, 明确地告知上层调用者发生了冲突。</p>
</li>
</ol>
<p><strong>RCU (读-拷贝-更新) 的使用</strong>:<br>此函数使用了<code>list_add_rcu</code>和<code>list_add_tail_rcu</code>。<code>_rcu</code>后缀表明这个链表是受RCU机制保护的。这是一种高级的同步技术, 它允许其他代码在<strong>不获取任何锁的情况下安全地并发读取</strong><code>gpio_devices</code>链表, 极大地提高了系统的并发性能。只有在写入(添加或删除节点)时才需要获取锁。</p>
<p><strong>在STM32H750上的应用:</strong><br>当STM32驱动程序一个接一个地注册其GPIO Bank (GPIOA, GPIOB, GPIOC…)时, <code>gpiochip_add_data</code>内部就会调用此函数。</p>
<ul>
<li>注册GPIOA时, 会命中”空列表”路径。</li>
<li>注册GPIOB时, 会命中”尾部插入”路径。</li>
<li>注册GPIOC时, 同样会命中”尾部插入”路径。<br>…以此类推。这使得STM32众多GPIO Bank的注册过程非常高效。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * gpiodev_add_to_list_unlocked: 将一个新的chip添加到全局chips列表中, 保持列表</span></span><br><span class="line"><span class="comment"> * 按范围(即[base, base + ngpio - 1])排序.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回:</span></span><br><span class="line"><span class="comment"> * -EBUSY 如果新的chip与某个其他chip的整数空间重叠.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpiodev_add_to_list_unlocked</span><span class="params">(<span class="keyword">struct</span> gpio_device *gdev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_device</span> *<span class="title">prev</span>, *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 这是一个锁调试断言, 确保调用者确实持有了 gpio_devices_lock 锁. */</span></span><br><span class="line">	lockdep_assert_held(&amp;gpio_devices_lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 情况1: 列表为空. 这是第一个被添加的设备. */</span></span><br><span class="line">	<span class="keyword">if</span> (list_empty(&amp;gpio_devices)) &#123;</span><br><span class="line">		<span class="comment">/* 直接添加到链表尾部. _rcu版本确保了对并发RCU读者的安全. */</span></span><br><span class="line">		list_add_tail_rcu(&amp;gdev-&gt;<span class="built_in">list</span>, &amp;gpio_devices);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 情况2: 尝试在头部插入 (优化). */</span></span><br><span class="line">	next = list_first_entry(&amp;gpio_devices, <span class="keyword">struct</span> gpio_device, <span class="built_in">list</span>);</span><br><span class="line">	<span class="comment">/* 检查新设备的范围是否完全在第一个设备之前. */</span></span><br><span class="line">	<span class="keyword">if</span> (gdev-&gt;base + gdev-&gt;ngpio &lt;= next-&gt;base) &#123;</span><br><span class="line">		<span class="comment">/* 使用_rcu版本添加到链表头部. */</span></span><br><span class="line">		list_add_rcu(&amp;gdev-&gt;<span class="built_in">list</span>, &amp;gpio_devices);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 情况3: 尝试在尾部插入 (优化). */</span></span><br><span class="line">	prev = list_last_entry(&amp;gpio_devices, <span class="keyword">struct</span> gpio_device, <span class="built_in">list</span>);</span><br><span class="line">	<span class="comment">/* 检查新设备的范围是否完全在最后一个设备之后. */</span></span><br><span class="line">	<span class="keyword">if</span> (prev-&gt;base + prev-&gt;ngpio &lt;= gdev-&gt;base) &#123;</span><br><span class="line">		list_add_tail_rcu(&amp;gdev-&gt;<span class="built_in">list</span>, &amp;gpio_devices);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 情况4: 在中间插入 (通用路径). */</span></span><br><span class="line">	<span class="comment">/* _safe版本可以安全地处理循环中对链表的修改, 这里用于方便地获取prev和next. */</span></span><br><span class="line">	list_for_each_entry_safe(prev, next, &amp;gpio_devices, <span class="built_in">list</span>) &#123;</span><br><span class="line">		<span class="comment">/* &amp;next-&gt;list == &amp;gpio_devices 表示prev已经是最后一个元素了. */</span></span><br><span class="line">		<span class="keyword">if</span> (&amp;next-&gt;<span class="built_in">list</span> == &amp;gpio_devices)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 检查是否找到了一个间隙:</span></span><br><span class="line"><span class="comment">		 * 新设备的起始地址在prev之后, 并且新设备的结束地址在next之前.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (prev-&gt;base + prev-&gt;ngpio &lt;= gdev-&gt;base</span><br><span class="line">				&amp;&amp; gdev-&gt;base + gdev-&gt;ngpio &lt;= next-&gt;base) &#123;</span><br><span class="line">			<span class="comment">/* 在prev之后插入新设备. */</span></span><br><span class="line">			list_add_rcu(&amp;gdev-&gt;<span class="built_in">list</span>, &amp;prev-&gt;<span class="built_in">list</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 如果执行到这里, 说明遍历了整个列表都没有找到可以插入的间隙.</span></span><br><span class="line"><span class="comment">	 * 这意味着存在地址范围重叠.</span></span><br><span class="line"><span class="comment">	 * 在返回错误前, 等待所有正在进行的RCU读取操作完成.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	synchronize_srcu(&amp;gpio_devices_srcu);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 返回 &quot;设备或资源繁忙&quot; 错误. */</span></span><br><span class="line">	<span class="keyword">return</span> -EBUSY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="GPIO有效引脚掩码-Valid-Mask-与引脚范围管理系列函数"><a href="#GPIO有效引脚掩码-Valid-Mask-与引脚范围管理系列函数" class="headerlink" title="GPIO有效引脚掩码(Valid Mask)与引脚范围管理系列函数"></a>GPIO有效引脚掩码(Valid Mask)与引脚范围管理系列函数</h2><p>此代码片段展示了Linux内核<code>gpiolib</code>子系统中一组用于管理GPIO控制器引脚有效性和范围映射的函数。它们共同构成了一个强大而灵活的系统, 其核心原理是<strong>通过静态的设备树声明和&#x2F;或动态的驱动回调, 创建一个精确的”有效引脚掩码”(valid mask), 并将GPIO编号范围与pinctrl子系统关联起来</strong>。这使得<code>gpiolib</code>能够安全地处理具有非连续、复杂引脚布局的硬件, 并确保了不同子系统间的正确协作。</p>
<hr>
<h3 id="1-有效引脚掩码的生命周期管理"><a href="#1-有效引脚掩码的生命周期管理" class="headerlink" title="1. 有效引脚掩码的生命周期管理"></a>1. 有效引脚掩码的生命周期管理</h3><p>这组函数负责创建、填充和释放<code>valid_mask</code>位图。</p>
<h4 id="gpiochip-allocate-mask-gpiochip-free-mask-gpiochip-free-valid-mask"><a href="#gpiochip-allocate-mask-gpiochip-free-mask-gpiochip-free-valid-mask" class="headerlink" title="gpiochip_allocate_mask &amp; gpiochip_free_mask &#x2F; gpiochip_free_valid_mask"></a><code>gpiochip_allocate_mask</code> &amp; <code>gpiochip_free_mask</code> &#x2F; <code>gpiochip_free_valid_mask</code></h4><p>这是位图最基本的内存管理。<code>allocate</code>负责分配内存并设定一个”全部有效”的初始状态, <code>free</code>则负责释放。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* gpiochip_allocate_mask: 分配一个有效掩码位图. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> *<span class="title function_">gpiochip_allocate_mask</span><span class="params">(<span class="keyword">struct</span> gpio_chip *gc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> *p;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 使用内核位图API分配一块能容纳 ngpio 个比特的内存. */</span></span><br><span class="line">	p = bitmap_alloc(gc-&gt;ngpio, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!p)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 关键的初始状态: 默认假设所有GPIO引脚都是有效的, 将所有位都设置为1. */</span></span><br><span class="line">	bitmap_fill(p, gc-&gt;ngpio);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* gpiochip_free_mask: 释放一个掩码位图. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">gpiochip_free_mask</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> **p)</span></span><br><span class="line">&#123;</span><br><span class="line">	bitmap_free(*p); <span class="comment">/* 释放位图内存. */</span></span><br><span class="line">	*p = <span class="literal">NULL</span>;       <span class="comment">/* 将指针设为NULL, 防止悬挂指针. */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* gpiochip_free_valid_mask: devm框架使用的清理函数, 释放有效掩码. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">gpiochip_free_valid_mask</span><span class="params">(<span class="keyword">struct</span> gpio_chip *gc)</span></span><br><span class="line">&#123;</span><br><span class="line">	gpiochip_free_mask(&amp;gc-&gt;gpiodev-&gt;valid_mask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-通过设备树声明无效引脚-静态方式"><a href="#2-通过设备树声明无效引脚-静态方式" class="headerlink" title="2. 通过设备树声明无效引脚 (静态方式)"></a>2. 通过设备树声明无效引脚 (静态方式)</h3><p>这组函数实现了通过设备树中的<code>gpio-reserved-ranges</code>属性来声明无效引脚范围。</p>
<h4 id="gpiochip-count-reserved-ranges-gpiochip-apply-reserved-ranges"><a href="#gpiochip-count-reserved-ranges-gpiochip-apply-reserved-ranges" class="headerlink" title="gpiochip_count_reserved_ranges &amp; gpiochip_apply_reserved_ranges"></a><code>gpiochip_count_reserved_ranges</code> &amp; <code>gpiochip_apply_reserved_ranges</code></h4><p><code>count</code>函数检查属性是否存在且格式正确, <code>apply</code>函数则读取属性内容并在<code>valid_mask</code>中”打孔”。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* gpiochip_count_reserved_ranges: 计算 &quot;gpio-reserved-ranges&quot; 属性中的条目数量. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">gpiochip_count_reserved_ranges</span><span class="params">(<span class="keyword">struct</span> gpio_chip *gc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> =</span> &amp;gc-&gt;gpiodev-&gt;dev;</span><br><span class="line">	<span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 属性格式是成对的u32值: [起始偏移, 数量, ...], 所以总数必须是偶数. */</span></span><br><span class="line">	size = device_property_count_u32(dev, <span class="string">&quot;gpio-reserved-ranges&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; size % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> size;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* gpiochip_apply_reserved_ranges: 读取保留范围属性并将其应用到有效掩码上. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpiochip_apply_reserved_ranges</span><span class="params">(<span class="keyword">struct</span> gpio_chip *gc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// ... (代码逻辑: 1. 检查是否有保留范围. 2. 分配临时内存读取属性. 3. 读取属性.) ...</span></span><br><span class="line">    <span class="comment">// ... (循环读取[start, count]对)</span></span><br><span class="line">	<span class="keyword">while</span> (size) &#123;</span><br><span class="line">		u32 count = ranges[--size]; <span class="comment">// 获取数量</span></span><br><span class="line">		u32 start = ranges[--size]; <span class="comment">// 获取起始偏移</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 安全检查, 确保范围不会超出芯片的能力. */</span></span><br><span class="line">		<span class="keyword">if</span> (start &gt;= gc-&gt;ngpio || start + count &gt; gc-&gt;ngpio)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 核心操作: 在valid_mask位图中, 从start位开始, 清除count个位 (将它们设为0). */</span></span><br><span class="line">		bitmap_clear(gc-&gt;gpiodev-&gt;valid_mask, start, count);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// ... (释放临时内存) ...</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-有效掩码的构建与查询"><a href="#3-有效掩码的构建与查询" class="headerlink" title="3. 有效掩码的构建与查询"></a>3. 有效掩码的构建与查询</h3><p>这组函数是上层API, 用于协调掩码的构建过程并提供查询接口。</p>
<h4 id="gpiochip-init-valid-mask"><a href="#gpiochip-init-valid-mask" class="headerlink" title="gpiochip_init_valid_mask"></a><code>gpiochip_init_valid_mask</code></h4><p>这是<code>gpiochip_add_data</code>调用的主协调函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* gpiochip_init_valid_mask: 为一个gpio_chip初始化其有效引脚掩码. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpiochip_init_valid_mask</span><span class="params">(<span class="keyword">struct</span> gpio_chip *gc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 只有在驱动定义了&quot;保留范围&quot;(静态方式)或提供了自定义初始化函数(动态方式)时, 才需要创建掩码. */</span></span><br><span class="line">	<span class="keyword">if</span> (!(gpiochip_count_reserved_ranges(gc) || gc-&gt;init_valid_mask))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 1. 分配一个全1的掩码. */</span></span><br><span class="line">	gc-&gt;gpiodev-&gt;valid_mask = gpiochip_allocate_mask(gc);</span><br><span class="line">	<span class="keyword">if</span> (!gc-&gt;gpiodev-&gt;valid_mask)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 2. 应用设备树中定义的静态保留范围, 在掩码上&quot;打孔&quot;. */</span></span><br><span class="line">	ret = gpiochip_apply_reserved_ranges(gc);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 3. 如果驱动提供了自定义的回调函数, 调用它, 给予驱动最后一次动态修改掩码的机会. */</span></span><br><span class="line">	<span class="keyword">if</span> (gc-&gt;init_valid_mask)</span><br><span class="line">		<span class="keyword">return</span> gc-&gt;init_valid_mask(gc,</span><br><span class="line">					   gc-&gt;gpiodev-&gt;valid_mask,</span><br><span class="line">					   gc-&gt;ngpio);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="gpiochip-query-valid-mask-gpiochip-line-is-valid"><a href="#gpiochip-query-valid-mask-gpiochip-line-is-valid" class="headerlink" title="gpiochip_query_valid_mask &amp; gpiochip_line_is_valid"></a><code>gpiochip_query_valid_mask</code> &amp; <code>gpiochip_line_is_valid</code></h4><p>这两个函数提供了对已构建好的<code>valid_mask</code>的查询能力。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* gpiochip_query_valid_mask: 返回整个有效掩码位图的指针. */</span></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> *<span class="title function_">gpiochip_query_valid_mask</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> gpio_chip *gc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> gc-&gt;gpiodev-&gt;valid_mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* gpiochip_line_is_valid: 检查单个引脚是否有效. */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">gpiochip_line_is_valid</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> gpio_chip *gc,</span></span><br><span class="line"><span class="params">				<span class="type">unsigned</span> <span class="type">int</span> offset)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 在芯片完全注册前(例如处理pin hog时), 默认所有引脚有效. */</span></span><br><span class="line">	<span class="keyword">if</span> (!gc-&gt;gpiodev)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 快速路径优化: 如果没有掩码(NULL), 说明所有引脚都有效. */</span></span><br><span class="line">	<span class="keyword">if</span> (likely(!gc-&gt;gpiodev-&gt;valid_mask))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 慢速路径: 检查掩码位图中对应的位是否为1. */</span></span><br><span class="line">	<span class="keyword">return</span> test_bit(offset, gc-&gt;gpiodev-&gt;valid_mask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-GPIO范围与Pinctrl的关联"><a href="#4-GPIO范围与Pinctrl的关联" class="headerlink" title="4. GPIO范围与Pinctrl的关联"></a>4. GPIO范围与Pinctrl的关联</h3><h4 id="gpiochip-add-pin-ranges"><a href="#gpiochip-add-pin-ranges" class="headerlink" title="gpiochip_add_pin_ranges"></a><code>gpiochip_add_pin_ranges</code></h4><p>此函数负责将GPIO控制器的编号范围与pinctrl子系统关联起来。</p>
<p><strong>原理与作用</strong>:<br>它的作用是调用驱动提供的<code>add_pin_ranges</code>回调函数, 在这个回调中驱动通常会手动调用<code>pinctrl_add_gpio_range</code>来注册映射关系。但是, <strong>这个机制很大程度上是遗留(legacy)的</strong>。</p>
<ul>
<li><strong>现代方法</strong>: 现代内核强烈推荐使用设备树中的<code>gpio-ranges</code>属性来完成这个映射。内核的OF(Open Firmware)解析器会自动处理这个属性, 无需驱动操心。</li>
<li><strong>函数行为</strong>: 因此, 此函数首先会检查设备树中是否存在<code>gpio-ranges</code>属性。如果存在, 它会<strong>立即返回成功</strong>, 有意地跳过调用驱动的<code>add_pin_ranges</code>回调, 以避免重复或冲突的映射。只有在<code>gpio-ranges</code>属性不存在时, 它才会调用那个遗留的回调函数, 以提供向后兼容性。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* gpiochip_add_pin_ranges: 为gpio_chip添加引脚范围. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpiochip_add_pin_ranges</span><span class="params">(<span class="keyword">struct</span> gpio_chip *gc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 关键检查: 如果设备树平台已经使用了标准的&quot;gpio-ranges&quot;属性,</span></span><br><span class="line"><span class="comment">	 * 那么就不应该再调用遗留的回调函数.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (device_property_present(&amp;gc-&gt;gpiodev-&gt;dev, <span class="string">&quot;gpio-ranges&quot;</span>))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果驱动提供了遗留的回调函数, 则调用它. */</span></span><br><span class="line">	<span class="keyword">if</span> (gc-&gt;add_pin_ranges)</span><br><span class="line">		<span class="keyword">return</span> gc-&gt;add_pin_ranges(gc);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="GPIO层次化中断域-Hierarchical-IRQ-Domain-实现"><a href="#GPIO层次化中断域-Hierarchical-IRQ-Domain-实现" class="headerlink" title="GPIO层次化中断域(Hierarchical IRQ Domain)实现"></a>GPIO层次化中断域(Hierarchical IRQ Domain)实现</h2><p>此代码片段是Linux内核<code>gpiolib</code>中用于<strong>实现和管理层次化中断域</strong>的核心。其根本原理是<strong>为那些级联(cascaded)在另一个主中断控制器之下的GPIO控制器, 创建一个”子域”(child domain), 并提供一套完整的操作函数集来管理这个子域的生命周期, 包括它的创建、中断翻译、分配和释放</strong>。</p>
<p>这个模型对于像STM32这样具有分层中断结构的复杂SoC是必不可少的。在STM32中, <code>GPIO引脚 -&gt; EXTI控制器 -&gt; NVIC(CPU)</code>构成了一个清晰的中断层次。这组函数就是在软件层面精确地建模这种硬件上的父子级联关系, 使得内核能够正确地将一个来自特定GPIO引脚的中断请求, 逐级翻译并路由到CPU。</p>
<hr>
<h3 id="1-域的创建与配置"><a href="#1-域的创建与配置" class="headerlink" title="1. 域的创建与配置"></a>1. 域的创建与配置</h3><p>这组函数负责判断是否需要创建层次化域, 并执行创建和配置过程。</p>
<h4 id="gpiochip-hierarchy-is-hierarchical"><a href="#gpiochip-hierarchy-is-hierarchical" class="headerlink" title="gpiochip_hierarchy_is_hierarchical"></a><code>gpiochip_hierarchy_is_hierarchical</code></h4><p>一个简单的谓词函数, 用于判断是否应使用层次化模型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* gpiochip_hierarchy_is_hierarchical: 判断一个gpio_chip是否被配置为层次化中断. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">gpiochip_hierarchy_is_hierarchical</span><span class="params">(<span class="keyword">struct</span> gpio_chip *gc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * !! 是一个C语言技巧, 将任何非NULL指针转换为true(1), NULL指针转换为false(0).</span></span><br><span class="line"><span class="comment">	 * 它的逻辑是: 如果驱动已经为 gc-&gt;irq.parent_domain 提供了有效的父域指针,</span></span><br><span class="line"><span class="comment">	 * 那么就认为它工作在层次化模式下.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> !!gc-&gt;irq.parent_domain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="gpiochip-hierarchy-setup-domain-ops"><a href="#gpiochip-hierarchy-setup-domain-ops" class="headerlink" title="gpiochip_hierarchy_setup_domain_ops"></a><code>gpiochip_hierarchy_setup_domain_ops</code></h4><p>为子域的<code>irq_domain_ops</code>结构体填充一组标准的、预设的回调函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* gpiochip_hierarchy_setup_domain_ops: 为层次化域的操作函数集(ops)进行设置. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">gpiochip_hierarchy_setup_domain_ops</span><span class="params">(<span class="keyword">struct</span> irq_domain_ops *ops)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 当一个中断被请求时, 调用此函数来锁定GPIO引脚, 防止其被用作他途. */</span></span><br><span class="line">	ops-&gt;activate = gpiochip_irq_domain_activate;</span><br><span class="line">	<span class="comment">/* 当中断被释放时, 调用此函数来解锁GPIO引脚. */</span></span><br><span class="line">	ops-&gt;deactivate = gpiochip_irq_domain_deactivate;</span><br><span class="line">	<span class="comment">/* 当需要将硬件中断号映射到Linux IRQ号时, 调用此核心分配函数. */</span></span><br><span class="line">	ops-&gt;alloc = gpiochip_hierarchy_irq_domain_alloc;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 对于层次化芯片, 我们只允许驱动有选择地覆盖 translate 和 free 函数.</span></span><br><span class="line"><span class="comment">	 * 默认的 translate 函数能够处理标准的设备树绑定.</span></span><br><span class="line"><span class="comment">	 * 默认的 free 函数能够处理通用的IRQ释放.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!ops-&gt;translate)</span><br><span class="line">		ops-&gt;translate = gpiochip_hierarchy_irq_domain_translate;</span><br><span class="line">	<span class="keyword">if</span> (!ops-&gt;<span class="built_in">free</span>)</span><br><span class="line">		ops-&gt;<span class="built_in">free</span> = irq_domain_free_irqs_common;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="gpiochip-hierarchy-create-domain"><a href="#gpiochip-hierarchy-create-domain" class="headerlink" title="gpiochip_hierarchy_create_domain"></a><code>gpiochip_hierarchy_create_domain</code></h4><p>创建层次化中断域的主函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* gpiochip_hierarchy_create_domain: 为一个gpio_chip创建一个层次化的中断域(子域). */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> irq_domain *<span class="title function_">gpiochip_hierarchy_create_domain</span><span class="params">(<span class="keyword">struct</span> gpio_chip *gc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_domain</span> *<span class="title">domain</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 健全性检查: 驱动必须提供核心的回调函数和固件节点. */</span></span><br><span class="line">	<span class="keyword">if</span> (!gc-&gt;irq.child_to_parent_hwirq || !gc-&gt;irq.fwnode) &#123;</span><br><span class="line">		chip_err(gc, <span class="string">&quot;missing irqdomain vital data\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* 为驱动未提供的可选回调函数设置无操作的默认值, 简化驱动编写. */</span></span><br><span class="line">	<span class="keyword">if</span> (!gc-&gt;irq.child_offset_to_irq)</span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	static unsigned int gpiochip_child_offset_to_irq_noop(struct gpio_chip *gc,</span></span><br><span class="line"><span class="comment">								unsigned int offset)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		return offset;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">		gc-&gt;irq.child_offset_to_irq = gpiochip_child_offset_to_irq_noop;</span><br><span class="line">	<span class="keyword">if</span> (!gc-&gt;irq.populate_parent_alloc_arg)</span><br><span class="line">		gc-&gt;irq.populate_parent_alloc_arg =</span><br><span class="line">			gpiochip_populate_parent_fwspec_twocell;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 为子域配置标准的操作函数集. */</span></span><br><span class="line">	gpiochip_hierarchy_setup_domain_ops(&amp;gc-&gt;irq.child_irq_domain_ops);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 调用内核通用的层次化域创建函数, 实际创建域并建立父子链接. */</span></span><br><span class="line">	domain = irq_domain_create_hierarchy(</span><br><span class="line">		gc-&gt;irq.parent_domain, <span class="comment">/* 父域 */</span></span><br><span class="line">		<span class="number">0</span>,                     <span class="comment">/* flags */</span></span><br><span class="line">		gc-&gt;ngpio,             <span class="comment">/* 子域大小 */</span></span><br><span class="line">		gc-&gt;irq.fwnode,        <span class="comment">/* 子域的固件节点 */</span></span><br><span class="line">		&amp;gc-&gt;irq.child_irq_domain_ops, <span class="comment">/* 子域的操作函数集 */</span></span><br><span class="line">		gc);                   <span class="comment">/* 私有数据 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!domain)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 为irq_chip本身设置用于层次化操作的钩子 (主要是为了兼容非设备树的旧系统). */</span></span><br><span class="line">	gpiochip_set_hierarchical_irqchip(gc, gc-&gt;irq.chip);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> domain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-中断域操作回调-irq-domain-ops-的实现"><a href="#2-中断域操作回调-irq-domain-ops-的实现" class="headerlink" title="2. 中断域操作回调 (irq_domain_ops) 的实现"></a>2. 中断域操作回调 (<code>irq_domain_ops</code>) 的实现</h3><p>这组函数是<code>gpiochip_hierarchy_setup_domain_ops</code>所设置的回调, 它们定义了子域的具体行为。</p>
<h4 id="gpiochip-hierarchy-irq-domain-translate"><a href="#gpiochip-hierarchy-irq-domain-translate" class="headerlink" title="gpiochip_hierarchy_irq_domain_translate"></a><code>gpiochip_hierarchy_irq_domain_translate</code></h4><p>负责解析来自设备树的中断请求。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* gpiochip_hierarchy_irq_domain_translate: 层次化域的translate回调. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpiochip_hierarchy_irq_domain_translate</span><span class="params">(<span class="keyword">struct</span> irq_domain *d,</span></span><br><span class="line"><span class="params">						   <span class="keyword">struct</span> irq_fwspec *fwspec,</span></span><br><span class="line"><span class="params">						   <span class="type">unsigned</span> <span class="type">long</span> *hwirq,</span></span><br><span class="line"><span class="params">						   <span class="type">unsigned</span> <span class="type">int</span> *type)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 如果是标准的设备树节点, 使用内核提供的标准twocell/threecell翻译函数. */</span></span><br><span class="line">	<span class="keyword">if</span> (is_of_node(fwspec-&gt;fwnode))</span><br><span class="line">		<span class="keyword">return</span> irq_domain_translate_twothreecell(d, fwspec, hwirq, type);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 这是为了兼容旧的、非设备树的板级文件. */</span></span><br><span class="line">	<span class="keyword">if</span> (is_fwnode_irqchip(fwspec-&gt;fwnode)) &#123;</span><br><span class="line">		<span class="comment">// ... (处理旧格式) ...</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="gpiochip-hierarchy-irq-domain-alloc"><a href="#gpiochip-hierarchy-irq-domain-alloc" class="headerlink" title="gpiochip_hierarchy_irq_domain_alloc"></a><code>gpiochip_hierarchy_irq_domain_alloc</code></h4><p>这是<strong>最核心</strong>的函数, 负责将一个子域的硬件中断(hwirq)映射到一个Linux IRQ, 并递归地向父域申请资源。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* gpiochip_hierarchy_irq_domain_alloc: 层次化域的alloc回调. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpiochip_hierarchy_irq_domain_alloc</span><span class="params">(<span class="keyword">struct</span> irq_domain *d,</span></span><br><span class="line"><span class="params">					       <span class="type">unsigned</span> <span class="type">int</span> irq,</span></span><br><span class="line"><span class="params">					       <span class="type">unsigned</span> <span class="type">int</span> nr_irqs,</span></span><br><span class="line"><span class="params">					       <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_chip</span> *<span class="title">gc</span> =</span> d-&gt;host_data; <span class="comment">// 获取私有数据, 即gpio_chip</span></span><br><span class="line">	<span class="type">irq_hw_number_t</span> hwirq; <span class="comment">// 子域的硬件中断号 (即GPIO偏移)</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> type = IRQ_TYPE_NONE;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_fwspec</span> *<span class="title">fwspec</span> =</span> data; <span class="comment">// 来自设备树的请求参数</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> <span class="title">gpio_irq_fwspec</span> <span class="title">gpio_parent_fwspec</span> =</span> &#123;&#125;; <span class="comment">// 准备传递给父域的参数</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> parent_hwirq; <span class="comment">// 父域的硬件中断号 (即EXTI线号)</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> parent_type;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_irq_chip</span> *<span class="title">girq</span> =</span> &amp;gc-&gt;irq;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 步骤1: 将设备树请求翻译成本地域的hwirq和type. */</span></span><br><span class="line">	ret = gc-&gt;irq.child_irq_domain_ops.translate(d, fwspec, &amp;hwirq, &amp;type);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 步骤2: 核心翻译. 调用驱动提供的回调, 将子域hwirq翻译成父域的parent_hwirq. */</span></span><br><span class="line">	ret = girq-&gt;child_to_parent_hwirq(gc, hwirq, type,</span><br><span class="line">					  &amp;parent_hwirq, &amp;parent_type);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		chip_err(gc, <span class="string">&quot;can&#x27;t look up hwirq %lu\n&quot;</span>, hwirq);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 步骤3: 设置本地域的映射关系. 将Linux IRQ(irq)与本地hwirq和irq_chip关联起来. */</span></span><br><span class="line">	irq_domain_set_info(d, irq, hwirq, gc-&gt;irq.chip, gc,</span><br><span class="line">			    girq-&gt;handler, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	irq_set_probe(irq); <span class="comment">// 标记此IRQ需要探测</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 步骤4: 准备向父域申请资源的参数. */</span></span><br><span class="line">	ret = girq-&gt;populate_parent_alloc_arg(gc, &amp;gpio_parent_fwspec,</span><br><span class="line">					      parent_hwirq, parent_type);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 步骤5: 递归向上, 向父域申请中断. 这会触发父域的alloc回调. */</span></span><br><span class="line">	ret = irq_domain_alloc_irqs_parent(d, irq, <span class="number">1</span>, &amp;gpio_parent_fwspec);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		chip_err(gc, <span class="string">&quot;failed to allocate parent hwirq %d for hwirq %lu\n&quot;</span>,</span><br><span class="line">			 parent_hwirq, hwirq);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="gpiochip-irq-domain-activate-deactivate"><a href="#gpiochip-irq-domain-activate-deactivate" class="headerlink" title="gpiochip_irq_domain_activate &#x2F; deactivate"></a><code>gpiochip_irq_domain_activate</code> &#x2F; <code>deactivate</code></h4><p>在请求&#x2F;释放中断时, 锁定&#x2F;解锁对应的GPIO引脚, 防止其被用作普通IO。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* gpiochip_irq_domain_activate: activate回调, 锁定GPIO引脚作为IRQ. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpiochip_irq_domain_activate</span><span class="params">(<span class="keyword">struct</span> irq_domain *domain,</span></span><br><span class="line"><span class="params">					<span class="keyword">struct</span> irq_data *data, <span class="type">bool</span> reserve)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_chip</span> *<span class="title">gc</span> =</span> domain-&gt;host_data;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> hwirq = irqd_to_hwirq(data); <span class="comment">// 从irq_data获取hwirq</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 调用gpiolib内部函数, 将该引脚标记为&quot;已被IRQ使用&quot;. */</span></span><br><span class="line">	<span class="keyword">return</span> gpiochip_lock_as_irq(gc, hwirq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* gpiochip_irq_domain_deactivate: deactivate回调, 解锁作为IRQ的GPIO引脚. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">gpiochip_irq_domain_deactivate</span><span class="params">(<span class="keyword">struct</span> irq_domain *domain,</span></span><br><span class="line"><span class="params">					   <span class="keyword">struct</span> irq_data *data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_chip</span> *<span class="title">gc</span> =</span> domain-&gt;host_data;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> hwirq = irqd_to_hwirq(data);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 调用gpiolib内部函数, 解除引脚的&quot;已被IRQ使用&quot;标记. */</span></span><br><span class="line">	<span class="keyword">return</span> gpiochip_unlock_as_irq(gc, hwirq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-其他辅助与遗留-Legacy-支持函数"><a href="#3-其他辅助与遗留-Legacy-支持函数" class="headerlink" title="3. 其他辅助与遗留(Legacy)支持函数"></a>3. 其他辅助与遗留(Legacy)支持函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* gpiochip_set_hierarchical_irqchip: (主要用于遗留系统) 设置层次化irqchip. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">gpiochip_set_hierarchical_irqchip</span><span class="params">(<span class="keyword">struct</span> gpio_chip *gc,</span></span><br><span class="line"><span class="params">					      <span class="keyword">struct</span> irq_chip *irqchip)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 如果使用设备树, 内核会动态处理映射, 无需此函数做任何事. */</span></span><br><span class="line">	<span class="keyword">if</span> (is_of_node(gc-&gt;irq.fwnode))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 下面的代码是为了兼容旧的、不使用设备树的板级文件.</span></span><br><span class="line"><span class="comment">	 * 它会尝试为所有可能的引脚预先分配中断.</span></span><br><span class="line"><span class="comment">	 * 在现代内核和STM32开发中, 这部分代码通常不会被执行.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">// ... (legacy code) ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* gpiochip_populate_parent_fwspec_*: 用于准备传递给父域中断分配函数的参数的默认实现. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">gpiochip_populate_parent_fwspec_twocell</span><span class="params">(<span class="keyword">struct</span> gpio_chip *gc,</span></span><br><span class="line"><span class="params">					    <span class="keyword">union</span> gpio_irq_fwspec *gfwspec,</span></span><br><span class="line"><span class="params">					    <span class="type">unsigned</span> <span class="type">int</span> parent_hwirq,</span></span><br><span class="line"><span class="params">					    <span class="type">unsigned</span> <span class="type">int</span> parent_type)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_fwspec</span> *<span class="title">fwspec</span> =</span> &amp;gfwspec-&gt;fwspec;</span><br><span class="line"></span><br><span class="line">	fwspec-&gt;fwnode = gc-&gt;irq.parent_domain-&gt;fwnode; <span class="comment">// 使用父域的节点</span></span><br><span class="line">	fwspec-&gt;param_count = <span class="number">2</span>; <span class="comment">// 父域需要2个参数</span></span><br><span class="line">	fwspec-&gt;param[<span class="number">0</span>] = parent_hwirq; <span class="comment">// 第一个参数是父hwirq</span></span><br><span class="line">	fwspec-&gt;param[<span class="number">1</span>] = parent_type;  <span class="comment">// 第二个参数是触发类型</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="GPIO简单中断域-Simple-IRQ-Domain-创建函数"><a href="#GPIO简单中断域-Simple-IRQ-Domain-创建函数" class="headerlink" title="GPIO简单中断域(Simple IRQ Domain)创建函数"></a>GPIO简单中断域(Simple IRQ Domain)创建函数</h2><p>此代码片段展示了<code>gpiolib</code>中用于创建<strong>简单(或称”扁平”, flat)中断域</strong>的机制。其核心原理是<strong>为那些硬件结构较为简单、其GPIO中断线可以直接一对一映射到主中断控制器上的GPIO控制器, 提供一个简化的、非层次化的中断域创建流程</strong>。</p>
<p>这与我们之前讨论的<code>gpiochip_hierarchy_create_domain</code>形成了鲜明对比。层次化模型用于处理像STM32这样具有”GPIO -&gt; EXTI -&gt; NVIC”多级级联关系的复杂硬件, 而<strong>简单模型则适用于那些GPIO引脚中断可以直接被系统顶级中断控制器(如GIC on multi-core ARM, or NVIC on Cortex-M)识别的硬件</strong>。</p>
<hr>
<h3 id="gpiochip-irq-map-映射一个Linux-IRQ到GPIO引脚"><a href="#gpiochip-irq-map-映射一个Linux-IRQ到GPIO引脚" class="headerlink" title="gpiochip_irq_map: 映射一个Linux IRQ到GPIO引脚"></a>gpiochip_irq_map: 映射一个Linux IRQ到GPIO引脚</h3><p>此函数是<code>irq_domain_ops</code>中<strong>最核心</strong>的回调函数。它的作用是<strong>建立一个从全局唯一的Linux IRQ号(<code>irq</code>)到特定GPIO控制器上一个本地硬件中断号(<code>hwirq</code>, 即引脚偏移量)的完整映射关系</strong>。它负责完成所有必要的软件配置, 为即将到来的中断做好准备。</p>
<p><strong>原理与工作流程:</strong></p>
<ol>
<li><strong>获取上下文</strong>: 从中断域的私有数据<code>d-&gt;host_data</code>中获取到对应的<code>gpio_chip</code>结构体, 这是所有操作的基础。</li>
<li><strong>有效性检查</strong>: 调用<code>gpiochip_irqchip_irq_valid</code>检查<code>hwirq</code>(引脚偏移)是否在该<code>gpio_chip</code>的中断有效掩码内。如果一个引脚不支持中断, 则映射失败。</li>
<li><strong>关联核心数据</strong>:<ul>
<li><code>irq_set_chip_data(irq, gc)</code>: 将<code>gpio_chip</code>本身设置为该IRQ的”chip data”。这使得中断处理代码在处理这个IRQ时, 可以快速地回溯到管理它的GPIO控制器。</li>
<li><code>irq_set_chip_and_handler(irq, gc-&gt;irq.chip, gc-&gt;irq.handler)</code>: 这是关键的一步。它将驱动提供的<code>irq_chip</code>结构体(包含<code>ack</code>, <code>mask</code>, <code>unmask</code>等底层硬件操作函数)和中断流处理器(<code>handler</code>)与该IRQ关联起来。从此, 当这个IRQ触发时, 内核就知道应该调用哪个函数来处理它。</li>
</ul>
</li>
<li><strong>设置父IRQ (可选)</strong>: 如果该GPIO控制器的中断是级联在一个父IRQ之下的(即使是在简单模型中也可能出现这种情况), 此函数会调用<code>irq_set_parent</code>来建立这种级联关系。</li>
<li><strong>设置默认触发类型</strong>: 如果驱动程序在<code>gpio_chip</code>中指定了<code>default_type</code> (如边沿触发、电平触发), 此函数会调用<code>irq_set_irq_type</code>来将这个默认配置应用到硬件上。</li>
<li><strong>配置特殊属性</strong>: 它还会设置一些额外的属性, 如<code>lockdep</code>锁分类(用于调试死锁)和<code>nested_thread</code>标志(用于支持嵌套的线程化中断处理器)。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * gpiochip_irq_map() - 将一个IRQ映射到一个GPIO irqchip中</span></span><br><span class="line"><span class="comment"> * @d: 此irqchip使用的irqdomain</span></span><br><span class="line"><span class="comment"> * @irq: 此GPIO irqchip irq使用的全局irq号</span></span><br><span class="line"><span class="comment"> * @hwirq: 此gpiochip上的本地IRQ/GPIO线偏移量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpiochip_irq_map</span><span class="params">(<span class="keyword">struct</span> irq_domain *d, <span class="type">unsigned</span> <span class="type">int</span> irq,</span></span><br><span class="line"><span class="params">			    <span class="type">irq_hw_number_t</span> hwirq)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_chip</span> *<span class="title">gc</span> =</span> d-&gt;host_data; <span class="comment">// 获取gpio_chip上下文</span></span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 检查此hwirq(引脚)是否支持中断. */</span></span><br><span class="line">	<span class="keyword">if</span> (!gpiochip_irqchip_irq_valid(gc, hwirq))</span><br><span class="line">		<span class="keyword">return</span> -ENXIO; <span class="comment">// 不支持则返回&quot;无此设备或地址&quot;错误</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 将gpio_chip本身设置为此IRQ的私有数据. */</span></span><br><span class="line">	irq_set_chip_data(irq, gc);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 为锁调试器设置特殊的锁分类, 以避免误报. */</span></span><br><span class="line">	irq_set_lockdep_class(irq, gc-&gt;irq.lock_key, gc-&gt;irq.request_key);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 核心关联: 将驱动提供的irq_chip和中断流处理器(handler)与此IRQ号绑定.</span></span><br><span class="line"><span class="comment">	 * 当此IRQ触发时, 内核将调用 gc-&gt;irq.handler.</span></span><br><span class="line"><span class="comment">	 * 在handler内部, 会再调用 gc-&gt;irq.chip 中的函数来操作硬件.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	irq_set_chip_and_handler(irq, gc-&gt;irq.chip, gc-&gt;irq.handler);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 如果驱动使用了嵌套线程化中断处理器, 则设置相应标志. */</span></span><br><span class="line">	<span class="keyword">if</span> (gc-&gt;irq.threaded)</span><br><span class="line">		irq_set_nested_thread(irq, <span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 标记此IRQ不需要在启动时被内核自动探测. */</span></span><br><span class="line">	irq_set_noprobe(irq);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果有父IRQ, 建立级联关系. */</span></span><br><span class="line">	<span class="keyword">if</span> (gc-&gt;irq.num_parents == <span class="number">1</span>) <span class="comment">// 简单级联, 只有一个父IRQ</span></span><br><span class="line">		ret = irq_set_parent(irq, gc-&gt;irq.parents[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (gc-&gt;irq.<span class="built_in">map</span>) <span class="comment">// 复杂级联, 每个hwirq可能对应不同的父IRQ</span></span><br><span class="line">		ret = irq_set_parent(irq, gc-&gt;irq.<span class="built_in">map</span>[hwirq]);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果驱动指定了默认触发类型, 则应用它. */</span></span><br><span class="line">	<span class="keyword">if</span> (gc-&gt;irq.default_type != IRQ_TYPE_NONE)</span><br><span class="line">		irq_set_irq_type(irq, gc-&gt;irq.default_type);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="gpiochip-irq-unmap-解除一个Linux-IRQ与GPIO引脚的映射"><a href="#gpiochip-irq-unmap-解除一个Linux-IRQ与GPIO引脚的映射" class="headerlink" title="gpiochip_irq_unmap: 解除一个Linux IRQ与GPIO引脚的映射"></a>gpiochip_irq_unmap: 解除一个Linux IRQ与GPIO引脚的映射</h3><p>此函数是<code>gpiochip_irq_map</code>的逆操作。当一个IRQ被释放时, 内核会调用此函数来清除所有在<code>map</code>阶段建立的软件关联。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * gpiochip_irq_unmap() - 解除一个IRQ与gpiochip的映射</span></span><br><span class="line"><span class="comment"> * @d: irqdomain</span></span><br><span class="line"><span class="comment"> * @irq: 要解除映射的全局irq号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">gpiochip_irq_unmap</span><span class="params">(<span class="keyword">struct</span> irq_domain *d, <span class="type">unsigned</span> <span class="type">int</span> irq)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_chip</span> *<span class="title">gc</span> =</span> d-&gt;host_data; <span class="comment">// 获取gpio_chip上下文</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 清除嵌套线程标志. */</span></span><br><span class="line">	<span class="keyword">if</span> (gc-&gt;irq.threaded)</span><br><span class="line">		irq_set_nested_thread(irq, <span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 解除核心关联: 将irq_chip和handler都设为NULL.</span></span><br><span class="line"><span class="comment">	 * 这样, 即使这个IRQ号意外触发, 内核也不会再调用旧的处理函数.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	irq_set_chip_and_handler(irq, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 清除私有数据. */</span></span><br><span class="line">	irq_set_chip_data(irq, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="gpiochip-irq-select-选择一个中断控制器"><a href="#gpiochip-irq-select-选择一个中断控制器" class="headerlink" title="gpiochip_irq_select: 选择一个中断控制器"></a>gpiochip_irq_select: 选择一个中断控制器</h3><p>此回调函数用于一个高级场景: 当一个设备在设备树中描述的中断可以由<strong>多个</strong>不同的中断控制器来提供服务时, 内核会调用<code>.select</code>回调来让驱动程序判断自己是否是那个”正确”的控制器。</p>
<p><strong>原理与作用</strong>:<br>它的主要作用是进行匹配。内核将从设备树中解析出的中断请求<code>fwspec</code>传递给它, 它需要将<code>fwspec</code>中的信息与自身<code>irq_domain</code>的信息进行比较。</p>
<ul>
<li>对于使用设备树的现代系统, 它可能会调用<code>of_gpiochip_instance_match</code>来进行更复杂的匹配。</li>
<li>对于简单的、非层次化的域, 它主要比较<code>fwspec</code>中的固件节点(<code>fwnode</code>)是否与自身域的固件节点(<code>d-&gt;fwnode</code>)相同, 并可能比较总线令牌(<code>bus_token</code>)。如果匹配, 就返回<code>true</code>, 表示”这个中断请求是给我的”。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * gpiochip_irq_select() - 选择一个中断控制器来处理中断请求</span></span><br><span class="line"><span class="comment"> * @d: irqdomain</span></span><br><span class="line"><span class="comment"> * @fwspec: 从设备树解析出的中断请求描述符</span></span><br><span class="line"><span class="comment"> * @bus_token: 总线令牌</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpiochip_irq_select</span><span class="params">(<span class="keyword">struct</span> irq_domain *d, <span class="keyword">struct</span> irq_fwspec *fwspec,</span></span><br><span class="line"><span class="params">			       <span class="keyword">enum</span> irq_domain_bus_token bus_token)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fwnode_handle</span> *<span class="title">fwnode</span> =</span> fwspec-&gt;fwnode;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_chip</span> *<span class="title">gc</span> =</span> d-&gt;host_data;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> index = fwspec-&gt;param[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 对于三单元格的设备树中断描述, 使用一个更复杂的匹配函数. */</span></span><br><span class="line">	<span class="keyword">if</span> (fwspec-&gt;param_count == <span class="number">3</span> &amp;&amp; is_of_node(fwnode))</span><br><span class="line">		<span class="keyword">return</span> of_gpiochip_instance_match(gc, index);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 对于两单元格的描述, 进行简单的匹配:</span></span><br><span class="line"><span class="comment">	 * 请求的固件节点是否与本域的固件节点相同? 并且总线令牌是否匹配?</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> (fwnode &amp;&amp; (d-&gt;fwnode == fwnode) &amp;&amp; (d-&gt;bus_token == bus_token));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="gpiochip-domain-ops-简单域的操作函数集"><a href="#gpiochip-domain-ops-简单域的操作函数集" class="headerlink" title="gpiochip_domain_ops: 简单域的操作函数集"></a>gpiochip_domain_ops: 简单域的操作函数集</h3><p>这是一个静态的<code>irq_domain_ops</code>结构体实例, 它为所有通过”简单模型”创建的GPIO中断域提供了一套标准的、通用的操作函数集。它就像是中断域的”行为手册”, 告诉内核在对该域进行各种操作时应该调用哪些函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义一个静态的、常量类型的 struct irq_domain_ops 实例.</span></span><br><span class="line"><span class="comment"> * 这是为所有&quot;简单&quot;GPIO中断域提供的标准操作集.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">irq_domain_ops</span> <span class="title">gpiochip_domain_ops</span> =</span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * .map: 指向 gpiochip_irq_map 函数.</span></span><br><span class="line"><span class="comment">	 * 作用: 这是最重要的回调函数. 当内核需要将一个硬件中断号(hwirq, 在此上下文中就是GPIO的偏移量)</span></span><br><span class="line"><span class="comment">	 *       映射到一个Linux IRQ号(virq)时, 此函数被调用. 它的职责是:</span></span><br><span class="line"><span class="comment">	 *       1. 将virq与hwirq关联起来.</span></span><br><span class="line"><span class="comment">	 *       2. 调用gpio_chip提供的irq_chip回调函数(如.irq_ack, .irq_mask)来配置硬件.</span></span><br><span class="line"><span class="comment">	 *       3. 设置该IRQ的中断处理器(handler).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	.<span class="built_in">map</span>	= gpiochip_irq_map,</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * .unmap: 指向 gpiochip_irq_unmap 函数.</span></span><br><span class="line"><span class="comment">	 * 作用: 这是 .map 的逆操作. 当一个映射被销毁时, 此函数被调用以释放硬件资源和软件关联.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	.unmap	= gpiochip_irq_unmap,</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * .select: 指向 gpiochip_irq_select 函数.</span></span><br><span class="line"><span class="comment">	 * 作用: (可选) 当一个IRQ可以由多个芯片或配置提供时, 此函数用于在它们之间进行选择.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	.select	= gpiochip_irq_select,</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * .xlate: 指向 irq_domain_xlate_twothreecell 函数.</span></span><br><span class="line"><span class="comment">	 * 作用: &quot;Translate&quot;, 即翻译. 此函数用于解析设备树(Device Tree)中的 &quot;interrupts&quot; 属性.</span></span><br><span class="line"><span class="comment">	 *       内核提供了几个标准的xlate函数, irq_domain_xlate_twothreecell 用于处理最常见的两种格式:</span></span><br><span class="line"><span class="comment">	 *       - 两单元格(twocell): interrupts = &lt;hwirq trigger_type&gt;; (例如 &lt;5 IRQ_TYPE_EDGE_RISING&gt;)</span></span><br><span class="line"><span class="comment">	 *       - 三单元格(threecell): interrupts = &lt;hwirq trigger_type priority&gt;;</span></span><br><span class="line"><span class="comment">	 *       它的职责是从设备树的这两个或三个单元格中提取出硬件中断号(hwirq)和触发类型等信息.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	.xlate	= irq_domain_xlate_twothreecell,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="gpiochip-simple-create-domain-创建一个简单中断域"><a href="#gpiochip-simple-create-domain-创建一个简单中断域" class="headerlink" title="gpiochip_simple_create_domain: 创建一个简单中断域"></a>gpiochip_simple_create_domain: 创建一个简单中断域</h3><p>这是一个内部函数, 它封装了内核通用的<code>irq_domain_create_simple</code>函数, 为GPIO控制器提供了一个便捷的创建接口。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * gpiochip_simple_create_domain: 为一个gpio_chip创建一个简单的中断域.</span></span><br><span class="line"><span class="comment"> * @gc: 目标gpio_chip.</span></span><br><span class="line"><span class="comment"> * @return: 成功时返回一个指向新创建的 irq_domain 的指针, 失败时返回一个错误指针.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> irq_domain *<span class="title function_">gpiochip_simple_create_domain</span><span class="params">(<span class="keyword">struct</span> gpio_chip *gc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 获取与该gpiolib设备关联的固件节点(设备树节点). */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fwnode_handle</span> *<span class="title">fwnode</span> =</span> dev_fwnode(&amp;gc-&gt;gpiodev-&gt;dev);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_domain</span> *<span class="title">domain</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 调用内核通用的 irq_domain_create_simple 函数来完成实际的创建工作.</span></span><br><span class="line"><span class="comment">	 * 这个函数适用于创建线性的、扁平的、一对一映射的中断域.</span></span><br><span class="line"><span class="comment">	 * 参数解释:</span></span><br><span class="line"><span class="comment">	 * - fwnode: 该中断控制器的固件节点.</span></span><br><span class="line"><span class="comment">	 * - gc-&gt;ngpio: 域的大小, 即该控制器管理的GPIO(中断)数量.</span></span><br><span class="line"><span class="comment">	 * - gc-&gt;irq.first: 硬件中断号(hwirq)的起始值. 对于简单模型, 这通常是0.</span></span><br><span class="line"><span class="comment">	 * - &amp;gpiochip_domain_ops: 为这个新域指定上面定义好的标准操作函数集.</span></span><br><span class="line"><span class="comment">	 * - gc: 将gpio_chip自身作为私有数据(host_data)传递给中断域, 以便在回调函数中可以访问到它.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	domain = irq_domain_create_simple(fwnode, gc-&gt;ngpio, gc-&gt;irq.first,</span><br><span class="line">					  &amp;gpiochip_domain_ops, gc);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * irq_domain_create_simple 在成功时返回域指针, 失败时返回NULL.</span></span><br><span class="line"><span class="comment">	 * 这里将其转换为内核标准的错误指针格式.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!domain)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> domain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="gpiolib中断资源管理与使能-禁用函数"><a href="#gpiolib中断资源管理与使能-禁用函数" class="headerlink" title="gpiolib中断资源管理与使能&#x2F;禁用函数"></a><code>gpiolib</code>中断资源管理与使能&#x2F;禁用函数</h2><p>此代码片段展示了Linux内核<code>gpiolib</code>子系统中用于<strong>管理GPIO引脚作为中断资源</strong>的一组核心函数。这组函数与<code>irqchip</code>子系统紧密协作, 其根本原理是<strong>在一个GPIO引脚被用作中断源的整个生命周期中, 对其进行状态跟踪和访问控制</strong>。这包括:</p>
<ol>
<li><strong>锁定&#x2F;解锁</strong>: 当引脚被请求为中断时, 将其”锁定”, 防止它同时被用作普通的输入&#x2F;输出引脚, 从而避免了功能冲突。</li>
<li><strong>模块引用计数</strong>: 确保提供GPIO控制器功能的内核模块在使用期间不会被意外卸载。</li>
<li><strong>使能&#x2F;禁用状态跟踪</strong>: 在引脚的描述符中维护一个软件状态位, 记录该中断是处于使能还是禁用状态。</li>
</ol>
<h3 id="gpiochip-lock-as-irq-将GPIO引脚锁定为中断模式"><a href="#gpiochip-lock-as-irq-将GPIO引脚锁定为中断模式" class="headerlink" title="gpiochip_lock_as_irq: 将GPIO引脚锁定为中断模式"></a>gpiochip_lock_as_irq: 将GPIO引脚锁定为中断模式</h3><p>当一个驱动程序请求一个GPIO引脚作为中断源时(通常在<code>request_irq</code>的调用链深处), <code>irqchip</code>子系统的<code>request_resources</code>回调函数(即<code>gpiolib</code>的<code>gpiochip_reqres_irq</code>)最终会调用此函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * gpiochip_lock_as_irq() - 锁定一个GPIO以用作IRQ</span></span><br><span class="line"><span class="comment"> * @gc: GPIO所属的chip</span></span><br><span class="line"><span class="comment"> * @offset: 要锁定为IRQ的GPIO的偏移量</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这个函数由那些希望锁定某条GPIO线用于IRQ的GPIO驱动直接使用.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回:</span></span><br><span class="line"><span class="comment"> * 0 on success, or negative errno on failure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">gpiochip_lock_as_irq</span><span class="params">(<span class="keyword">struct</span> gpio_chip *gc, <span class="type">unsigned</span> <span class="type">int</span> offset)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">desc</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 步骤1: 获取该引脚的软件描述符. */</span></span><br><span class="line">	desc = gpiochip_get_desc(gc, offset);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(desc))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(desc); <span class="comment">// 如果偏移无效, 返回错误.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 步骤2 (可选的硬件同步):</span></span><br><span class="line"><span class="comment">	 * 如果GPIO控制器的操作不能休眠(gc-&gt;can_sleep为false), 并且驱动提供了get_direction回调,</span></span><br><span class="line"><span class="comment">	 * 这通常意味着寄存器访问非常快, 而且引脚方向可能被硬件或其他未知因素改变.</span></span><br><span class="line"><span class="comment">	 * 在这种情况下, 函数会主动调用gpiod_get_direction()来从硬件回读当前的方向,</span></span><br><span class="line"><span class="comment">	 * 以确保描述符中的软件状态与硬件的实际状态同步.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!gc-&gt;can_sleep &amp;&amp; gc-&gt;get_direction) &#123;</span><br><span class="line">		<span class="type">int</span> dir = gpiod_get_direction(desc);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (dir &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			chip_err(gc, <span class="string">&quot;%s: cannot get GPIO direction\n&quot;</span>,</span><br><span class="line">				 __func__);</span><br><span class="line">			<span class="keyword">return</span> dir;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 步骤3: 关键的健全性检查.</span></span><br><span class="line"><span class="comment">	 * 一个引脚要能作为中断输入, 它本身必须是输入模式, 或者是一种特殊的&quot;开漏&quot;(open drain)输出模式.</span></span><br><span class="line"><span class="comment">	 * 开漏输出可以驱动低电平, 但在高电平状态下呈高阻态, 因此可以安全地感知外部信号的上拉或下拉.</span></span><br><span class="line"><span class="comment">	 * 如果一个引脚被配置为标准的推挽(push-pull)输出模式, 那么它无法可靠地接收外部中断信号.</span></span><br><span class="line"><span class="comment">	 * test_bit()用于原子地检查描述符中的标志位.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (test_bit(FLAG_IS_OUT, &amp;desc-&gt;flags) &amp;&amp;</span><br><span class="line">	    !test_bit(FLAG_OPEN_DRAIN, &amp;desc-&gt;flags)) &#123;</span><br><span class="line">		chip_err(gc,</span><br><span class="line">			 <span class="string">&quot;%s: tried to flag a GPIO set as output for IRQ\n&quot;</span>,</span><br><span class="line">			 __func__);</span><br><span class="line">		<span class="keyword">return</span> -EIO; <span class="comment">// 返回&quot;IO错误&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 步骤4: 核心操作.</span></span><br><span class="line"><span class="comment">	 * 使用set_bit()原子地设置两个标志位:</span></span><br><span class="line"><span class="comment">	 * FLAG_USED_AS_IRQ: 这是&quot;锁定&quot;标志, 表明该引脚现在被中断子系统独占.</span></span><br><span class="line"><span class="comment">	 * FLAG_IRQ_IS_ENABLED: 将该中断的软件使能状态初始化为&quot;使能&quot;.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	set_bit(FLAG_USED_AS_IRQ, &amp;desc-&gt;flags);</span><br><span class="line">	set_bit(FLAG_IRQ_IS_ENABLED, &amp;desc-&gt;flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 成功</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 将此函数导出, 使其对内核其他部分(主要是irqchip驱动)可用. */</span></span><br><span class="line">EXPORT_SYMBOL_GPL(gpiochip_lock_as_irq);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="gpiochip-unlock-as-irq-解锁一个用作中断的GPIO引脚"><a href="#gpiochip-unlock-as-irq-解锁一个用作中断的GPIO引脚" class="headerlink" title="gpiochip_unlock_as_irq: 解锁一个用作中断的GPIO引脚"></a>gpiochip_unlock_as_irq: 解锁一个用作中断的GPIO引脚</h3><p>当一个驱动程序释放一个中断时(在<code>free_irq</code>的调用链中), <code>irqchip</code>子系统的<code>release_resources</code>回调函数(即<code>gpiolib</code>的<code>gpiochip_relres_irq</code>)会调用此函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * gpiochip_unlock_as_irq() - 解锁一个用作IRQ的GPIO</span></span><br><span class="line"><span class="comment"> * @gc: GPIO所属的chip</span></span><br><span class="line"><span class="comment"> * @offset: 要解锁的GPIO的偏移量</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这个函数由那些希望表明某条GPIO不再被专门用于IRQ的GPIO驱动直接使用.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">gpiochip_unlock_as_irq</span><span class="params">(<span class="keyword">struct</span> gpio_chip *gc, <span class="type">unsigned</span> <span class="type">int</span> offset)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">desc</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 步骤1: 获取该引脚的软件描述符. */</span></span><br><span class="line">	desc = gpiochip_get_desc(gc, offset);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(desc))</span><br><span class="line">		<span class="keyword">return</span>; <span class="comment">// 如果偏移无效, 静默返回.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 步骤2: 核心操作.</span></span><br><span class="line"><span class="comment">	 * 使用clear_bit()原子地清除两个标志位, 解除锁定并重置状态.</span></span><br><span class="line"><span class="comment">	 * 此后, 该引脚就可以被重新配置为普通的输入或输出引脚了.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	clear_bit(FLAG_USED_AS_IRQ, &amp;desc-&gt;flags);</span><br><span class="line">	clear_bit(FLAG_IRQ_IS_ENABLED, &amp;desc-&gt;flags);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 将此函数导出. */</span></span><br><span class="line">EXPORT_SYMBOL_GPL(gpiochip_unlock_as_irq);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="gpiochip-reqres-irq-gpiochip-relres-irq-请求-释放中断资源"><a href="#gpiochip-reqres-irq-gpiochip-relres-irq-请求-释放中断资源" class="headerlink" title="gpiochip_reqres_irq &#x2F; gpiochip_relres_irq: 请求&#x2F;释放中断资源"></a>gpiochip_reqres_irq &#x2F; gpiochip_relres_irq: 请求&#x2F;释放中断资源</h3><p>这两个函数是<code>irqchip</code>子系统的<code>request_resources</code>和<code>release_resources</code>回调函数的标准实现。它们负责一个GPIO引脚作为中断源的”获取”和”释放”操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * gpiochip_reqres_irq - 请求一个GPIO引脚作为中断资源</span></span><br><span class="line"><span class="comment"> * @gc: 目标gpio_chip</span></span><br><span class="line"><span class="comment"> * @offset: 该chip上的引脚偏移量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">gpiochip_reqres_irq</span><span class="params">(<span class="keyword">struct</span> gpio_chip *gc, <span class="type">unsigned</span> <span class="type">int</span> offset)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 步骤1: 增加模块引用计数.</span></span><br><span class="line"><span class="comment">	 * try_module_get()会尝试增加提供该GPIO控制器的内核模块(owner)的引用计数.</span></span><br><span class="line"><span class="comment">	 * 这可以防止在中断正在使用时, 该模块被`rmmod`命令卸载, 从而避免了使用悬挂指针导致的系统崩溃.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!try_module_get(gc-&gt;gpiodev-&gt;owner))</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 步骤2: 将引脚锁定为中断模式.</span></span><br><span class="line"><span class="comment">	 * gpiochip_lock_as_irq()会在该引脚的描述符中设置一个FLAG_USED_AS_IRQ标志.</span></span><br><span class="line"><span class="comment">	 * 任何后续尝试通过gpiod_direction_*()等函数来改变该引脚方向的操作,</span></span><br><span class="line"><span class="comment">	 * 都会因为检查到这个标志而失败.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ret = gpiochip_lock_as_irq(gc, offset);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 错误处理: 如果锁定失败, 必须撤销第一步的操作.</span></span><br><span class="line"><span class="comment">		 * module_put()会减少模块的引用计数.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		chip_err(gc, <span class="string">&quot;unable to lock HW IRQ %u for IRQ\n&quot;</span>, offset);</span><br><span class="line">		module_put(gc-&gt;gpiodev-&gt;owner);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 成功</span></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(gpiochip_reqres_irq);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * gpiochip_relres_irq - 释放一个作为中断资源的GPIO引脚</span></span><br><span class="line"><span class="comment"> * @gc: 目标gpio_chip</span></span><br><span class="line"><span class="comment"> * @offset: 该chip上的引脚偏移量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">gpiochip_relres_irq</span><span class="params">(<span class="keyword">struct</span> gpio_chip *gc, <span class="type">unsigned</span> <span class="type">int</span> offset)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 步骤1: 解锁引脚.</span></span><br><span class="line"><span class="comment">	 * gpiochip_unlock_as_irq()会清除FLAG_USED_AS_IRQ标志,</span></span><br><span class="line"><span class="comment">	 * 使得该引脚可以被重新用作普通的GPIO.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	gpiochip_unlock_as_irq(gc, offset);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 步骤2: 减少模块引用计数.</span></span><br><span class="line"><span class="comment">	 * 与try_module_get()配对, 表明我们已经不再需要这个模块提供的中断服务了.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	module_put(gc-&gt;gpiodev-&gt;owner);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(gpiochip_relres_irq);</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="gpiochip-enable-irq-gpiochip-disable-irq-使能-禁用中断-软件状态"><a href="#gpiochip-enable-irq-gpiochip-disable-irq-使能-禁用中断-软件状态" class="headerlink" title="gpiochip_enable_irq &#x2F; gpiochip_disable_irq: 使能&#x2F;禁用中断(软件状态)"></a>gpiochip_enable_irq &#x2F; gpiochip_disable_irq: 使能&#x2F;禁用中断(软件状态)</h3><p>这两个函数通常被<code>irq_chip</code>的<code>mask</code>&#x2F;<code>unmask</code>回调函数的包装器所调用。它们<strong>只负责在<code>gpiolib</code>的软件层面更新中断的使能状态</strong>, <strong>而不直接操作硬件</strong>。硬件的屏蔽&#x2F;解屏蔽操作由<code>irq_chip</code>回调本身负责。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * gpiochip_disable_irq - (在gpiolib层面)禁用一个GPIO中断</span></span><br><span class="line"><span class="comment"> * @gc: 目标gpio_chip</span></span><br><span class="line"><span class="comment"> * @offset: 该chip上的引脚偏移量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">gpiochip_disable_irq</span><span class="params">(<span class="keyword">struct</span> gpio_chip *gc, <span class="type">unsigned</span> <span class="type">int</span> offset)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 获取该引脚的描述符(gpio_desc). */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">desc</span> =</span> gpiochip_get_desc(gc, offset);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 检查描述符是否有效, 并使用WARN_ON确保该引脚确实被配置为中断模式.</span></span><br><span class="line"><span class="comment">	 * 如果一个引脚没有被配置为中断, 那么禁用它是一个逻辑错误, WARN_ON会打印警告.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!IS_ERR(desc) &amp;&amp;</span><br><span class="line">	    !WARN_ON(!test_bit(FLAG_USED_AS_IRQ, &amp;desc-&gt;flags)))</span><br><span class="line">		<span class="comment">/* 核心操作: 清除描述符中的FLAG_IRQ_IS_ENABLED标志位. */</span></span><br><span class="line">		clear_bit(FLAG_IRQ_IS_ENABLED, &amp;desc-&gt;flags);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(gpiochip_disable_irq);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * gpiochip_enable_irq - (在gpiolib层面)使能一个GPIO中断</span></span><br><span class="line"><span class="comment"> * @gc: 目标gpio_chip</span></span><br><span class="line"><span class="comment"> * @offset: 该chip上的引脚偏移量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">gpiochip_enable_irq</span><span class="params">(<span class="keyword">struct</span> gpio_chip *gc, <span class="type">unsigned</span> <span class="type">int</span> offset)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 获取该引脚的描述符. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">desc</span> =</span> gpiochip_get_desc(gc, offset);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!IS_ERR(desc) &amp;&amp;</span><br><span class="line">	    !WARN_ON(!test_bit(FLAG_USED_AS_IRQ, &amp;desc-&gt;flags))) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 关键的健全性检查:</span></span><br><span class="line"><span class="comment">		 * 一个引脚在用作中断时, 通常必须是输入模式.</span></span><br><span class="line"><span class="comment">		 * 唯一的例外是它被配置为&quot;开漏&quot;(open drain)输出, 此时它可以同时驱动低电平并感知外部信号.</span></span><br><span class="line"><span class="comment">		 * 如果一个推挽(push-pull)输出引脚被用作中断, 这是一个硬件配置错误, WARN_ON会打印警告.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		WARN_ON(test_bit(FLAG_IS_OUT, &amp;desc-&gt;flags) &amp;&amp;</span><br><span class="line">			!test_bit(FLAG_OPEN_DRAIN, &amp;desc-&gt;flags));</span><br><span class="line">		<span class="comment">/* 核心操作: 设置描述符中的FLAG_IRQ_IS_ENABLED标志位. */</span></span><br><span class="line">		set_bit(FLAG_IRQ_IS_ENABLED, &amp;desc-&gt;flags);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(gpiochip_enable_irq);</span><br></pre></td></tr></table></figure>

<h2 id="gpiolib中断控制器-irqchip-的实现"><a href="#gpiolib中断控制器-irqchip-的实现" class="headerlink" title="gpiolib中断控制器(irqchip)的实现"></a><code>gpiolib</code>中断控制器(irqchip)的实现</h2><p>此代码片段是Linux内核<code>gpiolib</code>子系统与<code>irqchip</code>子系统集成的核心部分。它的根本原理是<strong>提供一套标准的适配器(Adapter)和包装器(Wrapper)函数, 将一个驱动程序提供的、特定于硬件的<code>gpio_chip</code>对象, 封装成一个内核可以统一识别和管理的标准<code>irq_chip</code>对象</strong>。这使得任何一个GPIO控制器, 无论其硬件实现如何, 都能作为中断源无缝地融入内核的中断处理框架, 从而实现了<code>gpio_to_irq()</code>这个关键功能。</p>
<hr>
<h3 id="1-gpio-to-irq的核心实现"><a href="#1-gpio-to-irq的核心实现" class="headerlink" title="1. gpio_to_irq的核心实现"></a>1. <code>gpio_to_irq</code>的核心实现</h3><p><code>gpiochip_to_irq</code>是驱动程序和内核其他部分将一个GPIO引脚坐标(控制器+偏移)翻译成一个全局Linux IRQ号所调用的核心API。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * gpiochip_to_irq - 将一个gpiochip上的偏移量翻译成Linux IRQ号</span></span><br><span class="line"><span class="comment"> * @gc: 目标gpio_chip</span></span><br><span class="line"><span class="comment"> * @offset: 该chip上的引脚偏移量</span></span><br><span class="line"><span class="comment"> * @return: 成功时返回Linux IRQ号, 失败时返回负的错误码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpiochip_to_irq</span><span class="params">(<span class="keyword">struct</span> gpio_chip *gc, <span class="type">unsigned</span> <span class="type">int</span> offset)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_domain</span> *<span class="title">domain</span> =</span> gc-&gt;irq.domain; <span class="comment">// 获取与该chip关联的中断域</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 关键的竞态条件防护: 检查irq子系统是否已完全初始化.</span></span><br><span class="line"><span class="comment">	 * 如果一个驱动尝试获取IRQ, 但gpiochip的irqchip部分尚未通过</span></span><br><span class="line"><span class="comment">	 * gpiochip_irqchip_add_allocated_domain()注册完毕, gc-&gt;irq.initialized会是false.</span></span><br><span class="line"><span class="comment">	 * 返回-EPROBE_DEFER是标准的处理方法, 请求内核稍后重试该驱动的探测.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!gc-&gt;irq.initialized)</span><br><span class="line">		<span class="keyword">return</span> -EPROBE_DEFER;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 检查该引脚是否在硬件上支持中断. */</span></span><br><span class="line">	<span class="keyword">if</span> (!gpiochip_irqchip_irq_valid(gc, offset))</span><br><span class="line">		<span class="keyword">return</span> -ENXIO; <span class="comment">// 不支持则返回&quot;无此设备或地址&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_IRQ_DOMAIN_HIERARCHY</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 如果这是一个层次化域 (例如STM32的GPIO域是EXTI域的子域).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (irq_domain_is_hierarchy(domain)) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">irq_fwspec</span> <span class="title">spec</span>;</span> <span class="comment">// 创建一个通用的中断请求描述符</span></span><br><span class="line"></span><br><span class="line">		spec.fwnode = domain-&gt;fwnode; <span class="comment">// 使用子域的固件节点</span></span><br><span class="line">		spec.param_count = <span class="number">2</span>; <span class="comment">// 指定请求包含2个参数</span></span><br><span class="line">		<span class="comment">/* 第一个参数: 本地硬件中断号(hwirq), 即引脚偏移 */</span></span><br><span class="line">		spec.param[<span class="number">0</span>] = gc-&gt;irq.child_offset_to_irq(gc, offset);</span><br><span class="line">		<span class="comment">/* 第二个参数: 触发类型, 此时未知, 设为NONE */</span></span><br><span class="line">		spec.param[<span class="number">1</span>] = IRQ_TYPE_NONE;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 调用irq_create_fwspec_mapping(), 这个函数会触发整个层次化域的</span></span><br><span class="line"><span class="comment">		 * 分配(alloc)流程, 逐级向上申请和翻译, 最终创建一个完整的映射.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">return</span> irq_create_fwspec_mapping(&amp;spec);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 对于简单的(非层次化的)域, 直接调用irq_create_mapping.</span></span><br><span class="line"><span class="comment">	 * 这个函数会使用domain-&gt;ops-&gt;map回调(即gpiochip_irq_map)来建立映射.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> irq_create_mapping(domain, offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-irq-chip回调函数的包装器"><a href="#2-irq-chip回调函数的包装器" class="headerlink" title="2. irq_chip回调函数的包装器"></a>2. <code>irq_chip</code>回调函数的包装器</h3><p><code>gpiochip_set_irq_hooks</code>函数通过巧妙的指针交换, 将<code>gpiolib</code>自己的通用逻辑”注入”到驱动提供的<code>irq_chip</code>回调中。下面是被注入的包装器函数, 它们在调用驱动原始的回调函数的同时, 执行了<code>gpiolib</code>的通用操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* gpiochip_irq_reqres: &quot;request_resources&quot;回调的包装器. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">gpiochip_irq_reqres</span><span class="params">(<span class="keyword">struct</span> irq_data *d)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 从irq_data中获取gpio_chip上下文 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_chip</span> *<span class="title">gc</span> =</span> irq_data_get_irq_chip_data(d);</span><br><span class="line">	<span class="comment">/* 从irq_data中获取硬件中断号(引脚偏移) */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> hwirq = irqd_to_hwirq(d);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 调用gpiolib内部函数, 将该引脚锁定为IRQ模式, 防止被用作普通GPIO. */</span></span><br><span class="line">	<span class="keyword">return</span> gpiochip_reqres_irq(gc, hwirq);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(gpiochip_irq_reqres);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* gpiochip_irq_relres: &quot;release_resources&quot;回调的包装器. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">gpiochip_irq_relres</span><span class="params">(<span class="keyword">struct</span> irq_data *d)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_chip</span> *<span class="title">gc</span> =</span> irq_data_get_irq_chip_data(d);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> hwirq = irqd_to_hwirq(d);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 解锁引脚, 使其可以被重新用作普通GPIO. */</span></span><br><span class="line">	gpiochip_relres_irq(gc, hwirq);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(gpiochip_irq_relres);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* gpiochip_irq_mask: &quot;irq_mask&quot;回调的包装器. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">gpiochip_irq_mask</span><span class="params">(<span class="keyword">struct</span> irq_data *d)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_chip</span> *<span class="title">gc</span> =</span> irq_data_get_irq_chip_data(d);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> hwirq = irqd_to_hwirq(d);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果驱动提供了自己的irq_mask实现, 先调用它. */</span></span><br><span class="line">	<span class="keyword">if</span> (gc-&gt;irq.irq_mask)</span><br><span class="line">		gc-&gt;irq.irq_mask(d);</span><br><span class="line">	<span class="comment">/* 然后, 调用gpiolib的通用disable函数. */</span></span><br><span class="line">	gpiochip_disable_irq(gc, hwirq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* gpiochip_irq_unmask: &quot;irq_unmask&quot;回调的包装器. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">gpiochip_irq_unmask</span><span class="params">(<span class="keyword">struct</span> irq_data *d)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_chip</span> *<span class="title">gc</span> =</span> irq_data_get_irq_chip_data(d);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> hwirq = irqd_to_hwirq(d);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 先调用gpiolib的通用enable函数. */</span></span><br><span class="line">	gpiochip_enable_irq(gc, hwirq);</span><br><span class="line">	<span class="comment">/* 如果驱动提供了自己的irq_unmask实现, 再调用它. */</span></span><br><span class="line">	<span class="keyword">if</span> (gc-&gt;irq.irq_unmask)</span><br><span class="line">		gc-&gt;irq.irq_unmask(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* gpiochip_irq_enable: &quot;irq_enable&quot;回调的包装器 (用于旧式API). */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">gpiochip_irq_enable</span><span class="params">(<span class="keyword">struct</span> irq_data *d)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_chip</span> *<span class="title">gc</span> =</span> irq_data_get_irq_chip_data(d);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> hwirq = irqd_to_hwirq(d);</span><br><span class="line"></span><br><span class="line">	gpiochip_enable_irq(gc, hwirq);</span><br><span class="line">	<span class="comment">/* 调用驱动原始的irq_enable. */</span></span><br><span class="line">	gc-&gt;irq.irq_enable(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* gpiochip_irq_disable: &quot;irq_disable&quot;回调的包装器 (用于旧式API). */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">gpiochip_irq_disable</span><span class="params">(<span class="keyword">struct</span> irq_data *d)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_chip</span> *<span class="title">gc</span> =</span> irq_data_get_irq_chip_data(d);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> hwirq = irqd_to_hwirq(d);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 调用驱动原始的irq_disable. */</span></span><br><span class="line">	gc-&gt;irq.irq_disable(d);</span><br><span class="line">	gpiochip_disable_irq(gc, hwirq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-irqchip的安装与初始化"><a href="#3-irqchip的安装与初始化" class="headerlink" title="3. irqchip的安装与初始化"></a>3. <code>irqchip</code>的安装与初始化</h3><p>这组函数负责将上述所有部分组装起来, 完成<code>irqchip</code>在<code>gpiolib</code>中的注册。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* gpiochip_set_irq_hooks: 为gpio_chip的irqchip安装包装器钩子. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">gpiochip_set_irq_hooks</span><span class="params">(<span class="keyword">struct</span> gpio_chip *gc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_chip</span> *<span class="title">irqchip</span> =</span> gc-&gt;irq.chip;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 如果irq_chip被标记为&quot;不可变的&quot;(immutable), 说明其回调函数不应被修改,</span></span><br><span class="line"><span class="comment">	 * 直接返回. 这是现代驱动推荐的做法.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (irqchip-&gt;flags &amp; IRQCHIP_IMMUTABLE)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 否则, 打印一条警告, 建议驱动作者修复它. */</span></span><br><span class="line">	chip_warn(gc, <span class="string">&quot;not an immutable chip, please consider fixing it!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果驱动没有提供资源管理回调, 则安装gpiolib的默认实现. */</span></span><br><span class="line">	<span class="keyword">if</span> (!irqchip-&gt;irq_request_resources &amp;&amp;</span><br><span class="line">	    !irqchip-&gt;irq_release_resources) &#123;</span><br><span class="line">		irqchip-&gt;irq_request_resources = gpiochip_irq_reqres;</span><br><span class="line">		irqchip-&gt;irq_release_resources = gpiochip_irq_relres;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON(gc-&gt;irq.irq_enable))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ... (检查共享irqchip的警告) ...</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 核心的指针交换&quot;包装&quot;逻辑:</span></span><br><span class="line"><span class="comment">	 * 1. 保存驱动原始的回调函数指针到gc-&gt;irq的私有字段中.</span></span><br><span class="line"><span class="comment">	 * 2. 用gpiolib自己的包装器函数覆盖irqchip中的回调函数指针.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (irqchip-&gt;irq_disable) &#123;</span><br><span class="line">		gc-&gt;irq.irq_disable = irqchip-&gt;irq_disable;</span><br><span class="line">		irqchip-&gt;irq_disable = gpiochip_irq_disable;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		gc-&gt;irq.irq_mask = irqchip-&gt;irq_mask;</span><br><span class="line">		irqchip-&gt;irq_mask = gpiochip_irq_mask;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (irqchip-&gt;irq_enable) &#123;</span><br><span class="line">		gc-&gt;irq.irq_enable = irqchip-&gt;irq_enable;</span><br><span class="line">		irqchip-&gt;irq_enable = gpiochip_irq_enable;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		gc-&gt;irq.irq_unmask = irqchip-&gt;irq_unmask;</span><br><span class="line">		irqchip-&gt;irq_unmask = gpiochip_irq_unmask;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* gpiochip_irqchip_add_allocated_domain: 将一个已分配的域与gpio_chip关联. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpiochip_irqchip_add_allocated_domain</span><span class="params">(<span class="keyword">struct</span> gpio_chip *gc,</span></span><br><span class="line"><span class="params">						 <span class="keyword">struct</span> irq_domain *domain,</span></span><br><span class="line"><span class="params">						 <span class="type">bool</span> allocated_externally)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!domain)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 警告并覆盖驱动中可能存在的旧的、已废弃的to_irq函数指针.</span></span><br><span class="line"><span class="comment">	 * 现代驱动不应再使用它.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (gc-&gt;to_irq)</span><br><span class="line">		chip_warn(gc, <span class="string">&quot;to_irq is redefined in %s and you shouldn&#x27;t rely on it\n&quot;</span>, __func__);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 将gpiolib自己的to_irq实现和已创建的domain关联到gpio_chip.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	gc-&gt;to_irq = gpiochip_to_irq;</span><br><span class="line">	gc-&gt;irq.domain = domain;</span><br><span class="line">	gc-&gt;irq.domain_is_allocated_externally = allocated_externally;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 使用内存屏障, 防止编译器将下面的initialized赋值操作重排到前面的指针赋值之前.</span></span><br><span class="line"><span class="comment">	 * 这是确保竞态条件防护有效的关键.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	barrier();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 最后, 设置initialized标志为true, 向外界宣告irqchip已准备就绪.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	gc-&gt;irq.initialized = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="gpiochip-add-irqchip-为GPIO控制器添加中断控制器功能"><a href="#gpiochip-add-irqchip-为GPIO控制器添加中断控制器功能" class="headerlink" title="gpiochip_add_irqchip: 为GPIO控制器添加中断控制器功能"></a>gpiochip_add_irqchip: 为GPIO控制器添加中断控制器功能</h2><p>此函数是Linux内核<code>gpiolib</code>和<code>irqchip</code>两大子系统之间的核心桥梁。它的根本原理是<strong>将一个已经注册的GPIO控制器(<code>gpio_chip</code>)进一步封装和注册, 使其在内核中也扮演一个标准的中断控制器(<code>irqchip</code>)的角色</strong>。完成此函数的调用后, <code>gpiolib</code>就具备了将一个GPIO引脚号翻译成一个全局Linux IRQ号的能力(即<code>gpio_to_irq()</code>功能得以实现), 并且能够处理来自该引脚的中断请求。</p>
<p>这是一个复杂但设计精巧的注册过程, 其工作流程如下:</p>
<ol>
<li><p><strong>前提检查与配置</strong>: 函数首先进行一系列健全性检查。例如, 如果驱动使用了”链式中断处理器”(<code>parent_handler</code>), 那么该GPIO控制器的操作函数就绝不能休眠, 因为链式处理器通常在原子上下文中被调用。它还会警告并修正一个不推荐的做法: 在设备树系统中使用驱动硬编码的默认中断触发类型, 因为这应该由设备树来描述。</p>
</li>
<li><p><strong>创建中断域 (<code>irq_domain</code>) - 核心逻辑</strong>: 这是函数最关键的一步。它会根据GPIO控制器的特性, 选择两种方式之一来创建其中断域:</p>
<ul>
<li><strong>层次化域 (Hierarchical Domain)</strong>: 这是为像STM32这样复杂的SoC设计的。在这种模型中, GPIO控制器本身并不是顶级中断控制器, 而是作为一个次级(或三级)控制器, <strong>级联(cascaded)<strong>在另一个主中断控制器之下(例如, STM32的EXTI)。函数会调用<code>gpiochip_hierarchy_create_domain</code>来创建一个</strong>子域(child domain)</strong>, 并将其与驱动指定的**父域(parent domain)**关联起来。</li>
<li><strong>简单域 (Simple Domain)</strong>: 对于一些简单的硬件, GPIO控制器可能就是主中断源, 或者其级联关系非常简单。在这种情况下, 函数会创建一个独立的、非层次化的中断域。</li>
</ul>
</li>
<li><p><strong>设置链式中断处理器 (可选)</strong>: 如果GPIO控制器是一个”中断解复用器”(即它自己有一条中断线连接到父中断控制器, 当其任何一个引脚中断时, 这条线都会触发), 此函数会调用<code>irq_set_chained_handler_and_data</code>。这个调用会将父中断控制器上的那个IRQ配置为: 当它触发时, 不去执行一个普通的中断服务程序, 而是<strong>直接调用</strong>本GPIO控制器驱动提供的<code>parent_handler</code>函数。这个<code>parent_handler</code>的职责就是去查询自己内部的寄存器, 找出到底是哪个GPIO引脚真正触发了中断。</p>
</li>
<li><p><strong>最终注册与激活</strong>: 在创建好<code>irq_domain</code>并设置好所有链接后, 函数会调用<code>gpiochip_irqchip_add_allocated_domain</code>将这个域与<code>gpio_chip</code>正式绑定。从此, <code>gpiolib</code>和<code>irqchip</code>两大子系统就完全关联起来了。</p>
</li>
</ol>
<p><strong>在STM32H750上的应用:</strong><br>STM32的中断系统是典型的<strong>层次化</strong>结构:<br><code>GPIO Pin</code> -&gt; <code>GPIO Bank</code> -&gt; <code>EXTI Controller</code> -&gt; <code>NVIC (CPU Interrupt Controller)</code></p>
<p>因此, 当STM32的GPIO驱动调用<code>gpiochip_add_irqchip</code>时, <strong>总是会走”层次化域”的路径</strong>:</p>
<ul>
<li>STM32的EXTI驱动会首先注册一个代表EXTI的<strong>父</strong><code>irq_domain</code>。</li>
<li>当<code>gpiolib</code>为GPIOA这个Bank注册<code>irqchip</code>时, <code>gpiochip_add_irqchip</code>会创建一个新的<code>irq_domain</code>, 并将其<code>parent</code>指针指向EXTI的域。</li>
<li>当上层驱动调用<code>gpio_to_irq()</code>请求PA5的中断时, 这个两级域的层次结构就会被用来进行翻译, 最终返回一个由NVIC管理的、全局唯一的Linux IRQ号。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * gpiochip_add_irqchip: 为一个GPIO chip添加一个IRQ chip功能.</span></span><br><span class="line"><span class="comment"> * @gc: 要添加IRQ chip功能的GPIO chip.</span></span><br><span class="line"><span class="comment"> * @lock_key: 用于锁调试的锁分类键 (IRQ锁).</span></span><br><span class="line"><span class="comment"> * @request_key: 用于锁调试的锁分类键 (IRQ请求锁).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回: 成功时返回0, 失败时返回负的错误码.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpiochip_add_irqchip</span><span class="params">(<span class="keyword">struct</span> gpio_chip *gc,</span></span><br><span class="line"><span class="params">				<span class="keyword">struct</span> lock_class_key *lock_key,</span></span><br><span class="line"><span class="params">				<span class="keyword">struct</span> lock_class_key *request_key)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fwnode_handle</span> *<span class="title">fwnode</span> =</span> dev_fwnode(&amp;gc-&gt;gpiodev-&gt;dev);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_chip</span> *<span class="title">irqchip</span> =</span> gc-&gt;irq.chip;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_domain</span> *<span class="title">domain</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> type;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果驱动没有提供 irqchip 结构体, 说明它不支持中断, 直接成功返回. */</span></span><br><span class="line">	<span class="keyword">if</span> (!irqchip)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 健全性检查: 如果驱动使用了链式中断处理器, 那么它的操作函数绝不能休眠.</span></span><br><span class="line"><span class="comment">	 * 因为链式处理器在原子上下文中被调用, 睡眠会导致系统死锁.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (gc-&gt;irq.parent_handler &amp;&amp; gc-&gt;can_sleep) &#123;</span><br><span class="line">		chip_err(gc, <span class="string">&quot;you cannot have chained interrupts on a chip that may sleep\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	type = gc-&gt;irq.default_type;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 健全性检查: 在使用设备树(fwnode存在)的系统中, 不应在驱动中硬编码默认触发类型.</span></span><br><span class="line"><span class="comment">	 * 触发类型应该由设备树描述. 如果驱动这么做了, 打印警告并忽略该默认值.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (WARN(fwnode &amp;&amp; type != IRQ_TYPE_NONE,</span><br><span class="line">		 <span class="string">&quot;%pfw: Ignoring %u default trigger\n&quot;</span>, fwnode, type))</span><br><span class="line">		type = IRQ_TYPE_NONE;</span><br><span class="line"></span><br><span class="line">	gc-&gt;irq.default_type = type;</span><br><span class="line">	gc-&gt;irq.lock_key = lock_key;</span><br><span class="line">	gc-&gt;irq.request_key = request_key;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 核心逻辑: 根据驱动配置, 创建中断域.</span></span><br><span class="line"><span class="comment">	 * 如果提供了父域, 则构建一个层次化域.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (gpiochip_hierarchy_is_hierarchical(gc)) &#123;</span><br><span class="line">		domain = gpiochip_hierarchy_create_domain(gc);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; <span class="comment">/* 否则, 创建一个简单的、非层次化的域. */</span></span><br><span class="line">		domain = gpiochip_simple_create_domain(gc);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(domain))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(domain);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果驱动配置了链式中断处理器. */</span></span><br><span class="line">	<span class="keyword">if</span> (gc-&gt;irq.parent_handler) &#123;</span><br><span class="line">		<span class="comment">/* 遍历所有父中断线. */</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; gc-&gt;irq.num_parents; i++) &#123;</span><br><span class="line">			<span class="type">void</span> *data;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 获取传递给处理器的私有数据. */</span></span><br><span class="line">			<span class="keyword">if</span> (gc-&gt;irq.per_parent_data)</span><br><span class="line">				data = gc-&gt;irq.parent_handler_data_array[i];</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				data = gc-&gt;irq.parent_handler_data ?: gc;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * 将父IRQ配置为链式中断模式.</span></span><br><span class="line"><span class="comment">			 * 当父IRQ触发时, 会直接调用我们提供的 parent_handler 函数.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			irq_set_chained_handler_and_data(gc-&gt;irq.parents[i],</span><br><span class="line">							 gc-&gt;irq.parent_handler,</span><br><span class="line">							 data);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 设置gpiolib内部用于中断处理的钩子函数. */</span></span><br><span class="line">	gpiochip_set_irq_hooks(gc);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 将新创建的域与gpiochip正式关联起来. */</span></span><br><span class="line">	ret = gpiochip_irqchip_add_allocated_domain(gc, domain, <span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 为ACPI平台请求中断(在非ACPI系统上此函数为空操作). */</span></span><br><span class="line">	acpi_gpiochip_request_interrupts(gc);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="gpiochip-setup-dev-创建GPIO控制器的用户空间接口"><a href="#gpiochip-setup-dev-创建GPIO控制器的用户空间接口" class="headerlink" title="gpiochip_setup_dev: 创建GPIO控制器的用户空间接口"></a>gpiochip_setup_dev: 创建GPIO控制器的用户空间接口</h2><p>此函数是<code>gpiolib</code>注册流程的最后一步, 也是至关重要的一步。它的核心原理是<strong>将一个已经在内核内部完全初始化好的<code>gpio_device</code>对象”发布”(publish)给系统的更高层和用户空间</strong>, 主要通过两种机制来完成: <strong>注册一个字符设备(character device)</strong> 和 <strong>创建其sysfs接口</strong>。</p>
<p>这个函数是连接内核内部的<code>gpiolib</code>世界和外部的用户空间世界的桥梁。在此函数成功执行之前, GPIO控制器只存在于内核的内存中; 在此函数执行之后, 它就成为了一个用户空间工具(如<code>libgpiod</code>的<code>gpiodetect</code>, <code>gpioinfo</code>命令)和<code>udev</code>&#x2F;<code>mdev</code>系统可以看见并与之交互的实体。</p>
<p><strong>工作流程详解:</strong></p>
<ol>
<li><strong>设备对象初始化</strong>: 它首先调用<code>device_initialize</code>, 对内核的<code>gpio_device</code>内部嵌入的<code>struct device</code>对象进行标准化的最后准备。此时, 设备对象已准备就绪, 但尚未对系统可见。</li>
<li><strong>字符设备注册</strong>: 这是最关键的一步。它调用<code>gcdev_register</code>(GPIO Character Device Register), 将该GPIO控制器注册为一个<strong>字符设备</strong>。<ul>
<li>内核会从<code>gpiolib</code>的动态主设备号<code>gpio_devt</code>中为这个新设备分配一个唯一的设备号(major:minor)。</li>
<li>这个注册操作会触发<code>udev</code>或<code>mdev</code>守护进程, 在<code>/dev/</code>目录下自动创建一个对应的设备节点, 例如<code>/dev/gpiochip0</code>。</li>
<li>现代的Linux GPIO用户空间工具(基于<code>libgpiod</code>)就是通过<code>open()</code>这个字符设备节点来与内核中的GPIO控制器进行交互的, 这种方式取代了旧的、已被废弃的通过<code>sysfs</code>的<code>/sys/class/gpio/export</code>接口来控制引脚的方法。</li>
</ul>
</li>
<li><strong>Sysfs接口注册</strong>: 它接着调用<code>gpiochip_sysfs_register</code>, 在<code>/sys/class/gpio/</code>目录下创建一个名为<code>gpiochipN</code> (N是该控制器的ID号)的符号链接, 指向其在<code>/sys/devices/</code>下的真实设备目录。同时, 它还会创建一些用于描述该控制器属性的只读文件, 例如:<ul>
<li><code>label</code>: 包含该控制器的名称(例如 “GPIOA”)。</li>
<li><code>base</code>: 该控制器在全局GPIO编号空间中的起始编号。</li>
<li><code>ngpio</code>: 该控制器管理的引脚数量。<br>这些<code>sysfs</code>文件主要用于系统状态的查看、调试和诊断。</li>
</ul>
</li>
<li><strong>错误处理</strong>: 函数包含了健壮的错误处理逻辑。如果在注册<code>sysfs</code>接口时失败, 它会跳转到<code>err_remove_device</code>标签, 调用<code>gcdev_unregister</code>来<strong>撤销</strong>已经成功的字符设备注册, 从而保证了系统状态的一致性, 不会留下一个”半注册”的设备。</li>
</ol>
<p><strong>在STM32H750上的应用:</strong><br>当STM32驱动为每一个GPIO Bank(如GPIOA, GPIOB)调用<code>gpiochip_add_data</code>并成功完成所有内部初始化后, <code>gpiochip_setup_dev</code>就会被调用。</p>
<ul>
<li>为GPIOA调用此函数后, 系统中就会出现<code>/dev/gpiochip0</code>设备节点和<code>/sys/class/gpio/gpiochip0</code>符号链接。</li>
<li>在Linux终端中运行<code>gpioinfo</code>命令, 你会看到一行输出, 显示”gpiochip0 [GPIOA] 16 lines”, 这些信息就是通过读写<code>/dev/gpiochip0</code>和解析其<code>sysfs</code>属性而获得的。</li>
<li>同样地, 为GPIOB调用后, 就会出现<code>/dev/gpiochip1</code>和<code>/sys/class/gpio/gpiochip1</code>。这个过程对所有使能的GPIO Bank依次重复。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * gpiochip_setup_dev: 为一个gpio_device设置其设备模型和用户空间接口.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpiochip_setup_dev</span><span class="params">(<span class="keyword">struct</span> gpio_device *gdev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 获取与该gpiolib设备关联的固件节点(设备树节点)句柄. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fwnode_handle</span> *<span class="title">fwnode</span> =</span> dev_fwnode(&amp;gdev-&gt;dev);</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 对gdev内部嵌入的struct device对象进行标准初始化.</span></span><br><span class="line"><span class="comment">	 * 此时该设备对象已在内存中准备好, 但尚未注册到内核设备模型中.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	device_initialize(&amp;gdev-&gt;dev);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 一个微妙的检查: 如果一个固件节点(fwnode)没有被一个主要设备所拥有</span></span><br><span class="line"><span class="comment">	 * (fwnode-&gt;dev为NULL), 那么我们可以安全地清除它的&quot;已初始化&quot;标志.</span></span><br><span class="line"><span class="comment">	 * 这允许我们将这个新的gpio_device作为该fwnode的主要用户接口.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (fwnode &amp;&amp; !fwnode-&gt;dev)</span><br><span class="line">		fwnode_dev_initialized(fwnode, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 步骤1: 注册一个字符设备.</span></span><br><span class="line"><span class="comment">	 * 这使得用户空间可以通过 /dev/gpiochipN 节点与此控制器交互.</span></span><br><span class="line"><span class="comment">	 * gpio_devt 是gpiolib子系统的主设备号.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ret = gcdev_register(gdev, gpio_devt);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 步骤2: 注册sysfs接口.</span></span><br><span class="line"><span class="comment">	 * 这会创建 /sys/class/gpio/gpiochipN 等目录和属性文件.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ret = gpiochip_sysfs_register(gdev);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">goto</span> err_remove_device; <span class="comment">/* 如果失败, 跳转到错误处理路径. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 打印一条调试信息, 宣告该GPIO控制器已成功注册.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	dev_dbg(&amp;gdev-&gt;dev, <span class="string">&quot;registered GPIOs %u to %u on %s\n&quot;</span>, gdev-&gt;base,</span><br><span class="line">		gdev-&gt;base + gdev-&gt;ngpio - <span class="number">1</span>, gdev-&gt;label);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* 成功 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 错误处理路径 */</span></span><br><span class="line">err_remove_device:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 撤销操作: 如果sysfs注册失败, 必须将已经成功注册的字符设备注销掉,</span></span><br><span class="line"><span class="comment">	 * 以保持系统状态的一致性.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	gcdev_unregister(gdev);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="gpiochip-add-data-将一个GPIO控制器注册到内核"><a href="#gpiochip-add-data-将一个GPIO控制器注册到内核" class="headerlink" title="gpiochip_add_data: 将一个GPIO控制器注册到内核"></a>gpiochip_add_data: 将一个GPIO控制器注册到内核</h2><p>此函数是Linux内核<code>gpiolib</code>子系统的心脏。一个设备驱动程序(例如STM32的pinctrl驱动)在准备好一个描述其硬件能力的<code>struct gpio_chip</code>结构体之后, 会调用此函数, 将其<strong>正式注册并”激活”</strong>, 使其成为一个对整个内核可用的、功能完备的GPIO控制器。</p>
<p>它的核心原理是一个<strong>精心设计的、分阶段的”构造”过程</strong>, 它将一个驱动提供的、半成品的<code>gpio_chip</code>蓝图, 实例化为一个内核内部的、标准化的<code>gpio_device</code>对象, 并将其与内核的各大关键子系统(设备模型、中断系统、pinctrl系统、设备树)一一链接起来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这两个宏为调用者提供了更简洁的API, 它们会自动将用于高级锁分类的key参数设置为NULL. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> gpiochip_add_data(gc, data) gpiochip_add_data_with_key(gc, data, NULL, NULL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> devm_gpiochip_add_data(dev, gc, data) \</span></span><br><span class="line"><span class="meta">	devm_gpiochip_add_data_with_key(dev, gc, data, NULL, NULL)</span></span><br></pre></td></tr></table></figure>

<h2 id="gpiochip-add-data-with-key-核心注册函数"><a href="#gpiochip-add-data-with-key-核心注册函数" class="headerlink" title="gpiochip_add_data_with_key: 核心注册函数"></a><code>gpiochip_add_data_with_key</code>: 核心注册函数</h2><p><strong>工作流程概览:</strong></p>
<ol>
<li><strong>内部对象创建</strong>: 函数首先为内核创建一个内部的<code>gpio_device</code>结构体, 这是<code>gpiolib</code>核心用来管理控制器的标准容器。它还会为此控制器分配一个全局唯一的ID号(例如, 0, 1, 2…), 并生成对应的设备名(如 “gpiochip0”)。</li>
<li><strong>描述符分配</strong>: 它为该控制器的每一个引脚都分配一个<code>struct gpio_desc</code>描述符。这是现代内核中代表单个GPIO引脚的标准方式。</li>
<li><strong>全局编号空间分配</strong>: 它会为该控制器在Linux全局GPIO编号空间中分配一段连续的编号。虽然这种全局编号机制已不被推荐(现代驱动应使用描述符), 但为了兼容旧的API和<code>sysfs</code>接口, 这一步仍然是必需的。此函数支持动态分配(推荐, <code>gc-&gt;base = -1</code>)和静态分配(已废弃)两种模式。</li>
<li><strong>子系统集成</strong>: 这是最关键的部分, 它像接线员一样, 将这个新创建的<code>gpio_device</code>连接到各个相关子系统:<ul>
<li><strong>pinctrl</strong>: 调用<code>gpiochip_add_pin_ranges</code>来注册GPIO编号范围。</li>
<li><strong>设备树(OF)</strong>: 调用<code>of_gpiochip_add</code>来解析设备树中与GPIO相关的属性。</li>
<li><strong>中断(IRQ)</strong>: 调用<code>gpiochip_add_irqchip</code>将该GPIO控制器注册为一个<code>irqchip</code>(中断控制器), 这使得<code>gpio_to_irq()</code>功能得以实现。</li>
</ul>
</li>
<li><strong>sysfs设备创建</strong>: 最后, 它调用<code>gpiochip_setup_dev</code>在<code>/sys/class/gpio/</code>目录下创建对应的<code>gpiochipN</code>设备节点, 使得用户空间工具(如<code>gpiodetect</code>, <code>udev</code>)可以看到并与之交互。</li>
<li><strong>错误处理</strong>: 此函数拥有一个非常健壮的错误处理机制。它使用了一系列的<code>goto</code>标签, 如果在上述任何一个阶段失败, 程序会跳转到对应的标签, 并以<strong>与注册相反的顺序</strong>, 精确地撤销所有已经成功完成的步骤, 确保不会有任何资源泄漏或状态不一致, 保证了系统的稳定性。</li>
</ol>
<p><strong>在STM32H750上的应用:</strong><br>当<code>stm32_gpiolib_register_bank</code>函数为STM32的某一个GPIO Bank(例如, GPIOA)准备好其<code>gpio_chip</code>结构体后, 它就会调用<code>gpiochip_add_data</code> (通过宏)。这个调用会触发上述所有流程, 最终结果是:</p>
<ul>
<li>GPIOA被注册为<code>gpiochipN</code>。</li>
<li>它所管理的16个引脚(PA0-PA15)在内核中都有了对应的<code>gpio_desc</code>。</li>
<li>它会被分配一段GPIO编号(例如, 0-15)。</li>
<li><code>gpio_to_irq</code>功能被激活, 可以将PA5的中断请求转换为一个全局的Linux IRQ号。</li>
<li>其他驱动程序从此可以通过<code>gpio_request(5, ...)</code>来申请并使用PA5。</li>
</ul>
<hr>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gpiochip_add_data_with_key</span><span class="params">(<span class="keyword">struct</span> gpio_chip *gc, <span class="type">void</span> *data,</span></span><br><span class="line"><span class="params">			       <span class="keyword">struct</span> lock_class_key *lock_key,</span></span><br><span class="line"><span class="params">			       <span class="keyword">struct</span> lock_class_key *request_key)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_device</span> *<span class="title">gdev</span>;</span> <span class="comment">// 内核内部的GPIO设备表示</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> desc_index;</span><br><span class="line">	<span class="type">int</span> base = <span class="number">0</span>; <span class="comment">// GPIO编号基地址</span></span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ... (一些合法性检查) ...</span></span><br><span class="line">	<span class="comment">/* Only allow one set() and one set_multiple(). */</span></span><br><span class="line">	<span class="keyword">if</span> ((gc-&gt;<span class="built_in">set</span> &amp;&amp; gc-&gt;set_rv) ||</span><br><span class="line">	    (gc-&gt;set_multiple &amp;&amp; gc-&gt;set_multiple_rv))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 步骤1: 分配并填充内核内部的gpio_device结构体 */</span></span><br><span class="line">	gdev = kzalloc(<span class="keyword">sizeof</span>(*gdev), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!gdev)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	gdev-&gt;dev.type = &amp;gpio_dev_type;  <span class="comment">// 设置设备类型</span></span><br><span class="line">	gdev-&gt;dev.bus = &amp;gpio_bus_type;   <span class="comment">// 设置所属总线</span></span><br><span class="line">	gdev-&gt;dev.parent = gc-&gt;parent;    <span class="comment">// 设置父设备</span></span><br><span class="line">	rcu_assign_pointer(gdev-&gt;chip, gc); <span class="comment">// 安全地将驱动的gpio_chip关联到内核的gpio_device</span></span><br><span class="line"></span><br><span class="line">	gc-&gt;gpiodev = gdev;            <span class="comment">// 反向关联, 从gpio_chip可以找到gpio_device</span></span><br><span class="line">	<span class="comment">/* gc-&gt;gpiodev-&gt;data = data; */</span></span><br><span class="line">	gpiochip_set_data(gc, data);   <span class="comment">// 将驱动的私有数据与chip关联</span></span><br><span class="line"></span><br><span class="line">	device_set_node(&amp;gdev-&gt;dev, gpiochip_choose_fwnode(gc)); <span class="comment">// 关联设备树节点</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 使用IDA(ID Allocator)分配一个唯一的、动态的ID号 */</span></span><br><span class="line">	ret = ida_alloc(&amp;gpio_ida, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> err_free_gdev;</span><br><span class="line">	gdev-&gt;id = ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 使用ID号生成设备名, 例如 &quot;gpiochip0&quot; */</span></span><br><span class="line">	ret = dev_set_name(&amp;gdev-&gt;dev, GPIOCHIP_NAME <span class="string">&quot;%d&quot;</span>, gdev-&gt;id);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">goto</span> err_free_ida;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ... (设置owner模块) ...</span></span><br><span class="line">	<span class="keyword">if</span> (gc-&gt;parent &amp;&amp; gc-&gt;parent-&gt;driver)</span><br><span class="line">		gdev-&gt;owner = gc-&gt;parent-&gt;driver-&gt;owner;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (gc-&gt;owner)</span><br><span class="line">		<span class="comment">/* <span class="doctag">TODO:</span> remove chip-&gt;owner */</span></span><br><span class="line">		gdev-&gt;owner = gc-&gt;owner;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		gdev-&gt;owner = THIS_MODULE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 步骤2: 分配GPIO描述符数组 */</span></span><br><span class="line">	ret = gpiochip_get_ngpios(gc, &amp;gdev-&gt;dev);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">goto</span> err_free_dev_name;</span><br><span class="line"></span><br><span class="line">	gdev-&gt;descs = kcalloc(gc-&gt;ngpio, <span class="keyword">sizeof</span>(*gdev-&gt;descs), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!gdev-&gt;descs) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> err_free_dev_name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gdev-&gt;label = kstrdup_const(gc-&gt;label ?: <span class="string">&quot;unknown&quot;</span>, GFP_KERNEL);</span><br><span class="line">	<span class="comment">// ... (填充gdev的其他字段: ngpio, can_sleep等) ...</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 步骤3: 锁定并分配全局GPIO编号空间 */</span></span><br><span class="line">	scoped_guard(mutex, &amp;gpio_devices_lock) &#123;</span><br><span class="line">		base = gc-&gt;base;</span><br><span class="line">		<span class="keyword">if</span> (base &lt; <span class="number">0</span>) &#123; <span class="comment">// base为-1, 请求动态分配</span></span><br><span class="line">			base = gpiochip_find_base_unlocked(gc-&gt;ngpio);</span><br><span class="line">			<span class="keyword">if</span> (base &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				ret = base;</span><br><span class="line">				<span class="keyword">goto</span> err_free_label; <span class="comment">// 分配失败</span></span><br><span class="line">			&#125;</span><br><span class="line">			gc-&gt;base = base; <span class="comment">// 将动态分配的基地址回写到驱动的chip结构体中</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">// 驱动请求了静态基地址, 已不推荐</span></span><br><span class="line">			dev_warn(&amp;gdev-&gt;dev,</span><br><span class="line">				 <span class="string">&quot;Static allocation of GPIO base is deprecated, use dynamic allocation.\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		gdev-&gt;base = base; <span class="comment">// 保存基地址</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 将gdev添加到全局列表中, 此函数会检查编号空间是否冲突 */</span></span><br><span class="line">		ret = gpiodev_add_to_list_unlocked(gdev);</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			chip_err(gc, <span class="string">&quot;GPIO integer space overlap, cannot add chip\n&quot;</span>);</span><br><span class="line">			<span class="keyword">goto</span> err_free_label;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="comment">// 锁在此处自动释放</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// ... (初始化各种锁和通知链) ...</span></span><br><span class="line">	rwlock_init(&amp;gdev-&gt;line_state_lock);</span><br><span class="line">	RAW_INIT_NOTIFIER_HEAD(&amp;gdev-&gt;line_state_notifier);</span><br><span class="line">	BLOCKING_INIT_NOTIFIER_HEAD(&amp;gdev-&gt;device_notifier);</span><br><span class="line"></span><br><span class="line">	ret = init_srcu_struct(&amp;gdev-&gt;srcu);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">goto</span> err_remove_from_list;</span><br><span class="line"></span><br><span class="line">	ret = init_srcu_struct(&amp;gdev-&gt;desc_srcu);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">goto</span> err_cleanup_gdev_srcu;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PINCTRL</span></span><br><span class="line">	INIT_LIST_HEAD(&amp;gdev-&gt;pin_ranges);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 步骤4: 子系统集成 */</span></span><br><span class="line">	<span class="keyword">if</span> (gc-&gt;names) <span class="comment">// 如果驱动提供了引脚名, 则设置它们</span></span><br><span class="line">		gpiochip_set_desc_names(gc);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ... (初始化valid_mask等) ...</span></span><br><span class="line">	ret = gpiochip_init_valid_mask(gc);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">goto</span> err_cleanup_desc_srcu;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 遍历所有描述符, 初始化其默认方向 */</span></span><br><span class="line">	<span class="keyword">for</span> (desc_index = <span class="number">0</span>; desc_index &lt; gc-&gt;ngpio; desc_index++) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">desc</span> =</span> &amp;gdev-&gt;descs[desc_index];</span><br><span class="line">		desc-&gt;gdev = gdev;</span><br><span class="line">		<span class="comment">// ... (根据驱动提供的回调函数, 设置引脚的初始输入/输出状态) ...</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * We would typically want to use gpiochip_get_direction() here</span></span><br><span class="line"><span class="comment">		 * but we must not check the return value and bail-out as pin</span></span><br><span class="line"><span class="comment">		 * controllers can have pins configured to alternate functions</span></span><br><span class="line"><span class="comment">		 * and return -EINVAL. Also: there&#x27;s no need to take the SRCU</span></span><br><span class="line"><span class="comment">		 * lock here.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (gc-&gt;get_direction &amp;&amp; gpiochip_line_is_valid(gc, desc_index))</span><br><span class="line">			assign_bit(FLAG_IS_OUT, &amp;desc-&gt;flags,</span><br><span class="line">				   !gc-&gt;get_direction(gc, desc_index));</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			assign_bit(FLAG_IS_OUT,</span><br><span class="line">				   &amp;desc-&gt;flags, !gc-&gt;direction_input);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 与设备树(OF)子系统集成 */</span></span><br><span class="line">	ret = of_gpiochip_add(gc);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">goto</span> err_free_valid_mask;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 添加pin ranges, 与pinctrl子系统集成 */</span></span><br><span class="line">	ret = gpiochip_add_pin_ranges(gc);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">goto</span> err_remove_of_chip;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ... (添加ACPI和machine-specific的支持) ...</span></span><br><span class="line">	acpi_gpiochip_add(gc);</span><br><span class="line">	machine_gpiochip_add(gc);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 与中断(IRQ)子系统集成 */</span></span><br><span class="line">	ret = gpiochip_irqchip_init_valid_mask(gc); <span class="comment">// 初始化IRQ的valid_mask</span></span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">goto</span> err_free_hogs;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	static int gpiochip_irqchip_init_hw(struct gpio_chip *gc)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		struct gpio_irq_chip *girq = &amp;gc-&gt;irq;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		if (!girq-&gt;init_hw)</span></span><br><span class="line"><span class="comment">			return 0;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		return girq-&gt;init_hw(gc);</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	ret = gpiochip_irqchip_init_hw(gc); <span class="comment">// 初始化IRQ硬件</span></span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">goto</span> err_remove_irqchip_mask;</span><br><span class="line">	</span><br><span class="line">	ret = gpiochip_add_irqchip(gc, lock_key, request_key); <span class="comment">// 正式添加irqchip</span></span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">goto</span> err_remove_irqchip_mask;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 步骤5: 创建sysfs设备节点 */</span></span><br><span class="line">	<span class="keyword">if</span> (gpiolib_initialized) &#123;</span><br><span class="line">		ret = gpiochip_setup_dev(gdev);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">goto</span> err_remove_irqchip;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 成功</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 步骤6: 错误处理的级联清理路径 */</span></span><br><span class="line">err_remove_irqchip:</span><br><span class="line">	gpiochip_irqchip_remove(gc);</span><br><span class="line">err_remove_irqchip_mask:</span><br><span class="line">	gpiochip_irqchip_free_valid_mask(gc);</span><br><span class="line">err_free_hogs:</span><br><span class="line"><span class="comment">// ... (逐层向上, 撤销所有已成功的操作) ...</span></span><br><span class="line">err_free_gdev:</span><br><span class="line">	kfree(gdev);</span><br><span class="line">err_print_message:</span><br><span class="line">	<span class="keyword">if</span> (ret != -EPROBE_DEFER) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;%s: GPIOs %d..%d (%s) failed to register, %d\n&quot;</span>, __func__,</span><br><span class="line">		       base, base + (<span class="type">int</span>)gc-&gt;ngpio - <span class="number">1</span>,</span><br><span class="line">		       gc-&gt;label ? : <span class="string">&quot;generic&quot;</span>, ret);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(gpiochip_add_data_with_key);</span><br></pre></td></tr></table></figure>

<h2 id="gpiod-find-by-fwnode-与固件无关的-GPIO-查找调度程序"><a href="#gpiod-find-by-fwnode-与固件无关的-GPIO-查找调度程序" class="headerlink" title="gpiod_find_by_fwnode: 与固件无关的 GPIO 查找调度程序"></a>gpiod_find_by_fwnode: 与固件无关的 GPIO 查找调度程序</h2><p>此函数是Linux内核<code>gpiod</code>子系统中一个至关重要的<strong>内部调度函数</strong>。它的核心原理是<strong>充当一个抽象层, 将一个来自上层API的、基于通用固件句柄(<code>fwnode</code>)的GPIO查找请求, 路由到与该固件类型相匹配的、特定于技术的后端解析函数</strong>。</p>
<p>这个函数是实现驱动程序跨平台可移植性的关键。一个编写良好的驱动程序不应该关心它所运行的系统是使用设备树(Device Tree)还是ACPI来描述硬件, 它只知道设备有一个<code>fwnode</code>。此函数正是负责处理这种差异的中间人。</p>
<p>其工作流程非常直接, 作为一个多路分发器:</p>
<ol>
<li><strong>接收通用句柄</strong>: 它接收一个<code>fwnode_handle</code>作为输入。这是一个通用的、不透明的句柄, 可以代表设备树节点、ACPI设备节点, 甚至是纯软件定义的节点。</li>
<li><strong>识别句柄类型</strong>: 它使用一系列的类型检查函数 (<code>is_of_node</code>, <code>is_acpi_node</code>, <code>is_software_node</code>) 来确定<code>fwnode</code>的真实 underlying 类型。</li>
<li><strong>分派到专用后端</strong>:<ul>
<li>如果<code>fwnode</code>是一个<strong>设备树节点</strong>, 它就调用<code>of_find_gpio</code>。<code>of_find_gpio</code>是专门为设备树设计的后端, 它知道如何去解析设备树节点中的<code>&lt;con_id&gt;-gpios</code>属性(例如<code>enable-gpios</code>), 并将设备树的phandle和specifier转换为内核的<code>gpio_desc</code>。</li>
<li>如果<code>fwnode</code>是一个<strong>ACPI节点</strong>, 它就调用<code>acpi_find_gpio</code>。<code>acpi_find_gpio</code>则知道如何去解析ACPI表中的<code>_CRS</code>(Current Resource Settings)资源, 找到匹配的<code>GpioIo</code>或<code>GpioInt</code>条目来获取GPIO信息。</li>
<li>如果<code>fwnode</code>是一个<strong>软件节点</strong>, 它就调用<code>swnode_find_gpio</code>, 该函数用于处理在代码中定义的、用于模拟固件描述的软件节点层次结构。</li>
</ul>
</li>
<li><strong>返回结果</strong>: 它将专用后端函数的返回值(一个<code>gpio_desc</code>指针或一个错误码)直接向上传递给调用者(<code>gpiod_find_and_request</code>)。如果<code>fwnode</code>的类型不被识别, 它会返回初始设置的默认错误码<code>-ENOENT</code>(“No such entity”)。</li>
</ol>
<p>在STM32H750这样的嵌入式系统上, 固件几乎总是<strong>设备树(Device Tree)</strong>。因此, 当一个驱动程序为STM32平台上的设备请求GPIO时, <code>gpiod_find_by_fwnode</code>的执行路径将是通过<code>is_of_node()</code>检查, 最终调用<code>of_find_gpio</code>来完成实际的查找工作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * gpiod_find_by_fwnode - 通过固件节点查找GPIO描述符</span></span><br><span class="line"><span class="comment"> * @fwnode: 要查找的固件节点 (一个通用的句柄)</span></span><br><span class="line"><span class="comment"> * @consumer: 请求GPIO的设备</span></span><br><span class="line"><span class="comment"> * @con_id: GPIO的功能名称 (如 &quot;enable&quot;, &quot;reset&quot;)</span></span><br><span class="line"><span class="comment"> * @idx: 在多GPIO功能中的索引</span></span><br><span class="line"><span class="comment"> * @flags: 用于ACPI查找的GPIO标志</span></span><br><span class="line"><span class="comment"> * @lookupflags: 用于设备树查找的GPIO标志</span></span><br><span class="line"><span class="comment"> * @return: 成功时返回有效的gpio_desc, 失败时返回错误指针.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> gpio_desc *<span class="title function_">gpiod_find_by_fwnode</span><span class="params">(<span class="keyword">struct</span> fwnode_handle *fwnode,</span></span><br><span class="line"><span class="params">					      <span class="keyword">struct</span> device *consumer,</span></span><br><span class="line"><span class="params">					      <span class="type">const</span> <span class="type">char</span> *con_id,</span></span><br><span class="line"><span class="params">					      <span class="type">unsigned</span> <span class="type">int</span> idx,</span></span><br><span class="line"><span class="params">					      <span class="keyword">enum</span> gpiod_flags *flags,</span></span><br><span class="line"><span class="params">					      <span class="type">unsigned</span> <span class="type">long</span> *lookupflags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name = function_name_or_default(con_id);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 初始化 desc 为 -ENOENT (&quot;No such entity&quot;) 错误.</span></span><br><span class="line"><span class="comment">	 * 这是一个安全的默认值, 如果 fwnode 类型不匹配或查找失败, 将返回此错误.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">desc</span> =</span> ERR_PTR(-ENOENT);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* --- 调度逻辑开始 --- */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 检查 fwnode 是否是一个设备树(Open Firmware)节点? */</span></span><br><span class="line">	<span class="keyword">if</span> (is_of_node(fwnode)) &#123;</span><br><span class="line">		dev_dbg(consumer, <span class="string">&quot;using DT &#x27;%pfw&#x27; for &#x27;%s&#x27; GPIO lookup\n&quot;</span>, fwnode, name);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 如果是, 调用专门处理设备树的后端函数 of_find_gpio.</span></span><br><span class="line"><span class="comment">		 * to_of_node() 宏用于将通用的 fwnode_handle 安全地转换为 device_node 指针.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		desc = of_find_gpio(to_of_node(fwnode), con_id, idx, lookupflags);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_acpi_node(fwnode)) &#123;</span><br><span class="line">		<span class="comment">/* 否则, 检查 fwnode 是否是一个ACPI节点? */</span></span><br><span class="line">		dev_dbg(consumer, <span class="string">&quot;using ACPI &#x27;%pfw&#x27; for &#x27;%s&#x27; GPIO lookup\n&quot;</span>, fwnode, name);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 如果是, 调用专门处理ACPI的后端函数 acpi_find_gpio.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		desc = acpi_find_gpio(fwnode, con_id, idx, flags, lookupflags);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_software_node(fwnode)) &#123;</span><br><span class="line">		<span class="comment">/* 否则, 检查 fwnode 是否是一个软件节点? */</span></span><br><span class="line">		dev_dbg(consumer, <span class="string">&quot;using swnode &#x27;%pfw&#x27; for &#x27;%s&#x27; GPIO lookup\n&quot;</span>, fwnode, name);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 如果是, 调用专门处理软件节点的后端函数 swnode_find_gpio.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		desc = swnode_find_gpio(fwnode, con_id, idx, lookupflags);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 返回其中一个后端函数的结果, 或者返回初始的 -ENOENT 错误.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="gpiod-add-lookup-tables-注册GPIO查找表"><a href="#gpiod-add-lookup-tables-注册GPIO查找表" class="headerlink" title="gpiod_add_lookup_tables: 注册GPIO查找表"></a>gpiod_add_lookup_tables: 注册GPIO查找表</h2><p>此函数的核心作用是<strong>将一个或多个GPIO查找表(<code>gpiod_lookup_table</code>)注册到内核的全局GPIO查找列表<code>gpio_lookup_list</code>中</strong>。这个机制是Linux内核GPIO子系统的一种**非设备树(non-Device-Tree)**的配置方法, 它允许板级支持文件(Board Support Package, BSP)以编程方式、在C代码中定义哪个设备的哪个功能性引脚(例如, “sd-power-gpio”)对应于哪个物理GPIO引脚(例如, GPIOC的第5脚)。</p>
<p>该函数的原理非常直接, 并且以线程安全为核心:</p>
<ol>
<li><strong>获取全局锁</strong>: 它首先获取一个全局互斥锁<code>gpio_lookup_lock</code>。这个锁保护着全局的<code>gpio_lookup_list</code>链表。</li>
<li><strong>添加到全局链表</strong>: 在锁的保护下, 它遍历调用者传入的查找表数组, 并使用<code>list_add_tail</code>将每一个查找表中的<code>list</code>成员(一个<code>struct list_head</code>)添加到<code>gpio_lookup_list</code>链表的末尾。</li>
<li><strong>释放锁</strong>: 遍历完成后, 锁被自动释放。</li>
</ol>
<p>当系统中的某个驱动程序(消费者)稍后调用<code>gpiod_get()</code>来请求一个GPIO时, 内核的GPIO核心代码就会遍历这个<code>gpio_lookup_list</code>全局链表, 查找是否有哪个已注册的表项能够匹配该消费者设备的名称和它请求的GPIO功能名称。如果找到匹配项, 内核就能够知道要分配哪个具体的物理GPIO。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * gpiod_add_lookup_tables() - 注册GPIO设备消费者</span></span><br><span class="line"><span class="comment"> * @tables: 要注册的消费者表(gpiod_lookup_table)的指针数组</span></span><br><span class="line"><span class="comment"> * @n: 数组中的表的数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">gpiod_add_lookup_tables</span><span class="params">(<span class="keyword">struct</span> gpiod_lookup_table **tables, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 定义一个无符号整型变量 i, 用作循环计数器.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * guard(mutex)(&amp;gpio_lookup_lock);</span></span><br><span class="line"><span class="comment">	 * 这是一个现代C语言的宏, 用于实现作用域范围的锁 (scoped lock), 类似于C++的 std::lock_guard.</span></span><br><span class="line"><span class="comment">	 * 它会在进入其作用域(由花括号或下一条语句定义)时自动获取 gpio_lookup_lock 互斥锁,</span></span><br><span class="line"><span class="comment">	 * 并在退出作用域时自动释放该锁.</span></span><br><span class="line"><span class="comment">	 * gpio_lookup_lock 是一个全局互斥锁, 用于保护全局的 gpio_lookup_list 链表, 防止并发访问导致的数据损坏.</span></span><br><span class="line"><span class="comment">	 * 即使在单核抢占式系统上, 这个锁也是必需的, 以防止任务在修改链表时被抢占.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	guard(mutex)(&amp;gpio_lookup_lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 开始一个 for 循环, 遍历调用者提供的所有查找表.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 调用内核标准的链表操作函数 list_add_tail.</span></span><br><span class="line"><span class="comment">		 * &amp;tables[i]-&gt;list: 获取第 i 个 gpiod_lookup_table 结构体中的 list 成员的地址.</span></span><br><span class="line"><span class="comment">		 *                  这个 list 成员是一个 struct list_head, 是链表节点.</span></span><br><span class="line"><span class="comment">		 * &amp;gpio_lookup_list: 这是内核中用于存储所有GPIO查找表的全局链表的头节点.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * 整个语句的作用是: 将当前遍历到的查找表安全地添加到全局查找链表的末尾.</span></span><br><span class="line"><span class="comment">		 * 添加到尾部可以保持注册的顺序.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		list_add_tail(&amp;tables[i]-&gt;<span class="built_in">list</span>, &amp;gpio_lookup_list);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 在这个函数中, guard(mutex) 的作用域覆盖了整个 for 循环.</span></span><br><span class="line"><span class="comment"> * 当 for 循环结束, 函数即将返回时, 宏会自动展开代码以释放 gpio_lookup_lock 互斥锁.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="gpiod-find-传统平台-GPIO-查找引擎"><a href="#gpiod-find-传统平台-GPIO-查找引擎" class="headerlink" title="gpiod_find: 传统平台 GPIO 查找引擎"></a>gpiod_find: 传统平台 GPIO 查找引擎</h2><p>此函数是Linux内核<code>gpiod</code>子系统中负责执行<strong>基于平台查找表(platform lookup table)的GPIO查找</strong>的底层核心函数。它的核心原理是<strong>充当一个备用&#x2F;回退机制</strong>, 用于那些没有使用现代固件描述(如设备树或ACPI)的系统。在这种旧式系统中, 硬件布线信息不是在设备树中描述, 而是通过C代码中的静态查找表(通常在”board file”中定义)来提供的。</p>
<p><code>gpiod_find</code>是连接消费者驱动程序和这些静态C语言查找表之间的桥梁。</p>
<p><strong>工作流程详解:</strong></p>
<ol>
<li><p><strong>同步与安全</strong>: 函数的第一步是获取一个全局互斥锁<code>gpio_lookup_lock</code>。这至关重要, 因为这些静态查找表可以在系统运行时被动态地添加或移除。这个锁确保了在函数遍历查找表的过程中, 查找表本身不会被另一个任务或CPU核心并发地修改, 从而防止了竞态条件和数据损坏。</p>
</li>
<li><p><strong>查找正确的表 (<code>gpiod_find_lookup_table</code>)</strong>: 系统中可能存在多个查找表, 每个表可能与特定的设备或总线相关联。此函数首先会根据传入的<code>dev</code>参数, 找到与该消费者设备最匹配的那个查找表。</p>
</li>
<li><p><strong>遍历与匹配</strong>: 找到正确的表之后, 函数会遍历表中的每一个条目 (<code>struct gpiod_lookup</code>)。对于每个条目, 它会执行精确的匹配逻辑:</p>
<ul>
<li><strong>索引 (<code>idx</code>)</strong>: 必须与请求的索引完全匹配。</li>
<li><strong>功能ID (<code>con_id</code>)</strong>: 如果表中的条目定义了<code>con_id</code>, 那么请求的<code>con_id</code>也必须存在且完全相同。如果表中条目没有定义<code>con_id</code>(即为NULL), 它可以匹配任何功能名称, 这通常用于只有一个GPIO的简单设备。</li>
</ul>
</li>
<li><p><strong>两种查找方式</strong>: 匹配成功后, 它会根据表中条目的内容, 采用两种方式之一来定位GPIO:</p>
<ul>
<li><strong>方式A: 按全局名称查找 (罕见)</strong>: 如果表条目中的<code>chip_hwnum</code>被设置为一个特殊值<code>U16_MAX</code>, 这意味着条目中的<code>key</code>字符串不是一个GPIO芯片的标签, 而是一个<strong>全局唯一的GPIO线路名称</strong>。函数会调用<code>gpio_name_to_desc</code>在整个系统中搜索这个名称。</li>
<li><strong>方式B: 按芯片标签和硬件编号查找 (常见)</strong>: 这是最主要的方式。表条目中的<code>key</code>字符串是GPIO控制器芯片的<code>label</code>(例如, <code>&quot;gpio-a&quot;</code>)。函数会:<br>a.  调用<code>gpio_device_find_by_label</code>来查找与该标签匹配的、已经注册的<code>gpio_device</code>。<br>b.  从<code>gpio_device</code>中获取其硬件编号<code>chip_hwnum</code>。<br>c.  进行范围检查, 确保请求的硬件编号没有超出该芯片的引脚总数。<br>d.  最终从该芯片获取代表特定引脚的<code>gpio_desc</code>。</li>
</ul>
</li>
<li><p><strong>健壮的依赖处理 (<code>-EPROBE_DEFER</code>)</strong>: 这是此函数设计中非常关键的一点。在上述查找过程中(无论是按名称还是按标签), 如果依赖的GPIO控制器驱动程序尚未被内核探测和初始化, 那么查找就会失败。此时, <code>gpiod_find</code><strong>不会</strong>返回一个硬性的”未找到”错误, 而是会返回<code>-EPROBE_DEFER</code>。这个特殊的返回值会通知上层调用者和内核驱动模型:”我的一个依赖项还没准备好, 请稍后重试探测我这个消费者驱动”。这是自动解决驱动加载顺序问题的核心机制。</p>
</li>
</ol>
<h4 id="与STM32H750的关系"><a href="#与STM32H750的关系" class="headerlink" title="与STM32H750的关系"></a><strong>与STM32H750的关系</strong></h4><p>对于一个使用现代设备树的STM32H750系统, <strong><code>gpiod_find</code>函数通常不会被执行</strong>。</p>
<ul>
<li>GPIO的查找会由<code>gpiod_find_and_request</code>首先调用<code>gpiod_find_by_fwnode</code>, 然后分派到<code>of_find_gpio</code>来处理。</li>
<li>只有在<code>of_find_gpio</code>完全没有在设备树中找到任何匹配的GPIO属性, <strong>并且</strong>上层调用者(<code>gpiod_find_and_request</code>)的<code>platform_lookup_allowed</code>参数为<code>true</code>时, <code>gpiod_find</code>才会作为最后的手段被调用。</li>
<li>因此, 在一个配置正确的STM32设备树系统中, <code>gpiod_find</code>的执行通常意味着设备树配置存在问题或不完整。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> gpio_desc *<span class="title function_">gpiod_find</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">const</span> <span class="type">char</span> *con_id,</span></span><br><span class="line"><span class="params">				    <span class="type">unsigned</span> <span class="type">int</span> idx, <span class="type">unsigned</span> <span class="type">long</span> *flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">desc</span> =</span> ERR_PTR(-ENOENT); <span class="comment">// 默认返回 &quot;未找到&quot;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpiod_lookup_table</span> *<span class="title">table</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpiod_lookup</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_chip</span> *<span class="title">gc</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 1. 获取互斥锁, 保护全局查找表 */</span></span><br><span class="line">	guard(mutex)(&amp;gpio_lookup_lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 2. 找到与此设备关联的查找表 */</span></span><br><span class="line">	table = gpiod_find_lookup_table(dev);</span><br><span class="line">	<span class="keyword">if</span> (!table)</span><br><span class="line">		<span class="keyword">return</span> desc; <span class="comment">// 没有表, 直接返回 &quot;未找到&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 3. 遍历表中的每一个条目 */</span></span><br><span class="line">	<span class="keyword">for</span> (p = &amp;table-&gt;table[<span class="number">0</span>]; p-&gt;key; p++) &#123;</span><br><span class="line">		<span class="comment">/* --- 匹配逻辑 --- */</span></span><br><span class="line">		<span class="keyword">if</span> (p-&gt;idx != idx) <span class="comment">// 索引必须精确匹配</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;con_id &amp;&amp; (!con_id || <span class="built_in">strcmp</span>(p-&gt;con_id, con_id))) <span class="comment">// 功能ID必须精确匹配 (如果表中定义了的话)</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* --- 4. 两种查找方式 --- */</span></span><br><span class="line">		<span class="keyword">if</span> (p-&gt;chip_hwnum == U16_MAX) &#123;</span><br><span class="line">			<span class="comment">/* 方式A: 按全局线路名称查找 */</span></span><br><span class="line">			desc = gpio_name_to_desc(p-&gt;key);</span><br><span class="line">			<span class="keyword">if</span> (desc) &#123;</span><br><span class="line">				*flags = p-&gt;flags;</span><br><span class="line">				<span class="keyword">return</span> desc; <span class="comment">// 找到了, 返回</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 没找到, 可能是因为对应的GPIO驱动还没注册, 推迟探测 */</span></span><br><span class="line">			dev_warn(dev, <span class="string">&quot;cannot find GPIO line %s, deferring\n&quot;</span>,</span><br><span class="line">				 p-&gt;key);</span><br><span class="line">			<span class="keyword">return</span> ERR_PTR(-EPROBE_DEFER);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 方式B: 按芯片标签和硬件编号查找 */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">gpio_device</span> *<span class="title">gdev</span> __<span class="title">free</span>(<span class="title">gpio_device_put</span>) =</span></span><br><span class="line">					gpio_device_find_by_label(p-&gt;key);</span><br><span class="line">		<span class="keyword">if</span> (!gdev) &#123;</span><br><span class="line">			<span class="comment">/* GPIO芯片驱动还没注册, 推迟探测 */</span></span><br><span class="line">			dev_warn(dev, <span class="string">&quot;cannot find GPIO chip %s, deferring\n&quot;</span>,</span><br><span class="line">				 p-&gt;key);</span><br><span class="line">			<span class="keyword">return</span> ERR_PTR(-EPROBE_DEFER);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		gc = gpio_device_get_chip(gdev);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 范围检查, 防止访问越界 */</span></span><br><span class="line">		<span class="keyword">if</span> (gc-&gt;ngpio &lt;= p-&gt;chip_hwnum) &#123;</span><br><span class="line">			dev_err(dev,</span><br><span class="line">				<span class="string">&quot;requested GPIO %u (%u) is out of range [0..%u] for chip %s\n&quot;</span>,</span><br><span class="line">				idx, p-&gt;chip_hwnum, gc-&gt;ngpio - <span class="number">1</span>,</span><br><span class="line">				gc-&gt;label);</span><br><span class="line">			<span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 从找到的芯片中获取指定硬件编号的描述符 */</span></span><br><span class="line">		desc = gpio_device_get_desc(gdev, p-&gt;chip_hwnum);</span><br><span class="line">		*flags = p-&gt;flags;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> desc; <span class="comment">// 找到了, 返回</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 遍历完整个表都没找到匹配项 */</span></span><br><span class="line">	<span class="keyword">return</span> desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="gpiod-request-和-gpiod-request-commit-安全地请求并独占一个GPIO"><a href="#gpiod-request-和-gpiod-request-commit-安全地请求并独占一个GPIO" class="headerlink" title="gpiod_request 和 gpiod_request_commit: 安全地请求并独占一个GPIO"></a>gpiod_request 和 gpiod_request_commit: 安全地请求并独占一个GPIO</h2><p>这两个函数协同工作, 共同构成了Linux内核<code>gpiolib</code>框架中用于”请求”或”声明”一个GPIO引脚的核心API。当一个设备驱动程序需要使用某个GPIO引脚时, 它必须先调用<code>gpiod_request</code>来获得对该引脚的独占访问权。这个过程确保了不会有多个驱动程序试图同时控制同一个物理引脚, 从而避免了硬件冲突。</p>
<p><code>gpiod_request_commit</code>是执行实际工作的内部核心函数, 而<code>gpiod_request</code>则是一个安全封装, 它在调用核心函数之前处理了至关重要的模块生命周期管理。</p>
<hr>
<h3 id="gpiod-request-commit-执行请求的核心逻辑"><a href="#gpiod-request-commit-执行请求的核心逻辑" class="headerlink" title="gpiod_request_commit: 执行请求的核心逻辑"></a><code>gpiod_request_commit</code>: 执行请求的核心逻辑</h3><p>此函数负责执行所有将GPIO引脚标记为”已使用”的底层操作。它的原理是<strong>通过一个原子操作来确保排他性, 并调用底层硬件驱动提供的可选回调函数, 同时在任何失败的情况下都能安全地回滚所有状态变更</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这些&quot;可选的&quot;分配调用有助于防止驱动程序之间互相干扰,</span></span><br><span class="line"><span class="comment"> * 并在debugfs中提供更好的诊断信息.</span></span><br><span class="line"><span class="comment"> * 它们被调用的频率甚至比&quot;设置方向&quot;的调用还要低.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 静态函数声明: gpiod_request_commit</span></span><br><span class="line"><span class="comment"> * 这是执行GPIO请求的内部核心函数.</span></span><br><span class="line"><span class="comment"> * @desc: 指向 struct gpio_desc 的指针, 这是代表一个GPIO引脚的核心描述符.</span></span><br><span class="line"><span class="comment"> * @label: 一个字符串, 用于为此GPIO的使用场景提供一个描述性标签 (例如 &quot;sd-card-detect&quot;).</span></span><br><span class="line"><span class="comment"> * @return: 成功时返回 0, 失败时返回负的错误码.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpiod_request_commit</span><span class="params">(<span class="keyword">struct</span> gpio_desc *desc, <span class="type">const</span> <span class="type">char</span> *label)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 定义一个无符号整型 offset, 用于存储引脚在GPIO控制器内的硬件编号.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> offset;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 定义整型变量 ret, 用于存储返回值.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * CLASS(gpio_chip_guard, guard)(desc);</span></span><br><span class="line"><span class="comment">	 * 这是一个自定义宏, 用于安全地获取与此GPIO描述符关联的 gpio_chip (guard.gc).</span></span><br><span class="line"><span class="comment">	 * gpio_chip 代表了物理上的GPIO控制器硬件 (例如 STM32H7上的 GPIOC).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	CLASS(gpio_chip_guard, guard)(desc);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 如果无法找到关联的GPIO控制器, 返回设备未找到错误.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!guard.gc)</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 这是确保独占性的核心操作.</span></span><br><span class="line"><span class="comment">	 * test_and_set_bit 是一个原子操作, 它会:</span></span><br><span class="line"><span class="comment">	 * 1. 测试 desc-&gt;flags 中的 FLAG_REQUESTED 位是否已经被设置.</span></span><br><span class="line"><span class="comment">	 * 2. 无论测试结果如何, 都将该位设置为1.</span></span><br><span class="line"><span class="comment">	 * 3. 返回该位在操作之前的原始值.</span></span><br><span class="line"><span class="comment">	 * 因此, 如果该引脚已经被其他驱动请求 (FLAG_REQUESTED=1), 此函数返回true,</span></span><br><span class="line"><span class="comment">	 * 我们立即返回 -EBUSY (设备或资源忙), 表示请求失败.</span></span><br><span class="line"><span class="comment">	 * 由于操作是原子的, 即使在单核抢占式系统上, 也能防止两个任务之间的竞态条件.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (test_and_set_bit(FLAG_REQUESTED, &amp;desc-&gt;flags))</span><br><span class="line">		<span class="keyword">return</span> -EBUSY;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 获取此引脚在其GPIO控制器内的硬件偏移量/编号.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	offset = gpio_chip_hwgpio(desc);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 检查此编号对于该控制器是否有效.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!gpiochip_line_is_valid(guard.gc, offset))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 注意: gpio_request() 可以在系统早期启动阶段被调用,</span></span><br><span class="line"><span class="comment">	 * 此时中断可能还未启用, 这对于非休眠的(片上SOC)GPIO是允许的.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 检查底层的GPIO控制器驱动是否提供了 .request 回调函数.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (guard.gc-&gt;request) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 如果提供了, 就调用它. 这允许硬件驱动执行任何特定于硬件的请求时设置.</span></span><br><span class="line"><span class="comment">		 * 例如, 某些硬件可能需要在这里启用引脚的数字功能.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		ret = guard.gc-&gt;request(guard.gc, offset);</span><br><span class="line">		<span class="comment">/* 内核API约定错误码为负值. 如果驱动返回了正值, 将其标准化为-EBADE. */</span></span><br><span class="line">		<span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">			ret = -EBADE;</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="comment">/* 如果硬件驱动的 .request 失败, 跳转到错误处理代码. */</span></span><br><span class="line">			<span class="keyword">goto</span> out_clear_bit;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 如果硬件驱动提供了 .get_direction 回调, 就调用它来读取引脚的当前方向(输入/输出).</span></span><br><span class="line"><span class="comment">	 * 这可以使软件状态与硬件的实际状态同步.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (guard.gc-&gt;get_direction)</span><br><span class="line">		gpiod_get_direction(desc);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 调用 desc_set_label 为此GPIO设置描述性标签. 这在调试时非常有用 (例如在 /sys/kernel/debug/gpio 中).</span></span><br><span class="line"><span class="comment">	 * 如果调用者没有提供标签, 则使用 &quot;?&quot; 作为默认值.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ret = desc_set_label(desc, label ? : <span class="string">&quot;?&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="comment">/* 如果设置标签失败 (例如内存不足), 跳转到错误处理. */</span></span><br><span class="line">		<span class="keyword">goto</span> out_clear_bit;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 所有步骤都成功, 返回 0.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 错误处理标签.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">out_clear_bit:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 清除 FLAG_REQUESTED 标志位.</span></span><br><span class="line"><span class="comment">	 * 这是至关重要的回滚操作: 因为我们在函数开头成功设置了该位,</span></span><br><span class="line"><span class="comment">	 * 所以在任何后续步骤失败时, 都必须将其清除, 以便该引脚可以被再次请求.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	clear_bit(FLAG_REQUESTED, &amp;desc-&gt;flags);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 返回导致失败的错误码.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="gpiod-request-安全的公共API封装"><a href="#gpiod-request-安全的公共API封装" class="headerlink" title="gpiod_request: 安全的公共API封装"></a><code>gpiod_request</code>: 安全的公共API封装</h3><p>此函数是在驱动程序中应该被调用的标准API。它在<code>gpiod_request_commit</code>的基础上, 增加了对<strong>内核模块生命周期的管理</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * gpiod_request: 请求一个GPIO描述符以供独占使用.</span></span><br><span class="line"><span class="comment"> * @desc: 要请求的GPIO描述符.</span></span><br><span class="line"><span class="comment"> * @label: 描述此GPIO用途的标签.</span></span><br><span class="line"><span class="comment"> * @return: 成功时返回 0, 失败时返回错误码.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">gpiod_request</span><span class="params">(<span class="keyword">struct</span> gpio_desc *desc, <span class="type">const</span> <span class="type">char</span> *label)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 将默认返回值设置为 -EPROBE_DEFER.</span></span><br><span class="line"><span class="comment">	 * 这是一个重要的默认值. 如果try_module_get失败, 意味着GPIO控制器模块</span></span><br><span class="line"><span class="comment">	 * 可能正在卸载, 或者尚未完全准备好. 返回-EPROBE_DEFER会告诉调用者</span></span><br><span class="line"><span class="comment">	 * (通常是一个正在probe的驱动), 它的一个依赖项未就绪, 应该稍后重试.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> ret = -EPROBE_DEFER;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 验证传入的 desc 指针是否有效, 防止空指针解引用.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	VALIDATE_DESC(desc);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 这是此封装函数的核心价值所在.</span></span><br><span class="line"><span class="comment">	 * GPIO控制器驱动本身可能是一个可加载的内核模块.</span></span><br><span class="line"><span class="comment">	 * try_module_get() 会尝试增加该模块的引用计数.</span></span><br><span class="line"><span class="comment">	 * 这可以防止内核在另一个驱动正在使用其提供的GPIO时, 将该模块卸载掉 (例如用户执行 `rmmod`).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (try_module_get(desc-&gt;gdev-&gt;owner)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 如果成功获取了模块的引用, 就调用核心函数来执行实际的请求操作.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		ret = gpiod_request_commit(desc, label);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 检查请求是否失败.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * 如果请求失败了 (例如引脚已被占用), 我们必须撤销之前对模块的引用计数增加.</span></span><br><span class="line"><span class="comment">			 * module_put() 会减少模块的引用计数.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			module_put(desc-&gt;gdev-&gt;owner);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * 如果请求成功, 我们再增加 gpio_device 的引用计数.</span></span><br><span class="line"><span class="comment">			 * 这是一个更细粒度的引用, 确保gpio_device本身在被使用时不会被释放.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			gpio_device_get(desc-&gt;gdev);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 如果最终结果是错误, 打印一条调试信息.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		gpiod_dbg(desc, <span class="string">&quot;%s: status %d\n&quot;</span>, __func__, ret);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 返回最终的状态码.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="gpiochip-静态函数-gpiolib-核心到硬件驱动的安全调度层"><a href="#gpiochip-静态函数-gpiolib-核心到硬件驱动的安全调度层" class="headerlink" title="gpiochip_* 静态函数: gpiolib 核心到硬件驱动的安全调度层"></a><code>gpiochip_*</code> 静态函数: <code>gpiolib</code> 核心到硬件驱动的安全调度层</h2><p>这四个静态函数是Linux <code>gpiolib</code> 框架内部的核心组件。它们共同构成了一个<strong>安全调度层(Safe Dispatch Layer)<strong>或</strong>网关(Gateway)</strong>, 其核心作用是<strong>将上层 <code>gpiolib</code> 的通用、硬件无关的请求, 安全地分发到下层具体的、硬件相关的<code>gpio_chip</code>驱动程序所实现的回调函数中</strong>。</p>
<p>这些函数的设计原理体现了Linux内核驱动框架的几个核心思想:</p>
<ol>
<li><strong>抽象与封装</strong>: 上层驱动(如<code>gpiod_direction_output</code>)不需要知道底层硬件是STM32、NXP还是TI的芯片。它们只与通用的<code>gpio_desc</code>交互。而这一组<code>gpiochip_*</code>函数就是实现这种抽象的关键环节, 它们负责调用与<code>gpio_desc</code>关联的那个具体硬件驱动(<code>gpio_chip</code>)的实现。</li>
<li><strong>健壮性与错误检查</strong>: 每一个函数都内置了关键的检查:<ul>
<li><code>lockdep_assert_held</code>: 这是一个锁调试断言, 确保调用者已经持有了适当的锁(在这里是SRCU读锁)。SRCU(Sleepable Read-Copy Update)是一种高级锁机制, 即使在单核系统上, 它也能确保在一个驱动正在使用某个<code>gpio_chip</code>时, 提供该<code>gpio_chip</code>的内核模块不会被中途卸载, 从而防止了悬空指针等严重问题。</li>
<li><code>WARN_ON</code>: 这是一个运行时检查, 用于确保底层的<code>gpio_chip</code>驱动程序确实实现了它应该实现的回调函数。如果一个上层函数试图调用一个<code>gpio_chip</code>驱动没有提供的功能(例如, 在一个只支持输入的芯片上调用<code>.set</code>), 内核会打印一个警告, 这极大地帮助了驱动开发者的调试。</li>
</ul>
</li>
<li><strong>API约定强制</strong>: 内核API约定错误码必须是负的<code>errno</code>值。这些函数会检查底层驱动的返回值, 如果驱动错误地返回了一个正值, 它们会将其规范化为<code>-EBADE</code>(错误的交换描述符), 从而保证了整个内核API的一致性。</li>
</ol>
<p>在STM32H750的上下文中, 当<code>gpiolib</code>核心需要操作一个GPIO时(例如GPIOC的第5脚), <code>gc</code>参数就会是一个指向代表STM32 GPIOC端口的<code>gpio_chip</code>结构体的指针。而<code>gc-&gt;set</code>、<code>gc-&gt;direction_input</code>等函数指针, 则会指向在ST的<code>pinctrl-stm32.c</code>驱动中实现的、真正通过读写<code>GPIOC-&gt;MODER</code>, <code>GPIOC-&gt;ODR</code>, <code>GPIOC-&gt;BSRR</code>等寄存器来操作硬件的函数。</p>
<hr>
<h3 id="gpiochip-set-设置GPIO输出电平的硬件调度函数"><a href="#gpiochip-set-设置GPIO输出电平的硬件调度函数" class="headerlink" title="gpiochip_set: 设置GPIO输出电平的硬件调度函数"></a>gpiochip_set: 设置GPIO输出电平的硬件调度函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 静态函数: gpiochip_set</span></span><br><span class="line"><span class="comment"> * 作用: 调用底层硬件驱动的 .set 回调函数, 来设置一个输出引脚的物理电平.</span></span><br><span class="line"><span class="comment"> * @gc: 指向 struct gpio_chip 的指针, 代表硬件GPIO控制器.</span></span><br><span class="line"><span class="comment"> * @offset: 要操作的引脚在控制器内的硬件编号 (0-15).</span></span><br><span class="line"><span class="comment"> * @value: 要设置的物理电平 (0 或 1).</span></span><br><span class="line"><span class="comment"> * @return: 成功时返回0, 失败时返回负的错误码.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpiochip_set</span><span class="params">(<span class="keyword">struct</span> gpio_chip *gc, <span class="type">unsigned</span> <span class="type">int</span> offset, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 锁调试断言: 确保调用者已经持有了SRCU读锁.</span></span><br><span class="line"><span class="comment">	 * 这可以防止在执行此函数期间, gc 所属的 gpio_device 被释放或其驱动模块被卸载.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	lockdep_assert_held(&amp;gc-&gt;gpiodev-&gt;srcu);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 检查并警告: 如果底层驱动没有实现 .set 回调函数, 这是一个驱动程序错误.</span></span><br><span class="line"><span class="comment">	 * WARN_ON 会打印一个内核警告信息, 并返回true.</span></span><br><span class="line"><span class="comment">	 * unlikely() 是一个编译器提示, 告诉编译器这个分支很少会进入, 以便进行优化.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON(unlikely(!gc-&gt;<span class="built_in">set</span>)))</span><br><span class="line">		<span class="keyword">return</span> -EOPNOTSUPP; <span class="comment">// 返回 &quot;操作不支持&quot; 错误.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 核心调度操作: 调用 gc-&gt;set 指针所指向的函数.</span></span><br><span class="line"><span class="comment">	 * 这会执行具体硬件驱动中的代码, 真正地去写硬件寄存器 (例如STM32的ODR或BSRR).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ret = gc-&gt;<span class="built_in">set</span>(gc, offset, value);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 错误码规范化: 如果驱动错误地返回了一个正数, 将其转换为一个标准的负错误码.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">		ret = -EBADE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 返回最终结果.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="gpiochip-get-direction-获取GPIO方向的硬件调度函数"><a href="#gpiochip-get-direction-获取GPIO方向的硬件调度函数" class="headerlink" title="gpiochip_get_direction: 获取GPIO方向的硬件调度函数"></a>gpiochip_get_direction: 获取GPIO方向的硬件调度函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 静态函数: gpiochip_get_direction</span></span><br><span class="line"><span class="comment"> * 作用: 调用底层硬件驱动的 .get_direction 回调函数, 来查询引脚的当前方向 (输入/输出).</span></span><br><span class="line"><span class="comment"> * @gc: 指向 struct gpio_chip 的指针.</span></span><br><span class="line"><span class="comment"> * @offset: 引脚的硬件编号.</span></span><br><span class="line"><span class="comment"> * @return: 成功时返回 GPIO_LINE_DIRECTION_IN 或 GPIO_LINE_DIRECTION_OUT, 失败时返回负的错误码.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpiochip_get_direction</span><span class="params">(<span class="keyword">struct</span> gpio_chip *gc, <span class="type">unsigned</span> <span class="type">int</span> offset)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 锁调试断言: 确保SRCU读锁已被持有.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	lockdep_assert_held(&amp;gc-&gt;gpiodev-&gt;srcu);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 检查并警告: 确保底层驱动实现了 .get_direction 回调.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON(!gc-&gt;get_direction))</span><br><span class="line">		<span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 核心调度操作: 调用硬件驱动的函数来读取方向寄存器 (例如STM32的MODER).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ret = gc-&gt;get_direction(gc, offset);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 如果驱动返回了负的错误码, 直接将其返回.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 返回值验证: 确保驱动返回的是两个标准方向常量之一.</span></span><br><span class="line"><span class="comment">	 * 如果不是, 说明驱动实现有误.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (ret != GPIO_LINE_DIRECTION_OUT &amp;&amp; ret != GPIO_LINE_DIRECTION_IN)</span><br><span class="line">		ret = -EBADE; <span class="comment">// 将返回值修正为错误码.</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="gpiochip-direction-input-设置GPIO为输入的硬件调度函数"><a href="#gpiochip-direction-input-设置GPIO为输入的硬件调度函数" class="headerlink" title="gpiochip_direction_input: 设置GPIO为输入的硬件调度函数"></a>gpiochip_direction_input: 设置GPIO为输入的硬件调度函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 静态函数: gpiochip_direction_input</span></span><br><span class="line"><span class="comment"> * 作用: 调用底层硬件驱动的 .direction_input 回调函数, 将引脚配置为输入模式.</span></span><br><span class="line"><span class="comment"> * @gc: 指向 struct gpio_chip 的指针.</span></span><br><span class="line"><span class="comment"> * @offset: 引脚的硬件编号.</span></span><br><span class="line"><span class="comment"> * @return: 成功时返回0, 失败时返回负的错误码.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpiochip_direction_input</span><span class="params">(<span class="keyword">struct</span> gpio_chip *gc, <span class="type">unsigned</span> <span class="type">int</span> offset)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 锁调试断言: 确保SRCU读锁已被持有.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	lockdep_assert_held(&amp;gc-&gt;gpiodev-&gt;srcu);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 检查并警告: 确保底层驱动实现了 .direction_input 回调.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON(!gc-&gt;direction_input))</span><br><span class="line">		<span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 核心调度操作: 调用硬件驱动的函数来设置方向寄存器 (例如STM32的MODER).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ret = gc-&gt;direction_input(gc, offset);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 错误码规范化.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">		ret = -EBADE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="gpiochip-direction-output-设置GPIO为输出的硬件调度函数"><a href="#gpiochip-direction-output-设置GPIO为输出的硬件调度函数" class="headerlink" title="gpiochip_direction_output: 设置GPIO为输出的硬件调度函数"></a>gpiochip_direction_output: 设置GPIO为输出的硬件调度函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 静态函数: gpiochip_direction_output</span></span><br><span class="line"><span class="comment"> * 作用: 调用底层硬件驱动的 .direction_output 回调函数, 将引脚配置为输出模式并设置初始电平.</span></span><br><span class="line"><span class="comment"> * @gc: 指向 struct gpio_chip 的指针.</span></span><br><span class="line"><span class="comment"> * @offset: 引脚的硬件编号.</span></span><br><span class="line"><span class="comment"> * @value: 初始的物理输出电平 (0 或 1).</span></span><br><span class="line"><span class="comment"> * @return: 成功时返回0, 失败时返回负的错误码.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpiochip_direction_output</span><span class="params">(<span class="keyword">struct</span> gpio_chip *gc, <span class="type">unsigned</span> <span class="type">int</span> offset,</span></span><br><span class="line"><span class="params">				     <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 锁调试断言: 确保SRCU读锁已被持有.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	lockdep_assert_held(&amp;gc-&gt;gpiodev-&gt;srcu);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 检查并警告: 确保底层驱动实现了 .direction_output 回调.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON(!gc-&gt;direction_output))</span><br><span class="line">		<span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 核心调度操作: 调用硬件驱动的函数来设置方向和初始值.</span></span><br><span class="line"><span class="comment">	 * 这通常是一个原子操作, 同时写入方向寄存器(MODER)和输出数据寄存器(ODR/BSRR).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ret = gc-&gt;direction_output(gc, offset, value);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 错误码规范化.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">		ret = -EBADE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="gpiod-direction-input及相关函数-设置GPIO为输入模式"><a href="#gpiod-direction-input及相关函数-设置GPIO为输入模式" class="headerlink" title="gpiod_direction_input及相关函数: 设置GPIO为输入模式"></a><code>gpiod_direction_input</code>及相关函数: 设置GPIO为输入模式</h2><p>这一组函数是<code>gpiod_direction_output</code>函数的逻辑对应面, 它们共同构成了将一个GPIO引脚配置为<strong>输入模式</strong>的标准实现。同样, 它们也采用了层次化设计, 从一个简单的公共API深入到一个能够智能适应不同硬件能力的内部核心函数。</p>
<p>其核心原理是<strong>优先使用硬件驱动提供的专用回调函数来将引脚设置为输入, 如果专用函数不存在, 则通过查询引脚当前状态来推断其是否可用作输入, 最终在成功后更新<code>gpiolib</code>的内部软件状态标志并应用任何必要的偏置(如上拉&#x2F;下拉电阻)</strong>。</p>
<hr>
<h3 id="gpiod-direction-input-nonotify-核心逻辑与硬件适配"><a href="#gpiod-direction-input-nonotify-核心逻辑与硬件适配" class="headerlink" title="gpiod_direction_input_nonotify: 核心逻辑与硬件适配"></a><code>gpiod_direction_input_nonotify</code>: 核心逻辑与硬件适配</h3><p>这是执行所有实际工作的核心函数。它负责与底层<code>gpio_chip</code>驱动交互, 并处理了各种可能的硬件驱动实现方式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * gpiod_direction_input_nonotify: 设置方向为输入, 但不发送uapi通知.</span></span><br><span class="line"><span class="comment"> * 这是执行实际工作的内部核心函数.</span></span><br><span class="line"><span class="comment"> * @desc: GPIO描述符</span></span><br><span class="line"><span class="comment"> * @return: 0表示成功, 负值表示错误.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">gpiod_direction_input_nonotify</span><span class="params">(<span class="keyword">struct</span> gpio_desc *desc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>, dir;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* CLASS宏: 安全地获取与此GPIO描述符关联的gpio_chip (硬件控制器). */</span></span><br><span class="line">	CLASS(gpio_chip_guard, guard)(desc);</span><br><span class="line">	<span class="keyword">if</span> (!guard.gc)</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 驱动实现完整性检查 (Driver Contract Sanity Check):</span></span><br><span class="line"><span class="comment">	 * 如果一个芯片是仅输出的, 那么没有 .get() 和 .direction_input() 是合法的.</span></span><br><span class="line"><span class="comment">	 * 但是, 如果你指定了 .direction_input() 却不支持 .get() 操作, 那就说不通了.</span></span><br><span class="line"><span class="comment">	 * 因为设置一个引脚为输入的全部意义就在于能够读取它的值.</span></span><br><span class="line"><span class="comment">	 * 这是一个针对驱动程序实现逻辑一致性的检查.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!guard.gc-&gt;get &amp;&amp; guard.gc-&gt;direction_input) &#123;</span><br><span class="line">		gpiod_warn(desc,</span><br><span class="line">			   <span class="string">&quot;%s: missing get() but have direction_input()\n&quot;</span>,</span><br><span class="line">			   __func__);</span><br><span class="line">		<span class="keyword">return</span> -EIO;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * --- 核心的硬件能力适配逻辑 ---</span></span><br><span class="line"><span class="comment">	 * 这是一个三层回退(fallback)策略, 以适应不同能力的硬件驱动.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 路径1 (首选): 硬件驱动提供了专用的 .direction_input() 回调.</span></span><br><span class="line"><span class="comment">	 * 这是最理想、最明确的情况.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (guard.gc-&gt;direction_input) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 调用gpiochip_direction_input, 它会安全地调度到底层驱动的实现.</span></span><br><span class="line"><span class="comment">		 * 对于STM32, 这会写入相应引脚的MODER寄存器, 将其配置为输入模式.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		ret = gpiochip_direction_input(guard.gc,</span><br><span class="line">					       gpio_chip_hwgpio(desc));</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (guard.gc-&gt;get_direction) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 路径2 (回退): 驱动没有专用的设置函数, 但可以查询当前方向.</span></span><br><span class="line"><span class="comment">		 * 这通常用于那些方向固定为输入, 或者方向不可更改的硬件.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		dir = gpiochip_get_direction(guard.gc, gpio_chip_hwgpio(desc));</span><br><span class="line">		<span class="keyword">if</span> (dir &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> dir; <span class="comment">// 查询出错</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 关键检查: 如果引脚当前不是输入模式, 而我们又没有办法改变它,</span></span><br><span class="line"><span class="comment">		 * 那么就必须报错.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (dir != GPIO_LINE_DIRECTION_IN) &#123;</span><br><span class="line">			gpiod_warn(desc,</span><br><span class="line">				   <span class="string">&quot;%s: missing direction_input() operation and line is output\n&quot;</span>,</span><br><span class="line">				    __func__);</span><br><span class="line">			<span class="keyword">return</span> -EIO;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 路径3 (隐式回退): 驱动既没有 .direction_input 也没有 .get_direction.</span></span><br><span class="line"><span class="comment">	 * 在这种情况下, 代码会直接 &quot;fall through&quot;,</span></span><br><span class="line"><span class="comment">	 * 并 &quot;默默地假设&quot; 该引脚已经是输入模式了. 这适用于最简单的、</span></span><br><span class="line"><span class="comment">	 * 默认就是输入且不可配置的硬件.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * --- 成功后的状态更新 ---</span></span><br><span class="line"><span class="comment">		 * 只有在硬件操作成功(或被假定成功)后, 才执行以下步骤.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 1. 更新软件状态: 清除 FLAG_IS_OUT 标志.</span></span><br><span class="line"><span class="comment">		 * 这是至关重要的, gpiolib 现在从软件层面知道此引脚是输入模式,</span></span><br><span class="line"><span class="comment">		 * 这会禁止后续对它调用 gpiod_set_value() 等输出操作.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		clear_bit(FLAG_IS_OUT, &amp;desc-&gt;flags);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 2. 应用偏置: 调用 gpio_set_bias.</span></span><br><span class="line"><span class="comment">		 * 对于输入引脚, 设置正确的上拉或下拉电阻通常是必需的,</span></span><br><span class="line"><span class="comment">		 * 以确保在外部没有驱动时, 引脚有一个确定的默认电平.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		ret = gpio_set_bias(desc);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 记录追踪事件, 用于内核调试. */</span></span><br><span class="line">	trace_gpio_direction(desc_to_gpio(desc), <span class="number">1</span>, ret);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="gpiod-direction-input-公共API封装"><a href="#gpiod-direction-input-公共API封装" class="headerlink" title="gpiod_direction_input: 公共API封装"></a><code>gpiod_direction_input</code>: 公共API封装</h3><p>这个函数是暴露给驱动程序使用的标准顶层API。它的作用很简单: 调用核心逻辑函数, 并在成功后向用户空间发送状态变更通知。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * gpiod_direction_input - 设置GPIO方向为输入</span></span><br><span class="line"><span class="comment"> * @desc:	要设置为输入的GPIO</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 将传入的GPIO的方向设置为输入, 以便可以安全地对其调用 gpiod_get_value().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回:</span></span><br><span class="line"><span class="comment"> * 成功时返回0, 失败时返回负的errno.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">gpiod_direction_input</span><span class="params">(<span class="keyword">struct</span> gpio_desc *desc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 标准的安全检查宏, 确保desc指针有效. */</span></span><br><span class="line">	VALIDATE_DESC(desc);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 调用执行所有实际工作的核心函数. */</span></span><br><span class="line">	ret = gpiod_direction_input_nonotify(desc);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 如果核心函数成功返回0, 就调用gpiod_line_state_notify.</span></span><br><span class="line"><span class="comment">	 * 这个函数会通过netlink套接字发送一个事件,</span></span><br><span class="line"><span class="comment">	 * 通知用户空间(例如gpiomon等工具)这个引脚的配置已经改变.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">		gpiod_line_state_notify(desc, GPIO_V2_LINE_CHANGED_CONFIG);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 将此函数导出, 使其对其他内核模块可用. */</span></span><br><span class="line">EXPORT_SYMBOL_GPL(gpiod_direction_input);</span><br></pre></td></tr></table></figure>

<h2 id="gpiod-direction-output及相关函数-设置GPIO为输出模式的层次化实现"><a href="#gpiod-direction-output及相关函数-设置GPIO为输出模式的层次化实现" class="headerlink" title="gpiod_direction_output及相关函数: 设置GPIO为输出模式的层次化实现"></a><code>gpiod_direction_output</code>及相关函数: 设置GPIO为输出模式的层次化实现</h2><p>这一组函数共同构成了Linux <code>gpiolib</code>框架中将一个GPIO引脚配置为输出模式的完整实现。它们采用了一种层次化的设计, 从一个易于使用的高层逻辑API, 逐层深入到底层的硬件交互, 每一层都增加了特定的功能, 如安全检查、逻辑值转换、硬件能力适配和软件仿真。</p>
<hr>
<h3 id="gpiod-direction-output-raw-commit-执行硬件配置的底层核心"><a href="#gpiod-direction-output-raw-commit-执行硬件配置的底层核心" class="headerlink" title="gpiod_direction_output_raw_commit: 执行硬件配置的底层核心"></a><code>gpiod_direction_output_raw_commit</code>: 执行硬件配置的底层核心</h3><p>这是整个功能链的最底层和最核心的函数。它的作用是<strong>直接与底层的<code>gpio_chip</code>驱动程序交互, 发出将引脚设置为输出模式并赋予初始值的硬件命令</strong>。它的原理是<strong>适配不同的硬件驱动能力, 并原子性地更新软件状态</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 静态函数声明: gpiod_direction_output_raw_commit</span></span><br><span class="line"><span class="comment"> * 这是设置GPIO为输出的内部核心实现.</span></span><br><span class="line"><span class="comment"> * @desc: GPIO描述符</span></span><br><span class="line"><span class="comment"> * @value: 要设置的初始*物理*电平 (0或1)</span></span><br><span class="line"><span class="comment"> * @return: 0表示成功, 负值表示错误.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpiod_direction_output_raw_commit</span><span class="params">(<span class="keyword">struct</span> gpio_desc *desc, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* val: 将value规范化为0或1. ret: 返回值. dir: 方向. */</span></span><br><span class="line">	<span class="type">int</span> val = !!value, ret = <span class="number">0</span>, dir;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* CLASS宏: 安全地获取与此GPIO描述符关联的gpio_chip (硬件控制器). */</span></span><br><span class="line">	CLASS(gpio_chip_guard, guard)(desc);</span><br><span class="line">	<span class="keyword">if</span> (!guard.gc)</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 关键的驱动能力检查:</span></span><br><span class="line"><span class="comment">	 * 如果一个gpiochip是仅输出的, 那么它不提供.direction_output()是可以接受的,</span></span><br><span class="line"><span class="comment">	 * 但如果它甚至连.set()操作都没有, 那么驱动输出线就非常棘手了.</span></span><br><span class="line"><span class="comment">	 * 确保驱动至少实现了这两个回调之一.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!guard.gc-&gt;<span class="built_in">set</span> &amp;&amp; !guard.gc-&gt;direction_output) &#123;</span><br><span class="line">		gpiod_warn(desc,</span><br><span class="line">			   <span class="string">&quot;%s: missing set() and direction_output() operations\n&quot;</span>,</span><br><span class="line">			   __func__);</span><br><span class="line">		<span class="keyword">return</span> -EIO;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 优先路径: 如果硬件驱动提供了.direction_output()回调...</span></span><br><span class="line"><span class="comment">	 * 这是首选方式, 因为它允许在一个原子操作中设置方向和初始值.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (guard.gc-&gt;direction_output) &#123;</span><br><span class="line">		ret = gpiochip_direction_output(guard.gc,</span><br><span class="line">						gpio_chip_hwgpio(desc), val);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 备用路径: 驱动没有提供组合的回调.</span></span><br><span class="line"><span class="comment">		 * 检查我们是否可以查询当前的方向.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (guard.gc-&gt;get_direction) &#123;</span><br><span class="line">			dir = gpiochip_get_direction(guard.gc,</span><br><span class="line">						     gpio_chip_hwgpio(desc));</span><br><span class="line">			<span class="keyword">if</span> (dir &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">return</span> dir; <span class="comment">// 查询出错</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 如果引脚当前不是输出模式, 我们又无法改变它, 这是一个错误. */</span></span><br><span class="line">			<span class="keyword">if</span> (dir != GPIO_LINE_DIRECTION_OUT) &#123;</span><br><span class="line">				gpiod_warn(desc,</span><br><span class="line">					   <span class="string">&quot;%s: missing direction_output() operation\n&quot;</span>,</span><br><span class="line">					   __func__);</span><br><span class="line">				<span class="keyword">return</span> -EIO;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 如果我们不能主动设置方向, 我们就假定它是一个仅输出的芯片,</span></span><br><span class="line"><span class="comment">		 * 直接驱动输出线到期望的值.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		ret = gpiochip_set(guard.gc, gpio_chip_hwgpio(desc), val);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果硬件操作成功 (ret == 0), 更新软件状态标志.</span></span><br><span class="line"><span class="comment">	 * 设置FLAG_IS_OUT, 表明此引脚现在是输出模式.</span></span><br><span class="line"><span class="comment">	 * 这个标志对于后续的gpiod_set_value()调用至关重要.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!ret)</span><br><span class="line">		set_bit(FLAG_IS_OUT, &amp;desc-&gt;flags);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 记录追踪事件, 用于内核调试. */</span></span><br><span class="line">	trace_gpio_value(desc_to_gpio(desc), <span class="number">0</span>, val);</span><br><span class="line">	trace_gpio_direction(desc_to_gpio(desc), <span class="number">0</span>, ret);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="gpiod-direction-output-nonotify-逻辑层核心-处理特殊模式和安全检查"><a href="#gpiod-direction-output-nonotify-逻辑层核心-处理特殊模式和安全检查" class="headerlink" title="gpiod_direction_output_nonotify: 逻辑层核心 (处理特殊模式和安全检查)"></a><code>gpiod_direction_output_nonotify</code>: 逻辑层核心 (处理特殊模式和安全检查)</h3><p>这个函数是整个逻辑的核心。它的作用是<strong>处理所有与软件相关的复杂性, 包括逻辑电平转换、开漏&#x2F;开源模式的硬件支持或软件仿真, 以及关键的安全检查</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">gpiod_direction_input_nonotify</span><span class="params">(<span class="keyword">struct</span> gpio_desc *desc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>, dir;</span><br><span class="line"></span><br><span class="line">	CLASS(gpio_chip_guard, guard)(desc);</span><br><span class="line">	<span class="keyword">if</span> (!guard.gc)</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * It is legal to have no .get() and .direction_input() specified if</span></span><br><span class="line"><span class="comment">	 * the chip is output-only, but you can&#x27;t specify .direction_input()</span></span><br><span class="line"><span class="comment">	 * and not support the .get() operation, that doesn&#x27;t make sense.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!guard.gc-&gt;get &amp;&amp; guard.gc-&gt;direction_input) &#123;</span><br><span class="line">		gpiod_warn(desc,</span><br><span class="line">			   <span class="string">&quot;%s: missing get() but have direction_input()\n&quot;</span>,</span><br><span class="line">			   __func__);</span><br><span class="line">		<span class="keyword">return</span> -EIO;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If we have a .direction_input() callback, things are simple,</span></span><br><span class="line"><span class="comment">	 * just call it. Else we are some input-only chip so try to check the</span></span><br><span class="line"><span class="comment">	 * direction (if .get_direction() is supported) else we silently</span></span><br><span class="line"><span class="comment">	 * assume we are in input mode after this.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (guard.gc-&gt;direction_input) &#123;</span><br><span class="line">		ret = gpiochip_direction_input(guard.gc,</span><br><span class="line">					       gpio_chip_hwgpio(desc));</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (guard.gc-&gt;get_direction) &#123;</span><br><span class="line">		dir = gpiochip_get_direction(guard.gc, gpio_chip_hwgpio(desc));</span><br><span class="line">		<span class="keyword">if</span> (dir &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> dir;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (dir != GPIO_LINE_DIRECTION_IN) &#123;</span><br><span class="line">			gpiod_warn(desc,</span><br><span class="line">				   <span class="string">&quot;%s: missing direction_input() operation and line is output\n&quot;</span>,</span><br><span class="line">				    __func__);</span><br><span class="line">			<span class="keyword">return</span> -EIO;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">		clear_bit(FLAG_IS_OUT, &amp;desc-&gt;flags);</span><br><span class="line">		ret = gpio_set_bias(desc);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	trace_gpio_direction(desc_to_gpio(desc), <span class="number">1</span>, ret);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * gpiod_direction_output_nonotify: 设置方向为输出, 但不发送uapi通知.</span></span><br><span class="line"><span class="comment"> * @desc: GPIO描述符</span></span><br><span class="line"><span class="comment"> * @value: 初始的 *逻辑* 电平 (考虑ACTIVE_LOW)</span></span><br><span class="line"><span class="comment"> * @return: 0表示成功, 负值表示错误.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">gpiod_direction_output_nonotify</span><span class="params">(<span class="keyword">struct</span> gpio_desc *desc, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 使用READ_ONCE安全地读取标志, 防止并发问题. */</span></span><br><span class="line">	flags = READ_ONCE(desc-&gt;flags);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 核心的逻辑到物理电平转换:</span></span><br><span class="line"><span class="comment">	 * 如果FLAG_ACTIVE_LOW被设置, 则反转逻辑值.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (test_bit(FLAG_ACTIVE_LOW, &amp;flags))</span><br><span class="line">		value = !value;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		value = !!value; <span class="comment">/* 否则, 仅规范化为0或1. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 关键的安全检查:</span></span><br><span class="line"><span class="comment">	 * 如果一个GPIO被用作一个已使能的中断, 绝对不能将其设置为输出模式.</span></span><br><span class="line"><span class="comment">	 * 这会造成硬件冲突.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (test_bit(FLAG_USED_AS_IRQ, &amp;flags) &amp;&amp;</span><br><span class="line">	    test_bit(FLAG_IRQ_IS_ENABLED, &amp;flags)) &#123;</span><br><span class="line">		gpiod_err(desc,</span><br><span class="line">			  <span class="string">&quot;%s: tried to set a GPIO tied to an IRQ as output\n&quot;</span>,</span><br><span class="line">			  __func__);</span><br><span class="line">		<span class="keyword">return</span> -EIO;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 处理开漏(Open Drain)模式:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (test_bit(FLAG_OPEN_DRAIN, &amp;flags)) &#123;</span><br><span class="line">		<span class="comment">/* 首先, 尝试让硬件直接支持开漏模式. */</span></span><br><span class="line">		ret = gpio_set_config(desc, PIN_CONFIG_DRIVE_OPEN_DRAIN);</span><br><span class="line">		<span class="keyword">if</span> (!ret)</span><br><span class="line">			<span class="keyword">goto</span> set_output_value; <span class="comment">/* 硬件支持, 直接去设置值. */</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 硬件不支持, 进行软件仿真:</span></span><br><span class="line"><span class="comment">		 * 仿真开漏时, 如果要输出高电平(value=1), 我们不能主动驱动线路,</span></span><br><span class="line"><span class="comment">		 * 而是应该将其设置为输入模式(高阻态), 依靠外部上拉电阻.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (value)</span><br><span class="line">			<span class="keyword">goto</span> set_output_flag;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (test_bit(FLAG_OPEN_SOURCE, &amp;flags)) &#123; <span class="comment">/* 开源模式处理, 逻辑与开漏相反. */</span></span><br><span class="line">		ret = gpio_set_config(desc, PIN_CONFIG_DRIVE_OPEN_SOURCE);</span><br><span class="line">		<span class="keyword">if</span> (!ret)</span><br><span class="line">			<span class="keyword">goto</span> set_output_value;</span><br><span class="line">		<span class="comment">/* 仿真开源时, 输出低电平(value=0)需要设置为输入模式. */</span></span><br><span class="line">		<span class="keyword">if</span> (!value)</span><br><span class="line">			<span class="keyword">goto</span> set_output_flag;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* 标准的推挽(Push-Pull)模式, 这是一个建议性设置. */</span></span><br><span class="line">		gpio_set_config(desc, PIN_CONFIG_DRIVE_PUSH_PULL);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">set_output_value:</span><br><span class="line">	<span class="comment">/* 设置任何已配置的偏置(上下拉电阻). */</span></span><br><span class="line">	ret = gpio_set_bias(desc);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	<span class="comment">/* 调用底层核心函数, 使用已转换为物理值的value来配置硬件. */</span></span><br><span class="line">	<span class="keyword">return</span> gpiod_direction_output_raw_commit(desc, value);</span><br><span class="line"></span><br><span class="line">set_output_flag:</span><br><span class="line">	<span class="comment">/* 软件仿真路径: */</span></span><br><span class="line">	ret = gpiod_direction_input_nonotify(desc); <span class="comment">/* 将引脚实际设置为输入模式. */</span></span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 这是仿真的关键技巧:</span></span><br><span class="line"><span class="comment">	 * 当我们通过不主动驱动线路来仿真开漏/开源功能时(将模式设置为输入),</span></span><br><span class="line"><span class="comment">	 * 我们仍然需要设置IS_OUT软件标志, 否则我们将无法再设置线路的值.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	set_bit(FLAG_IS_OUT, &amp;desc-&gt;flags);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="gpiod-direction-output-和-gpiod-direction-output-raw-公共API"><a href="#gpiod-direction-output-和-gpiod-direction-output-raw-公共API" class="headerlink" title="gpiod_direction_output 和 gpiod_direction_output_raw: 公共API"></a><code>gpiod_direction_output</code> 和 <code>gpiod_direction_output_raw</code>: 公共API</h3><p>这两个函数是暴露给驱动程序使用的顶层API。它们非常相似, 都是简单地调用它们各自的<code>_nonotify</code>或<code>_commit</code>版本, 然后在成功后<strong>发送一个通知</strong>, 通常用于更新用户空间的状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * gpiod_direction_output - 设置GPIO方向为输出 (使用逻辑值)</span></span><br><span class="line"><span class="comment"> * 这是推荐使用的标准API.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">gpiod_direction_output</span><span class="params">(<span class="keyword">struct</span> gpio_desc *desc, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	VALIDATE_DESC(desc);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 调用逻辑核心函数. */</span></span><br><span class="line">	ret = gpiod_direction_output_nonotify(desc, value);</span><br><span class="line">	<span class="comment">/* 如果成功, 发送配置变更通知. */</span></span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">		gpiod_line_state_notify(desc, GPIO_V2_LINE_CHANGED_CONFIG);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(gpiod_direction_output);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * gpiod_direction_output_raw - 设置GPIO方向为输出 (使用物理值)</span></span><br><span class="line"><span class="comment"> * 这是一个更底层的API, 绕过了ACTIVE_LOW处理.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">gpiod_direction_output_raw</span><span class="params">(<span class="keyword">struct</span> gpio_desc *desc, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	VALIDATE_DESC(desc);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 直接调用底层核心函数. */</span></span><br><span class="line">	ret = gpiod_direction_output_raw_commit(desc, value);</span><br><span class="line">	<span class="comment">/* 如果成功, 发送配置变更通知. */</span></span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">		gpiod_line_state_notify(desc, GPIO_V2_LINE_CHANGED_CONFIG);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(gpiod_direction_output_raw);</span><br></pre></td></tr></table></figure>

<h2 id="gpiod-set-transitory及相关函数-配置GPIO状态的持久性"><a href="#gpiod-set-transitory及相关函数-配置GPIO状态的持久性" class="headerlink" title="gpiod_set_transitory及相关函数: 配置GPIO状态的持久性"></a><code>gpiod_set_transitory</code>及相关函数: 配置GPIO状态的持久性</h2><p>这一组函数共同实现了一个功能: <strong>配置一个GPIO引脚的状态在系统低功耗(挂起&#x2F;suspend)或复位事件中是否应该被保持(持久化, persistent)还是可以丢失(瞬态的, transitory)</strong>。这对于电源管理至关重要, 例如, 一个用于唤醒系统的引脚必须保持其状态, 而一个用于点亮LED的引脚则可以在系统睡眠时被关闭。</p>
<p>这个功能通过一个从高层API到底层硬件驱动调用的函数链来实现。我们将从最高层的<code>gpiod_set_transitory</code>开始, 逐层深入。</p>
<hr>
<h3 id="gpiod-set-transitory-设置引脚状态是否为瞬态的公共API"><a href="#gpiod-set-transitory-设置引脚状态是否为瞬态的公共API" class="headerlink" title="gpiod_set_transitory: 设置引脚状态是否为瞬态的公共API"></a><code>gpiod_set_transitory</code>: 设置引脚状态是否为瞬态的公共API</h3><p>这是驱动程序应该调用的顶层函数。它的核心原理是<strong>实现了一个两级状态管理: (1) 它无条件地更新内核<code>gpiolib</code>框架中关于该引脚的软件状态标志; (2) 然后, 它”尽力而为”(best-effort)地尝试将这个配置应用到底层的物理硬件上</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * gpiod_set_transitory - 在挂起或复位时丢失或保留GPIO状态</span></span><br><span class="line"><span class="comment"> * @desc: 要为其配置持久性的GPIO的描述符</span></span><br><span class="line"><span class="comment"> * @transitory: true表示在挂起或复位时丢失状态, false表示持久化</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回:</span></span><br><span class="line"><span class="comment"> * 成功时返回0, 否则返回一个负的错误码.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">gpiod_set_transitory</span><span class="params">(<span class="keyword">struct</span> gpio_desc *desc, <span class="type">bool</span> transitory)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 验证传入的 desc 指针是否有效, 这是一个防止空指针解引用的标准安全检查宏.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	VALIDATE_DESC(desc);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 第一步, 也是最重要的一步: 更新软件状态.</span></span><br><span class="line"><span class="comment">	 * assign_bit 是一个辅助宏, 它会根据 &#x27;transitory&#x27; 的值 (true 或 false)</span></span><br><span class="line"><span class="comment">	 * 来设置或清除 desc-&gt;flags 中的 FLAG_TRANSITORY 位.</span></span><br><span class="line"><span class="comment">	 * 这一步是无条件的, 它确保了 gpiolib 的软件层面始终知道该引脚期望的持久性策略,</span></span><br><span class="line"><span class="comment">	 * 即使底层硬件不支持配置, 其他内核代码也可以查询这个标志.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	assign_bit(FLAG_TRANSITORY, &amp;desc-&gt;flags, transitory);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 第二步: 尝试将配置应用到硬件.</span></span><br><span class="line"><span class="comment">	 * 调用下一层辅助函数 gpio_set_config_with_argument_optional.</span></span><br><span class="line"><span class="comment">	 * - 第一个参数是引脚描述符.</span></span><br><span class="line"><span class="comment">	 * - 第二个参数 PIN_CONFIG_PERSIST_STATE 是一个枚举, 告诉下层函数我们要配置的是持久性.</span></span><br><span class="line"><span class="comment">	 * - 第三个参数 !transitory 是一个逻辑非操作. 这是因为下层函数期望的参数是&quot;是否持久化&quot;,</span></span><br><span class="line"><span class="comment">	 *   而本函数的输入是&quot;是否为瞬态&quot;, 两者逻辑相反.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> gpio_set_config_with_argument_optional(desc,</span><br><span class="line">						      PIN_CONFIG_PERSIST_STATE,</span><br><span class="line">						      !transitory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="gpio-set-config-with-argument-optional-“可选地”应用配置"><a href="#gpio-set-config-with-argument-optional-“可选地”应用配置" class="headerlink" title="gpio_set_config_with_argument_optional: “可选地”应用配置"></a><code>gpio_set_config_with_argument_optional</code>: “可选地”应用配置</h3><p>此函数是<code>gpiod_set_transitory</code>的直接辅助函数。它的核心作用是<strong>尝试应用一个配置, 但如果底层硬件明确表示”不支持”该功能, 则将其视为成功, 而不是一个错误</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 静态函数声明: gpio_set_config_with_argument_optional</span></span><br><span class="line"><span class="comment"> * @desc: GPIO描述符</span></span><br><span class="line"><span class="comment"> * @mode: 要配置的参数类型 (enum pin_config_param)</span></span><br><span class="line"><span class="comment"> * @argument: 要设置的参数值</span></span><br><span class="line"><span class="comment"> * @return: 0表示成功或功能不支持, 其他负值表示真实错误.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_set_config_with_argument_optional</span><span class="params">(<span class="keyword">struct</span> gpio_desc *desc,</span></span><br><span class="line"><span class="params">						  <span class="keyword">enum</span> pin_config_param mode,</span></span><br><span class="line"><span class="params">						  u32 argument)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> =</span> &amp;desc-&gt;gdev-&gt;dev;</span><br><span class="line">	<span class="type">int</span> gpio = gpio_chip_hwgpio(desc);</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 调用下一层的函数, 实际尝试去设置配置.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ret = gpio_set_config_with_argument(desc, mode, argument);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 这是本函数的关键逻辑.</span></span><br><span class="line"><span class="comment">	 * 如果返回值不是 -ENOTSUPP (不支持), 那么就直接返回这个结果.</span></span><br><span class="line"><span class="comment">	 * 这意味着, 如果操作成功(ret=0)或发生了其他真实错误(如-EINVAL), 都将结果向上传递.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (ret != -ENOTSUPP)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 如果代码执行到这里, 意味着 ret == -ENOTSUPP, 即硬件不支持此配置.</span></span><br><span class="line"><span class="comment">	 * 函数会根据配置模式打印一条可选的调试信息.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">	<span class="keyword">case</span> PIN_CONFIG_PERSIST_STATE:</span><br><span class="line">		dev_dbg(dev, <span class="string">&quot;Persistence not supported for GPIO %d\n&quot;</span>, gpio);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 最重要的一点: 即使硬件不支持, 此函数也返回 0 (成功).</span></span><br><span class="line"><span class="comment">	 * 这使得上层API gpiod_set_transitory 能够实现 &quot;best-effort&quot; 的行为.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="gpio-set-config-with-argument-和-gpio-do-set-config-打包并分发配置"><a href="#gpio-set-config-with-argument-和-gpio-do-set-config-打包并分发配置" class="headerlink" title="gpio_set_config_with_argument 和 gpio_do_set_config: 打包并分发配置"></a><code>gpio_set_config_with_argument</code> 和 <code>gpio_do_set_config</code>: 打包并分发配置</h3><p><code>gpio_set_config_with_argument</code>是一个简单的转换器, 而<code>gpio_do_set_config</code>是最终与硬件驱动程序交互的网关。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_set_config</span><span class="params">(<span class="keyword">struct</span> gpio_desc *desc, <span class="keyword">enum</span> pin_config_param mode)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> gpio_set_config_with_argument(desc, mode, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 静态函数声明: gpio_set_config_with_argument</span></span><br><span class="line"><span class="comment"> * 作用: 将高级的 (mode, argument) 参数打包成一个底层的 unsigned long 配置值.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_set_config_with_argument</span><span class="params">(<span class="keyword">struct</span> gpio_desc *desc,</span></span><br><span class="line"><span class="params">					 <span class="keyword">enum</span> pin_config_param mode,</span></span><br><span class="line"><span class="params">					 u32 argument)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> config;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 使用 pinconf_to_config_packed 宏将 mode 和 argument 打包成一个单一的 config 值.</span></span><br><span class="line"><span class="comment">	 * 这是 pinconf (引脚配置) 框架的一部分, 用于在不同子系统间传递配置.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	config = pinconf_to_config_packed(mode, argument);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 调用最终的执行函数.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> gpio_do_set_config(desc, config);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * gpio_do_set_config: 最终执行设置配置的函数.</span></span><br><span class="line"><span class="comment"> * @desc: GPIO描述符</span></span><br><span class="line"><span class="comment"> * @config: 已打包的配置值</span></span><br><span class="line"><span class="comment"> * @return: 0表示成功, 负值表示错误.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">gpio_do_set_config</span><span class="params">(<span class="keyword">struct</span> gpio_desc *desc, <span class="type">unsigned</span> <span class="type">long</span> config)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * CLASS宏: 安全地获取与此GPIO描述符关联的 gpio_chip (硬件控制器).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	CLASS(gpio_chip_guard, guard)(desc);</span><br><span class="line">	<span class="keyword">if</span> (!guard.gc)</span><br><span class="line">		<span class="keyword">return</span> -ENODEV; <span class="comment">// 如果没有关联的控制器, 返回错误.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 检查底层硬件驱动 (gpio_chip) 是否实现了 .set_config 回调函数.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!guard.gc-&gt;set_config)</span><br><span class="line">		<span class="keyword">return</span> -ENOTSUPP; <span class="comment">// 如果没有实现, 返回&quot;不支持&quot;错误.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 调用硬件驱动的 .set_config 函数, 将配置应用到物理硬件.</span></span><br><span class="line"><span class="comment">	 * gpio_chip_hwgpio(desc) 获取引脚在控制器内的硬件编号.</span></span><br><span class="line"><span class="comment">	 * 这是通用 gpiolib 框架与具体硬件驱动 (如STM32 GPIO驱动) 之间的接口点.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ret = guard.gc-&gt;set_config(guard.gc, gpio_chip_hwgpio(desc), config);</span><br><span class="line">	<span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">		ret = -EBADE; <span class="comment">// 标准化内核错误码 (错误码应为负值).</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GPIO_CDEV</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 这是一个特殊情况, 用于支持通过字符设备(/dev/gpiochipX)访问GPIO.</span></span><br><span class="line"><span class="comment">	 * 如果配置的是输入去抖动, 需要将去抖周期存入描述符中, 以便用户空间可以读回它.</span></span><br><span class="line"><span class="comment">	 * WRITE_ONCE 用于并发安全的写入.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!ret &amp;&amp; pinconf_to_config_param(config) == PIN_CONFIG_INPUT_DEBOUNCE)</span><br><span class="line">		WRITE_ONCE(desc-&gt;debounce_period_us,</span><br><span class="line">			   pinconf_to_config_argument(config));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="gpiod-configure-flags-集中式GPIO配置核心辅助函数"><a href="#gpiod-configure-flags-集中式GPIO配置核心辅助函数" class="headerlink" title="gpiod_configure_flags: 集中式GPIO配置核心辅助函数"></a>gpiod_configure_flags: 集中式GPIO配置核心辅助函数</h2><p>此函数是Linux <code>gpiolib</code>框架内部的一个核心辅助函数。它的主要作用是<strong>提供一个统一的接口, 用于将从两个不同来源获取的配置标志——静态的板级描述(<code>lflags</code>)和动态的驱动程序请求(<code>dflags</code>)——应用到一个GPIO引脚描述符(<code>desc</code>)上</strong>。它负责处理引脚的所有关键电气特性(如逻辑电平、开漏&#x2F;开源、上下拉)以及其工作方向(输入&#x2F;输出)。</p>
<p>该函数的原理可以分解为两个主要阶段:</p>
<ol>
<li><p><strong>应用静态电气特性 (<code>lflags</code>)</strong>: 函数首先处理从设备树、ACPI或板级文件中解析出的标志(<code>lflags</code>)。这些标志定义了引脚在特定硬件设计中的固有电气属性。</p>
<ul>
<li><strong>逻辑电平 (Active-Low)</strong>: 如果<code>GPIO_ACTIVE_LOW</code>被设置, 它会在此引脚的内部标志中设置<code>FLAG_ACTIVE_LOW</code>。这会反转该引脚的逻辑含义, 即物理低电平被软件视为”1”或”激活”, 反之亦然。</li>
<li><strong>输出模式 (Open-Drain&#x2F;Source)</strong>: 它会设置<code>FLAG_OPEN_DRAIN</code>或<code>FLAG_OPEN_SOURCE</code>。开漏(Open-Drain)模式意味着引脚只能主动将线路拉低至地, 或进入高阻态(浮空); 它不能主动输出高电平。这对于I2C等多主设备总线至关重要。</li>
<li><strong>偏置&#x2F;上下拉 (Bias&#x2F;Pull)</strong>: 它会解析<code>GPIO_PULL_UP</code>, <code>GPIO_PULL_DOWN</code>, 或<code>GPIO_PULL_DISABLE</code>标志, 并在内部设置相应的<code>FLAG_PULL_UP</code>, <code>FLAG_PULL_DOWN</code>, 或<code>FLAG_BIAS_DISABLE</code>。在设置前, 它会执行一个关键的<strong>完整性检查</strong>, 确保设备树中没有定义相互冲突的拉电阻配置(例如, 不能同时上拉和下拉)。</li>
<li><strong>瞬态值 (Transitory)</strong>: 它会处理<code>GPIO_TRANSITORY</code>标志, 表明此引脚的状态在系统睡眠&#x2F;挂起期间无需被保持, 这是一种电源管理优化。</li>
</ul>
</li>
<li><p><strong>应用动态方向和初始值 (<code>dflags</code>)</strong>: 在处理完静态标志后, 函数会检查调用者(通常是设备驱动)传入的<code>dflags</code>。</p>
<ul>
<li><strong>方向设置</strong>: 如果<code>dflags</code>中包含<code>GPIOD_FLAGS_BIT_DIR_SET</code>标志, 意味着驱动程序希望明确设置引脚的方向。</li>
<li>如果<code>GPIOD_FLAGS_BIT_DIR_OUT</code>被设置, 它会调用<code>gpiod_direction_output_nonotify</code>将引脚配置为输出模式。同时, 它会检查<code>GPIOD_FLAGS_BIT_DIR_VAL</code>标志, 以此决定引脚的<strong>初始输出电平</strong>是高还是低。</li>
<li>否则, 它会调用<code>gpiod_direction_input_nonotify</code>将引脚配置为输入模式。</li>
<li>如果<code>dflags</code>中<strong>不</strong>包含<code>GPIOD_FLAGS_BIT_DIR_SET</code>, 函数在完成第一阶段后就会直接返回成功。这允许驱动程序只获取一个GPIO句柄并应用其静态电气特性, 而不立即改变其方向。</li>
</ul>
</li>
</ol>
<p>一个值得注意的细节是该函数如何处理<code>OPEN_DRAIN</code>的动态请求: 它允许驱动程序通过<code>dflags</code>来强制设置开漏模式, 但前提是<code>lflags</code>中没有指定。然而, 它会打印一条警告, 强调这种配置<strong>应该</strong>在设备树等板级描述中定义, 驱动程序强制指定是一种不规范的备用手段。</p>
<p>在STM32H750这样的系统中, 当一个设备驱动(例如I2C驱动)调用<code>devm_gpiod_get_optional()</code>或类似函数时, <code>gpiolib</code>核心最终会调用<code>gpiod_configure_flags</code>。<code>lflags</code>参数会携带从STM32H750设备树中解析出的标志(如<code>GPIO_ACTIVE_LOW</code>), 而<code>dflags</code>则携带驱动自身指定的标志(如<code>GPIOD_OUT_HIGH</code>)。此函数随后会将这些抽象的标志转换为对底层STM32 GPIO驱动<code>gpio_chip</code>的回调函数(如<code>.direction_output</code>)的调用, 最终实现对STM32 GPIO端口的<code>MODER</code>, <code>PUPDR</code>, <code>OTYPER</code>, <code>ODR</code>等寄存器的精确配置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * gpiod_configure_flags - 用于配置一个给定GPIO的辅助函数</span></span><br><span class="line"><span class="comment"> * @desc:	将被赋值的gpio描述符</span></span><br><span class="line"><span class="comment"> * @con_id:	GPIO消费者内部的功能名称</span></span><br><span class="line"><span class="comment"> * @lflags:	gpio_lookup_flags GPIO_* 值的位掩码 - 从</span></span><br><span class="line"><span class="comment"> *		of_find_gpio() 或 of_get_gpio_hog() 返回</span></span><br><span class="line"><span class="comment"> * @dflags:	gpiod_flags - 可选的GPIO初始化标志</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回:</span></span><br><span class="line"><span class="comment"> * 成功时返回0, 如果没有GPIO被分配给请求的功能和/或索引, 返回-ENOENT,</span></span><br><span class="line"><span class="comment"> * 或者在尝试获取GPIO时发生其他错误, 返回另一个IS_ERR()代码.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">gpiod_configure_flags</span><span class="params">(<span class="keyword">struct</span> gpio_desc *desc, <span class="type">const</span> <span class="type">char</span> *con_id,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">long</span> lflags, <span class="keyword">enum</span> gpiod_flags dflags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 获取一个用于调试打印的名称. */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name = function_name_or_default(con_id);</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* --- 阶段一: 应用 lflags (来自设备树/板级文件的静态配置) --- */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果lflags中包含GPIO_ACTIVE_LOW, 则在描述符的内部标志中设置FLAG_ACTIVE_LOW. */</span></span><br><span class="line">	<span class="keyword">if</span> (lflags &amp; GPIO_ACTIVE_LOW)</span><br><span class="line">		set_bit(FLAG_ACTIVE_LOW, &amp;desc-&gt;flags);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果lflags中包含GPIO_OPEN_DRAIN, 则设置FLAG_OPEN_DRAIN. */</span></span><br><span class="line">	<span class="keyword">if</span> (lflags &amp; GPIO_OPEN_DRAIN)</span><br><span class="line">		set_bit(FLAG_OPEN_DRAIN, &amp;desc-&gt;flags);</span><br><span class="line">	<span class="comment">/* 否则, 如果dflags (来自驱动的请求) 要求开漏模式... */</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (dflags &amp; GPIOD_FLAGS_BIT_OPEN_DRAIN) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 这是从消费者端强制设置开漏模式.</span></span><br><span class="line"><span class="comment">		 * 这对于像I2C这样的总线是必需的, 但是查找过程</span></span><br><span class="line"><span class="comment">		 * *真的*应该首先在板级文件中将它们指定为开漏,</span></span><br><span class="line"><span class="comment">		 * 所以在这里打印一个小警告.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		set_bit(FLAG_OPEN_DRAIN, &amp;desc-&gt;flags);</span><br><span class="line">		gpiod_warn(desc,</span><br><span class="line">			   <span class="string">&quot;enforced open drain please flag it properly in DT/ACPI DSDT/board file\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果lflags中包含GPIO_OPEN_SOURCE, 则设置FLAG_OPEN_SOURCE. */</span></span><br><span class="line">	<span class="keyword">if</span> (lflags &amp; GPIO_OPEN_SOURCE)</span><br><span class="line">		set_bit(FLAG_OPEN_SOURCE, &amp;desc-&gt;flags);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 完整性检查: 确保没有定义相互冲突的上下拉/偏置配置. */</span></span><br><span class="line">	<span class="keyword">if</span> (((lflags &amp; GPIO_PULL_UP) &amp;&amp; (lflags &amp; GPIO_PULL_DOWN)) ||</span><br><span class="line">	    ((lflags &amp; GPIO_PULL_UP) &amp;&amp; (lflags &amp; GPIO_PULL_DISABLE)) ||</span><br><span class="line">	    ((lflags &amp; GPIO_PULL_DOWN) &amp;&amp; (lflags &amp; GPIO_PULL_DISABLE))) &#123;</span><br><span class="line">		gpiod_err(desc,</span><br><span class="line">			  <span class="string">&quot;multiple pull-up, pull-down or pull-disable enabled, invalid configuration\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 根据lflags应用唯一的拉电阻/偏置配置. */</span></span><br><span class="line">	<span class="keyword">if</span> (lflags &amp; GPIO_PULL_UP)</span><br><span class="line">		set_bit(FLAG_PULL_UP, &amp;desc-&gt;flags);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (lflags &amp; GPIO_PULL_DOWN)</span><br><span class="line">		set_bit(FLAG_PULL_DOWN, &amp;desc-&gt;flags);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (lflags &amp; GPIO_PULL_DISABLE)</span><br><span class="line">		set_bit(FLAG_BIAS_DISABLE, &amp;desc-&gt;flags);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 设置瞬态标志, 表明引脚状态在系统睡眠时无需保持. */</span></span><br><span class="line">	ret = gpiod_set_transitory(desc, (lflags &amp; GPIO_TRANSITORY));</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* --- 阶段二: 应用 dflags (来自驱动程序的动态请求) --- */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果dflags中没有请求设置方向的标志, 那么工作已经完成, 在此返回... */</span></span><br><span class="line">	<span class="keyword">if</span> (!(dflags &amp; GPIOD_FLAGS_BIT_DIR_SET)) &#123;</span><br><span class="line">		gpiod_dbg(desc, <span class="string">&quot;no flags found for GPIO %s\n&quot;</span>, name);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 处理方向标志 */</span></span><br><span class="line">	<span class="keyword">if</span> (dflags &amp; GPIOD_FLAGS_BIT_DIR_OUT)</span><br><span class="line">		<span class="comment">/* 如果请求输出, 则调用内部的gpiod_direction_output_nonotify函数.</span></span><br><span class="line"><span class="comment">		 * 第二个参数 !!(dflags &amp; GPIOD_FLAGS_BIT_DIR_VAL) 是一个C语言技巧,</span></span><br><span class="line"><span class="comment">		 * 它将 GPIOD_FLAGS_BIT_DIR_VAL 标志的存在与否转换为一个干净的 1 或 0,</span></span><br><span class="line"><span class="comment">		 * 用于设置引脚的初始输出值 (高或低).</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		ret = gpiod_direction_output_nonotify(desc,</span><br><span class="line">				!!(dflags &amp; GPIOD_FLAGS_BIT_DIR_VAL));</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="comment">/* 否则, 将引脚设置为输入. */</span></span><br><span class="line">		ret = gpiod_direction_input_nonotify(desc);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="gpiod-find-and-request-GPIO-获取、请求与配置的核心引擎"><a href="#gpiod-find-and-request-GPIO-获取、请求与配置的核心引擎" class="headerlink" title="gpiod_find_and_request: GPIO 获取、请求与配置的核心引擎"></a>gpiod_find_and_request: GPIO 获取、请求与配置的核心引擎</h2><p>此函数是Linux内核现代<code>gpiod</code>接口的<strong>底层核心工作函数</strong>。所有上层的<code>gpiod_get_*</code>便利封装函数最终都会调用它来完成实际的工作。它的核心原理是<strong>执行一个完整且健壮的”查找-&gt;请求-&gt;配置”三步流程, 将一个来自消费者驱动的、基于功能的抽象GPIO请求, 转化为一个已声明所有权并正确初始化的、可供驱动程序直接使用的硬件句柄(<code>struct gpio_desc</code>)</strong>。</p>
<p>这是一个高度复杂的函数, 其内部原理融合了多种内核机制:</p>
<ol>
<li><p><strong>分层查找策略 (Find)</strong>: 函数首先采用现代的、基于固件(Firmware)的查找方法。</p>
<ul>
<li><strong>首选: 设备树&#x2F;ACPI (<code>gpiod_find_by_fwnode</code>)</strong>: 它优先使用<code>fwnode</code>(通常是设备树节点)来查找GPIO。它会在设备树节点中寻找匹配的<code>&lt;con_id&gt;-gpios</code>属性(例如, <code>enable-gpios</code>), 并解析出GPIO信息。这是首选的、与硬件描述绑定的方式。</li>
<li><strong>备用: 平台查找 (<code>gpiod_find</code>)</strong>: 如果基于固件的查找没有找到结果, 并且调用者允许, 它会回退到旧式的、基于平台查找表(board file)的机制。这确保了对没有使用设备树的旧平台的向后兼容性。</li>
</ul>
</li>
<li><p><strong>所有权与资源管理 (Request)</strong>: 在成功<strong>找到</strong>GPIO描述符后, 最关键的一步是调用<code>gpiod_request</code>。</p>
<ul>
<li>此调用向<code>gpiolib</code>核心声明:”这个GPIO引脚现在归我(由<code>label</code>标识的消费者)所有”。</li>
<li>内核会将该引脚标记为”已使用”, 防止其他驱动程序无意中请求同一个引脚而导致硬件冲突。这是一个至关重要的资源管理和互斥机制。</li>
</ul>
</li>
<li><p><strong>并发安全</strong>: 整个查找和请求过程被一个<code>scoped_guard(srcu, &amp;gpio_devices_srcu)</code>块包裹。</p>
<ul>
<li>SRCU (Sleepable Read-Copy-Update) 是一种高级的同步机制, 用于保护被频繁读取但很少写入的数据结构, 比如系统中的GPIO控制器列表。</li>
<li>这个锁确保了在函数查找GPIO控制器的过程中, 该控制器不会被另一个CPU核心或因抢占而运行的任务并发地从系统中注销, 从而防止了悬空指针等竞态条件的发生。即使在STM32H750这样的单核系统中, 这也能防止任务抢占和中断上下文访问带来的并发问题。</li>
</ul>
</li>
<li><p><strong>灵活的共享机制 (Non-Exclusive Access)</strong>: 函数包含了对”非独占”访问的特殊处理。</p>
<ul>
<li>正常情况下, 如果一个已经被请求的GPIO再次被请求, <code>gpiod_request</code>会返回<code>-EBUSY</code>错误。</li>
<li>但如果第二次请求时设置了<code>GPIOD_FLAGS_BIT_NONEXCLUSIVE</code>标志, 此函数会<strong>抑制</strong>这个<code>-EBUSY</code>错误。它会直接返回已存在的描述符, 但<strong>跳过</strong>后续的配置步骤。</li>
<li>这解决了多个设备(例如两个电源调节器)共享同一个物理使能引脚的硬件设计问题, 允许它们共享同一个GPIO句柄, 并假定第一个请求者已经完成了必要的初始化配置。</li>
</ul>
</li>
<li><p><strong>最终配置与错误恢复 (Configure)</strong>: 在成功声明所有权后, 函数调用<code>gpiod_configure_flags</code>来应用调用者请求的初始状态, 例如将引脚设置为输出低电平、配置为开漏模式等。</p>
<ul>
<li><strong>关键的错误处理</strong>: 如果配置步骤失败, 函数会立即调用<code>gpiod_put</code>(与<code>gpiod_request</code>配对的释放函数)来<strong>撤销</strong>刚刚成功的请求操作, 将GPIO引脚释放回池中, 从而确保系统状态的一致性。</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">gpiod_line_state_notify</span><span class="params">(<span class="keyword">struct</span> gpio_desc *desc, <span class="type">unsigned</span> <span class="type">long</span> action)</span></span><br><span class="line">&#123;</span><br><span class="line">	guard(read_lock_irqsave)(&amp;desc-&gt;gdev-&gt;line_state_lock);</span><br><span class="line"></span><br><span class="line">	raw_notifier_call_chain(&amp;desc-&gt;gdev-&gt;line_state_notifier, action, desc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> gpio_desc *<span class="title function_">gpiod_find_and_request</span><span class="params">(<span class="keyword">struct</span> device *consumer,</span></span><br><span class="line"><span class="params">					 <span class="keyword">struct</span> fwnode_handle *fwnode,</span></span><br><span class="line"><span class="params">					 <span class="type">const</span> <span class="type">char</span> *con_id,</span></span><br><span class="line"><span class="params">					 <span class="type">unsigned</span> <span class="type">int</span> idx,</span></span><br><span class="line"><span class="params">					 <span class="keyword">enum</span> gpiod_flags flags,</span></span><br><span class="line"><span class="params">					 <span class="type">const</span> <span class="type">char</span> *label,</span></span><br><span class="line"><span class="params">					 <span class="type">bool</span> platform_lookup_allowed)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> lookupflags = GPIO_LOOKUP_FLAGS_DEFAULT;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name = function_name_or_default(con_id);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">desc</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 使用 SRCU 读侧锁保护整个查找和请求过程.</span></span><br><span class="line"><span class="comment">	 * 这确保了在遍历和查找 GPIO 控制器列表时, 列表不会被并发修改.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	scoped_guard(srcu, &amp;gpio_devices_srcu) &#123;</span><br><span class="line">		<span class="comment">/* --- 阶段 1: 查找 (Find) --- */</span></span><br><span class="line">		<span class="comment">/* 首选方法: 通过固件节点(Device Tree/ACPI)查找. */</span></span><br><span class="line">		desc = gpiod_find_by_fwnode(fwnode, consumer, con_id, idx,</span><br><span class="line">					    &amp;flags, &amp;lookupflags);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 如果固件查找未找到, 并且允许平台回退 */</span></span><br><span class="line">		<span class="keyword">if</span> (gpiod_not_found(desc) &amp;&amp; platform_lookup_allowed) &#123;</span><br><span class="line">			<span class="comment">/* 备用方法: 使用旧式的平台查找表. */</span></span><br><span class="line">			dev_dbg(consumer,</span><br><span class="line">				<span class="string">&quot;using lookup tables for GPIO lookup\n&quot;</span>);</span><br><span class="line">			desc = gpiod_find(consumer, con_id, idx, &amp;lookupflags);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 如果查找阶段返回任何错误 (除了&quot;未找到&quot;, 因为它被回退处理了) */</span></span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(desc)) &#123;</span><br><span class="line">			dev_dbg(consumer, <span class="string">&quot;No GPIO consumer %s found\n&quot;</span>, name);</span><br><span class="line">			<span class="keyword">return</span> desc; <span class="comment">// 直接返回错误.</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* --- 阶段 2: 请求 (Request) --- */</span></span><br><span class="line">		<span class="comment">/* 声明对此 GPIO 的所有权. */</span></span><br><span class="line">		ret = gpiod_request(desc, label);</span><br><span class="line">	&#125; <span class="comment">/* SRCU 锁在此处自动释放 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* --- 处理请求结果 --- */</span></span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 这是一个关键的特殊情况处理. 如果请求失败, 检查:</span></span><br><span class="line"><span class="comment">		 * 1. 失败原因是否是 -EBUSY (已被占用)?</span></span><br><span class="line"><span class="comment">		 * 2. 调用者是否请求了 GPIOD_FLAGS_BIT_NONEXCLUSIVE (非独占访问)?</span></span><br><span class="line"><span class="comment">		 * 如果以上两个条件 *不* 同时满足, 那么这是一个真正的错误.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!(ret == -EBUSY &amp;&amp; flags &amp; GPIOD_FLAGS_BIT_NONEXCLUSIVE))</span><br><span class="line">			<span class="keyword">return</span> ERR_PTR(ret);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 如果满足了上述两个条件, 说明这是一个合法的共享场景.</span></span><br><span class="line"><span class="comment">		 * 打印一条信息, 然后直接返回已存在的描述符, 但跳过后续的配置.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		dev_info(consumer, <span class="string">&quot;nonexclusive access to GPIO for %s\n&quot;</span>, name);</span><br><span class="line">		<span class="keyword">return</span> desc;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* --- 阶段 3: 配置 (Configure) --- */</span></span><br><span class="line">	<span class="comment">/* 对成功请求的 GPIO 应用初始化标志 (方向, 初始值等). */</span></span><br><span class="line">	ret = gpiod_configure_flags(desc, con_id, lookupflags, flags);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">/* 如果配置失败, 必须撤销请求! */</span></span><br><span class="line">		gpiod_put(desc);</span><br><span class="line">		dev_err(consumer, <span class="string">&quot;setup of GPIO %s failed: %d\n&quot;</span>, name, ret);</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(ret);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 通知用户空间等监听者, 这个 GPIO line 的状态已改变 (已被请求). */</span></span><br><span class="line">	gpiod_line_state_notify(desc, GPIO_V2_LINE_CHANGED_REQUESTED);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* --- 成功 --- */</span></span><br><span class="line">	<span class="comment">/* 返回一个完全就绪的 GPIO 描述符. */</span></span><br><span class="line">	<span class="keyword">return</span> desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="gpiod-get-API-获取GPIO描述符的-layered-Convenience-Wrappers"><a href="#gpiod-get-API-获取GPIO描述符的-layered-Convenience-Wrappers" class="headerlink" title="gpiod_get API: 获取GPIO描述符的 layered Convenience Wrappers"></a>gpiod_get API: 获取GPIO描述符的 layered Convenience Wrappers</h2><p>此代码片段展示了Linux内核现代GPIO接口(<code>gpiod</code>)中三个关键的、相互关联的API函数。它们共同构成了一个层次化的便利封装体系, 用于从消费者驱动程序(consumer)的角度, 根据功能名称(如 “enable”, “reset”)来安全地请求和获取GPIO引脚的句柄(<code>struct gpio_desc</code>)。其核心原理是<strong>将硬件布线(在设备树中描述)与驱动程序逻辑分离, 并为处理可选和多路GPIO提供了清晰、安全的抽象</strong>。</p>
<hr>
<h3 id="gpiod-get-index-获取多索引GPIO的基础函数"><a href="#gpiod-get-index-获取多索引GPIO的基础函数" class="headerlink" title="gpiod_get_index: 获取多索引GPIO的基础函数"></a><code>gpiod_get_index</code>: 获取多索引GPIO的基础函数</h3><p>这是三者中最基础的函数。它的核心作用是获取与某个特定功能(<code>con_id</code>)关联的<strong>第N个</strong>(<code>idx</code>)GPIO。这对于一个功能需要多个GPIO引脚的场景(例如, 一个4位的并行数据总线)是必不可少的。</p>
<p><strong>原理</strong>:</p>
<ol>
<li>它首先获取设备的固件节点(<code>fwnode</code>), 这在现代Linux中通常指向设备树节点。</li>
<li>然后, 它将所有参数(包括设备、功能名、索引、初始化标志)传递给底层的核心函数<code>gpiod_find_and_request</code>。</li>
<li><code>gpiod_find_and_request</code>会执行以下关键操作:<ul>
<li>在设备的设备树节点中, 查找名为<code>&lt;con_id&gt;-gpios</code>的属性(例如, <code>data-gpios</code>)。</li>
<li>定位到该属性列表中的第<code>idx</code>个条目。</li>
<li>解析该条目, 找到它所指向的GPIO控制器和引脚号。</li>
<li>向<code>gpiolib</code>核心请求(request)该GPIO, 这会将其标记为”已使用”, 防止其他驱动程序产生冲突。</li>
<li>根据传入的<code>flags</code>, 对GPIO进行初始配置(例如, 设置为输出低电平)。</li>
</ul>
</li>
<li><strong>返回值至关重要</strong>:<ul>
<li><strong>成功</strong>: 返回一个有效的<code>gpio_desc</code>指针。</li>
<li><strong>未找到</strong>: 如果设备树中没有定义对应的GPIO, 它会返回特定的错误码<code>-ENOENT</code>。</li>
<li><strong>其他错误</strong>: 如果GPIO已被占用(<code>-EBUSY</code>)或发生其他问题, 它会返回相应的错误码。</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> gpio_desc *__must_check <span class="title function_">gpiod_get_index</span><span class="params">(<span class="keyword">struct</span> device *dev,</span></span><br><span class="line"><span class="params">					       <span class="type">const</span> <span class="type">char</span> *con_id,</span></span><br><span class="line"><span class="params">					       <span class="type">unsigned</span> <span class="type">int</span> idx,</span></span><br><span class="line"><span class="params">					       <span class="keyword">enum</span> gpiod_flags flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 准备 fwnode, devname, label 等参数...</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fwnode_handle</span> *<span class="title">fwnode</span> =</span> dev ? dev_fwnode(dev) : <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *devname = dev ? dev_name(dev) : <span class="string">&quot;?&quot;</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *label = con_id ?: devname;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将实际工作委托给底层的 gpiod_find_and_request 函数</span></span><br><span class="line">	<span class="keyword">return</span> gpiod_find_and_request(dev, fwnode, con_id, idx, flags, label, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(gpiod_get_index);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="gpiod-get-index-optional-获取可选的多索引GPIO"><a href="#gpiod-get-index-optional-获取可选的多索引GPIO" class="headerlink" title="gpiod_get_index_optional: 获取可选的多索引GPIO"></a><code>gpiod_get_index_optional</code>: 获取可选的多索引GPIO</h3><p>这是一个基于<code>gpiod_get_index</code>的便利封装。它的核心作用是<strong>改变”未找到”这种情况下的返回值</strong>, 使其对驱动开发者更友好。</p>
<p><strong>原理</strong>:</p>
<ol>
<li>它直接调用<code>gpiod_get_index</code>来执行获取操作。</li>
<li>然后, 它检查返回值。它使用<code>gpiod_not_found(desc)</code>(内部等价于<code>PTR_ERR(desc) == -ENOENT</code>)来专门判断失败的原因是否是”未找到”。</li>
<li><strong>如果是因为”未找到”而失败, 它会抑制这个错误, 并返回<code>NULL</code></strong>。</li>
<li>如果是因为其他原因(如<code>-EBUSY</code>)而失败, 它会<strong>保留并返回原始的错误指针</strong>。</li>
</ol>
<p>这个函数对于处理硬件设计上可选的GPIO引脚极为有用。驱动程序可以通过检查返回值是否为<code>NULL</code>来知道该可选功能是否存在, 从而调整自身行为, 而无需处理<code>-ENOENT</code>这个特定的错误码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> gpio_desc *__must_check <span class="title function_">gpiod_get_index_optional</span><span class="params">(<span class="keyword">struct</span> device *dev,</span></span><br><span class="line"><span class="params">							<span class="type">const</span> <span class="type">char</span> *con_id,</span></span><br><span class="line"><span class="params">							<span class="type">unsigned</span> <span class="type">int</span> index,</span></span><br><span class="line"><span class="params">							<span class="keyword">enum</span> gpiod_flags flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">desc</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用基础函数</span></span><br><span class="line">	desc = gpiod_get_index(dev, con_id, index, flags);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果失败的原因是&quot;未找到&quot;</span></span><br><span class="line">	<span class="keyword">if</span> (gpiod_not_found(desc))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 则返回 NULL, 而不是错误指针</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 否则, 返回原始的描述符或错误指针</span></span><br><span class="line">	<span class="keyword">return</span> desc;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(gpiod_get_index_optional);</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="gpiod-get-optional-获取单个可选GPIO-最常用"><a href="#gpiod-get-optional-获取单个可选GPIO-最常用" class="headerlink" title="gpiod_get_optional: 获取单个可选GPIO (最常用)"></a><code>gpiod_get_optional</code>: 获取单个可选GPIO (最常用)</h4><p>这是最顶层的、也是最常用的便利封装。它的核心作用是获取与某个功能关联的**第一个(也是唯一一个)**可选GPIO。</p>
<p><strong>原理</strong>:<br>它是一个极简的封装, 直接调用<code>gpiod_get_index_optional</code>, 并将索引<code>idx</code>硬编码为<code>0</code>。</p>
<p>在STM32H750这样的嵌入式系统中, 大多数功能(如复位、中断、使能)都只由单个GPIO引脚控制。因此, 这个函数是驱动程序中最常见的选择。例如, <code>reg_fixed_voltage_probe</code>中获取使能引脚时, 使用的就是这个函数。它允许设备树中可以完全不定义<code>enable-gpios</code>属性, 驱动程序也能正常工作(只是没有使能控制功能), 从而大大增强了硬件描述的灵活性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> gpio_desc *__must_check <span class="title function_">gpiod_get_optional</span><span class="params">(<span class="keyword">struct</span> device *dev,</span></span><br><span class="line"><span class="params">						  <span class="type">const</span> <span class="type">char</span> *con_id,</span></span><br><span class="line"><span class="params">						  <span class="keyword">enum</span> gpiod_flags flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 直接调用索引版本, 并将索引硬编码为 0</span></span><br><span class="line">	<span class="keyword">return</span> gpiod_get_index_optional(dev, con_id, <span class="number">0</span>, flags);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(gpiod_get_optional);</span><br></pre></td></tr></table></figure>

<h1 id="drivers-gpio-gpiolib-cdev-c"><a href="#drivers-gpio-gpiolib-cdev-c" class="headerlink" title="drivers&#x2F;gpio&#x2F;gpiolib-cdev.c"></a>drivers&#x2F;gpio&#x2F;gpiolib-cdev.c</h1><h2 id="lineinfo-watch-poll-等待GPIO事件"><a href="#lineinfo-watch-poll-等待GPIO事件" class="headerlink" title="lineinfo_watch_poll: 等待GPIO事件"></a><code>lineinfo_watch_poll</code>: 等待GPIO事件</h2><p>此函数实现了<code>poll()</code>、<code>select()</code>和<code>epoll()</code>系统调用的后端逻辑。它的核心原理是<strong>提供一个无阻塞的机制来查询事件是否已发生, 并在没有事件时将当前进程注册到一个等待队列上, 以便在未来事件发生时被内核唤醒</strong>。</p>
<p><strong>工作流程详解:</strong></p>
<ol>
<li><strong>获取会话上下文</strong>: 从<code>file-&gt;private_data</code>中获取在<code>open()</code>时创建的私有会话数据<code>cdev</code>。</li>
<li><strong>设备存在性检查</strong>: 使用<code>SRCU</code>机制安全地检查底层的GPIO芯片是否仍然存在。如果设备已被移除, 它会返回<code>EPOLLHUP | EPOLLERR</code>, 通知用户空间此文件句柄已失效。</li>
<li><strong>注册等待队列</strong>: 这是<code>poll</code>的核心。<code>poll_wait(file, &amp;cdev-&gt;wait, pollt)</code><strong>不会阻塞</strong>。它只是将当前进程的等待信息添加到<code>cdev-&gt;wait</code>这个等待队列头中。这相当于对内核说: “如果未来有谁唤醒了<code>cdev-&gt;wait</code>这个队列, 请务必唤醒我(这个正在执行<code>poll</code>的进程)”。</li>
<li><strong>检查当前状态</strong>: 在注册完等待后, 它会立即检查事件FIFO缓冲区(<code>cdev-&gt;events</code>)是否已经有数据了。这个检查是在持有自旋锁的情况下进行的, 以确保与生产者(中断处理程序)的并发安全。</li>
<li><strong>返回结果</strong>:<ul>
<li>如果FIFO<strong>不为空</strong>, 意味着有事件可以立即读取。函数返回<code>EPOLLIN | EPOLLRDNORM</code>, <code>poll()</code>系统调用会立即返回, 告知应用程序可以进行<code>read()</code>操作了。</li>
<li>如果FIFO<strong>为空</strong>, 函数返回<code>0</code>。此时, <code>poll()</code>系统调用不会立即返回, 而是会使应用程序进入睡眠, 等待被步骤3中注册的唤醒机制唤醒。</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * lineinfo_watch_poll: poll方法实现, 用于等待线路信息变化事件.</span></span><br><span class="line"><span class="comment"> * @file: 文件结构体指针.</span></span><br><span class="line"><span class="comment"> * @pollt: poll表指针, 用于注册等待队列.</span></span><br><span class="line"><span class="comment"> * @return: 一个表示事件状态的位掩码 (如 EPOLLIN).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">__poll_t</span> <span class="title function_">lineinfo_watch_poll</span><span class="params">(<span class="keyword">struct</span> file *file,</span></span><br><span class="line"><span class="params">				    <span class="keyword">struct</span> poll_table_struct *pollt)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 获取本次文件打开的私有会话数据. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_chardev_data</span> *<span class="title">cdev</span> =</span> file-&gt;private_data;</span><br><span class="line">	<span class="type">__poll_t</span> events = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 进入SRCU临界区, 安全检查gpiochip是否存在. */</span></span><br><span class="line">	guard(srcu)(&amp;cdev-&gt;gdev-&gt;srcu);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!rcu_access_pointer(cdev-&gt;gdev-&gt;chip))</span><br><span class="line">		<span class="keyword">return</span> EPOLLHUP | EPOLLERR; <span class="comment">/* 设备已消失, 返回挂起和错误. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 关键一步: 将当前进程注册到cdev-&gt;wait这个等待队列上. 此函数不阻塞. */</span></span><br><span class="line">	poll_wait(file, &amp;cdev-&gt;wait, pollt);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 在持有锁的情况下检查事件FIFO是否为空.</span></span><br><span class="line"><span class="comment">	 * 这个锁与生产者(中断处理程序)使用的锁是同一个, 保证了检查和唤醒的原子性.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!kfifo_is_empty_spinlocked_noirqsave(&amp;cdev-&gt;events,</span><br><span class="line">						 &amp;cdev-&gt;wait.lock))</span><br><span class="line">		<span class="comment">/* 如果FIFO不为空, 表示有数据可读. */</span></span><br><span class="line">		events = EPOLLIN | EPOLLRDNORM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 返回事件掩码. 如果没有事件, 返回0, poll()系统调用会使进程睡眠. */</span></span><br><span class="line">	<span class="keyword">return</span> events;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="lineinfo-watch-read-读取GPIO事件"><a href="#lineinfo-watch-read-读取GPIO事件" class="headerlink" title="lineinfo_watch_read: 读取GPIO事件"></a><code>lineinfo_watch_read</code>: 读取GPIO事件</h2><p>此函数实现了<code>read()</code>系统调用的后端逻辑。它的核心原理是<strong>从客户端私有的FIFO缓冲区中取出一个或多个事件, 并将它们安全地复制到用户空间提供的缓冲区中。如果缓冲区为空, 它会使调用进程进入睡眠, 直到有事件被推入缓冲区并被唤醒。</strong></p>
<p><strong>工作流程详解:</strong></p>
<ol>
<li><strong>获取会话上下文与安全检查</strong>: 与<code>poll</code>函数类似。</li>
<li><strong>阻塞&#x2F;非阻塞逻辑 (主循环内)</strong>:<ul>
<li><strong>加锁</strong>: 使用<code>scoped_guard</code>获取保护FIFO和等待队列的自旋锁。</li>
<li><strong>检查FIFO</strong>: 如果FIFO为空:<ul>
<li>如果之前已经读取过数据(<code>bytes_read &gt; 0</code>), 则立即返回已读取的数据, 避免不必要的阻塞。</li>
<li>如果文件是以<strong>非阻塞</strong>模式(<code>O_NONBLOCK</code>)打开的, 则立即返回<code>-EAGAIN</code>错误, 这是标准的非阻塞I&#x2F;O行为。</li>
<li>如果以上都不是, 则进入<strong>阻塞</strong>状态。<code>wait_event_interruptible_locked</code>是一个强大的宏, 它会自动释放锁, 将进程置于可中断的睡眠状态并加入等待队列。当被唤醒时, 它会自动重新获取锁并继续执行。</li>
</ul>
</li>
<li><strong>出队操作</strong>: 一旦确认FIFO非空(无论是最初就不空, 还是被唤醒后), 就调用<code>kfifo_out</code>从FIFO中取出一个事件到内核的<code>event</code>变量中。</li>
<li><strong>解锁</strong>: <code>scoped_guard</code>在代码块结束时自动释放锁。</li>
</ul>
</li>
<li><strong>API版本兼容性</strong>: <code>#ifdef CONFIG_GPIO_CDEV_V1</code>部分处理了新旧两套API的兼容性问题。它会检查客户端请求的ABI版本, 如果是旧版本, 它会将从FIFO中取出的新版v2事件结构体转换为旧版v1结构体, 然后再复制给用户。</li>
<li><strong>复制到用户空间</strong>: <code>copy_to_user</code>是一个关键的、安全的内存复制函数, 它将内核空间中的<code>event</code>数据复制到用户空间程序提供的<code>buf</code>缓冲区中, 并处理可能发生的地址错误。</li>
<li><strong>循环读取</strong>: <code>do-while</code>循环允许在用户缓冲区足够大的情况下, 一次<code>read()</code>调用读取多个待处理的事件, 提高了效率。</li>
</ol>
<p><strong>在STM32H750上的意义:</strong><br>这两个函数构成了在STM32上进行高性能、事件驱动式GPIO编程的基础。一个监控按键输入的程序无需在循环中不断地轮询GPIO电平(这会浪费大量CPU周期)。取而代之的是, 它可以调用<code>poll()</code>让自己的进程进入睡眠。当STM32的EXTI中断被触发时, 内核中断处理程序(生产者)会将一个事件推入FIFO并唤醒该进程。进程被唤醒后, <code>poll()</code>返回, 进程接着调用<code>read()</code>来获取事件的详细信息(例如, 哪个引脚发生了什么类型的事件)。这种机制在任何现代操作系统中, 对于处理异步硬件事件都是至关重要的, 即使是在单核系统上, 它也能极大地提高系统的响应能力和能效。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * lineinfo_watch_read: read方法实现, 用于读取线路信息变化事件.</span></span><br><span class="line"><span class="comment"> * @file: 文件结构体指针.</span></span><br><span class="line"><span class="comment"> * @buf: 指向用户空间缓冲区的指针.</span></span><br><span class="line"><span class="comment"> * @count: 用户空间缓冲区的大小.</span></span><br><span class="line"><span class="comment"> * @off: 文件偏移量指针 (此处未使用).</span></span><br><span class="line"><span class="comment"> * @return: 成功时返回读取的字节数, 失败时返回负的errno.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">lineinfo_watch_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf,</span></span><br><span class="line"><span class="params">				   <span class="type">size_t</span> count, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_chardev_data</span> *<span class="title">cdev</span> =</span> file-&gt;private_data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_v2_line_info_changed</span> <span class="title">event</span>;</span> <span class="comment">// 内核空间的事件缓冲区</span></span><br><span class="line">	<span class="type">ssize_t</span> bytes_read = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">size_t</span> event_size;</span><br><span class="line"></span><br><span class="line">	guard(srcu)(&amp;cdev-&gt;gdev-&gt;srcu);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!rcu_access_pointer(cdev-&gt;gdev-&gt;chip))</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_GPIO_CDEV_V1</span></span><br><span class="line">	<span class="comment">/* 如果只支持v2 API, 检查用户缓冲区大小是否足够. */</span></span><br><span class="line">	event_size = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> gpio_v2_line_info_changed);</span><br><span class="line">	<span class="keyword">if</span> (count &lt; event_size)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 循环读取, 直到用户缓冲区满或FIFO为空. */</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="comment">/* 使用自旋锁保护对FIFO和等待队列的访问. */</span></span><br><span class="line">		scoped_guard(spinlock, &amp;cdev-&gt;wait.lock) &#123;</span><br><span class="line">			<span class="keyword">if</span> (kfifo_is_empty(&amp;cdev-&gt;events)) &#123;</span><br><span class="line">				<span class="comment">/* 如果已经读到一些数据, 先返回, 避免阻塞. */</span></span><br><span class="line">				<span class="keyword">if</span> (bytes_read)</span><br><span class="line">					<span class="keyword">return</span> bytes_read;</span><br><span class="line"></span><br><span class="line">				<span class="comment">/* 如果是非阻塞模式, 立即返回EAGAIN. */</span></span><br><span class="line">				<span class="keyword">if</span> (file-&gt;f_flags &amp; O_NONBLOCK)</span><br><span class="line">					<span class="keyword">return</span> -EAGAIN;</span><br><span class="line"></span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * 阻塞等待, 直到FIFO不再为空.</span></span><br><span class="line"><span class="comment">				 * wait_event_interruptible_locked会自动处理加锁/解锁和睡眠.</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				ret = wait_event_interruptible_locked(cdev-&gt;wait,</span><br><span class="line">						!kfifo_is_empty(&amp;cdev-&gt;events));</span><br><span class="line">				<span class="keyword">if</span> (ret)</span><br><span class="line">					<span class="keyword">return</span> ret;</span><br><span class="line">			&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GPIO_CDEV_V1</span></span><br><span class="line">			<span class="comment">/* 兼容性处理: 根据客户端请求的ABI版本确定事件大小. */</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="type">atomic_read</span>(&amp;cdev-&gt;watch_abi_version) == <span class="number">2</span>)</span><br><span class="line">				event_size = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> gpio_v2_line_info_changed);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				event_size = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> gpioline_info_changed);</span><br><span class="line">			<span class="keyword">if</span> (count &lt; event_size)</span><br><span class="line">				<span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">			<span class="comment">/* 从FIFO中取出一个事件. */</span></span><br><span class="line">			<span class="keyword">if</span> (kfifo_out(&amp;cdev-&gt;events, &amp;event, <span class="number">1</span>) != <span class="number">1</span>) &#123;</span><br><span class="line">				WARN(<span class="number">1</span>, <span class="string">&quot;failed to read from non-empty kfifo&quot;</span>);</span><br><span class="line">				<span class="keyword">return</span> -EIO;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GPIO_CDEV_V1</span></span><br><span class="line">		<span class="comment">/* 兼容性处理: 如果需要v1格式, 进行转换. */</span></span><br><span class="line">		<span class="keyword">if</span> (event_size == <span class="keyword">sizeof</span>(<span class="keyword">struct</span> gpio_v2_line_info_changed)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (copy_to_user(buf + bytes_read, &amp;event, event_size))</span><br><span class="line">				<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">struct</span> gpioline_info_changed event_v1;</span><br><span class="line">			gpio_v2_line_info_changed_to_v1(&amp;event, &amp;event_v1);</span><br><span class="line">			<span class="keyword">if</span> (copy_to_user(buf + bytes_read, &amp;event_v1, event_size))</span><br><span class="line">				<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		<span class="comment">/* 将内核空间的事件数据安全地复制到用户空间缓冲区. */</span></span><br><span class="line">		<span class="keyword">if</span> (copy_to_user(buf + bytes_read, &amp;event, event_size))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">endif</span><br><span class="line">		bytes_read += event_size;</span><br><span class="line">	&#125; <span class="keyword">while</span> (count &gt;= bytes_read + <span class="keyword">sizeof</span>(event)); <span class="comment">/* 检查是否还有空间读取下一个事件. */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> bytes_read;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="gpio-chrdev-open-打开GPIO字符设备"><a href="#gpio-chrdev-open-打开GPIO字符设备" class="headerlink" title="gpio_chrdev_open: 打开GPIO字符设备"></a>gpio_chrdev_open: 打开GPIO字符设备</h2><p>此函数是Linux GPIO子系统字符设备接口的<code>open</code>方法实现。当一个用户空间程序调用<code>open()</code>系统调用来打开一个GPIO控制器设备文件(例如<code>/dev/gpiochip0</code>)时, 内核就会执行此函数。</p>
<p>它的核心原理是<strong>为一个新的客户端(即一个打开的文件描述符)创建一个独立的、私有的会话上下文</strong>。这个上下文(<code>struct gpio_chardev_data</code>)会存储该特定客户端的所有状态, 例如它正在监视哪些GPIO线、它有哪些待处理的事件等。通过这种方式, 多个不同的用户空间程序可以同时打开并操作同一个GPIO控制器设备文件, 而它们各自的会话状态互不干扰。</p>
<p><strong>工作流程详解:</strong></p>
<ol>
<li><strong>获取设备上下文</strong>: 函数首先通过<code>container_of</code>宏从VFS层传入的通用<code>inode</code>结构体, 反向找到代表整个GPIO控制器设备的<code>struct gpio_device</code> (<code>gdev</code>)。</li>
<li><strong>并发安全检查</strong>: 它使用<code>SRCU</code>(一种专门用于可睡眠上下文的读-拷贝-更新同步机制)来安全地检查底层的<code>gpio_chip</code>是否仍然存在。这是一个至关重要的步骤, 用于防止在用户尝试打开设备的同时, 驱动程序恰好被卸载(即”热拔插”场景), 从而避免了使用无效指针导致的系统崩溃。</li>
<li><strong>分配私有会话数据</strong>: 它调用<code>kzalloc</code>为这次<code>open</code>操作分配一个全新的<code>struct gpio_chardev_data</code>实例(<code>cdev</code>)。这个结构体将作为此文件句柄的私有数据存储。</li>
<li><strong>初始化会话资源</strong>:<ul>
<li><code>bitmap_zalloc</code>: 为<code>cdev-&gt;watched_lines</code>分配一个位图。这个位图的大小等于该GPIO控制器拥有的引脚总数, 用于标记该客户端正在监视哪些引脚的状态变化。</li>
<li><code>init_waitqueue_head</code>: 初始化一个等待队列头(<code>cdev-&gt;wait</code>)。当用户空间程序对此文件句柄调用<code>poll()</code>或<code>select()</code>来等待事件时, 它的进程会在此等待队列上睡眠。</li>
<li><code>INIT_KFIFO</code>: 初始化一个内核FIFO缓冲区(<code>cdev-&gt;events</code>)。当被监视的GPIO引脚上发生事件时, 内核会将事件的详细信息推入此缓冲区, 等待用户空间程序通过<code>read()</code>来取走。</li>
</ul>
</li>
<li><strong>引用计数管理</strong>: 它调用<code>gpio_device_get(gdev)</code>来增加<code>gpio_device</code>的引用计数。这是一个关键的生命周期管理操作, 它确保了只要还有任何一个用户空间程序打开着这个设备文件, <code>gpio_device</code>结构体就不会被内核释放, 即使底层的硬件驱动模块已经被卸载。</li>
<li><strong>注册通知回调 (订阅事件)</strong>: 这是实现事件驱动监控的核心。<ul>
<li>它初始化两个”通知块”(<code>notifier_block</code>), <code>lineinfo_changed_nb</code>和<code>device_unregistered_nb</code>。</li>
<li>它将这两个通知块分别注册到<code>gdev</code>的<code>line_state_notifier</code>和<code>device_notifier</code>通知链中。这相当于为此客户端订阅了两类事件: “某个GPIO线的配置发生了变化”和”整个GPIO设备即将被注销”。当这些事件发生时, 内核会调用这里注册的回调函数(如<code>lineinfo_changed_notify</code>), 这些回调函数会将事件信息放入该客户端私有的FIFO缓冲区并唤醒在等待队列上睡眠的进程。</li>
</ul>
</li>
<li><strong>关联与完成</strong>:<ul>
<li><code>file-&gt;private_data = cdev</code>: <strong>这是将内核VFS与驱动逻辑连接起来的最后一步</strong>。它将新创建的私有会话数据<code>cdev</code>的指针存入<code>struct file</code>的<code>private_data</code>字段中。之后所有对此文件句柄的操作(如<code>ioctl</code>, <code>read</code>, <code>release</code>)都可以通过<code>file-&gt;private_data</code>轻松取回这个会话上下文。</li>
<li><code>nonseekable_open</code>: 调用一个辅助函数, 将此文件标记为不可寻址(seek), 这对于流式设备是标准做法。</li>
</ul>
</li>
</ol>
<p><strong>错误处理:</strong><br>该函数使用了内核中非常标准的<code>goto</code>标签错误处理模式。如果在初始化过程中的任何一步失败, 代码会跳转到相应的标签, 然后像瀑布一样执行所有必要的逆向清理操作(例如, 注销通知、释放位图、减少引用计数、释放内存), 从而保证在函数出错退出时不会留下任何悬挂的资源。</p>
<p><strong>在STM32H750上的意义:</strong><br>在STM32H750上, 当一个用户空间应用(如通过<code>libgpiod</code>编写的程序)执行<code>open(&quot;/dev/gpiochip0&quot;, ...)</code>时, 内核就会执行此函数来为该应用准备好一个与GPIOA控制器交互的通道。此后, 该应用就可以通过<code>ioctl</code>来配置引脚, 或通过<code>poll</code>和<code>read</code>来实时监控引脚电平或边沿触发事件。<code>write_lock_irqsave</code>等锁机制在单核抢占式系统上依然是必需的, 它通过禁用本地中断和抢占来保护对通知链表等共享资源的访问, 防止数据结构被并发修改所破坏。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * gpio_chrdev_open() - 为ioctl操作打开字符设备</span></span><br><span class="line"><span class="comment"> * @inode: 此字符设备的inode</span></span><br><span class="line"><span class="comment"> * @file: 用于存储私有数据的文件结构体</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回: 成功时返回0, 失败时返回负的errno.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_chrdev_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 从inode中内嵌的cdev成员, 反向找到其容器gpio_device结构体的地址. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_device</span> *<span class="title">gdev</span> =</span> container_of(inode-&gt;i_cdev,</span><br><span class="line">						<span class="keyword">struct</span> gpio_device, chrdev);</span><br><span class="line">	<span class="comment">/* cdev是为本次open调用分配的私有数据. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_chardev_data</span> *<span class="title">cdev</span>;</span></span><br><span class="line">	<span class="type">int</span> ret = -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 进入一个SRCU读端临界区, 保护对gdev-&gt;chip指针的访问.</span></span><br><span class="line"><span class="comment">	 * 确保在我们检查它的时候, 它不会被并发地移除.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	guard(srcu)(&amp;gdev-&gt;srcu);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果底层的gpiochip已经消失了, 则打开失败. */</span></span><br><span class="line">	<span class="keyword">if</span> (!rcu_access_pointer(gdev-&gt;chip))</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 为本次打开分配私有数据结构. */</span></span><br><span class="line">	cdev = kzalloc(<span class="keyword">sizeof</span>(*cdev), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!cdev)</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 分配一个位图, 用于记录此客户端监视了哪些线路. */</span></span><br><span class="line">	cdev-&gt;watched_lines = bitmap_zalloc(gdev-&gt;ngpio, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!cdev-&gt;watched_lines)</span><br><span class="line">		<span class="keyword">goto</span> out_free_cdev;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化用于poll()的等待队列和用于存储事件的FIFO缓冲区. */</span></span><br><span class="line">	init_waitqueue_head(&amp;cdev-&gt;wait);</span><br><span class="line">	<span class="comment">/* DECLARE_KFIFO(events, struct gpioevent_data, 16); */</span></span><br><span class="line">	INIT_KFIFO(cdev-&gt;events);</span><br><span class="line">	<span class="comment">/* 增加gpio_device的引用计数, 防止其在我们使用期间被释放. */</span></span><br><span class="line">	cdev-&gt;gdev = gpio_device_get(gdev);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 准备一个通知块, 用于接收线路配置变化的通知. */</span></span><br><span class="line">	cdev-&gt;lineinfo_changed_nb.notifier_call = lineinfo_changed_notify;</span><br><span class="line">	<span class="comment">/* 加锁并注册这个通知块到gdev的线路状态通知链中. */</span></span><br><span class="line">	scoped_guard(write_lock_irqsave, &amp;gdev-&gt;line_state_lock)</span><br><span class="line">		ret = raw_notifier_chain_register(&amp;gdev-&gt;line_state_notifier,</span><br><span class="line">						  &amp;cdev-&gt;lineinfo_changed_nb);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">goto</span> out_free_bitmap;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 准备另一个通知块, 用于接收整个设备被注销的通知. */</span></span><br><span class="line">	cdev-&gt;device_unregistered_nb.notifier_call =</span><br><span class="line">					gpio_device_unregistered_notify;</span><br><span class="line">	<span class="comment">/* 注册这个通知块到gdev的设备通知链中. */</span></span><br><span class="line">	ret = blocking_notifier_chain_register(&amp;gdev-&gt;device_notifier,</span><br><span class="line">					       &amp;cdev-&gt;device_unregistered_nb);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">goto</span> out_unregister_line_notifier;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 关键一步: 将我们新创建的私有数据cdev与文件句柄file关联起来. */</span></span><br><span class="line">	file-&gt;private_data = cdev;</span><br><span class="line">	cdev-&gt;fp = file;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 将此文件标记为不可寻址. */</span></span><br><span class="line">	ret = nonseekable_open(inode, file);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">goto</span> out_unregister_device_notifier;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- 错误处理回滚路径 -- */</span></span><br><span class="line">out_unregister_device_notifier:</span><br><span class="line">	blocking_notifier_chain_unregister(&amp;gdev-&gt;device_notifier,</span><br><span class="line">					   &amp;cdev-&gt;device_unregistered_nb);</span><br><span class="line">out_unregister_line_notifier:</span><br><span class="line">	scoped_guard(write_lock_irqsave, &amp;gdev-&gt;line_state_lock)</span><br><span class="line">		raw_notifier_chain_unregister(&amp;gdev-&gt;line_state_notifier,</span><br><span class="line">					      &amp;cdev-&gt;lineinfo_changed_nb);</span><br><span class="line">out_free_bitmap:</span><br><span class="line">	gpio_device_put(gdev);</span><br><span class="line">	bitmap_free(cdev-&gt;watched_lines);</span><br><span class="line">out_free_cdev:</span><br><span class="line">	kfree(cdev);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="GPIO字符设备接口的注册与注销"><a href="#GPIO字符设备接口的注册与注销" class="headerlink" title="GPIO字符设备接口的注册与注销"></a>GPIO字符设备接口的注册与注销</h2><h3 id="gpio-fileops-文件操作函数集"><a href="#gpio-fileops-文件操作函数集" class="headerlink" title="gpio_fileops: 文件操作函数集"></a><code>gpio_fileops</code>: 文件操作函数集</h3><p>这是一个静态常量结构体, 它像一张”功能表”, 定义了当用户空间对本驱动创建的字符设备文件进行操作时, 内核应该调用哪些具体的函数来响应该操作。这是连接VFS和GPIO驱动功能的桥梁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义一个静态的、常量类型的 file_operations 结构体.</span></span><br><span class="line"><span class="comment"> * 它将标准的文件操作映射到我们驱动中特定的处理函数.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">gpio_fileops</span> =</span> &#123;</span><br><span class="line">	<span class="comment">/* .release: 当最后一个打开此文件的进程关闭文件描述符时, 调用 gpio_chrdev_release 函数. */</span></span><br><span class="line">	.release = gpio_chrdev_release,</span><br><span class="line">	<span class="comment">/* .open: 当用户空间调用 open() 系统调用打开此设备文件时, 调用 gpio_chrdev_open 函数. */</span></span><br><span class="line">	.open = gpio_chrdev_open,</span><br><span class="line">	<span class="comment">/* .poll: 当用户空间对此文件描述符使用 poll() 或 select() 等待事件时, 调用 lineinfo_watch_poll. 用于监控GPIO线状态变化. */</span></span><br><span class="line">	.poll = lineinfo_watch_poll,</span><br><span class="line">	<span class="comment">/* .read: 当用户空间从此文件描述符读取数据时, 调用 lineinfo_watch_read. 用于读取GPIO线状态变化事件. */</span></span><br><span class="line">	.read = lineinfo_watch_read,</span><br><span class="line">	<span class="comment">/* .owner: 将这个文件操作集的所有者设置为当前模块. 这可以防止在设备仍被使用时卸载模块. */</span></span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">	<span class="comment">/* .unlocked_ioctl: 当用户空间对此文件描述符使用 ioctl() 系统调用时, 调用 gpio_ioctl 函数. 这是主要的控制接口. */</span></span><br><span class="line">	.unlocked_ioctl = gpio_ioctl,</span><br><span class="line"><span class="comment">/* 如果内核配置支持32位程序在64位内核上运行的兼容模式. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line">	<span class="comment">/* .compat_ioctl: 为兼容模式下的ioctl调用指定一个特殊的处理函数. */</span></span><br><span class="line">	.compat_ioctl = gpio_ioctl_compat,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="gpiolib-cdev-register-注册GPIO字符设备"><a href="#gpiolib-cdev-register-注册GPIO字符设备" class="headerlink" title="gpiolib_cdev_register: 注册GPIO字符设备"></a><code>gpiolib_cdev_register</code>: 注册GPIO字符设备</h3><p>此函数负责为一个GPIO设备(<code>gdev</code>)执行所有必要的步骤, 来创建一个功能齐全、可供用户空间访问的字符设备。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * gpiolib_cdev_register: 为一个gpio_device注册一个字符设备.</span></span><br><span class="line"><span class="comment"> * @gdev: 指向要注册的gpio_device的指针.</span></span><br><span class="line"><span class="comment"> * @devt: 包含此字符设备主设备号的dev_t类型变量.</span></span><br><span class="line"><span class="comment"> * @return: 成功时返回 0, 失败时返回负的错误码.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">gpiolib_cdev_register</span><span class="params">(<span class="keyword">struct</span> gpio_device *gdev, <span class="type">dev_t</span> devt)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_chip</span> *<span class="title">gc</span>;</span></span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 步骤1: 初始化字符设备结构体.</span></span><br><span class="line"><span class="comment">	 * 调用 cdev_init, 将 gdev 内嵌的 chrdev 结构体与我们上面定义的 gpio_fileops 功能表关联起来.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	cdev_init(&amp;gdev-&gt;chrdev, &amp;gpio_fileops);</span><br><span class="line">	<span class="comment">/* 设置字符设备的所有者为当前模块, 用于引用计数管理. */</span></span><br><span class="line">	gdev-&gt;chrdev.owner = THIS_MODULE;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 步骤2: 创建最终的设备号.</span></span><br><span class="line"><span class="comment">	 * 使用 MKDEV 宏, 结合传入的主设备号(MAJOR(devt))和gdev自身的唯一ID(gdev-&gt;id)作为次设备号,</span></span><br><span class="line"><span class="comment">	 * 来生成一个完整的、唯一的设备号. 例如, (主设备号 254, 次设备号 0) -&gt; /dev/gpiochip0.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	gdev-&gt;dev.devt = MKDEV(MAJOR(devt), gdev-&gt;id);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 步骤3: 分配一个工作队列.</span></span><br><span class="line"><span class="comment">	 * alloc_ordered_workqueue 创建一个保证工作项按提交顺序串行执行的工作队列.</span></span><br><span class="line"><span class="comment">	 * WQ_HIGHPRI 表示队列中的工作项具有高调度优先级.</span></span><br><span class="line"><span class="comment">	 * 这个队列用于异步处理GPIO线的状态变化事件, 避免在中断上下文中执行耗时操作.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	gdev-&gt;line_state_wq = alloc_ordered_workqueue(<span class="string">&quot;%s&quot;</span>, WQ_HIGHPRI,</span><br><span class="line">						      dev_name(&amp;gdev-&gt;dev));</span><br><span class="line">	<span class="keyword">if</span> (!gdev-&gt;line_state_wq)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 步骤4: 添加字符设备到系统, 并创建设备节点.</span></span><br><span class="line"><span class="comment">	 * cdev_device_add 是一个复合操作, 它:</span></span><br><span class="line"><span class="comment">	 * 1. 调用 cdev_add(), 使字符设备对内核VFS层&quot;生效&quot;.</span></span><br><span class="line"><span class="comment">	 * 2. 调用 device_create(), 触发udev/mdev在/dev目录下创建对应的设备文件.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ret = cdev_device_add(&amp;gdev-&gt;chrdev, &amp;gdev-&gt;dev);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 步骤5: 安全地获取底层的 gpio_chip 指针.</span></span><br><span class="line"><span class="comment">	 * gdev-&gt;chip 指针可能被并发地修改. SRCU(Sleepable Read-Copy Update)是一种轻量级同步机制.</span></span><br><span class="line"><span class="comment">	 * guard(srcu) 宏定义了一个读端临界区.</span></span><br><span class="line"><span class="comment">	 * 在单核抢占式系统上, 它能防止在解引用 gdev-&gt;chip 时, 恰好被一个正在修改该指针的更高优先级任务抢占.</span></span><br><span class="line"><span class="comment">	 * srcu_dereference 安全地获取一个在该临界区内保证有效的 gpio_chip 指针.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	guard(srcu)(&amp;gdev-&gt;srcu);</span><br><span class="line">	gc = srcu_dereference(gdev-&gt;chip, &amp;gdev-&gt;srcu);</span><br><span class="line">	<span class="keyword">if</span> (!gc)</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 打印一条调试日志, 宣告字符设备添加成功. */</span></span><br><span class="line">	chip_dbg(gc, <span class="string">&quot;added GPIO chardev (%d:%d)\n&quot;</span>, MAJOR(devt), gdev-&gt;id);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="gpiolib-cdev-unregister-注销GPIO字符设备"><a href="#gpiolib-cdev-unregister-注销GPIO字符设备" class="headerlink" title="gpiolib_cdev_unregister: 注销GPIO字符设备"></a><code>gpiolib_cdev_unregister</code>: 注销GPIO字符设备</h3><p>此函数是注册函数的逆过程, 负责清理和释放所有相关资源。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * gpiolib_cdev_unregister: 注销一个gpio_device的字符设备.</span></span><br><span class="line"><span class="comment"> * @gdev: 指向要注销的gpio_device的指针.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">gpiolib_cdev_unregister</span><span class="params">(<span class="keyword">struct</span> gpio_device *gdev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 销毁之前为处理线路状态变化而分配的工作队列. */</span></span><br><span class="line">	destroy_workqueue(gdev-&gt;line_state_wq);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 从系统中移除字符设备. cdev_device_del 是一个复合操作, 它:</span></span><br><span class="line"><span class="comment">	 * 1. 调用 device_destroy(), 触发udev/mdev从/dev目录删除设备文件.</span></span><br><span class="line"><span class="comment">	 * 2. 调用 cdev_del(), 使字符设备从VFS层失效.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	cdev_device_del(&amp;gdev-&gt;chrdev, &amp;gdev-&gt;dev);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 调用阻塞通知链, 告知系统中其他可能关心此设备的模块, 该设备正在被移除.</span></span><br><span class="line"><span class="comment">	 * 这允许其他模块执行相应的清理工作.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	blocking_notifier_call_chain(&amp;gdev-&gt;device_notifier, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="drivers-gpio-gpio-stmpe-c"><a href="#drivers-gpio-gpio-stmpe-c" class="headerlink" title="drivers&#x2F;gpio&#x2F;gpio-stmpe.c"></a>drivers&#x2F;gpio&#x2F;gpio-stmpe.c</h1><h2 id="STMPE-GPIO-操作回调函数集"><a href="#STMPE-GPIO-操作回调函数集" class="headerlink" title="STMPE GPIO 操作回调函数集"></a>STMPE GPIO 操作回调函数集</h2><h3 id="stmpe-gpio-get-获取GPIO引脚的输入电平"><a href="#stmpe-gpio-get-获取GPIO引脚的输入电平" class="headerlink" title="stmpe_gpio_get: 获取GPIO引脚的输入电平"></a><code>stmpe_gpio_get</code>: 获取GPIO引脚的输入电平</h3><ul>
<li><strong>作用</strong>: 当内核或用户空间需要读取一个GPIO引脚的当前逻辑状态(高电平或低电平)时, <code>gpiolib</code>框架会调用此函数。</li>
<li><strong>原理</strong>:<ol>
<li><strong>获取上下文</strong>: <code>gpiochip_get_data(chip)</code>获取到指向本驱动私有数据<code>stmpe_gpio</code>的指针, 从而可以访问到与父设备通信的<code>stmpe</code>句柄。</li>
<li><strong>定位寄存器</strong>: <code>stmpe-&gt;regs</code>是一个数组, 存储了不同功能寄存器的基地址。<code>STMPE_IDX_GPMR_LSB</code>是”GPIO Pin Monitor Register”(GPIO引脚监视寄存器)的基地址索引。<code>offset / 8</code>计算出该引脚属于哪个8位的寄存器(哪个bank)。</li>
<li><strong>定位比特位</strong>: <code>BIT(offset % 8)</code>计算出该引脚在8位寄存器中所对应的比特位掩码(例如, <code>offset</code>为10, 掩码为<code>BIT(2)</code>, 即<code>0x04</code>)。</li>
<li><strong>硬件交互</strong>: <code>stmpe_reg_read</code>通过I2C&#x2F;SPI总线读取目标寄存器的值。</li>
<li><strong>解析结果</strong>: <code>ret &amp; mask</code>从读取到的8位值中分离出我们关心的那一位。<code>!!</code>是一个C语言技巧, 用于将任何非零值转换为1, 0值保持为0, 确保返回值是标准的逻辑值。</li>
</ol>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">stmpe_gpio_get</span><span class="params">(<span class="keyword">struct</span> gpio_chip *chip, <span class="type">unsigned</span> offset)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stmpe_gpio</span> *<span class="title">stmpe_gpio</span> =</span> gpiochip_get_data(chip);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stmpe</span> *<span class="title">stmpe</span> =</span> stmpe_gpio-&gt;stmpe;</span><br><span class="line">	<span class="comment">/* 计算要读取的监视寄存器的确切地址 */</span></span><br><span class="line">	u8 reg = stmpe-&gt;regs[STMPE_IDX_GPMR_LSB + (offset / <span class="number">8</span>)];</span><br><span class="line">	<span class="comment">/* 计算要操作的比特位的掩码 */</span></span><br><span class="line">	u8 mask = BIT(offset % <span class="number">8</span>);</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 通过父驱动提供的函数, 经由I2C/SPI总线读取寄存器 */</span></span><br><span class="line">	ret = stmpe_reg_read(stmpe, reg);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> ret; <span class="comment">// 如果读取失败, 向上层返回错误码</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 将读取到的值与掩码进行按位与, 并将结果转换为 1 或 0 */</span></span><br><span class="line">	<span class="keyword">return</span> !!(ret &amp; mask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="stmpe-gpio-set-设置GPIO引脚的输出电平"><a href="#stmpe-gpio-set-设置GPIO引脚的输出电平" class="headerlink" title="stmpe_gpio_set: 设置GPIO引脚的输出电平"></a><code>stmpe_gpio_set</code>: 设置GPIO引脚的输出电平</h3><ul>
<li><strong>作用</strong>: 当需要将一个配置为输出的GPIO引脚设置为高电平或低电平时, <code>gpiolib</code>会调用此函数。</li>
<li><strong>原理</strong>:<ol>
<li><strong>选择操作</strong>: STMPE芯片通常有独立的”GPIO Pin Set Register”(GPSR, 写1置位)和”GPIO Pin Clear Register”(GPCR, 写1清零)。函数根据传入的<code>val</code>值(1或0)来选择<code>which</code>寄存器基址。</li>
<li><strong>定位</strong>: 与<code>get</code>函数一样, 计算出确切的寄存器地址和比特位掩码。</li>
<li><strong>特殊处理</strong>: 某些STMPE芯片型号可能只有一个寄存器用于置位&#x2F;清零。代码通过比较GPSR和GPCR的地址是否相同来检测这种情况。如果是, 它会调用<code>stmpe_set_bits</code>(一个读-修改-写操作)来设置或清除相应的位。</li>
<li><strong>标准操作</strong>: 对于有独立置位&#x2F;清零寄存器的型号, 只需向选定的寄存器写入掩码即可触发硬件操作。<code>stmpe_reg_write</code>完成这个总线写操作。</li>
</ol>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">stmpe_gpio_set</span><span class="params">(<span class="keyword">struct</span> gpio_chip *chip, <span class="type">unsigned</span> <span class="type">int</span> offset, <span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stmpe_gpio</span> *<span class="title">stmpe_gpio</span> =</span> gpiochip_get_data(chip);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stmpe</span> *<span class="title">stmpe</span> =</span> stmpe_gpio-&gt;stmpe;</span><br><span class="line">	<span class="comment">/* 根据 val 的值选择置位(Set)或清零(Clear)寄存器 */</span></span><br><span class="line">	<span class="type">int</span> which = val ? STMPE_IDX_GPSR_LSB : STMPE_IDX_GPCR_LSB;</span><br><span class="line">	u8 reg = stmpe-&gt;regs[which + (offset / <span class="number">8</span>)];</span><br><span class="line">	u8 mask = BIT(offset % <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 检查是否是只有一个set/clear寄存器的特殊型号 */</span></span><br><span class="line">	<span class="keyword">if</span> (stmpe-&gt;regs[STMPE_IDX_GPSR_LSB] == stmpe-&gt;regs[STMPE_IDX_GPCR_LSB])</span><br><span class="line">		<span class="comment">/* 是, 则使用读-修改-写操作 */</span></span><br><span class="line">		<span class="keyword">return</span> stmpe_set_bits(stmpe, reg, mask, val ? mask : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 否, 直接向选定的寄存器写入掩码即可 */</span></span><br><span class="line">	<span class="keyword">return</span> stmpe_reg_write(stmpe, reg, mask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="stmpe-gpio-get-direction-获取GPIO引脚的方向"><a href="#stmpe-gpio-get-direction-获取GPIO引脚的方向" class="headerlink" title="stmpe_gpio_get_direction: 获取GPIO引脚的方向"></a><code>stmpe_gpio_get_direction</code>: 获取GPIO引脚的方向</h3><ul>
<li><strong>作用</strong>: 查询一个GPIO引脚当前是被配置为输入还是输出。</li>
<li><strong>原理</strong>: 此操作围绕”GPIO Pin Direction Register”(GPDR)进行。<ol>
<li><strong>定位</strong>: 计算GPDR寄存器的地址和比特位掩码。注意这里有一个<code> - (offset / 8)</code>的笔误, 应该是<code>+</code>, 假设在父驱动的寄存器地址表中已做了修正。</li>
<li><strong>硬件交互</strong>: 读取GPDR寄存器的值。</li>
<li><strong>解析</strong>: 检查对应的比特位。根据STMPE的数据手册, 如果该位是1, 表示输出; 如果是0, 表示输入。函数返回<code>gpiolib</code>定义的标准方向常量。</li>
</ol>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">stmpe_gpio_get_direction</span><span class="params">(<span class="keyword">struct</span> gpio_chip *chip,</span></span><br><span class="line"><span class="params">				    <span class="type">unsigned</span> offset)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stmpe_gpio</span> *<span class="title">stmpe_gpio</span> =</span> gpiochip_get_data(chip);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stmpe</span> *<span class="title">stmpe</span> =</span> stmpe_gpio-&gt;stmpe;</span><br><span class="line">	<span class="comment">/* 计算方向寄存器的地址 (注意代码中的&#x27;-&#x27;可能是笔误, 通常是&#x27;+&#x27;) */</span></span><br><span class="line">	u8 reg = stmpe-&gt;regs[STMPE_IDX_GPDR_LSB] + (offset / <span class="number">8</span>); </span><br><span class="line">	u8 mask = BIT(offset % <span class="number">8</span>);</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	ret = stmpe_reg_read(stmpe, reg);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果对应位是1, 返回输出; 否则返回输入 */</span></span><br><span class="line">	<span class="keyword">if</span> (ret &amp; mask)</span><br><span class="line">		<span class="keyword">return</span> GPIO_LINE_DIRECTION_OUT;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> GPIO_LINE_DIRECTION_IN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="stmpe-gpio-direction-output-stmpe-gpio-direction-input-设置GPIO引脚的方向"><a href="#stmpe-gpio-direction-output-stmpe-gpio-direction-input-设置GPIO引脚的方向" class="headerlink" title="stmpe_gpio_direction_output &#x2F; stmpe_gpio_direction_input: 设置GPIO引脚的方向"></a><code>stmpe_gpio_direction_output</code> &#x2F; <code>stmpe_gpio_direction_input</code>: 设置GPIO引脚的方向</h3><ul>
<li><strong>作用</strong>: 将一个GPIO引脚配置为输入或输出模式。</li>
<li><strong>原理</strong>:<ol>
<li><strong><code>direction_output</code></strong>: 这是一个两步操作, 以避免引脚在方向切换瞬间产生不确定的电平(毛刺)。<ul>
<li>首先调用<code>stmpe_gpio_set</code>预先设置好期望的输出电平<code>val</code>。此时方向尚未改变, 但硬件内部状态已准备好。</li>
<li>然后调用<code>stmpe_set_bits</code>(一个安全的读-修改-写函数), 将GPDR寄存器中对应的比特位置为1, 正式将引脚切换为输出模式。</li>
</ul>
</li>
<li><strong><code>direction_input</code></strong>: 这是一个单步操作。只需调用<code>stmpe_set_bits</code>将GPDR寄存器中对应的比特位清零即可。</li>
</ol>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">stmpe_gpio_direction_output</span><span class="params">(<span class="keyword">struct</span> gpio_chip *chip,</span></span><br><span class="line"><span class="params">					 <span class="type">unsigned</span> offset, <span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stmpe_gpio</span> *<span class="title">stmpe_gpio</span> =</span> gpiochip_get_data(chip);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stmpe</span> *<span class="title">stmpe</span> =</span> stmpe_gpio-&gt;stmpe;</span><br><span class="line">	u8 reg = stmpe-&gt;regs[STMPE_IDX_GPDR_LSB + (offset / <span class="number">8</span>)];</span><br><span class="line">	u8 mask = BIT(offset % <span class="number">8</span>);</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 步骤1: 先设置好输出值 */</span></span><br><span class="line">	ret = stmpe_gpio_set(chip, offset, val);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 步骤2: 再将方向寄存器的对应位置1, 设为输出 */</span></span><br><span class="line">	<span class="keyword">return</span> stmpe_set_bits(stmpe, reg, mask, mask);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">stmpe_gpio_direction_input</span><span class="params">(<span class="keyword">struct</span> gpio_chip *chip,</span></span><br><span class="line"><span class="params">					<span class="type">unsigned</span> offset)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stmpe_gpio</span> *<span class="title">stmpe_gpio</span> =</span> gpiochip_get_data(chip);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stmpe</span> *<span class="title">stmpe</span> =</span> stmpe_gpio-&gt;stmpe;</span><br><span class="line">	u8 reg = stmpe-&gt;regs[STMPE_IDX_GPDR_LSB + (offset / <span class="number">8</span>)];</span><br><span class="line">	u8 mask = BIT(offset % <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 将方向寄存器的对应位清0, 设为输入 */</span></span><br><span class="line">	<span class="keyword">return</span> stmpe_set_bits(stmpe, reg, mask, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="stmpe-gpio-request-请求使用一个GPIO"><a href="#stmpe-gpio-request-请求使用一个GPIO" class="headerlink" title="stmpe_gpio_request: 请求使用一个GPIO"></a><code>stmpe_gpio_request</code>: 请求使用一个GPIO</h3><ul>
<li><strong>作用</strong>: 当一个驱动程序首次通过<code>gpio_request()</code>或<code>gpiod_get()</code>请求使用某个GPIO时, <code>gpiolib</code>会调用此函数。这是执行一次性初始化配置的理想位置。</li>
<li><strong>原理</strong>:<ol>
<li><strong>检查保留位</strong>: 首先检查该引脚<code>offset</code>是否在<code>norequest_mask</code>(从设备树读取)中被标记为保留。如果是, 则返回<code>-EINVAL</code>拒绝请求。</li>
<li><strong>设置复用功能</strong>: STMPE芯片的引脚通常是多功能的(例如, GPIO, ADC, PWM等)。<code>stmpe_set_altfunc</code>是一个父驱动提供的函数, 它会通过总线向芯片发送命令, 确保该引脚的复用功能被正确地设置为GPIO模式。这是确保引脚能作为通用IO使用的关键一步。</li>
</ol>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">stmpe_gpio_request</span><span class="params">(<span class="keyword">struct</span> gpio_chip *chip, <span class="type">unsigned</span> offset)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stmpe_gpio</span> *<span class="title">stmpe_gpio</span> =</span> gpiochip_get_data(chip);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stmpe</span> *<span class="title">stmpe</span> =</span> stmpe_gpio-&gt;stmpe;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 检查该引脚是否被标记为不可请求 */</span></span><br><span class="line">	<span class="keyword">if</span> (stmpe_gpio-&gt;norequest_mask &amp; BIT(offset))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 调用父驱动函数, 将该引脚的复用功能设置为GPIO */</span></span><br><span class="line">	<span class="keyword">return</span> stmpe_set_altfunc(stmpe, BIT(offset), STMPE_BLOCK_GPIO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="STMPE-GPIO驱动的核心实现"><a href="#STMPE-GPIO驱动的核心实现" class="headerlink" title="STMPE GPIO驱动的核心实现"></a>STMPE GPIO驱动的核心实现</h2><p>此代码片段展示了<code>stmpe-gpio</code>驱动程序的核心部分: 它定义了驱动的私有数据结构, 并提供了所有必要的回调函数, 以将STMPE IO扩展器的硬件操作与Linux内核通用的<code>gpiolib</code>框架连接起来。其核心原理是<strong>将<code>gpiolib</code>的抽象请求(如”设置引脚5为高电平”)转换为对STMPE芯片的具体、面向寄存器的I2C&#x2F;SPI总线操作</strong>。</p>
<hr>
<h3 id="struct-stmpe-gpio-驱动私有数据结构"><a href="#struct-stmpe-gpio-驱动私有数据结构" class="headerlink" title="struct stmpe_gpio: 驱动私有数据结构"></a><code>struct stmpe_gpio</code>: 驱动私有数据结构</h3><p>这个结构体是<code>stmpe-gpio</code>驱动实例的”大脑”, 它包含了驱动运行时所需的所有状态和信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 宏定义: CACHE_NR_REGS</span></span><br><span class="line"><span class="comment"> * 定义了需要缓存的寄存器类型的数量 (例如: 中断使能, 边沿检测等), 这里是3.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CACHE_NR_REGS	3</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 宏定义: CACHE_NR_BANKS</span></span><br><span class="line"><span class="comment"> * STMPE芯片最多有24个GPIO, 每8个GPIO由一组寄存器管理 (一个bank).</span></span><br><span class="line"><span class="comment"> * 因此, 24/8 = 3, 需要3个bank的缓存.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CACHE_NR_BANKS	(24 / 8)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * stmpe_gpio 结构体定义.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stmpe_gpio</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * .chip: 内嵌的 gpio_chip 结构体. 这是与gpiolib框架交互的核心.</span></span><br><span class="line"><span class="comment">	 * probe函数会用下面的 template_chip 来初始化它.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_chip</span> <span class="title">chip</span>;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * .stmpe: 指向父设备(核心STMPE驱动)数据结构的指针.</span></span><br><span class="line"><span class="comment">	 * 通过这个指针, 本驱动可以调用 stmpe_reg_read(), stmpe_reg_write() 等函数来与硬件通信.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stmpe</span> *<span class="title">stmpe</span>;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * .irq_lock: 一个互斥锁.</span></span><br><span class="line"><span class="comment">	 * 用于保护对中断相关寄存器的读-修改-写操作, 防止竞态条件.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">irq_lock</span>;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * .norequest_mask: 一个32位的位掩码.</span></span><br><span class="line"><span class="comment">	 * 用于标记哪些GPIO引脚是保留的, 不应被gpiolib分配和使用.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u32 norequest_mask;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * .regs, .oldregs: 两个二维数组, 用于在中断处理期间缓存寄存器的值.</span></span><br><span class="line"><span class="comment">	 * 当需要一次性读/写多个中断控制寄存器以避免多次总线锁定时, 这个缓存非常有用.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u8 regs[CACHE_NR_REGS][CACHE_NR_BANKS];</span><br><span class="line">	u8 oldregs[CACHE_NR_REGS][CACHE_NR_BANKS];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="template-chip-gpiolib接口的”蓝图”"><a href="#template-chip-gpiolib接口的”蓝图”" class="headerlink" title="template_chip: gpiolib接口的”蓝图”"></a><code>template_chip</code>: gpiolib接口的”蓝图”</h3><p>这个静态常量结构体将上面定义的所有回调函数打包在一起, 作为注册到<code>gpiolib</code>的模板。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义一个静态常量 gpio_chip 结构体, 作为模板.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio_chip</span> <span class="title">template_chip</span> =</span> &#123;</span><br><span class="line">	<span class="comment">/* .label: 在sysfs和调试信息中显示的名称. */</span></span><br><span class="line">	.label			= <span class="string">&quot;stmpe&quot;</span>,</span><br><span class="line">	<span class="comment">/* .owner: 指向拥有此驱动的模块, 用于管理模块引用计数. */</span></span><br><span class="line">	.owner			= THIS_MODULE,</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 将 gpiolib 的标准操作函数指针, 指向我们上面实现的具体函数.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	.get_direction		= stmpe_gpio_get_direction,</span><br><span class="line">	.direction_input	= stmpe_gpio_direction_input,</span><br><span class="line">	.get			= stmpe_gpio_get,</span><br><span class="line">	.direction_output	= stmpe_gpio_direction_output,</span><br><span class="line">	.<span class="built_in">set</span>			= stmpe_gpio_set,</span><br><span class="line">	.request		= stmpe_gpio_request,</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * .can_sleep = true: 这是一个非常重要的标志.</span></span><br><span class="line"><span class="comment">	 * 它告诉gpiolib框架, 这个驱动的所有回调函数都可能会&quot;睡眠&quot;(例如, 等待I2C/SPI总线操作完成).</span></span><br><span class="line"><span class="comment">	 * gpiolib会据此调整其内部行为, 例如在使用这些GPIO时不会禁用中断或持有自旋锁.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	.can_sleep		= <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="stmpe-gpio-probe-初始化STMPE-IO扩展器的GPIO功能"><a href="#stmpe-gpio-probe-初始化STMPE-IO扩展器的GPIO功能" class="headerlink" title="stmpe_gpio_probe: 初始化STMPE IO扩展器的GPIO功能"></a>stmpe_gpio_probe: 初始化STMPE IO扩展器的GPIO功能</h2><p>此函数是<code>stmpe-gpio</code>平台驱动程序的探测函数, 它是驱动程序的核心入口点。当内核的设备模型发现一个与此驱动匹配的设备时(通常是通过设备树), 就会调用此函数。它的核心作用是将一个物理上的STMPE芯片(通过I2C或SPI连接的外部IO扩展器)的GPIO功能, 初始化并注册到Linux内核通用的<code>gpiolib</code>子系统中, 使这些外部IO引脚能像处理器片上GPIO一样被系统标准地访问和控制。</p>
<p>其工作原理可以分解为以下几个关键步骤:</p>
<ol>
<li><strong>获取父设备数据与内存分配</strong>: 此驱动是一个”多功能设备”(MFD, Multi-Function Device)的客户端。它首先从其父设备(即主<code>stmpe</code>驱动, 负责I2C&#x2F;SPI通信)获取一个指向<code>stmpe</code>核心数据结构的句柄。然后, 它使用<code>devm_kzalloc</code>为自身的状态结构<code>stmpe_gpio</code>分配内存, 这种内存分配方式确保了在驱动卸载时资源能被自动释放, 极大地简化了错误处理。</li>
<li><strong>配置<code>gpio_chip</code>结构体</strong>: <code>gpio_chip</code>是<code>gpiolib</code>框架的核心, 它像一个”驱动蓝图”, 包含了一系列函数指针, 用于定义如何对GPIO进行读、写、设置方向等操作。此函数使用一个预定义的<code>template_chip</code>作为模板, 并根据从父设备获取的信息(如GPIO数量)对其进行定制。将<code>base</code>设置为-1, 是让<code>gpiolib</code>动态地为这些GPIO分配一个未被占用的编号区间。</li>
<li><strong>硬件使能与中断处理</strong>: 它调用父驱动提供的<code>stmpe_enable</code>函数, 向物理芯片发送命令以开启GPIO功能块。这是实际的硬件交互。接着, 它处理中断:<ul>
<li>它获取一个由STMPE芯片产生的中断号。这个中断是”共享的”, 即芯片上任何一个GPIO产生中断, 都会触发这一根物理中断线。</li>
<li>它注册一个<strong>线程化中断处理程序</strong>(<code>stmpe_gpio_irq</code>)。当物理中断发生时, 内核会唤醒一个专门的内核线程来执行这个处理函数, 这对于通过较慢总线(如I2C)连接的设备是最佳实践, 避免在中断上下文中进行耗时操作。</li>
<li>它配置<code>gpio_irq_chip</code>结构。这是将<code>gpiolib</code>和<code>irqchip</code>(中断控制器)框架连接起来的”胶水”。它定义了如何为单个GPIO使能&#x2F;屏蔽中断、设置触发类型等操作。当上层请求某个GPIO的中断时, <code>gpiolib</code>会通过<code>gpio_irq_chip</code>中的函数指针, 调用本驱动的相应函数来操作硬件。</li>
</ul>
</li>
<li><strong>注册到GPIOLIB</strong>: 最后, 它调用<code>devm_gpiochip_add_data</code>, 将完全配置好的<code>gpio_chip</code>注册到<code>gpiolib</code>中。一旦注册成功, 系统中其他任何部分(包括用户空间)就可以通过标准的GPIO接口(例如, <code>gpio_request</code>, <code>gpiod_get</code>, <code>/sys/class/gpio</code>等)来使用这些来自STMPE芯片的GPIO引脚了。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 静态函数声明: stmpe_gpio_probe</span></span><br><span class="line"><span class="comment"> * 这是 stmpe_gpio 平台驱动的探测函数.</span></span><br><span class="line"><span class="comment"> * @pdev: 指向 struct platform_device 的指针, 代表内核中与此驱动匹配的设备实例.</span></span><br><span class="line"><span class="comment"> * @return: 成功时返回 0, 失败时返回负的错误码.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">stmpe_gpio_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 获取指向设备核心结构体 struct device 的指针, 方便后续使用.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> =</span> &amp;pdev-&gt;dev;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 从父设备获取私有数据.</span></span><br><span class="line"><span class="comment">	 * 这是一个 MFD(多功能设备) 驱动模型: 有一个核心的 stmpe 驱动负责总线通信(I2C/SPI),</span></span><br><span class="line"><span class="comment">	 * 而GPIO, 触摸屏等功能块作为其 &quot;子设备&quot;. dev-&gt;parent 指向的就是核心 stmpe 设备.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stmpe</span> *<span class="title">stmpe</span> =</span> dev_get_drvdata(dev-&gt;parent);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 定义一个指向 stmpe_gpio 结构体的指针, 这是本GPIO驱动的私有数据结构.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stmpe_gpio</span> *<span class="title">stmpe_gpio</span>;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 定义返回值 ret 和中断号 irq.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> ret, irq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 健全性检查: 确保芯片报告的GPIO数量没有超过驱动程序内部定义的上限.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (stmpe-&gt;num_gpios &gt; MAX_GPIOS) &#123;</span><br><span class="line">		dev_err(dev, <span class="string">&quot;Need to increase maximum GPIO number\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 使用 devm_kzalloc 分配并清零 stmpe_gpio 结构体的内存.</span></span><br><span class="line"><span class="comment">	 * &#x27;devm_&#x27; 前缀确保了这块内存在设备分离时会被自动释放.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	stmpe_gpio = devm_kzalloc(dev, <span class="keyword">sizeof</span>(*stmpe_gpio), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!stmpe_gpio)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 初始化一个互斥锁, 用于保护对中断相关寄存器的并发访问.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	mutex_init(&amp;stmpe_gpio-&gt;irq_lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 在 stmpe_gpio 结构体中保存指向核心 stmpe 结构的指针.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	stmpe_gpio-&gt;stmpe = stmpe;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * stmpe_gpio-&gt;chip 是一个 gpio_chip 结构体, 是 gpiolib 的核心.</span></span><br><span class="line"><span class="comment">	 * 这里使用一个预定义的 template_chip 作为模板进行初始化.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	stmpe_gpio-&gt;chip = template_chip;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 根据从核心驱动获取的信息, 定制 gpio_chip 结构体.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	stmpe_gpio-&gt;chip.ngpio = stmpe-&gt;num_gpios; <span class="comment">// 设置GPIO数量</span></span><br><span class="line">	stmpe_gpio-&gt;chip.parent = dev; <span class="comment">// 设置父设备</span></span><br><span class="line">	stmpe_gpio-&gt;chip.base = <span class="number">-1</span>; <span class="comment">// 设置为-1, 让gpiolib动态分配GPIO编号基地址</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 如果内核开启了 DEBUG_FS, 则为这个 gpio_chip 设置一个调试输出函数.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_DEBUG_FS))</span><br><span class="line">                stmpe_gpio-&gt;chip.dbg_show = stmpe_dbg_show;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 从设备树中读取 &quot;st,norequest-mask&quot; 属性.</span></span><br><span class="line"><span class="comment">	 * 这个属性是一个位掩码, 用于指定哪些GPIO引脚不应该被内核请求使用 (例如, 可能被用于特殊功能).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	device_property_read_u32(dev, <span class="string">&quot;st,norequest-mask&quot;</span>, &amp;stmpe_gpio-&gt;norequest_mask);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 调用核心驱动的函数, 通过总线(I2C/SPI)向芯片发送命令, 使能GPIO功能块.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ret = stmpe_enable(stmpe, STMPE_BLOCK_GPIO);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 注册一个在驱动卸载时会自动执行的清理动作.</span></span><br><span class="line"><span class="comment">	 * 当驱动卸载时, stmpe_gpio_disable 函数会被调用, 以确保硬件被正确关闭.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ret = devm_add_action_or_reset(dev, stmpe_gpio_disable, stmpe);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 从平台设备数据中获取中断号. 这个中断是STMPE芯片上所有GPIO共享的.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	irq = platform_get_irq(pdev, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (irq &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 定义一个指向 gpio_irq_chip 的指针, 这是连接gpiolib和中断子系统的&quot;胶水&quot;.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">gpio_irq_chip</span> *<span class="title">girq</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 请求一个线程化的中断处理程序.</span></span><br><span class="line"><span class="comment">		 * - irq: 中断号.</span></span><br><span class="line"><span class="comment">		 * - NULL: 主中断处理函数, 设为NULL表示当中断发生时, 只唤醒线程.</span></span><br><span class="line"><span class="comment">		 * - stmpe_gpio_irq: 线程化的中断处理函数, 实际的中断处理逻辑在这里.</span></span><br><span class="line"><span class="comment">		 * - IRQF_ONESHOT: 标志位, 确保在线程化处理函数完成前, 中断线保持被屏蔽状态.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		ret = devm_request_threaded_irq(dev, irq, <span class="literal">NULL</span>, stmpe_gpio_irq,</span><br><span class="line">						IRQF_ONESHOT, <span class="string">&quot;stmpe-gpio&quot;</span>, stmpe_gpio);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">return</span> dev_err_probe(dev, ret, <span class="string">&quot;unable to register IRQ handler\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 配置 gpio_chip 内嵌的 irq 成员.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		girq = &amp;stmpe_gpio-&gt;chip.irq;</span><br><span class="line">		<span class="comment">/* 设置中断处理的回调函数集 (mask, unmask, set_type等). */</span></span><br><span class="line">		gpio_irq_chip_set_chip(girq, &amp;stmpe_gpio_irq_chip);</span><br><span class="line">		<span class="comment">/* 本驱动直接处理中断, 不需要父中断处理器. */</span></span><br><span class="line">		girq-&gt;parent_handler = <span class="literal">NULL</span>;</span><br><span class="line">		girq-&gt;num_parents = <span class="number">0</span>;</span><br><span class="line">		girq-&gt;parents = <span class="literal">NULL</span>;</span><br><span class="line">		girq-&gt;default_type = IRQ_TYPE_NONE; <span class="comment">// 默认触发类型为无</span></span><br><span class="line">		girq-&gt;handler = handle_simple_irq; <span class="comment">// 使用简单的中断流控处理</span></span><br><span class="line">		girq-&gt;threaded = <span class="literal">true</span>; <span class="comment">// 明确表明这是一个线程化中断</span></span><br><span class="line">		girq-&gt;init_valid_mask = stmpe_init_irq_valid_mask; <span class="comment">// 设置用于初始化有效中断掩码的回调</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 调用 devm_gpiochip_add_data 将配置好的 gpio_chip 注册到 gpiolib 核心中.</span></span><br><span class="line"><span class="comment">	 * 从此, 这些GPIO就可以被系统其他部分使用了.</span></span><br><span class="line"><span class="comment">	 * &#x27;devm_&#x27; 前缀确保了在驱动卸载时会自动调用 gpiochip_remove.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> devm_gpiochip_add_data(dev, &amp;stmpe_gpio-&gt;chip, stmpe_gpio);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="stmpe-gpio-STMPE-GPIO驱动的定义与注册"><a href="#stmpe-gpio-STMPE-GPIO驱动的定义与注册" class="headerlink" title="stmpe_gpio: STMPE GPIO驱动的定义与注册"></a>stmpe_gpio: STMPE GPIO驱动的定义与注册</h2><p>此代码片段的核心作用是定义一个针对”STMPE”系列芯片(通常是I2C&#x2F;SPI接口的IO扩展器、触摸屏控制器等)上GPIO功能的平台驱动程序, 并通过内核的初始化调用机制, 在系统启动的适当时机将其注册到内核中。</p>
<ol>
<li><strong>驱动定义 (<code>stmpe_gpio_driver</code>)</strong>: <code>struct platform_driver</code>是Linux平台总线模型中用来描述一个驱动程序的核心数据结构。它告诉内核这个驱动的名字、关键的回调函数(如<code>probe</code>), 以及一些行为属性。一旦注册, 内核就会用它的名字(<code>&quot;stmpe-gpio&quot;</code>)去匹配设备树或板级文件中定义的设备。</li>
<li><strong>注册函数 (<code>stmpe_gpio_init</code>)</strong>: 这个函数是驱动注册的入口点。它只做一件事: 调用<code>platform_driver_register</code>将<code>stmpe_gpio_driver</code>这个”驱动蓝图”提交给内核的平台总线核心, 使其变为一个”活”的、可用于设备匹配的驱动程序。</li>
<li><strong>初始化调用 (<code>subsys_initcall</code>)</strong>: <code>subsys_initcall</code>是一个宏, 它将<code>stmpe_gpio_init</code>函数的地址放入一个特殊的内存段中。在内核启动过程中, 会有一个专门的阶段来执行这个段里的所有函数指针。这确保了该GPIO驱动在核心子系统初始化之后、依赖它的具体设备驱动(device drivers)初始化之前被注册, 从而保证了正确的初始化顺序。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义一个静态的 platform_driver 结构体.</span></span><br><span class="line"><span class="comment"> * &#x27;static&#x27; 关键字使得这个变量只在当前文件中可见.</span></span><br><span class="line"><span class="comment"> * 这个结构体描述了 &quot;stmpe-gpio&quot; 驱动的核心属性.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">stmpe_gpio_driver</span> =</span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * .driver: 这是一个内嵌的 device_driver 结构体, 包含了通用的驱动属性.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	.driver = &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * .suppress_bind_attrs = true:</span></span><br><span class="line"><span class="comment">		 * 设置为 true 会阻止内核在 sysfs 中为这个驱动自动创建 &quot;bind&quot; 和 &quot;unbind&quot; 文件.</span></span><br><span class="line"><span class="comment">		 * 这通常用于那些不希望被用户从命令行手动绑定或解绑的驱动,</span></span><br><span class="line"><span class="comment">		 * 暗示该驱动与其设备的关系是在编译时或通过设备树固定的.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		.suppress_bind_attrs	= <span class="literal">true</span>,</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * .name = &quot;stmpe-gpio&quot;:</span></span><br><span class="line"><span class="comment">		 * 这是驱动的唯一名称. 内核的平台总线核心会用这个名字</span></span><br><span class="line"><span class="comment">		 * 去匹配在设备树中 compatible 字符串或者在板级文件中定义的 platform_device 的名字.</span></span><br><span class="line"><span class="comment">		 * 当一个名为 &quot;stmpe-gpio&quot; 的设备被注册时, 两者就会匹配成功.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		.name			= <span class="string">&quot;stmpe-gpio&quot;</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * .probe = stmpe_gpio_probe:</span></span><br><span class="line"><span class="comment">	 * 这是一个函数指针, 指向该驱动的探测函数 (probe function).</span></span><br><span class="line"><span class="comment">	 * 当驱动和设备成功匹配后, 内核会调用 stmpe_gpio_probe 函数.</span></span><br><span class="line"><span class="comment">	 * 这个函数是驱动的真正入口点, 负责初始化硬件、申请资源、</span></span><br><span class="line"><span class="comment">	 * 并将GPIO控制器注册到内核的 gpiolib 子系统中.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	.probe		= stmpe_gpio_probe,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义一个静态的初始化函数.</span></span><br><span class="line"><span class="comment"> * &#x27;static&#x27; 关键字使其仅在当前文件内可见.</span></span><br><span class="line"><span class="comment"> * &#x27;__init&#x27; 宏告诉编译器将这个函数放入一个特殊的内存段 (&quot;.init.text&quot;).</span></span><br><span class="line"><span class="comment"> * 内核在启动过程完成后, 会释放这个段所占用的所有内存, 这是一个重要的内存优化.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">stmpe_gpio_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 调用 platform_driver_register() 函数, 将 stmpe_gpio_driver 注册到内核的平台总线核心中.</span></span><br><span class="line"><span class="comment">	 * 从这一刻起, 内核就知道了这个驱动的存在, 并会开始为它寻找匹配的设备.</span></span><br><span class="line"><span class="comment">	 * 此函数返回一个整型值, 0表示成功, 负数表示错误码.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> platform_driver_register(&amp;stmpe_gpio_driver);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * subsys_initcall() 是一个宏, 它将 stmpe_gpio_init 函数注册为一个内核的 &quot;子系统初始化调用&quot;.</span></span><br><span class="line"><span class="comment"> * 在内核启动过程中, 内核会按照预定义的顺序(core, postcore, arch, subsys, fs, device, late)</span></span><br><span class="line"><span class="comment"> * 调用不同级别的初始化函数.</span></span><br><span class="line"><span class="comment"> * subsys_initcall 确保了 stmpe_gpio_init 会在一个比较早的、合适的阶段被执行,</span></span><br><span class="line"><span class="comment"> * 通常是在核心子系统(如内存管理, VFS)初始化之后, 但在大多数具体设备驱动初始化之前.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">subsys_initcall(stmpe_gpio_init);</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/wdfk-prog">Liya Huang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://wdfk-prog.space/posts/ba76d4d1/">https://wdfk-prog.space/posts/ba76d4d1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://wdfk-prog.space" target="_blank">wdfk-prog的个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/linux/">linux</a><a class="post-meta__tags" href="/tags/drivers/">drivers</a></div><div class="post-share"><div class="social-share" data-image="/images/covers/08.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/images/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/images/alipay.png" target="_blank"><img class="post-qr-code-img" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/alipay.png" alt="支付寶"/></a><div class="post-qr-code-desc">支付寶</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/c5f21b05/" title="nvmem"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/01.jpg" onerror="onerror=null;src='/images/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">nvmem</div></div><div class="info-2"><div class="info-item-1">[toc] drivers&#x2F;nvmem&#x2F;core.c NVMEM核心(NVMEM Core) 非易失性内存的统一访问框架历史与背景这项技术是为了解决什么特定问题而诞生的？NVMEM（Non-Volatile Memory）子系统的诞生是为了解决一个在嵌入式系统中普遍存在的问题：如何以一种标准的、统一的方式来访问各种小型、非易失性存储设备中的原始数据。 在此框架出现之前，内核中没有一个专门的子系统来处理这类需求，导致了实现上的混乱：  缺乏统一接口：一个以太网驱动需要从板载的I2C EEPROM中读取MAC地址，而一个无线网卡驱动可能需要从SoC内部的EFUSE（电子熔丝）中读取校准数据。这些驱动不得不自己去实现与特定存储芯片（EEPROM, EFUSE, OTP等）的交互逻辑，或者依赖于特定平台的私有接口。 驱动间强耦合：设备驱动（消费者）被迫要知道提供数据的存储芯片（生产者）的具体细节。如果硬件设计发生变化，例如将MAC地址从EEPROM移到了SPI Flash的一个分区中，那么设备驱动的代码就需要进行重大修改。 代码重复与不可移植：每个需要读取配置数据的驱...</div></div></div></a><a class="pagination-related" href="/posts/5a79feca/" title="dma"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/02.jpg" onerror="onerror=null;src='/images/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">dma</div></div><div class="info-2"><div class="info-item-1">[TOC] drivers&#x2F;dma DMA引擎与映射(DMA Engine &amp; Mapping) 内核统一的直接内存访问框架历史与背景这项技术是为了解决什么特定问题而诞生的？DMA（Direct Memory Access，直接内存访问）框架的诞生是为了解决一个根本性的性能瓶颈问题，并为内核提供一个统一、可移植的解决方案。  解决CPU性能瓶颈：在没有DMA的系统中，当外设（如网卡、磁盘）需要与内存交换大量数据时，CPU必须亲自担当“搬运工”的角色。这种方式被称为PIO（Programmed I&#x2F;O），CPU需要逐字节或逐字地从设备读取数据再写入内存，或者反之。对于高速设备，这会消耗大量的CPU周期，导致CPU无暇处理其他计算任务，严重影响系统整体性能。DMA技术通过引入一个专门的硬件控制器（DMAC），允许外设在没有CPU干预的情况下直接与内存进行数据传输，从而将CPU解放出来。 抽象硬件差异：不同的CPU架构和SoC平台，其DMA控制器的设计和编程接口千差万别。如果没有一个统一的软件框架，设备驱动程序的开发者将不得不为每一种不同的DMAC编写特定的...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/6ce74947/" title="regmap"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/08.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-03</div><div class="info-item-2">regmap</div></div><div class="info-2"><div class="info-item-1">[TOC] regmapRegmap 简介Regmap 是 Linux 内核中的一个子系统，用于抽象和管理设备寄存器的访问。它为驱动程序提供了统一的接口，支持多种总线（如 I2C、SPI、MMIO 等）上的寄存器操作，同时提供了缓存、锁机制和调试功能。Regmap 的设计目标是简化驱动开发，减少重复代码，并提高寄存器访问的效率和安全性。  工作原理1. 核心概念 寄存器映射 (Register Map):Regmap 将设备的寄存器抽象为一个统一的映射，屏蔽了底层总线的差异。  寄存器缓存:Regmap 提供了可选的寄存器缓存机制，用于减少总线访问次数，提高性能。  寄存器访问控制:通过配置文件（struct regmap_config），可以定义哪些寄存器是可读、可写或易失的。  总线适配器:Regmap 支持多种总线（如 I2C、SPI、MMIO 等），通过总线适配器实现具体的读写操作。   2. 数据结构 struct regmap:表示寄存器映射的核心数据结构，包含寄存器的地址、值、缓存等信息。  struct regmap_config:配置寄存器映射的结构体，用于定义...</div></div></div></a><a class="pagination-related" href="/posts/d32d8ac9/" title="clocksource"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/02.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-03</div><div class="info-item-2">clocksource</div></div><div class="info-2"><div class="info-item-1">[TOC] clocksource 内核时钟源(Kernel Clocksource) 为内核提供统一的时间基准历史与背景这项技术是为了解决什么特定问题而诞生的？clocksource框架的诞生是为了解决Linux内核中一个根本性的问题：如何以一种统一、可移植的方式来处理多样化的硬件计时器。  硬件的多样性：不同的CPU架构和平台提供了五花八门的硬件计时器，例如x86上的TSC（时间戳计数器）、HPET（高精度事件定时器）、ACPI PM Timer，以及ARM平台上的Architected Timer等。这些计时器的精度、速度、稳定性和编程接口各不相同。 缺乏统一抽象：在clocksource框架出现之前，内核中的时间管理代码与特定的硬件架构和计时器紧密耦合。这使得将内核移植到新平台变得困难，也难以在运行时动态选择最优的计时器硬件。 对高精度的需求：随着系统应用（如实时系统、高频交易、性能剖析）对时间精度要求的提高，内核需要一个能够充分利用现代高精度计时器硬件的框架。  clocksource框架通过创建一个通用的抽象层，将这些底层硬件计时器的差异性隐藏起来，为内核的上层时间子...</div></div></div></a><a class="pagination-related" href="/posts/5a79feca/" title="dma"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/02.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-03</div><div class="info-item-2">dma</div></div><div class="info-2"><div class="info-item-1">[TOC] drivers&#x2F;dma DMA引擎与映射(DMA Engine &amp; Mapping) 内核统一的直接内存访问框架历史与背景这项技术是为了解决什么特定问题而诞生的？DMA（Direct Memory Access，直接内存访问）框架的诞生是为了解决一个根本性的性能瓶颈问题，并为内核提供一个统一、可移植的解决方案。  解决CPU性能瓶颈：在没有DMA的系统中，当外设（如网卡、磁盘）需要与内存交换大量数据时，CPU必须亲自担当“搬运工”的角色。这种方式被称为PIO（Programmed I&#x2F;O），CPU需要逐字节或逐字地从设备读取数据再写入内存，或者反之。对于高速设备，这会消耗大量的CPU周期，导致CPU无暇处理其他计算任务，严重影响系统整体性能。DMA技术通过引入一个专门的硬件控制器（DMAC），允许外设在没有CPU干预的情况下直接与内存进行数据传输，从而将CPU解放出来。 抽象硬件差异：不同的CPU架构和SoC平台，其DMA控制器的设计和编程接口千差万别。如果没有一个统一的软件框架，设备驱动程序的开发者将不得不为每一种不同的DMAC编写特定的...</div></div></div></a><a class="pagination-related" href="/posts/ba80502e/" title="cpu"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/03.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-03</div><div class="info-item-2">cpu</div></div><div class="info-2"><div class="info-item-1">[TOC] include&#x2F;linux&#x2F;cpumask.hcpumask_check 验证当前cpu数量是否超过了配置的最大cpu数量,并返回cpu1234567891011121314151617// 验证当前cpu数量是否超过了配置的最大cpu数量static __always_inline void cpu_max_bits_warn(unsigned int cpu, unsigned int bits)&#123;#ifdef CONFIG_DEBUG_PER_CPU_MAPS	WARN_ON_ONCE(cpu &gt;= bits);#endif /* CONFIG_DEBUG_PER_CPU_MAPS */&#125;/* verify cpu argument to cpumask_* operators *///验证当前cpu数量是否超过了配置的最大cpu数量static __always_inline unsigned int cpumask_check(unsigned int cpu)&#123;    //small_cpumask_...</div></div></div></a><a class="pagination-related" href="/posts/c674e474/" title="init"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/06.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-03</div><div class="info-item-2">init</div></div><div class="info-2"><div class="info-item-1"> [TOC] init&#x2F;init_task.c 内核线程的一个核心特征是：它们没有自己独立的用户地址空间。它们只在内核空间运行，而内核地址空间是所有进程共享的。因此，内核线程不需要一个属于自己的内存描述符 struct mm_struct，所以它们的 task-&gt;mm 指针通常是 NULL  init_task 就是大名鼎鼎的 PID 0 进程，也常被称为 swapper 进程。从它的标志位 .flags &#x3D; PF_KTHREAD 可以看出，它是一个内核线程。  init_task 的调度策略(policy)是 SCHED_NORMAL，这意味着它是一个普通的分时调度任务，而不是实时任务。但是初始化阶段调用了init_idle()，使得它的sched_class 是 SCHED_IDLE，这样它就可以作为 CPU 的空闲任务运行。但是fork出来的其他进程继承的还是 SCHED_NORMAL 策略。  进程的“始祖”：init_task 是系统中所有进程的祖先。在系统启动后，它会创建第一个内核线程 kernel_init（它最终会成为 PID 1 的 i...</div></div></div></a><a class="pagination-related" href="/posts/8faf4fe2/" title="amba"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/05.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-03</div><div class="info-item-2">amba</div></div><div class="info-2"><div class="info-item-1">[TOC] drivers&#x2F;amba: Linux的AMBA总线与SoC设备驱动核心drivers/amba 目录是 Linux 内核中用于管理和驱动基于 AMBA (Advanced Microcontroller Bus Architecture) 总线的外设的核心框架。在现代基于 ARM 的片上系统 (SoC) 中，几乎所有的片上外设（如 UART、GPIO、SPI、I2C、定时器等）都挂载在 AMBA 总线上。因此，这个目录是 ARM SoC 平台驱动程序的基石。  一、 历史与背景这项技术是为了解决什么特定问题而诞生的？ 在嵌入式系统中，特别是 SoC 中，外设不是像 PCI 或 USB 设备那样可以在运行时动态发现的（即非“热插拔”或“可枚举”的）。它们是静态地集成在芯片上的，其物理地址和中断号在芯片设计时就已经固定。 早期的 Linux 内核通过在 C 代码（board-*.c 文件）中硬编码这些“平台设备”（platform devices）的信息来支持它们。这种方法导致了巨大的问题：  内核与硬件紧密耦合: 每支持一款新的开发板，就需要编写一个新的 b...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/avatar.png" onerror="this.onerror=null;this.src='/images/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Liya Huang</div><div class="author-info-description">WORK-LIFE BALANCE</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">417</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">49</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">53</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/wdfk-prog"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/wdfk-prog" rel="external nofollow noreferrer" target="_blank" title="GitHub"><i class="fab fa-github" style="color: #181717;"></i></a><a class="social-icon" href="https://wdfk-prog.blog.csdn.net/" rel="external nofollow noreferrer" target="_blank" title="CSDN"><i class="fas fa-blog" style="color: #FC5531;"></i></a><a class="social-icon" href="mailto:1425075683@qq.com" rel="external nofollow noreferrer" target="_blank" title="E-mail"><i class="fas fa-envelope" style="color: #4A4A4A;"></i></a><a class="social-icon" href="/images/wechat-qrcode.jpg" target="_blank" title="微信公众号"><i class="fab fa-weixin" style="color: #07C160;"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss" style="color: #EE802F;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎光临！有任何问题或想法，欢迎在文章下留言交流，或者通过 <a href='/about/'>关于页面</a> 联系我。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#drivers-gpio-GPIO%E5%AD%90%E7%B3%BB%E7%BB%9F-General-Purpose-Input-Output-%E5%86%85%E6%A0%B8%E4%B8%8E%E7%A1%AC%E4%BB%B6I-O%E5%BC%95%E8%84%9A%E4%BA%A4%E4%BA%92%E7%9A%84%E9%80%9A%E7%94%A8%E6%A1%86%E6%9E%B6"><span class="toc-number">1.</span> <span class="toc-text">drivers&#x2F;gpio GPIO子系统(General Purpose Input&#x2F;Output) 内核与硬件I&#x2F;O引脚交互的通用框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%86%E5%8F%B2%E4%B8%8E%E8%83%8C%E6%99%AF"><span class="toc-number">1.0.1.</span> <span class="toc-text">历史与背景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%99%E9%A1%B9%E6%8A%80%E6%9C%AF%E6%98%AF%E4%B8%BA%E4%BA%86%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E7%89%B9%E5%AE%9A%E9%97%AE%E9%A2%98%E8%80%8C%E8%AF%9E%E7%94%9F%E7%9A%84%EF%BC%9F"><span class="toc-number">1.0.1.1.</span> <span class="toc-text">这项技术是为了解决什么特定问题而诞生的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%83%E7%9A%84%E5%8F%91%E5%B1%95%E7%BB%8F%E5%8E%86%E4%BA%86%E5%93%AA%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9A%84%E9%87%8C%E7%A8%8B%E7%A2%91%E6%88%96%E7%89%88%E6%9C%AC%E8%BF%AD%E4%BB%A3%EF%BC%9F"><span class="toc-number">1.0.1.2.</span> <span class="toc-text">它的发展经历了哪些重要的里程碑或版本迭代？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E5%89%8D%E8%AF%A5%E6%8A%80%E6%9C%AF%E7%9A%84%E7%A4%BE%E5%8C%BA%E6%B4%BB%E8%B7%83%E5%BA%A6%E5%92%8C%E4%B8%BB%E6%B5%81%E5%BA%94%E7%94%A8%E6%83%85%E5%86%B5%E5%A6%82%E4%BD%95%EF%BC%9F"><span class="toc-number">1.0.1.3.</span> <span class="toc-text">目前该技术的社区活跃度和主流应用情况如何？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.0.2.</span> <span class="toc-text">核心原理与设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%83%E7%9A%84%E6%A0%B8%E5%BF%83%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.0.2.1.</span> <span class="toc-text">它的核心工作原理是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%83%E7%9A%84%E4%B8%BB%E8%A6%81%E4%BC%98%E5%8A%BF%E4%BD%93%E7%8E%B0%E5%9C%A8%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2%EF%BC%9F"><span class="toc-number">1.0.2.2.</span> <span class="toc-text">它的主要优势体现在哪些方面？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%83%E5%AD%98%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%B7%B2%E7%9F%A5%E7%9A%84%E5%8A%A3%E5%8A%BF%E3%80%81%E5%B1%80%E9%99%90%E6%80%A7%E6%88%96%E5%9C%A8%E7%89%B9%E5%AE%9A%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E4%B8%8D%E9%80%82%E7%94%A8%E6%80%A7%EF%BC%9F"><span class="toc-number">1.0.2.3.</span> <span class="toc-text">它存在哪些已知的劣势、局限性或在特定场景下的不适用性？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.0.3.</span> <span class="toc-text">使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%85%B7%E4%BD%93%E7%9A%84%E4%B8%9A%E5%8A%A1%E6%88%96%E6%8A%80%E6%9C%AF%E5%9C%BA%E6%99%AF%E4%B8%8B%EF%BC%8C%E5%AE%83%E6%98%AF%E9%A6%96%E9%80%89%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9F%E8%AF%B7%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%E3%80%82"><span class="toc-number">1.0.3.1.</span> <span class="toc-text">在哪些具体的业务或技术场景下，它是首选解决方案？请举例说明。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E5%90%A6%E6%9C%89%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E8%AF%A5%E6%8A%80%E6%9C%AF%E7%9A%84%E5%9C%BA%E6%99%AF%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.0.3.2.</span> <span class="toc-text">是否有不推荐使用该技术的场景？为什么？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90"><span class="toc-number">1.0.4.</span> <span class="toc-text">对比分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E5%B0%86%E5%85%B6-%E4%B8%8E-%E5%85%B6%E4%BB%96%E7%9B%B8%E4%BC%BC%E6%8A%80%E6%9C%AF-%E8%BF%9B%E8%A1%8C%E8%AF%A6%E7%BB%86%E5%AF%B9%E6%AF%94%E3%80%82"><span class="toc-number">1.0.4.1.</span> <span class="toc-text">请将其 与 其他相似技术 进行详细对比。</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#include-linux-gpio-driver-h"><span class="toc-number">2.</span> <span class="toc-text">include&#x2F;linux&#x2F;gpio&#x2F;driver.h</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#for-each-gpiochip-node-%E9%81%8D%E5%8E%86GPIO%E6%8E%A7%E5%88%B6%E5%99%A8%E8%8A%82%E7%82%B9"><span class="toc-number">2.1.</span> <span class="toc-text">for_each_gpiochip_node 遍历GPIO控制器节点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#drivers-gpio-gpiolib-of-c"><span class="toc-number">3.</span> <span class="toc-text">drivers&#x2F;gpio&#x2F;gpiolib-of.c</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#of-get-named-gpiod-flags-of-gpio-flags-quirks"><span class="toc-number">3.1.</span> <span class="toc-text">of_get_named_gpiod_flags &amp; of_gpio_flags_quirks</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#of-get-named-gpiod-flags-The-Core-Device-Tree-GPIO-Property-Parser"><span class="toc-number">3.1.1.</span> <span class="toc-text">of_get_named_gpiod_flags: The Core Device Tree GPIO Property Parser</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#of-gpio-flags-quirks-The-Legacy-Binding-Compatibility-Handler"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">of_gpio_flags_quirks: The Legacy Binding Compatibility Handler</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#of-find-gpio-The-Device-Tree-GPIO-Lookup-Engine-with-Quirk-Support"><span class="toc-number">3.2.</span> <span class="toc-text">of_find_gpio: The Device Tree GPIO Lookup Engine with Quirk Support</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#drivers-gpio-gpiolib-c"><span class="toc-number">4.</span> <span class="toc-text">drivers&#x2F;gpio&#x2F;gpiolib.c</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#gpiochip-setup-dev-%E4%B8%BA%E5%8D%95%E4%B8%AAGPIO%E6%8E%A7%E5%88%B6%E5%99%A8%E5%AE%8C%E6%88%90%E8%AE%BE%E5%A4%87%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%B3%A8%E5%86%8C"><span class="toc-number">4.1.</span> <span class="toc-text">gpiochip_setup_dev: 为单个GPIO控制器完成设备和接口的注册</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gpiochip-setup-devs-%E4%B8%BA%E5%B7%B2%E6%B3%A8%E5%86%8C%E7%9A%84GPIO%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AE%BE%E7%BD%AE%E8%AE%BE%E5%A4%87%E8%8A%82%E7%82%B9"><span class="toc-number">4.2.</span> <span class="toc-text">gpiochip_setup_devs: 为已注册的GPIO控制器设置设备节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gpiolib-dev-init-%E5%88%9D%E5%A7%8B%E5%8C%96GPIO%E8%AE%BE%E5%A4%87%E5%BA%93"><span class="toc-number">4.3.</span> <span class="toc-text">gpiolib_dev_init: 初始化GPIO设备库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gpiolib-%E6%80%BB%E7%BA%BF%E4%B8%8E%E8%AE%BE%E5%A4%87%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="toc-number">4.4.</span> <span class="toc-text">gpiolib 总线与设备类型定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#gpio-dev-type-GPIO%E8%8A%AF%E7%89%87%E7%9A%84%E8%AE%BE%E5%A4%87%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.4.1.</span> <span class="toc-text">gpio_dev_type: GPIO芯片的设备类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gpio-bus-match-GPIO%E6%80%BB%E7%BA%BF%E7%9A%84%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99"><span class="toc-number">4.4.2.</span> <span class="toc-text">gpio_bus_match: GPIO总线的匹配规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gpio-bus-type-%E2%80%9Cgpio%E2%80%9D-%E9%80%BB%E8%BE%91%E6%80%BB%E7%BA%BF"><span class="toc-number">4.4.3.</span> <span class="toc-text">gpio_bus_type: “gpio” 逻辑总线</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gpiochip-find-base-unlocked-%E5%8A%A8%E6%80%81%E6%9F%A5%E6%89%BE%E5%8F%AF%E7%94%A8%E7%9A%84GPIO%E7%BC%96%E5%8F%B7%E5%9F%BA%E5%9C%B0%E5%9D%80"><span class="toc-number">4.5.</span> <span class="toc-text">gpiochip_find_base_unlocked: 动态查找可用的GPIO编号基地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gpiodev-add-to-list-unlocked-%E5%B0%86GPIO%E8%AE%BE%E5%A4%87%E6%8F%92%E5%85%A5%E5%85%A8%E5%B1%80%E6%8E%92%E5%BA%8F%E5%88%97%E8%A1%A8"><span class="toc-number">4.6.</span> <span class="toc-text">gpiodev_add_to_list_unlocked: 将GPIO设备插入全局排序列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GPIO%E6%9C%89%E6%95%88%E5%BC%95%E8%84%9A%E6%8E%A9%E7%A0%81-Valid-Mask-%E4%B8%8E%E5%BC%95%E8%84%9A%E8%8C%83%E5%9B%B4%E7%AE%A1%E7%90%86%E7%B3%BB%E5%88%97%E5%87%BD%E6%95%B0"><span class="toc-number">4.7.</span> <span class="toc-text">GPIO有效引脚掩码(Valid Mask)与引脚范围管理系列函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%9C%89%E6%95%88%E5%BC%95%E8%84%9A%E6%8E%A9%E7%A0%81%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86"><span class="toc-number">4.7.1.</span> <span class="toc-text">1. 有效引脚掩码的生命周期管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gpiochip-allocate-mask-gpiochip-free-mask-gpiochip-free-valid-mask"><span class="toc-number">4.7.1.1.</span> <span class="toc-text">gpiochip_allocate_mask &amp; gpiochip_free_mask &#x2F; gpiochip_free_valid_mask</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%80%9A%E8%BF%87%E8%AE%BE%E5%A4%87%E6%A0%91%E5%A3%B0%E6%98%8E%E6%97%A0%E6%95%88%E5%BC%95%E8%84%9A-%E9%9D%99%E6%80%81%E6%96%B9%E5%BC%8F"><span class="toc-number">4.7.2.</span> <span class="toc-text">2. 通过设备树声明无效引脚 (静态方式)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gpiochip-count-reserved-ranges-gpiochip-apply-reserved-ranges"><span class="toc-number">4.7.2.1.</span> <span class="toc-text">gpiochip_count_reserved_ranges &amp; gpiochip_apply_reserved_ranges</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%9C%89%E6%95%88%E6%8E%A9%E7%A0%81%E7%9A%84%E6%9E%84%E5%BB%BA%E4%B8%8E%E6%9F%A5%E8%AF%A2"><span class="toc-number">4.7.3.</span> <span class="toc-text">3. 有效掩码的构建与查询</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gpiochip-init-valid-mask"><span class="toc-number">4.7.3.1.</span> <span class="toc-text">gpiochip_init_valid_mask</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gpiochip-query-valid-mask-gpiochip-line-is-valid"><span class="toc-number">4.7.3.2.</span> <span class="toc-text">gpiochip_query_valid_mask &amp; gpiochip_line_is_valid</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-GPIO%E8%8C%83%E5%9B%B4%E4%B8%8EPinctrl%E7%9A%84%E5%85%B3%E8%81%94"><span class="toc-number">4.7.4.</span> <span class="toc-text">4. GPIO范围与Pinctrl的关联</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gpiochip-add-pin-ranges"><span class="toc-number">4.7.4.1.</span> <span class="toc-text">gpiochip_add_pin_ranges</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GPIO%E5%B1%82%E6%AC%A1%E5%8C%96%E4%B8%AD%E6%96%AD%E5%9F%9F-Hierarchical-IRQ-Domain-%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.8.</span> <span class="toc-text">GPIO层次化中断域(Hierarchical IRQ Domain)实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9F%9F%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%85%8D%E7%BD%AE"><span class="toc-number">4.8.1.</span> <span class="toc-text">1. 域的创建与配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gpiochip-hierarchy-is-hierarchical"><span class="toc-number">4.8.1.1.</span> <span class="toc-text">gpiochip_hierarchy_is_hierarchical</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gpiochip-hierarchy-setup-domain-ops"><span class="toc-number">4.8.1.2.</span> <span class="toc-text">gpiochip_hierarchy_setup_domain_ops</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gpiochip-hierarchy-create-domain"><span class="toc-number">4.8.1.3.</span> <span class="toc-text">gpiochip_hierarchy_create_domain</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%AD%E6%96%AD%E5%9F%9F%E6%93%8D%E4%BD%9C%E5%9B%9E%E8%B0%83-irq-domain-ops-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.8.2.</span> <span class="toc-text">2. 中断域操作回调 (irq_domain_ops) 的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gpiochip-hierarchy-irq-domain-translate"><span class="toc-number">4.8.2.1.</span> <span class="toc-text">gpiochip_hierarchy_irq_domain_translate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gpiochip-hierarchy-irq-domain-alloc"><span class="toc-number">4.8.2.2.</span> <span class="toc-text">gpiochip_hierarchy_irq_domain_alloc</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gpiochip-irq-domain-activate-deactivate"><span class="toc-number">4.8.2.3.</span> <span class="toc-text">gpiochip_irq_domain_activate &#x2F; deactivate</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%85%B6%E4%BB%96%E8%BE%85%E5%8A%A9%E4%B8%8E%E9%81%97%E7%95%99-Legacy-%E6%94%AF%E6%8C%81%E5%87%BD%E6%95%B0"><span class="toc-number">4.8.3.</span> <span class="toc-text">3. 其他辅助与遗留(Legacy)支持函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GPIO%E7%AE%80%E5%8D%95%E4%B8%AD%E6%96%AD%E5%9F%9F-Simple-IRQ-Domain-%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0"><span class="toc-number">4.9.</span> <span class="toc-text">GPIO简单中断域(Simple IRQ Domain)创建函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#gpiochip-irq-map-%E6%98%A0%E5%B0%84%E4%B8%80%E4%B8%AALinux-IRQ%E5%88%B0GPIO%E5%BC%95%E8%84%9A"><span class="toc-number">4.9.1.</span> <span class="toc-text">gpiochip_irq_map: 映射一个Linux IRQ到GPIO引脚</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gpiochip-irq-unmap-%E8%A7%A3%E9%99%A4%E4%B8%80%E4%B8%AALinux-IRQ%E4%B8%8EGPIO%E5%BC%95%E8%84%9A%E7%9A%84%E6%98%A0%E5%B0%84"><span class="toc-number">4.9.2.</span> <span class="toc-text">gpiochip_irq_unmap: 解除一个Linux IRQ与GPIO引脚的映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gpiochip-irq-select-%E9%80%89%E6%8B%A9%E4%B8%80%E4%B8%AA%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">4.9.3.</span> <span class="toc-text">gpiochip_irq_select: 选择一个中断控制器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gpiochip-domain-ops-%E7%AE%80%E5%8D%95%E5%9F%9F%E7%9A%84%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%E9%9B%86"><span class="toc-number">4.9.4.</span> <span class="toc-text">gpiochip_domain_ops: 简单域的操作函数集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gpiochip-simple-create-domain-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E4%B8%AD%E6%96%AD%E5%9F%9F"><span class="toc-number">4.9.5.</span> <span class="toc-text">gpiochip_simple_create_domain: 创建一个简单中断域</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gpiolib%E4%B8%AD%E6%96%AD%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E4%B8%8E%E4%BD%BF%E8%83%BD-%E7%A6%81%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">4.10.</span> <span class="toc-text">gpiolib中断资源管理与使能&#x2F;禁用函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#gpiochip-lock-as-irq-%E5%B0%86GPIO%E5%BC%95%E8%84%9A%E9%94%81%E5%AE%9A%E4%B8%BA%E4%B8%AD%E6%96%AD%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.10.1.</span> <span class="toc-text">gpiochip_lock_as_irq: 将GPIO引脚锁定为中断模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gpiochip-unlock-as-irq-%E8%A7%A3%E9%94%81%E4%B8%80%E4%B8%AA%E7%94%A8%E4%BD%9C%E4%B8%AD%E6%96%AD%E7%9A%84GPIO%E5%BC%95%E8%84%9A"><span class="toc-number">4.10.2.</span> <span class="toc-text">gpiochip_unlock_as_irq: 解锁一个用作中断的GPIO引脚</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gpiochip-reqres-irq-gpiochip-relres-irq-%E8%AF%B7%E6%B1%82-%E9%87%8A%E6%94%BE%E4%B8%AD%E6%96%AD%E8%B5%84%E6%BA%90"><span class="toc-number">4.10.3.</span> <span class="toc-text">gpiochip_reqres_irq &#x2F; gpiochip_relres_irq: 请求&#x2F;释放中断资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gpiochip-enable-irq-gpiochip-disable-irq-%E4%BD%BF%E8%83%BD-%E7%A6%81%E7%94%A8%E4%B8%AD%E6%96%AD-%E8%BD%AF%E4%BB%B6%E7%8A%B6%E6%80%81"><span class="toc-number">4.10.4.</span> <span class="toc-text">gpiochip_enable_irq &#x2F; gpiochip_disable_irq: 使能&#x2F;禁用中断(软件状态)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gpiolib%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8-irqchip-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.11.</span> <span class="toc-text">gpiolib中断控制器(irqchip)的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-gpio-to-irq%E7%9A%84%E6%A0%B8%E5%BF%83%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.11.1.</span> <span class="toc-text">1. gpio_to_irq的核心实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-irq-chip%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%85%E8%A3%85%E5%99%A8"><span class="toc-number">4.11.2.</span> <span class="toc-text">2. irq_chip回调函数的包装器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-irqchip%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">4.11.3.</span> <span class="toc-text">3. irqchip的安装与初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gpiochip-add-irqchip-%E4%B8%BAGPIO%E6%8E%A7%E5%88%B6%E5%99%A8%E6%B7%BB%E5%8A%A0%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8%E5%8A%9F%E8%83%BD"><span class="toc-number">4.12.</span> <span class="toc-text">gpiochip_add_irqchip: 为GPIO控制器添加中断控制器功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gpiochip-setup-dev-%E5%88%9B%E5%BB%BAGPIO%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.13.</span> <span class="toc-text">gpiochip_setup_dev: 创建GPIO控制器的用户空间接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gpiochip-add-data-%E5%B0%86%E4%B8%80%E4%B8%AAGPIO%E6%8E%A7%E5%88%B6%E5%99%A8%E6%B3%A8%E5%86%8C%E5%88%B0%E5%86%85%E6%A0%B8"><span class="toc-number">4.14.</span> <span class="toc-text">gpiochip_add_data: 将一个GPIO控制器注册到内核</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gpiochip-add-data-with-key-%E6%A0%B8%E5%BF%83%E6%B3%A8%E5%86%8C%E5%87%BD%E6%95%B0"><span class="toc-number">4.15.</span> <span class="toc-text">gpiochip_add_data_with_key: 核心注册函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gpiod-find-by-fwnode-%E4%B8%8E%E5%9B%BA%E4%BB%B6%E6%97%A0%E5%85%B3%E7%9A%84-GPIO-%E6%9F%A5%E6%89%BE%E8%B0%83%E5%BA%A6%E7%A8%8B%E5%BA%8F"><span class="toc-number">4.16.</span> <span class="toc-text">gpiod_find_by_fwnode: 与固件无关的 GPIO 查找调度程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gpiod-add-lookup-tables-%E6%B3%A8%E5%86%8CGPIO%E6%9F%A5%E6%89%BE%E8%A1%A8"><span class="toc-number">4.17.</span> <span class="toc-text">gpiod_add_lookup_tables: 注册GPIO查找表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gpiod-find-%E4%BC%A0%E7%BB%9F%E5%B9%B3%E5%8F%B0-GPIO-%E6%9F%A5%E6%89%BE%E5%BC%95%E6%93%8E"><span class="toc-number">4.18.</span> <span class="toc-text">gpiod_find: 传统平台 GPIO 查找引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8ESTM32H750%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">4.18.0.1.</span> <span class="toc-text">与STM32H750的关系</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gpiod-request-%E5%92%8C-gpiod-request-commit-%E5%AE%89%E5%85%A8%E5%9C%B0%E8%AF%B7%E6%B1%82%E5%B9%B6%E7%8B%AC%E5%8D%A0%E4%B8%80%E4%B8%AAGPIO"><span class="toc-number">4.19.</span> <span class="toc-text">gpiod_request 和 gpiod_request_commit: 安全地请求并独占一个GPIO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#gpiod-request-commit-%E6%89%A7%E8%A1%8C%E8%AF%B7%E6%B1%82%E7%9A%84%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91"><span class="toc-number">4.19.1.</span> <span class="toc-text">gpiod_request_commit: 执行请求的核心逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gpiod-request-%E5%AE%89%E5%85%A8%E7%9A%84%E5%85%AC%E5%85%B1API%E5%B0%81%E8%A3%85"><span class="toc-number">4.19.2.</span> <span class="toc-text">gpiod_request: 安全的公共API封装</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gpiochip-%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0-gpiolib-%E6%A0%B8%E5%BF%83%E5%88%B0%E7%A1%AC%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%AE%89%E5%85%A8%E8%B0%83%E5%BA%A6%E5%B1%82"><span class="toc-number">4.20.</span> <span class="toc-text">gpiochip_* 静态函数: gpiolib 核心到硬件驱动的安全调度层</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#gpiochip-set-%E8%AE%BE%E7%BD%AEGPIO%E8%BE%93%E5%87%BA%E7%94%B5%E5%B9%B3%E7%9A%84%E7%A1%AC%E4%BB%B6%E8%B0%83%E5%BA%A6%E5%87%BD%E6%95%B0"><span class="toc-number">4.20.1.</span> <span class="toc-text">gpiochip_set: 设置GPIO输出电平的硬件调度函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gpiochip-get-direction-%E8%8E%B7%E5%8F%96GPIO%E6%96%B9%E5%90%91%E7%9A%84%E7%A1%AC%E4%BB%B6%E8%B0%83%E5%BA%A6%E5%87%BD%E6%95%B0"><span class="toc-number">4.20.2.</span> <span class="toc-text">gpiochip_get_direction: 获取GPIO方向的硬件调度函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gpiochip-direction-input-%E8%AE%BE%E7%BD%AEGPIO%E4%B8%BA%E8%BE%93%E5%85%A5%E7%9A%84%E7%A1%AC%E4%BB%B6%E8%B0%83%E5%BA%A6%E5%87%BD%E6%95%B0"><span class="toc-number">4.20.3.</span> <span class="toc-text">gpiochip_direction_input: 设置GPIO为输入的硬件调度函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gpiochip-direction-output-%E8%AE%BE%E7%BD%AEGPIO%E4%B8%BA%E8%BE%93%E5%87%BA%E7%9A%84%E7%A1%AC%E4%BB%B6%E8%B0%83%E5%BA%A6%E5%87%BD%E6%95%B0"><span class="toc-number">4.20.4.</span> <span class="toc-text">gpiochip_direction_output: 设置GPIO为输出的硬件调度函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gpiod-direction-input%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0-%E8%AE%BE%E7%BD%AEGPIO%E4%B8%BA%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.21.</span> <span class="toc-text">gpiod_direction_input及相关函数: 设置GPIO为输入模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#gpiod-direction-input-nonotify-%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91%E4%B8%8E%E7%A1%AC%E4%BB%B6%E9%80%82%E9%85%8D"><span class="toc-number">4.21.1.</span> <span class="toc-text">gpiod_direction_input_nonotify: 核心逻辑与硬件适配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gpiod-direction-input-%E5%85%AC%E5%85%B1API%E5%B0%81%E8%A3%85"><span class="toc-number">4.21.2.</span> <span class="toc-text">gpiod_direction_input: 公共API封装</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gpiod-direction-output%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0-%E8%AE%BE%E7%BD%AEGPIO%E4%B8%BA%E8%BE%93%E5%87%BA%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%B1%82%E6%AC%A1%E5%8C%96%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.22.</span> <span class="toc-text">gpiod_direction_output及相关函数: 设置GPIO为输出模式的层次化实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#gpiod-direction-output-raw-commit-%E6%89%A7%E8%A1%8C%E7%A1%AC%E4%BB%B6%E9%85%8D%E7%BD%AE%E7%9A%84%E5%BA%95%E5%B1%82%E6%A0%B8%E5%BF%83"><span class="toc-number">4.22.1.</span> <span class="toc-text">gpiod_direction_output_raw_commit: 执行硬件配置的底层核心</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gpiod-direction-output-nonotify-%E9%80%BB%E8%BE%91%E5%B1%82%E6%A0%B8%E5%BF%83-%E5%A4%84%E7%90%86%E7%89%B9%E6%AE%8A%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%AE%89%E5%85%A8%E6%A3%80%E6%9F%A5"><span class="toc-number">4.22.2.</span> <span class="toc-text">gpiod_direction_output_nonotify: 逻辑层核心 (处理特殊模式和安全检查)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gpiod-direction-output-%E5%92%8C-gpiod-direction-output-raw-%E5%85%AC%E5%85%B1API"><span class="toc-number">4.22.3.</span> <span class="toc-text">gpiod_direction_output 和 gpiod_direction_output_raw: 公共API</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gpiod-set-transitory%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0-%E9%85%8D%E7%BD%AEGPIO%E7%8A%B6%E6%80%81%E7%9A%84%E6%8C%81%E4%B9%85%E6%80%A7"><span class="toc-number">4.23.</span> <span class="toc-text">gpiod_set_transitory及相关函数: 配置GPIO状态的持久性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#gpiod-set-transitory-%E8%AE%BE%E7%BD%AE%E5%BC%95%E8%84%9A%E7%8A%B6%E6%80%81%E6%98%AF%E5%90%A6%E4%B8%BA%E7%9E%AC%E6%80%81%E7%9A%84%E5%85%AC%E5%85%B1API"><span class="toc-number">4.23.1.</span> <span class="toc-text">gpiod_set_transitory: 设置引脚状态是否为瞬态的公共API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gpio-set-config-with-argument-optional-%E2%80%9C%E5%8F%AF%E9%80%89%E5%9C%B0%E2%80%9D%E5%BA%94%E7%94%A8%E9%85%8D%E7%BD%AE"><span class="toc-number">4.23.2.</span> <span class="toc-text">gpio_set_config_with_argument_optional: “可选地”应用配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gpio-set-config-with-argument-%E5%92%8C-gpio-do-set-config-%E6%89%93%E5%8C%85%E5%B9%B6%E5%88%86%E5%8F%91%E9%85%8D%E7%BD%AE"><span class="toc-number">4.23.3.</span> <span class="toc-text">gpio_set_config_with_argument 和 gpio_do_set_config: 打包并分发配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gpiod-configure-flags-%E9%9B%86%E4%B8%AD%E5%BC%8FGPIO%E9%85%8D%E7%BD%AE%E6%A0%B8%E5%BF%83%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0"><span class="toc-number">4.24.</span> <span class="toc-text">gpiod_configure_flags: 集中式GPIO配置核心辅助函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gpiod-find-and-request-GPIO-%E8%8E%B7%E5%8F%96%E3%80%81%E8%AF%B7%E6%B1%82%E4%B8%8E%E9%85%8D%E7%BD%AE%E7%9A%84%E6%A0%B8%E5%BF%83%E5%BC%95%E6%93%8E"><span class="toc-number">4.25.</span> <span class="toc-text">gpiod_find_and_request: GPIO 获取、请求与配置的核心引擎</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gpiod-get-API-%E8%8E%B7%E5%8F%96GPIO%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%9A%84-layered-Convenience-Wrappers"><span class="toc-number">4.26.</span> <span class="toc-text">gpiod_get API: 获取GPIO描述符的 layered Convenience Wrappers</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#gpiod-get-index-%E8%8E%B7%E5%8F%96%E5%A4%9A%E7%B4%A2%E5%BC%95GPIO%E7%9A%84%E5%9F%BA%E7%A1%80%E5%87%BD%E6%95%B0"><span class="toc-number">4.26.1.</span> <span class="toc-text">gpiod_get_index: 获取多索引GPIO的基础函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gpiod-get-index-optional-%E8%8E%B7%E5%8F%96%E5%8F%AF%E9%80%89%E7%9A%84%E5%A4%9A%E7%B4%A2%E5%BC%95GPIO"><span class="toc-number">4.26.2.</span> <span class="toc-text">gpiod_get_index_optional: 获取可选的多索引GPIO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gpiod-get-optional-%E8%8E%B7%E5%8F%96%E5%8D%95%E4%B8%AA%E5%8F%AF%E9%80%89GPIO-%E6%9C%80%E5%B8%B8%E7%94%A8"><span class="toc-number">4.26.2.1.</span> <span class="toc-text">gpiod_get_optional: 获取单个可选GPIO (最常用)</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#drivers-gpio-gpiolib-cdev-c"><span class="toc-number">5.</span> <span class="toc-text">drivers&#x2F;gpio&#x2F;gpiolib-cdev.c</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#lineinfo-watch-poll-%E7%AD%89%E5%BE%85GPIO%E4%BA%8B%E4%BB%B6"><span class="toc-number">5.1.</span> <span class="toc-text">lineinfo_watch_poll: 等待GPIO事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lineinfo-watch-read-%E8%AF%BB%E5%8F%96GPIO%E4%BA%8B%E4%BB%B6"><span class="toc-number">5.2.</span> <span class="toc-text">lineinfo_watch_read: 读取GPIO事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gpio-chrdev-open-%E6%89%93%E5%BC%80GPIO%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87"><span class="toc-number">5.3.</span> <span class="toc-text">gpio_chrdev_open: 打开GPIO字符设备</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GPIO%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%B3%A8%E5%86%8C%E4%B8%8E%E6%B3%A8%E9%94%80"><span class="toc-number">5.4.</span> <span class="toc-text">GPIO字符设备接口的注册与注销</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#gpio-fileops-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%E9%9B%86"><span class="toc-number">5.4.1.</span> <span class="toc-text">gpio_fileops: 文件操作函数集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gpiolib-cdev-register-%E6%B3%A8%E5%86%8CGPIO%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87"><span class="toc-number">5.4.2.</span> <span class="toc-text">gpiolib_cdev_register: 注册GPIO字符设备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gpiolib-cdev-unregister-%E6%B3%A8%E9%94%80GPIO%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87"><span class="toc-number">5.4.3.</span> <span class="toc-text">gpiolib_cdev_unregister: 注销GPIO字符设备</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#drivers-gpio-gpio-stmpe-c"><span class="toc-number">6.</span> <span class="toc-text">drivers&#x2F;gpio&#x2F;gpio-stmpe.c</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#STMPE-GPIO-%E6%93%8D%E4%BD%9C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E9%9B%86"><span class="toc-number">6.1.</span> <span class="toc-text">STMPE GPIO 操作回调函数集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#stmpe-gpio-get-%E8%8E%B7%E5%8F%96GPIO%E5%BC%95%E8%84%9A%E7%9A%84%E8%BE%93%E5%85%A5%E7%94%B5%E5%B9%B3"><span class="toc-number">6.1.1.</span> <span class="toc-text">stmpe_gpio_get: 获取GPIO引脚的输入电平</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stmpe-gpio-set-%E8%AE%BE%E7%BD%AEGPIO%E5%BC%95%E8%84%9A%E7%9A%84%E8%BE%93%E5%87%BA%E7%94%B5%E5%B9%B3"><span class="toc-number">6.1.2.</span> <span class="toc-text">stmpe_gpio_set: 设置GPIO引脚的输出电平</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stmpe-gpio-get-direction-%E8%8E%B7%E5%8F%96GPIO%E5%BC%95%E8%84%9A%E7%9A%84%E6%96%B9%E5%90%91"><span class="toc-number">6.1.3.</span> <span class="toc-text">stmpe_gpio_get_direction: 获取GPIO引脚的方向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stmpe-gpio-direction-output-stmpe-gpio-direction-input-%E8%AE%BE%E7%BD%AEGPIO%E5%BC%95%E8%84%9A%E7%9A%84%E6%96%B9%E5%90%91"><span class="toc-number">6.1.4.</span> <span class="toc-text">stmpe_gpio_direction_output &#x2F; stmpe_gpio_direction_input: 设置GPIO引脚的方向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stmpe-gpio-request-%E8%AF%B7%E6%B1%82%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AAGPIO"><span class="toc-number">6.1.5.</span> <span class="toc-text">stmpe_gpio_request: 请求使用一个GPIO</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STMPE-GPIO%E9%A9%B1%E5%8A%A8%E7%9A%84%E6%A0%B8%E5%BF%83%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.2.</span> <span class="toc-text">STMPE GPIO驱动的核心实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#struct-stmpe-gpio-%E9%A9%B1%E5%8A%A8%E7%A7%81%E6%9C%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">6.2.1.</span> <span class="toc-text">struct stmpe_gpio: 驱动私有数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#template-chip-gpiolib%E6%8E%A5%E5%8F%A3%E7%9A%84%E2%80%9D%E8%93%9D%E5%9B%BE%E2%80%9D"><span class="toc-number">6.2.2.</span> <span class="toc-text">template_chip: gpiolib接口的”蓝图”</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stmpe-gpio-probe-%E5%88%9D%E5%A7%8B%E5%8C%96STMPE-IO%E6%89%A9%E5%B1%95%E5%99%A8%E7%9A%84GPIO%E5%8A%9F%E8%83%BD"><span class="toc-number">6.3.</span> <span class="toc-text">stmpe_gpio_probe: 初始化STMPE IO扩展器的GPIO功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stmpe-gpio-STMPE-GPIO%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E6%B3%A8%E5%86%8C"><span class="toc-number">6.4.</span> <span class="toc-text">stmpe_gpio: STMPE GPIO驱动的定义与注册</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/48974a1a/" title="mq-deadline"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/08.jpg" onerror="this.onerror=null;this.src='/images/404.jpg'" alt="mq-deadline"/></a><div class="content"><a class="title" href="/posts/48974a1a/" title="mq-deadline">mq-deadline</a><time datetime="2025-10-10T09:35:34.893Z" title="更新于 2025-10-10 17:35:34">2025-10-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/44c8f818/" title="list"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/10.jpg" onerror="this.onerror=null;this.src='/images/404.jpg'" alt="list"/></a><div class="content"><a class="title" href="/posts/44c8f818/" title="list">list</a><time datetime="2025-10-10T08:51:23.325Z" title="更新于 2025-10-10 16:51:23">2025-10-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/447af9b5/" title="genhd"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/09.jpg" onerror="this.onerror=null;this.src='/images/404.jpg'" alt="genhd"/></a><div class="content"><a class="title" href="/posts/447af9b5/" title="genhd">genhd</a><time datetime="2025-10-10T08:50:59.612Z" title="更新于 2025-10-10 16:50:59">2025-10-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/ed4b199f/" title="class"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/01.jpg" onerror="this.onerror=null;this.src='/images/404.jpg'" alt="class"/></a><div class="content"><a class="title" href="/posts/ed4b199f/" title="class">class</a><time datetime="2025-10-10T08:38:03.324Z" title="更新于 2025-10-10 16:38:03">2025-10-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/aa511041/" title="blk-core"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/07.jpg" onerror="this.onerror=null;this.src='/images/404.jpg'" alt="blk-core"/></a><div class="content"><a class="title" href="/posts/aa511041/" title="blk-core">blk-core</a><time datetime="2025-10-10T08:15:30.737Z" title="更新于 2025-10-10 16:15:30">2025-10-10</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/images/covers/08.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">文档</div><div class="footer-flex-content"><a href="/categories/linux/" target="_blank" title="🚀 linux">🚀 linux</a><a href="/categories/rt-thread/" target="_blank" title="📑 rt-thread">📑 rt-thread</a><a href="/categories/uboot/" target="_blank" title="📌 uboot">📌 uboot</a><a href="/categories/LoraWan/" target="_blank" title="⚔️ LoraWan">⚔️ LoraWan</a><a href="/categories/hpatch/" target="_blank" title="❓ hpatch">❓ hpatch</a><a href="/categories/git/" target="_blank" title="⚡️ git">⚡️ git</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/gallery/" target="_blank" title="图库">图库</a><a href="/messageboard/" target="_blank" title="留言板">留言板</a><a href="/shuoshuo/" target="_blank" title="说说">说说</a><a href="/link/" target="_blank" title="示例">示例</a><a href="/link/" target="_blank" title="友链">友链</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">框架</div><div class="footer-flex-content"><a href="https://hexo.io/zh-cn/" rel="external nofollow noreferrer" target="_blank" title="Hexo">Hexo</a><a href="https://butterfly.js.org/" rel="external nofollow noreferrer" target="_blank" title="Butterfly">Butterfly</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">贊助</div><div class="footer-flex-content"><div><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/alipay.png" alt='wdfk_prog' width='100px' height='100px'></div></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Liya Huang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo 8.0.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.1</a></span></div><div class="footer_custom_text">你好，欢迎来到我的 <a href="/about/">数字花园</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天" style="display:none"><i class="fas fa-message"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script><script>(() => {
  const abcjsInit = () => {
    const abcjsFn = () => {
      setTimeout(() => {
        const sheets = document.querySelectorAll(".abc-music-sheet")
        for (let i = 0; i < sheets.length; i++) {
          const ele = sheets[i]
          if (ele.children.length > 0) continue

          // Parse parameters from data-params attribute
          let params = {}
          const dp = ele.getAttribute("data-params")
          if (dp) {
            try {
              params = JSON.parse(dp)
            } catch (e) {
              console.error("Failed to parse data-params:", e)
            }
          }

          // Merge parsed parameters with the responsive option
          // Ensures params content appears before responsive
          const options = { ...params, responsive: "resize" }

          // Render the music score using ABCJS.renderAbc
          ABCJS.renderAbc(ele, ele.innerHTML, options)
        }
      }, 100)
    }

    if (typeof ABCJS === "object") {
      abcjsFn()
    } else {
      btf.getScript("https://cdn.jsdelivr.net/npm/abcjs/dist/abcjs-basic-min.min.js").then(abcjsFn)
    }
  }

  if (window.pjax) {
    abcjsInit()
  } else {
    window.addEventListener("load", abcjsInit)
  }

  btf.addGlobalFn("encrypt", abcjsInit, "abcjs")
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: 'Ov23livBmwx65h3XIdfT',
      clientSecret: '9f23bdaa2ea11322f9f405d77bcdc27166077a7d',
      repo: 'wdfk-prog.github.io',
      owner: 'wdfk-prog',
      admin: ['wdfk-prog'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || 'f15c9470a85c5c4101912f7c5033ac4e'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script>window.newestComments = {
  changeContent: content => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<code>.*?<\/code>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g, "") // remove html tag

    if (content.length > 150) {
      content = content.substring(0, 150) + '...'
    }
    return content
  },

  generateHtml: (array, ele) => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class="aside-list-item">'

        if (true && array[i].avatar) {
          const imgAttr = 'data-lazy-src'
          const lazyloadNative = ''
          result += `<a href="${array[i].url}" class="thumbnail"><img ${imgAttr}="${array[i].avatar}" alt="${array[i].nick}" ${lazyloadNative}></a>`
        }

        result += `<div class="content">
        <a class="comment" href="${array[i].url}" title="${array[i].content}">${array[i].content}</a>
        <div class="name"><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '暂无评论'
    }

    ele.innerHTML = result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh(ele)
  },

  newestCommentInit: (name, getComment) => {
    const $dom = document.querySelector('#card-newest-comments .aside-list')
    if ($dom) {
      const data = btf.saveToLocal.get(name)
      if (data) {
        newestComments.generateHtml(JSON.parse(data), $dom)
      } else {
        getComment($dom)
      }
    }
  },

  run: (name, getComment) => {
    newestComments.newestCommentInit(name, getComment)
    btf.addGlobalFn('pjaxComplete', () => newestComments.newestCommentInit(name, getComment), name)
  }
}</script><script>window.addEventListener('load', () => {
  const keyName = 'github-newest-comments'
  const { changeContent, generateHtml, run } = window.newestComments

  const findTrueUrl = (array, ele) => {
    Promise.all(array.map(item =>
      fetch(item.url).then(resp => resp.json()).then(data => {
        let urlArray = data.body ? data.body.match(/(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?/ig) : []
        if (!Array.isArray(urlArray) || urlArray.length === 0) {
          urlArray = [`${data.html_url}`]
        }
        if (data.user.login === 'utterances-bot') {
          return urlArray.pop()
        } else {
          return urlArray.shift()
        }
      })
    )).then(res => {
        array = array.map((i,index)=> {
          return {
            ...i,
            url: res[index]
          }
        })

        btf.saveToLocal.set(keyName, JSON.stringify(array), 10/(60*24))
        generateHtml(array, ele)
    });
  }

  const getComment = ele => {
    fetch('https://api.github.com/repos/wdfk-prog/wdfk-prog.github.io/issues/comments?sort=updated&direction=desc&per_page=6&page=1',{
      "headers": {
        Accept: 'application/vnd.github.v3.html+json'
      }
    })
      .then(response => response.json())
      .then(data => {
        const githubArray = data.map(item => {
          return {
            'avatar': item.user.avatar_url,
            'content': changeContent(item.body_html || item.body),
            'nick': item.user.login,
            'url': item.issue_url,
            'date': item.updated_at
          }
        })
        findTrueUrl(githubArray, ele)
      }).catch(e => {
        console.error(e)
        ele.textContent= "无法获取评论，请确认相关配置是否正确"
      })
  }
  run(keyName, getComment)
})</script><div class="aplayer no-destroy" data-id="60198" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="false" data-volume="0.5"></div><script>
  var titleTime, OriginTitile = document.title;
  document.addEventListener("visibilitychange", function() {
    if (document.hidden) {
      titleTime = setTimeout(function() {
        document.title = "w(ﾟДﾟ)w 不要走！再看看嘛！";
      }, 300);
    } else {
      document.title = "♪(^∇^*)欢迎回来！" + OriginTitile;
      titleTime = setTimeout(function() {
        document.title = OriginTitile;
      }, 2000);
    }
  });
</script>
<script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script>(() => {
  window.ChatraID = '5cPWcnA8HKGzg5hoc'
  window.Chatra = window.Chatra || function() {
    (window.Chatra.q = window.Chatra.q || []).push(arguments)
  }

  btf.getScript('https://call.chatra.io/chatra.js').then(() => {
    const isChatBtn = true
    const isChatHideShow = true

    if (isChatBtn) {
      const close = () => {
        Chatra('minimizeWidget')
        Chatra('hide')
      }

      const open = () => {
        Chatra('openChat', true)
        Chatra('show')
      }

      window.ChatraSetup = { startHidden: true }
    
      window.chatBtnFn = () => document.getElementById('chatra').classList.contains('chatra--expanded') ? close() : open()

      document.getElementById('chat-btn').style.display = 'block'
    } else if (isChatHideShow) {
      window.chatBtn = {
        hide: () => Chatra('hide'),
        show: () => Chatra('show')
      }
    }
  })
})()</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: true,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      true
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-MF3J339H" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript></div><script src="https://cdn.jsdelivr.net/npm/echarts@5.5.1/dist/echarts.min.js"></script>
        
        <script>
            document.addEventListener("DOMContentLoaded", function() {
                const heatmapChartDom = document.getElementById('heatmapChart');
                if(heatmapChartDom){
                    const heatmapChart = echarts.init(heatmapChartDom, 'dark');
                    const cellSize = [18, 18];
                    
                    const groupByYear = (data) => {
                        const result = {};
                        data.forEach(([date, value]) => {
                            const [year] = date.split('-').map(Number);
                            if (!result[year]) {
                                result[year] = [];
                            }
                            result[year].push([date, value]);
                        });
                        return result;
                    };
                    
                    const groupedData = groupByYear([["2025-10-03",392],["2025-10-04",5],["2025-10-06",9],["2025-10-07",8],["2025-10-10",3]]);
                    const years = Object.keys(groupedData).reverse();
                    
                    var initYear = parseInt(heatmapChartDom.getAttribute('year')) || new Date().getFullYear();
                    const minYear = years[years.length - 1];
                    const maxYear = years[0];
                    if (initYear < minYear || initYear > maxYear) {
                        initYear = maxYear;
                    }
                    console.log('[hexo-graph]generateHeatmapChart|initYear:', initYear, 'minYear:', minYear, 'maxYear:', maxYear);
                    
                    heatmapChart.setOption({
                        grid: {},
                        tooltip: { 
                            position: 'top', 
                            formatter: params => `${params.value[0]}: ${params.value[1]} Articles` 
                        },
                        calendar: { 
                            top: '10%',
                            left: 'left', 
                            right: '8%',
                            range: initYear,
                            cellSize: cellSize, 
                            splitLine: { lineStyle: { color: '#E0E0E0', width: 1 } }, 
                            itemStyle: { borderWidth: 1, borderColor: '#E0E0E0' }, 
                            dayLabel: { show: false },
                            monthLabel: { show: true },
                            yearLabel: { show: false },
                        },
                        visualMap: { 
                            show: true,
                            right: '8%',
                            bottom: '5%',
                            type: 'piecewise',
                            orient: 'horizontal',
                            text: ['More', 'Less'],
                            min: 0,
                            max: Math.max(...groupedData[initYear].map(item => item[1])),
                            inRange: { color: ["#ACE7AE","#69C16D","#549F57"] }
                        },
                        legend: {
                            type: 'scroll',
                            icon: 'none',
                            data: years,
                            orient: 'vertical',
                            top: '5%',
                            right: 'right',
                            itemWidth: 20,
                            itemHeight: 20,
                            itemGap: 10,
                            pageIconSize: 10,
                            pageTextStyle: { fontSize: 14 },
                            selectedMode: 'single',
                        },
                        series: years.map(year => ({
                            type: 'heatmap',
                            coordinateSystem: 'calendar',
                            data: groupedData[year],
                            name: year,
                            emphasis: {
                                disabled: true,
                            },
                            silent: year !== initYear,
                        })),
                    });
                    
                    // init selected year
                    heatmapChart.dispatchAction({
                        type: 'legendSelect',
                        name: initYear,
                    });
                    
                    heatmapChart.on('legendselectchanged', function(params) {
                        console.log('[hexo-graph]generateHeatmapChart|legendselectchanged:', params);
                        const selectedYear = Object.keys(params.selected).find(key => params.selected[key]);
                        if (selectedYear && groupedData[selectedYear]) {
                            heatmapChart.setOption({
                                calendar: {
                                    range: selectedYear,
                                },
                                visualMap: {
                                    max: Math.max(...groupedData[selectedYear].map(item => item[1])),
                                },
                                series: years.map(year => ({
                                    type: 'heatmap',
                                    coordinateSystem: 'calendar',
                                    data: groupedData[year],
                                    name: year,
                                    emphasis: {
                                        disabled: true,
                                    },
                                    silent: year !== selectedYear,
                                })),
                            });
                        }
                    });
                    
                    heatmapChart.on('click', function (params) {
                        if (params.componentType === 'series') {
                            const [year, month] = params.value[0].split('-');
                            window.location.href = '/archives/' + year + '/' + month;
                        }
                    });
                }
            });
        </script>
    
        
        <script>
            document.addEventListener("DOMContentLoaded", function() {
                const monthlyChartDom = document.getElementById('monthlyChart');
                if(monthlyChartDom){
                    const monthlyChart = echarts.init(monthlyChartDom, 'dark');
                    monthlyChart.setOption({
                        xAxis: { 
                            type: 'category', 
                            data: ["2025-10"], 
                            axisLabel: { fontSize: 14, fontWeight: 'bold', fontFamily: 'Microsoft YaHei, SimSun, serif' }
                        },
                        yAxis: { type: 'value', splitLine: { lineStyle: { type: 'dashed', color: '#ccc' } } },
                        series: [{
                            name: 'Articles',
                            type: 'line',
                            data: [417],
                            smooth: true,
                            lineStyle: { color: '#5470C6', width: 2 },
                            itemStyle: { color: '#5470C6' },
                            areaStyle: { color: 'rgba(84, 112, 198, 0.4)' },
                            symbolSize: 10,
                            label: {
                                show: true,
                                position: 'top',
                                formatter: params => params.value,
                                fontSize: 14,
                                color: '#000',
                                fontWeight: 'bold',
                                fontFamily: 'Microsoft YaHei, SimSun, serif'
                            }
                        }]
                    });

                    monthlyChart.on('click', function (params) {
                        const [year, month] = params.name.split('-');
                        window.location.href = '/archives/' + year + '/' + month;
                    });
                }
            })
        </script>
    
        
        <script>
            document.addEventListener("DOMContentLoaded", function() {
                const tagsChartDom = document.getElementById('tagsChart');
                if(tagsChartDom){
                    const tagsChart = echarts.init(tagsChartDom, 'dark');
                    tagsChart.setOption({
                        tooltip: { trigger: 'item', formatter: '{b}: {c} ({d}%)' },
                        series: [{
                            type: 'pie',
                            radius: '60%',
                            data: [{"name":"linux","value":230},{"name":"uboot","value":68},{"name":"kernel","value":61},{"name":"rt-thread","value":44},{"name":"u-boot分类","value":44},{"name":"drivers","value":39},{"name":"fs","value":37},{"name":"other","value":28}],
                            label: {
                                position: 'outside',
                                formatter: '{b} {c} ({d}%)',
                                fontSize: 14,
                                fontWeight: 'bold',
                                fontFamily: 'Microsoft YaHei, SimSun, serif'
                            },
                            color: ["#5470C6","#91CC75","#FAC858","#EE6666","#73C0DE","#3BA272","#FC8452","#9A60B4"],
                            labelLine: { show: true }
                        }],
                        legend: {
                            bottom: '0',
                            left: 'center',
                            data: [{"name":"linux","value":230},{"name":"uboot","value":68},{"name":"kernel","value":61},{"name":"rt-thread","value":44},{"name":"u-boot分类","value":44},{"name":"drivers","value":39},{"name":"fs","value":37},{"name":"other","value":28}].map(tag => tag.name),
                            textStyle: { fontSize: 14, fontWeight: 'bold', fontFamily: 'Microsoft YaHei, SimSun, serif' }
                        }
                    });

                    tagsChart.on('click', function (params) {
                        window.location.href = '/tags/' + params.name;
                    });
                }
            })
        </script>
    
        
        <script>
            document.addEventListener("DOMContentLoaded", function() {
                const categoriesChartDom = document.getElementById('categoriesChart');
                if(categoriesChartDom){
                    const categoriesChart = echarts.init(categoriesChartDom, 'dark');
                    categoriesChart.setOption({
                        xAxis: { type: 'value', splitLine: { lineStyle: { type: 'dashed', color: '#ccc' } } },
                        yAxis: { 
                            type: 'category', 
                            data: [{"name":"linux","value":230},{"name":"uboot","value":68},{"name":"kernel","value":61},{"name":"rt-thread","value":44},{"name":"u-boot分类","value":44}].map(category => category.name).reverse(), 
                            axisLabel: { fontSize: 14, fontWeight: 'bold', fontFamily: 'Microsoft YaHei, SimSun, serif' }
                        },
                        series: [{
                            name: 'Category Count',
                            type: 'bar',
                            data: [{"name":"linux","value":230},{"name":"uboot","value":68},{"name":"kernel","value":61},{"name":"rt-thread","value":44},{"name":"u-boot分类","value":44}].map(category => category.value).reverse(),
                            label: {
                                show: true,
                                position: 'right',
                                formatter: params => params.value,
                                fontSize: 14,
                                color: '#000',
                                fontWeight: 'bold',
                                fontFamily: 'Microsoft YaHei, SimSun, serif'
                            },
                            itemStyle: {
                                color: new echarts.graphic.LinearGradient(0, 0, 1, 0, [
                                    { offset: 0, color: '#91CC75' },
                                    { offset: 1, color: '#73C0DE' }
                                ])
                            }
                        }]
                    });

                    categoriesChart.on('click', function (params) {
                        window.location.href = '/categories/' + params.name;
                    });
                }
            });
        </script>
    
        
        <script>
            document.addEventListener("DOMContentLoaded", function() {
                const categoriesTreeChartDom = document.getElementById('categoriesTreeChart');
                if(categoriesTreeChartDom){
                    const treeChart = echarts.init(categoriesTreeChartDom, 'dark');
                    treeChart.setOption({
                        title: {
                            text: '操作提示：单击展开分类，双击进入具体分类页面',
                            textStyle: {
                                fontSize: 12,
                                color: '#999',
                                fontWeight: 'normal'
                            },
                            bottom: 0,
                            left: 'center'
                        },
                        tooltip: {
                            trigger: 'item',
                            triggerOn: 'mousemove'
                        },
                        series: [{
                            type: 'tree',
                            data: [{"name":"Categories","children":[{"name":"git","children":[],"count":6,"path":"git"},{"name":"hpatch","children":[{"name":"libdivsufsort","children":[],"count":3,"path":"hpatch/libdivsufsort"},{"name":"SA-IS","children":[],"count":1,"path":"hpatch/SA-IS"}],"count":10,"path":"hpatch"},{"name":"LoraWan","children":[{"name":"LoRaWAN标准","children":[{"name":"LoRaWAN-Specification_ZH_CN","children":[{"name":"LoRaWAN-Specification_ZH_CN-190102","children":[{"name":"chapter","children":[],"count":20,"path":"LoraWan/LoRaWAN标准/LoRaWAN-Specification_ZH_CN/LoRaWAN-Specification_ZH_CN-190102/chapter"}],"count":22,"path":"LoraWan/LoRaWAN标准/LoRaWAN-Specification_ZH_CN/LoRaWAN-Specification_ZH_CN-190102"}],"count":22,"path":"LoraWan/LoRaWAN标准/LoRaWAN-Specification_ZH_CN"}],"count":22,"path":"LoraWan/LoRaWAN标准"}],"count":23,"path":"LoraWan"},{"name":"MCU","children":[],"count":23,"path":"MCU"},{"name":"linux","children":[{"name":"block","children":[],"count":8,"path":"linux/block"},{"name":"include","children":[],"count":10,"path":"linux/include"},{"name":"fs","children":[],"count":37,"path":"linux/fs"},{"name":"drivers","children":[{"name":"base","children":[],"count":14,"path":"linux/drivers/base"},{"name":"tty","children":[],"count":2,"path":"linux/drivers/tty"},{"name":"clk","children":[],"count":2,"path":"linux/drivers/clk"}],"count":39,"path":"linux/drivers"},{"name":"kernel","children":[{"name":"rcu","children":[],"count":3,"path":"linux/kernel/rcu"},{"name":"lock","children":[],"count":7,"path":"linux/kernel/lock"},{"name":"irq","children":[],"count":5,"path":"linux/kernel/irq"},{"name":"sched","children":[],"count":7,"path":"linux/kernel/sched"},{"name":"time","children":[],"count":10,"path":"linux/kernel/time"}],"count":61,"path":"linux/kernel"},{"name":"lib","children":[],"count":19,"path":"linux/lib"},{"name":"security","children":[],"count":1,"path":"linux/security"},{"name":"scripts","children":[],"count":2,"path":"linux/scripts"},{"name":"other","children":[],"count":17,"path":"linux/other"},{"name":"mm","children":[],"count":19,"path":"linux/mm"},{"name":"arch","children":[{"name":"arm","children":[],"count":10,"path":"linux/arch/arm"}],"count":10,"path":"linux/arch"}],"count":230,"path":"linux"},{"name":"tmc5160","children":[],"count":1,"path":"tmc5160"},{"name":"rt-thread","children":[{"name":"其他资料","children":[{"name":"fatfs","children":[],"count":1,"path":"rt-thread/其他资料/fatfs"}],"count":1,"path":"rt-thread/其他资料"}],"count":44,"path":"rt-thread"},{"name":"uboot","children":[{"name":"other","children":[],"count":12,"path":"uboot/other"},{"name":"子目录","children":[],"count":10,"path":"uboot/子目录"},{"name":"u-boot分类","children":[{"name":"arch","children":[{"name":"arm","children":[],"count":2,"path":"uboot/u-boot分类/arch/arm"}],"count":3,"path":"uboot/u-boot分类/arch"},{"name":"boot","children":[],"count":4,"path":"uboot/u-boot分类/boot"},{"name":"api","children":[],"count":1,"path":"uboot/u-boot分类/api"},{"name":"common","children":[],"count":10,"path":"uboot/u-boot分类/common"},{"name":"cmd","children":[],"count":1,"path":"uboot/u-boot分类/cmd"},{"name":"dm","children":[],"count":15,"path":"uboot/u-boot分类/dm"},{"name":"env","children":[],"count":1,"path":"uboot/u-boot分类/env"},{"name":"lib","children":[],"count":4,"path":"uboot/u-boot分类/lib"},{"name":"include","children":[],"count":3,"path":"uboot/u-boot分类/include"},{"name":"fdt","children":[],"count":1,"path":"uboot/u-boot分类/fdt"},{"name":"test","children":[],"count":1,"path":"uboot/u-boot分类/test"}],"count":44,"path":"uboot/u-boot分类"}],"count":68,"path":"uboot"},{"name":"杂谈","children":[],"count":8,"path":"杂谈"},{"name":"freertos","children":[],"count":1,"path":"freertos"}],"count":0,"path":""}],
                            initialTreeDepth: -1,
                            top: '5%',
                            bottom: '10%',
                            left: '0%',
                            right: '0%',
                            symbolSize: 15,
                            layout: 'orthogonal',
                            orient: 'TB',
                            itemStyle: {
                                color: '#91CC75',
                                borderColor: '#73C0DE'
                            },
                            label: {
                                position: 'bottom',
                                verticalAlign: 'middle',
                                align: 'center',
                                fontSize: 14,
                                distance: 28,
                                formatter: function(params) {
                                    return params.data.name + (params.data.count ? ' (' + params.data.count + ')' : '');
                                }
                            },
                            leaves: {
                                label: {
                                    position: 'top',
                                    verticalAlign: 'middle',
                                    align: 'center'
                                }
                            },
                            emphasis: {
                                focus: 'descendant'
                            },
                            expandAndCollapse: true
                        }]
                    });

                    treeChart.on('dblclick', function (params) {
                        if (params.data && params.data.path) {
                            window.location.href = '/categories/' + params.data.path;
                        }
                    });
                }
            });
        </script>
    
    <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"react":{"opacity":0.7},"log":false});</script></body></html>