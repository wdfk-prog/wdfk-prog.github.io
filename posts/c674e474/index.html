<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>init | wdfk-prog的个人博客</title><meta name="author" content="Liya Huang"><meta name="copyright" content="Liya Huang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[TOC] Linux 内存模型之基石：FLATMEM 深度解析FLATMEM 是 Linux 内核中最基础、最常用，也是最高效的内存模型。正如其名，“平坦内存”模型假定系统的物理内存是一个单一、连续、不存在大间隙的地址空间。  一、 核心原理：mem_map 数组FLATMEM 模型的全部精髓都围绕着一个核心数据结构：一个巨大的、全局的 struct page 数组，通常被称为 mem_map。">
<meta property="og:type" content="article">
<meta property="og:title" content="init">
<meta property="og:url" content="https://wdfk-prog.space/posts/c674e474/index.html">
<meta property="og:site_name" content="wdfk-prog的个人博客">
<meta property="og:description" content="[TOC] Linux 内存模型之基石：FLATMEM 深度解析FLATMEM 是 Linux 内核中最基础、最常用，也是最高效的内存模型。正如其名，“平坦内存”模型假定系统的物理内存是一个单一、连续、不存在大间隙的地址空间。  一、 核心原理：mem_map 数组FLATMEM 模型的全部精髓都围绕着一个核心数据结构：一个巨大的、全局的 struct page 数组，通常被称为 mem_map。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wdfk-prog.space/images/covers/01.jpg">
<meta property="article:published_time" content="2025-10-03T01:01:49.000Z">
<meta property="article:modified_time" content="2025-10-03T09:23:28.711Z">
<meta property="article:author" content="Liya Huang">
<meta property="article:tag" content="linux">
<meta property="article:tag" content="mm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wdfk-prog.space/images/covers/01.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "init",
  "url": "https://wdfk-prog.space/posts/c674e474/",
  "image": "https://wdfk-prog.space/images/covers/01.jpg",
  "datePublished": "2025-10-03T01:01:49.000Z",
  "dateModified": "2025-10-03T09:23:28.711Z",
  "author": [
    {
      "@type": "Person",
      "name": "Liya Huang",
      "url": "https://github.com/wdfk-prog"
    }
  ]
}</script><link rel="shortcut icon" href="/images/favicon.png"><link rel="canonical" href="https://wdfk-prog.space/posts/c674e474/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//static.cloudflareinsights.com"/><link rel="preconnect" href="//www.clarity.ms"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxxxxx"/><meta name="baidu-site-verification" content="xxxxxxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-3978542742563797',
  enable_page_level_ads: 'true'
});</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?3c49dd4913ab43efb1bfc8d12b1cded9";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-PF2CVP2PL4"></script><script>window.dataLayer = window.dataLayer || []
function gtag(){dataLayer.push(arguments)}
gtag('js', new Date())
gtag('config', 'G-PF2CVP2PL4')
btf.addGlobalFn('pjaxComplete', () => {
  gtag('config', 'G-PF2CVP2PL4', {'page_path': window.location.pathname})
}, 'google_analytics')
</script><script defer="defer" data-pjax="data-pjax" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;17ff914b5e28493597b7dc19f3356022&quot;}"></script><script>(function(c,l,a,r,i,t,y){
    c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
    t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
    y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
})(window, document, "clarity", "script", "tkaenn1tjv");
</script><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
"https://www.googletagmanager.com/gtm.js?id="+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-MF3J339H');
btf.addGlobalFn('pjaxComplete', () => {
  dataLayer.push({'event': 'pjaxComplete', 'page_title': document.title, 'page_location': location.href, 'page_path': window.location.pathname})
}, 'google_tag_manager')</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":false,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'init',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.0.0"><link rel="alternate" href="/atom.xml" title="wdfk-prog的个人博客" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (true) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(/images/subtle-texture.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/avatar.png" onerror="this.onerror=null;this.src='/images/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">414</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">49</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">53</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book-open"></i><span> 页面</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fas fa-quote-left"></i><span> 说说</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 示例</span></a></li></ul></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/songs/"><i class="fa-fw fas fa-music"></i><span> 歌曲</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/images/covers/01.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/my-logo.png" alt="Logo"><span class="site-name">wdfk-prog的个人博客</span></a><a class="nav-page-title" href="/"><span class="site-name">init</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book-open"></i><span> 页面</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fas fa-quote-left"></i><span> 说说</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 示例</span></a></li></ul></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/songs/"><i class="fa-fw fas fa-music"></i><span> 歌曲</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">init<a class="post-edit-link" href="null_posts/linux/mm/mm_init.md" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-10-03T01:01:49.000Z" title="发表于 2025-10-03 09:01:49">2025-10-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-03T09:23:28.711Z" title="更新于 2025-10-03 17:23:28">2025-10-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/linux/">linux</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/linux/mm/">mm</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">12.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>47分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/c674e474/#post-comment"><span class="gitalk-comment-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;已经过了&quot;,&quot;messageNext&quot;:&quot;自上次更新以来，文章的内容可能已经过时&quot;,&quot;postUpdate&quot;:&quot;2025-10-03 17:23:28&quot;}" hidden></div><p>[TOC]</p>
<h1 id="Linux-内存模型之基石：FLATMEM-深度解析"><a href="#Linux-内存模型之基石：FLATMEM-深度解析" class="headerlink" title="Linux 内存模型之基石：FLATMEM 深度解析"></a>Linux 内存模型之基石：FLATMEM 深度解析</h1><p><code>FLATMEM</code> 是 Linux 内核中最基础、最常用，也是最高效的内存模型。正如其名，“平坦内存”模型假定系统的物理内存是一个<strong>单一、连续、不存在大间隙</strong>的地址空间。</p>
<hr>
<h3 id="一、-核心原理：mem-map-数组"><a href="#一、-核心原理：mem-map-数组" class="headerlink" title="一、 核心原理：mem_map 数组"></a>一、 核心原理：<code>mem_map</code> 数组</h3><p><code>FLATMEM</code> 模型的全部精髓都围绕着一个核心数据结构：<strong>一个巨大的、全局的 <code>struct page</code> 数组，通常被称为 <code>mem_map</code></strong>。</p>
<ol>
<li><p><strong>什么是 <code>struct page</code>？</strong></p>
<ul>
<li>在 Linux 内核中，物理内存不是按字节管理的，而是按固定大小的块来管理的，这个块被称为<strong>页帧 (Page Frame)</strong>（通常是 4KB）。</li>
<li>内核为<strong>每一个物理页帧</strong>都分配了一个 <code>struct page</code> 描述符。这个结构体包含了该物理页帧的所有元数据，例如：它的引用计数、它是否是脏页、是否被锁定、属于哪个地址空间映射等。</li>
</ul>
</li>
<li><p><strong><code>mem_map</code> 的作用</strong></p>
<ul>
<li><code>FLATMEM</code> 模型在内核启动的极早期，会分配一个足够大的连续内存区域，用来存放一个 <code>struct page</code> 数组。这个数组的大小足以覆盖从物理地址 <code>0</code>（或某个起始偏移）到系统最大物理内存地址之间的<strong>所有</strong>页帧。</li>
<li>这个 <code>mem_map</code> 数组就成为了一个<strong>全局的物理内存数据库</strong>。</li>
</ul>
</li>
<li><p><strong>核心转换机制</strong><br><code>FLATMEM</code> 的高效正源于其极其简单的地址转换逻辑。它在<strong>物理地址 (Physical Address)</strong>、<strong>页帧号 (Page Frame Number, PFN)</strong> 和 <strong><code>struct page</code> 描述符</strong>之间建立了直接、快速的算术映射关系：</p>
<ul>
<li><p><strong>物理地址 -&gt; PFN</strong>:<br><code>pfn = physical_address &gt;&gt; PAGE_SHIFT</code> (即 <code>physical_address / PAGE_SIZE</code>)<br>这是一个简单的位移操作。</p>
</li>
<li><p><strong>PFN -&gt; <code>struct page*</code></strong>:<br><code>struct page* page = mem_map + (pfn - ARCH_PFN_OFFSET)</code><br>这是一个简单的<strong>数组索引</strong>操作！<code>ARCH_PFN_OFFSET</code> 是一个架构相关的偏移量，代表 <code>mem_map</code> 所管理的第一个页帧的 PFN。</p>
</li>
<li><p><strong><code>struct page*</code> -&gt; PFN</strong>:<br><code>pfn = (page - mem_map) + ARCH_PFN_OFFSET</code><br>这同样是一个简单的<strong>指针减法</strong>操作。</p>
</li>
</ul>
</li>
</ol>
<p><strong>总结一下</strong>：在 <code>FLATMEM</code> 模型中，给你任何一个物理地址，内核都可以通过几次算术运算，<strong>以 O(1) 的时间复杂度</strong> 快速定位到管理这个物理地址的 <code>struct page</code> 描述符。反之亦然。这种简单、直接的映射是其性能的保证。</p>
<hr>
<h3 id="二、-优点与适用场景"><a href="#二、-优点与适用场景" class="headerlink" title="二、 优点与适用场景"></a>二、 优点与适用场景</h3><ol>
<li><strong>极高的效率</strong>: 所有的地址&#x2F;PFN&#x2F;page 转换都是简单的算术运算，几乎没有性能开销。这对于性能敏感的内存管理子系统至关重要。</li>
<li><strong>逻辑简单</strong>: 实现非常直观，代码易于理解和维护。</li>
<li><strong>广泛的适用性</strong>: 绝大多数消费级和服务器级计算机（非 NUMA 架构）、以及大量的嵌入式系统，其物理内存布局都是或近似是连续的。因此，<code>FLATMEM</code> 是这些系统上最理想、最常见的选择。</li>
</ol>
<hr>
<h3 id="三、-缺点与局限性"><a href="#三、-缺点与局限性" class="headerlink" title="三、 缺点与局限性"></a>三、 缺点与局限性</h3><p><code>FLATMEM</code> 的简单性也带来了其最大的缺点：<strong>缺乏灵活性和潜在的内存浪费</strong>。</p>
<ol>
<li><p><strong>巨大的内存开销</strong>: <code>mem_map</code> 数组必须覆盖从内存起点到最大物理地址之间的<strong>整个地址空间范围</strong>，即使中间的某些地址范围没有插内存条。</p>
<ul>
<li><strong>举例</strong>: 假设一个 64 位系统，最大支持 64GB 物理内存。每个 <code>struct page</code> 描述符大约需要 64 字节。那么 <code>mem_map</code> 数组本身就需要占用：<br><code>(64 * 1024^3 / 4096) * 64</code> 字节 ≈ <strong>512 MB</strong><br>这 512MB 的内存必须在启动时被预留出来，用于存放 <code>mem_map</code> 数组本身。如果系统实际只插了 16GB 内存，<code>mem_map</code> 仍然会按 64GB 的最大可能来分配（取决于具体的架构实现），造成浪费。</li>
</ul>
</li>
<li><p><strong>无法处理大的物理内存间隙 (Holes)</strong>:</p>
<ul>
<li>如果一个系统的物理内存布局是 <code>[0-2GB]</code> 和 <code>[8GB-10GB]</code>，中间有 6GB 的巨大空洞。<code>FLATMEM</code> 模型为了覆盖到 10GB，其 <code>mem_map</code> 数组也必须覆盖整个 <code>[0-10GB]</code> 的范围。那么对应于 <code>[2GB-8GB]</code> 这个空洞的 <code>struct page</code> 条目就完全被浪费了。</li>
</ul>
</li>
<li><p><strong>不兼容高级内存架构</strong>:</p>
<ul>
<li><strong>NUMA (Non-Uniform Memory Access)</strong>: 在 NUMA 架构中，内存分布在不同的“节点 (Node)”上，访问不同节点的内存延迟不同。<code>FLATMEM</code> 的单一连续模型无法描述这种节点化的、非均匀的内存布局。</li>
<li><strong>内存热插拔 (Memory Hotplug)</strong>: <code>FLATMEM</code> 在启动时就固定了 <code>mem_map</code> 的大小，无法动态地扩展以支持新插入的内存。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="四、-FLATMEM-在内存模型演进中的位置"><a href="#四、-FLATMEM-在内存模型演进中的位置" class="headerlink" title="四、 FLATMEM 在内存模型演进中的位置"></a>四、 FLATMEM 在内存模型演进中的位置</h3><p>为了克服 <code>FLATMEM</code> 的局限性，Linux 内核引入了更复杂的内存模型：</p>
<ol>
<li><p><strong><code>DISCONTIGMEM</code> (非连续内存模型)</strong>:</p>
<ul>
<li>这是早期的解决方案，主要为了支持 NUMA。它为每个不连续的内存区域（或 NUMA 节点）都维护一个独立的 <code>mem_map</code> 数组。</li>
<li>它的缺点是代码逻辑复杂，需要在不同节点之间进行转换，且已<strong>基本被淘汰</strong>。</li>
</ul>
</li>
<li><p><strong><code>SPARSEMEM</code> (稀疏内存模型)</strong>:</p>
<ul>
<li>这是当前<strong>最先进、最灵活</strong>的模型，也是 <code>DISCONTIGMEM</code> 的现代替代品。</li>
<li>它的核心思想是：<strong>不再一次性分配一个巨大的 <code>mem_map</code> 数组</strong>。而是将整个物理地址空间划分为固定大小的块（<code>section</code>，例如 128MB）。只有当一个 <code>section</code> 中确实存在物理内存时，内核才会为这个 <code>section</code> 分配一个 <code>mem_map</code> 数组。</li>
<li><code>SPARSEMEM</code> 完美地解决了内存空洞和内存热插拔的问题，同时也自然地支持 NUMA 架构。</li>
<li>它唯一的缺点是，PFN 到 <code>struct page</code> 的转换不再是简单的数组索引，而需要先计算 PFN 属于哪个 <code>section</code>，再在该 <code>section</code> 的 <code>mem_map</code> 中索引，多了一步间接查找，理论上比 <code>FLATMEM</code> 稍慢。</li>
<li><strong><code>SPARSEMEM_VMEMMAP</code></strong>: 这是对 <code>SPARSEMEM</code> 的一个重要优化。它通过虚拟内存技术，将所有零散的 <code>mem_map</code> 小数组映射到一个<strong>虚拟上连续</strong>的巨大地址空间中。这样一来，PFN 到 <code>struct page</code> 的转换又变回了简单的算术运算，使得 <code>SPARSEMEM</code> 几乎拥有了和 <code>FLATMEM</code> 一样的高效率，同时保留了其灵活性。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="五、-总结"><a href="#五、-总结" class="headerlink" title="五、 总结"></a>五、 总结</h3><p><code>FLATMEM</code> 是 Linux 内存管理的基础。它基于“物理内存是连续的”这一简单假设，通过一个全局的 <code>mem_map</code> 数组和高效的算术转换，提供了最快速、最直接的物理内存管理机制。</p>
<p>尽管它的刚性设计无法适应 NUMA 和内存热插拔等高级场景，但这并不妨碍它在绝大多数计算机和嵌入式设备上作为默认和最佳选择。理解 <code>FLATMEM</code> 的工作原理，是理解 Linux 为何以及如何演进出 <code>SPARSEMEM</code> 等更复杂内存模型的关键。</p>
<h1 id="include-linux-mm-types-h"><a href="#include-linux-mm-types-h" class="headerlink" title="include&#x2F;linux&#x2F;mm_types.h"></a>include&#x2F;linux&#x2F;mm_types.h</h1><h2 id="MM-MT-FLAGS-配置内存管理结构的多线程行为"><a href="#MM-MT-FLAGS-配置内存管理结构的多线程行为" class="headerlink" title="MM_MT_FLAGS 配置内存管理结构的多线程行为"></a>MM_MT_FLAGS 配置内存管理结构的多线程行为</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 组合多个标志，支持范围分配、外部锁保护和 RCU 同步机制 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MM_MT_FLAGS	(MT_FLAGS_ALLOC_RANGE | MT_FLAGS_LOCK_EXTERN | \</span></span><br><span class="line"><span class="meta">			 MT_FLAGS_USE_RCU)</span></span><br></pre></td></tr></table></figure>

<h1 id="include-linux-mm-h"><a href="#include-linux-mm-h" class="headerlink" title="include&#x2F;linux&#x2F;mm.h"></a>include&#x2F;linux&#x2F;mm.h</h1><h2 id="mm-zero-struct-page-设置结构体页面为零"><a href="#mm-zero-struct-page-设置结构体页面为零" class="headerlink" title="mm_zero_struct_page 设置结构体页面为零"></a>mm_zero_struct_page 设置结构体页面为零</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 在某些架构上，为小尺寸调用 memset（） 是昂贵的。</span></span><br><span class="line"><span class="comment"> * 如果架构决定实现自己的 mm_zero_struct_page 版本，他们应该将下面的定义包装在 #ifndef 中，并在 &lt;asm/pgtable.h 中定义他们自己的宏版本&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> BITS_PER_LONG == 64</span></span><br><span class="line"><span class="comment">/* 当 struct page 的大小增长到 96 以上或减小到 56 以下时，必须更新此函数。</span></span><br><span class="line"><span class="comment"> * 编译器优化 switch（） 语句，只留下 move/store 指令的想法。</span></span><br><span class="line"><span class="comment"> * 此外，如果 write 语句都是赋值并且可以重新排序，则编译器可以组合 write 语句，这可能会导致此处的多个写入被丢弃。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	mm_zero_struct_page(pp) __mm_zero_struct_page(pp)</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __mm_zero_struct_page(<span class="keyword">struct</span> page *page)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> *_pp = (<span class="type">void</span> *)page;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">/* Check that struct page is either 56, 64, 72, 80, 88 or 96 bytes */</span></span><br><span class="line">	BUILD_BUG_ON(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> page) &amp; <span class="number">7</span>);</span><br><span class="line">	BUILD_BUG_ON(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> page) &lt; <span class="number">56</span>);</span><br><span class="line">	BUILD_BUG_ON(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> page) &gt; <span class="number">96</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (<span class="keyword">sizeof</span>(<span class="keyword">struct</span> page)) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">96</span>:</span><br><span class="line">		_pp[<span class="number">11</span>] = <span class="number">0</span>;</span><br><span class="line">		fallthrough;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">88</span>:</span><br><span class="line">		_pp[<span class="number">10</span>] = <span class="number">0</span>;</span><br><span class="line">		fallthrough;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">80</span>:</span><br><span class="line">		_pp[<span class="number">9</span>] = <span class="number">0</span>;</span><br><span class="line">		fallthrough;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">72</span>:</span><br><span class="line">		_pp[<span class="number">8</span>] = <span class="number">0</span>;</span><br><span class="line">		fallthrough;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">64</span>:</span><br><span class="line">		_pp[<span class="number">7</span>] = <span class="number">0</span>;</span><br><span class="line">		fallthrough;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">56</span>:</span><br><span class="line">		_pp[<span class="number">6</span>] = <span class="number">0</span>;</span><br><span class="line">		_pp[<span class="number">5</span>] = <span class="number">0</span>;</span><br><span class="line">		_pp[<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">		_pp[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">		_pp[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">		_pp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">		_pp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mm_zero_struct_page(pp)  ((void)memset((pp), 0, sizeof(struct page)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="1-减少函数调用开销"><a href="#1-减少函数调用开销" class="headerlink" title="1. 减少函数调用开销"></a><strong>1. 减少函数调用开销</strong></h3><ul>
<li><code>memset</code> 是一个通用的库函数，通常需要处理多种情况（如不同的内存大小、对齐方式等），因此它的实现包含了额外的逻辑和分支判断。</li>
<li>而 <code>__mm_zero_struct_page</code> 是针对特定结构体大小（如 <code>struct page</code>）优化的内联函数，直接展开为一系列赋值操作，避免了函数调用的开销。</li>
</ul>
<h3 id="2-编译器优化"><a href="#2-编译器优化" class="headerlink" title="2. 编译器优化"></a><strong>2. 编译器优化</strong></h3><ul>
<li>在 <code>__mm_zero_struct_page</code> 中，使用了 <code>switch</code> 语句和 <code>fallthrough</code> 关键字，编译器可以根据 <code>struct page</code> 的大小生成最优的指令序列。</li>
<li>编译器可能会将连续的赋值操作合并为更高效的指令（如 SIMD 指令或块存储指令），从而进一步提升性能。</li>
</ul>
<h3 id="3-避免通用性开销"><a href="#3-避免通用性开销" class="headerlink" title="3. 避免通用性开销"></a><strong>3. 避免通用性开销</strong></h3><ul>
<li><code>memset</code> 是为任意大小的内存块设计的，因此需要处理对齐、边界条件等问题。</li>
<li>而 <code>__mm_zero_struct_page</code> 针对特定大小的 <code>struct page</code> 进行了优化，避免了这些额外的处理。</li>
</ul>
<h3 id="4-减少分支预测失败"><a href="#4-减少分支预测失败" class="headerlink" title="4. 减少分支预测失败"></a><strong>4. 减少分支预测失败</strong></h3><ul>
<li><code>memset</code> 的实现可能包含多个分支（如处理小块内存和大块内存的不同路径），这些分支可能导致分支预测失败，影响性能。</li>
<li><code>__mm_zero_struct_page</code> 的实现是固定的赋值操作，没有额外的分支，减少了分支预测失败的可能性。</li>
</ul>
<h3 id="5-内存对齐的优势"><a href="#5-内存对齐的优势" class="headerlink" title="5. 内存对齐的优势"></a><strong>5. 内存对齐的优势</strong></h3><ul>
<li>在 <code>__mm_zero_struct_page</code> 中，<code>struct page</code> 被转换为 <code>unsigned long</code> 类型的指针，并按 64 位（或更大）对齐的块进行操作。这种对齐方式通常能更好地利用 CPU 的缓存和内存带宽。</li>
<li><code>memset</code> 需要处理未对齐的情况，可能会引入额外的开销。</li>
</ul>
<h2 id="set-page-links-设置页面链接"><a href="#set-page-links-设置页面链接" class="headerlink" title="set_page_links 设置页面链接"></a>set_page_links 设置页面链接</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">set_page_zone</span><span class="params">(<span class="keyword">struct</span> page *page, <span class="keyword">enum</span> zone_type zone)</span></span><br><span class="line">&#123;</span><br><span class="line">	page-&gt;flags &amp;= ~(ZONES_MASK &lt;&lt; ZONES_PGSHIFT);</span><br><span class="line">	page-&gt;flags |= (zone &amp; ZONES_MASK) &lt;&lt; ZONES_PGSHIFT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">set_page_node</span><span class="params">(<span class="keyword">struct</span> page *page, <span class="type">unsigned</span> <span class="type">long</span> node)</span></span><br><span class="line">&#123;</span><br><span class="line">	page-&gt;flags &amp;= ~(NODES_MASK &lt;&lt; NODES_PGSHIFT);</span><br><span class="line">	page-&gt;flags |= (node &amp; NODES_MASK) &lt;&lt; NODES_PGSHIFT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">set_page_links</span><span class="params">(<span class="keyword">struct</span> page *page, <span class="keyword">enum</span> zone_type zone,</span></span><br><span class="line"><span class="params">	<span class="type">unsigned</span> <span class="type">long</span> node, <span class="type">unsigned</span> <span class="type">long</span> pfn)</span></span><br><span class="line">&#123;</span><br><span class="line">	set_page_zone(page, zone);</span><br><span class="line">	set_page_node(page, node);	<span class="comment">//没有page node</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SECTION_IN_PAGE_FLAGS</span></span><br><span class="line">	set_page_section(page, pfn_to_section_nr(pfn));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="mm-init-c-Linux内存管理子系统的引导者与初始化核心"><a href="#mm-init-c-Linux内存管理子系统的引导者与初始化核心" class="headerlink" title="mm&#x2F;init.c: Linux内存管理子系统的引导者与初始化核心"></a>mm&#x2F;init.c: Linux内存管理子系统的引导者与初始化核心</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><code>mm/init.c</code> 是 Linux 内核中负责<strong>初始化整个内存管理（MM）子系统</strong>的关键文件。它在内核启动过程中扮演着“<strong>点火器</strong>”和“<strong>交接官</strong>”的角色。它在系统启动的极早期被调用，其核心任务是建立起所有高级内存管理机制（如伙伴系统、Slab 分配器、vmalloc 等），并从临时的引导内存分配器（<code>memblock</code>）手中接管对所有物理内存的控制权。</p>
<hr>
<h3 id="一、-核心职责"><a href="#一、-核心职责" class="headerlink" title="一、 核心职责"></a>一、 核心职责</h3><p><code>mm/init.c</code> 的工作是一次性的，但在内核的生命周期中至关重要。它的职责可以分解为以下几个关键步骤：</p>
<ol>
<li><p><strong>从引导内存分配器 (<code>memblock</code>) 过渡</strong>: 在 <code>mm_init</code> 运行之前，内核使用一个非常简单、临时的 <code>memblock</code> 分配器来管理内存。<code>mm_init.c</code> 的首要任务是初始化真正的、高效的内存管理数据结构，然后将 <code>memblock</code> 管理的所有可用内存“释放”到新的管理体系中。</p>
</li>
<li><p><strong>初始化页区分配器 (Zone Allocator &#x2F; Buddy System)</strong>: 这是<strong>最核心</strong>的一步。它负责为系统的物理内存划分不同的<strong>页区 (Zones)</strong>，并为每个页区建立伙伴系统（Buddy System）所需的数据结构（如 <code>free_area</code> 列表）。在此之后，内核才拥有了以页（<code>PAGE_SIZE</code>）为单位进行高效分配和释放物理内存的能力。</p>
</li>
<li><p><strong>初始化 Slab&#x2F;SLUB&#x2F;SLOB 分配器</strong>: 伙伴系统只能分配整个页。为了高效地管理小于页的小块内存（供 <code>kmalloc</code> 使用），内核需要 Slab 分配器。<code>mm/init.c</code> 负责调用 Slab 分配器的初始化函数，而 Slab 分配器自身依赖于已经准备就绪的伙伴系统来获取大块内存。</p>
</li>
<li><p><strong>初始化 <code>vmalloc</code> 区域</strong>: <code>vmalloc</code> 用于分配虚拟地址连续但物理地址不一定连续的大块内存。<code>mm/init.c</code> 负责为其建立所需的数据结构和地址空间范围。</p>
</li>
<li><p><strong>释放初始化内存</strong>: 内核中大量的初始化代码和数据在系统启动完成后就不再需要了。<code>mm/init.c</code> 包含了<strong>回收这部分内存</strong>的逻辑，将其交还给伙伴系统，从而为系统增加数兆字节的可用 RAM。</p>
</li>
</ol>
<hr>
<h3 id="二、-核心函数深度解析"><a href="#二、-核心函数深度解析" class="headerlink" title="二、 核心函数深度解析"></a>二、 核心函数深度解析</h3><h4 id="1-mm-init-总指挥"><a href="#1-mm-init-总指挥" class="headerlink" title="1. mm_init() - 总指挥"></a>1. <code>mm_init()</code> - 总指挥</h4><p>这是 <code>init/main.c</code> 中的 <code>start_kernel()</code> 函数调用的顶层入口。它像一个总指挥，按严格的顺序协调调用其他初始化函数。</p>
<p><strong>典型的 <code>mm_init()</code> 执行流程</strong>:</p>
<ol>
<li><strong><code>mem_init()</code></strong>: 调用此函数来初始化伙伴系统。这是所有后续内存分配的基础。</li>
<li><strong><code>kmem_cache_init()</code></strong>: 初始化 Slab&#x2F;SLOB&#x2F;SLUB 分配器。从此 <code>kmalloc</code> 才真正可用。</li>
<li><strong><code>vmalloc_init()</code></strong>: 初始化 <code>vmalloc</code> 机制。</li>
<li>其他初始化：可能还包括页表相关的初始化等。</li>
</ol>
<p>这个函数标志着 Linux 从一个只能使用临时分配器的简单程序，转变为一个拥有复杂、动态内存管理能力的成熟操作系统内核。</p>
<h4 id="2-mem-init-伙伴系统的奠基者"><a href="#2-mem-init-伙伴系统的奠基者" class="headerlink" title="2. mem_init() - 伙伴系统的奠基者"></a>2. <code>mem_init()</code> - 伙伴系统的奠基者</h4><p>这是 <code>mm_init()</code> 调用的第一个关键函数，也是 <code>mm/init.c</code> 中技术含量最高的部分之一。</p>
<p><strong>它的核心任务</strong>: 将 <code>memblock</code> 报告的所有可用物理内存，逐一“注册”到伙伴系统的管理数据结构中。</p>
<p><strong>执行步骤</strong>:</p>
<ol>
<li><strong>清空 <code>mem_map</code></strong>: 将 <code>FLATMEM</code> 或 <code>SPARSEMEM</code> 模型提供的 <code>struct page</code> 数组（<code>mem_map</code>）中与保留页（内核代码、已分配内存等）无关的条目清零。</li>
<li><strong>计算页区边界</strong>: 内核将物理内存划分为不同的区域，称为“页区 (Zone)”，以应对不同的硬件限制：<ul>
<li><code>ZONE_DMA/DMA32</code>: 用于只能对低地址内存进行 DMA 的老旧设备。</li>
<li><code>ZONE_NORMAL</code>: 内核可以直接映射和访问的“常规”内存。</li>
<li><code>ZONE_HIGHMEM</code>: （仅在 32 位系统上）超出内核直接映射范围的高端物理内存。</li>
<li><code>ZONE_MOVABLE</code>: 用于可移动页，以减少内存碎片。<br><code>mem_init()</code> 会根据架构和内存大小计算出这些 Zone 的 PFN（页帧号）边界。</li>
</ul>
</li>
<li><strong>初始化 <code>free_area</code></strong>: 调用 <code>free_area_init_nodes()</code> 或类似函数，为每个 NUMA 节点（在 UMA 系统上只有一个节点）的每个 Zone 初始化其 <code>free_area</code> 数组。这个数组是伙伴系统的核心，包含了指向不同大小（order）的空闲内存块链表的指针。</li>
<li><strong>释放内存到伙伴系统</strong>: 遍历 <code>memblock.memory</code> 列表（即所有可用物理内存段），对每一段内存，调用 <code>memblock_free()</code> 或直接调用底层函数，将其<strong>以页为单位</strong>添加到对应 Zone 的 <code>free_area</code> 中。这个过程就是伙伴系统“获得”其初始可用内存的过程。</li>
</ol>
<p><strong>最终结果</strong>: <code>mem_init()</code> 执行完毕后，<code>alloc_pages()</code> 和 <code>__get_free_pages()</code> 等基于伙伴系统的物理页分配函数就完全可用了。</p>
<h4 id="3-free-initmem-“过河拆桥”的艺术"><a href="#3-free-initmem-“过河拆桥”的艺术" class="headerlink" title="3. free_initmem() - “过河拆桥”的艺术"></a>3. <code>free_initmem()</code> - “过河拆桥”的艺术</h4><p>这是在内核启动后期（在 <code>smp_init()</code> 之后）被调用的一个函数，它体现了内核对内存资源利用的极致追求。</p>
<p><strong>背景</strong>:</p>
<ul>
<li>内核代码和数据中，有很大一部分被 <code>__init</code> 和 <code>__initdata</code> 宏标记。</li>
<li><code>__init</code>: 标记一个函数是初始化函数。</li>
<li><code>__initdata</code>: 标记一个变量是初始化数据。</li>
<li>链接器会将所有被这些宏标记的代码和数据，都集中放置在一个特殊的、连续的内存区域（<code>.init</code> 段）。</li>
</ul>
<p><strong><code>free_initmem()</code> 的工作</strong>:</p>
<ol>
<li>内核启动过程已经完成，所有标记为 <code>__init</code> 的函数都已被执行，所有标记为 <code>__initdata</code> 的数据都已被使用。它们在内核的后续运行中<strong>永远不会再被访问</strong>。</li>
<li><code>free_initmem()</code> 计算出这个 <code>.init</code> 段的起始和结束物理地址。</li>
<li>它像对待普通可用内存一样，将这整块内存（通常有好几 MB）<strong>释放回伙伴系统</strong>。</li>
</ol>
<p><strong>最终结果</strong>: 内核通过“丢弃”掉自己的初始化代码，回收了宝贵的内存资源，供系统运行时使用。</p>
<hr>
<h3 id="三、-在内核启动流程中的位置"><a href="#三、-在内核启动流程中的位置" class="headerlink" title="三、 在内核启动流程中的位置"></a>三、 在内核启动流程中的位置</h3><p><code>mm/init.c</code> 的代码位于一个承上启下的关键节点：</p>
<ul>
<li><strong>之前</strong>: 架构相关的汇编代码 (<code>head.S</code>) 已经完成了最基础的设置（如启用分页、建立临时页表）。<code>memblock</code> 分配器已经通过解析 Bootloader 传递的参数（如设备树、E820 表），建立了一个物理内存的初步布局图。</li>
<li><strong>调用</strong>: <code>init/main.c</code> 中的 <code>start_kernel()</code> 函数，在完成了 Trap 初始化、调度器早期初始化等步骤后，调用 <code>mm_init()</code>。</li>
<li><strong>之后</strong>: 完整的内存管理子系统上线。内核可以动态地分配和释放各种大小的内存，为设备驱动的加载、进程的创建等所有后续操作铺平了道路。</li>
</ul>
<hr>
<h3 id="四、-总结"><a href="#四、-总结" class="headerlink" title="四、 总结"></a>四、 总结</h3><p><code>mm/init.c</code> 是 Linux 内核从一个静态加载的程序转变为一个全功能动态操作系统的<strong>转换开关</strong>。它不是一个驱动，也不是一个持续运行的子系统，而是一个<strong>一次性的、至关重要的初始化模块</strong>。</p>
<p>它通过精心设计的顺序，<strong>用高级的内存管理机制替换掉临时的引导机制</strong>，并最终通过回收自身的初始化代码来最大化可用内存。理解 <code>mm/init.c</code> 的工作流程，是深入理解 Linux 内存管理如何从无到有建立起来的关键。</p>
<h2 id="find-usable-zone-for-movable-查找可用于ZONE-MOVABLE页面的区域"><a href="#find-usable-zone-for-movable-查找可用于ZONE-MOVABLE页面的区域" class="headerlink" title="find_usable_zone_for_movable 查找可用于ZONE_MOVABLE页面的区域"></a>find_usable_zone_for_movable 查找可用于ZONE_MOVABLE页面的区域</h2><ul>
<li>按照从高到低的顺序查找可用于 ZONE_MOVABLE 的区域。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这将查找可用于ZONE_MOVABLE页面的区域。</span></span><br><span class="line"><span class="comment"> * 假设节点中的区域按单调递增的内存地址排序，以便使用“最高”填充的区域</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __init <span class="title function_">find_usable_zone_for_movable</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> zone_index;</span><br><span class="line">	<span class="keyword">for</span> (zone_index = MAX_NR_ZONES - <span class="number">1</span>; zone_index &gt;= <span class="number">0</span>; zone_index--) &#123;</span><br><span class="line">		<span class="keyword">if</span> (zone_index == ZONE_MOVABLE)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (arch_zone_highest_possible_pfn[zone_index] &gt;</span><br><span class="line">				arch_zone_lowest_possible_pfn[zone_index])</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	VM_BUG_ON(zone_index == <span class="number">-1</span>);</span><br><span class="line">	movable_zone = zone_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="mirrored-kernelcore-设置内核内存的镜像"><a href="#mirrored-kernelcore-设置内核内存的镜像" class="headerlink" title="mirrored_kernelcore 设置内核内存的镜像"></a>mirrored_kernelcore 设置内核内存的镜像</h2><ul>
<li>该选项用于设置内核内存的镜像。</li>
<li>该选项在内核启动时解析，并在内存块初始化期间使用。</li>
<li>该选项的值可以是“mirror”或“mirror&#x3D;0”。</li>
<li>该选项的默认值为“mirror&#x3D;0”。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> mirrored_kernelcore __initdata_memblock;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> required_kernelcore __initdata;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> required_kernelcore_percent __initdata;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * kernelcore=size sets the amount of memory for use for allocations that</span></span><br><span class="line"><span class="comment"> * cannot be reclaimed or migrated.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">cmdline_parse_kernelcore</span><span class="params">(<span class="type">char</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* parse kernelcore=mirror */</span></span><br><span class="line">	<span class="keyword">if</span> (parse_option_str(p, <span class="string">&quot;mirror&quot;</span>)) &#123;</span><br><span class="line">		mirrored_kernelcore = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> cmdline_parse_core(p, &amp;required_kernelcore,</span><br><span class="line">				  &amp;required_kernelcore_percent);</span><br><span class="line">&#125;</span><br><span class="line">early_param(<span class="string">&quot;kernelcore&quot;</span>, cmdline_parse_kernelcore);</span><br></pre></td></tr></table></figure>

<h2 id="find-zone-movable-pfns-for-nodes-寻找可移动区域的页面"><a href="#find-zone-movable-pfns-for-nodes-寻找可移动区域的页面" class="headerlink" title="find_zone_movable_pfns_for_nodes 寻找可移动区域的页面"></a>find_zone_movable_pfns_for_nodes 寻找可移动区域的页面</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __init <span class="title function_">find_zone_movable_pfns_for_nodes</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, nid;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> usable_startpfn;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> kernelcore_node, kernelcore_remaining;</span><br><span class="line">	<span class="comment">/* 在借用 NodeMask 之前保存状态*/</span></span><br><span class="line">	<span class="type">nodemask_t</span> saved_node_state = node_states[N_MEMORY];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> totalpages = early_calculate_totalpages();</span><br><span class="line">	<span class="type">int</span> usable_nodes = nodes_weight(node_states[N_MEMORY]);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">memblock_region</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*指定 movable_node 时需要更早地找到movable_zone。 */</span></span><br><span class="line">	find_usable_zone_for_movable();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 如果指定了 movable_node，则忽略 kernelcore 和 movablecore 选项。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (movable_node_is_enabled()) &#123;    <span class="comment">//!CONFIG_MEMORY_HOTPLUG = false</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//如果指定了 kernelcore=mirror，则忽略 movablecore 选项</span></span><br><span class="line">	<span class="keyword">if</span> (mirrored_kernelcore) &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 如果指定了 kernelcore=nn% 或 movablecore=nn%，则计算必要的内存量。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (required_kernelcore_percent)</span><br><span class="line">		required_kernelcore = (totalpages * <span class="number">100</span> * required_kernelcore_percent) /</span><br><span class="line">				       <span class="number">10000UL</span>;</span><br><span class="line">	<span class="keyword">if</span> (required_movablecore_percent)</span><br><span class="line">		required_movablecore = (totalpages * <span class="number">100</span> * required_movablecore_percent) /</span><br><span class="line">					<span class="number">10000UL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 如果指定了 movablecore=，则计算对应的 kernelcore 大小，以便均匀分布可用于任何分配类型的内存。如果同时指定了 kernelcore 和 movablecore，则 kernelcore 的值将用于required_kernelcore如果该值大于 movablecore 允许的值。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (required_movablecore) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 如果未指定 kernelcore 或 kernelcore 大小大于 totalpages，则没有ZONE_MOVABLE(可移动的内存页面)。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!required_kernelcore || required_kernelcore &gt;= totalpages)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">out:</span><br><span class="line">	<span class="comment">/*恢复 node_state */</span></span><br><span class="line">	node_states[N_MEMORY] = saved_node_state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="calculate-node-totalpages-计算节点总页数"><a href="#calculate-node-totalpages-计算节点总页数" class="headerlink" title="calculate_node_totalpages 计算节点总页数"></a>calculate_node_totalpages 计算节点总页数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __init <span class="title function_">calculate_node_totalpages</span><span class="params">(<span class="keyword">struct</span> pglist_data *pgdat,</span></span><br><span class="line"><span class="params">						<span class="type">unsigned</span> <span class="type">long</span> node_start_pfn,</span></span><br><span class="line"><span class="params">						<span class="type">unsigned</span> <span class="type">long</span> node_end_pfn)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> realtotalpages = <span class="number">0</span>, totalpages = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">zone_type</span> <span class="title">i</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_NR_ZONES; i++) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span> =</span> pgdat-&gt;node_zones + i;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> zone_start_pfn, zone_end_pfn;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> spanned, absent;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> real_size;</span><br><span class="line"></span><br><span class="line">		spanned = zone_spanned_pages_in_node(pgdat-&gt;node_id, i,</span><br><span class="line">						     node_start_pfn,</span><br><span class="line">						     node_end_pfn,</span><br><span class="line">						     &amp;zone_start_pfn,</span><br><span class="line">						     &amp;zone_end_pfn);</span><br><span class="line">		absent = zone_absent_pages_in_node(pgdat-&gt;node_id, i,</span><br><span class="line">						   zone_start_pfn,</span><br><span class="line">						   zone_end_pfn);</span><br><span class="line"></span><br><span class="line">		real_size = spanned - absent;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (spanned)</span><br><span class="line">			zone-&gt;zone_start_pfn = zone_start_pfn;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			zone-&gt;zone_start_pfn = <span class="number">0</span>;</span><br><span class="line">		zone-&gt;spanned_pages = spanned;</span><br><span class="line">		zone-&gt;present_pages = real_size;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_MEMORY_HOTPLUG)</span></span><br><span class="line">		zone-&gt;present_early_pages = real_size;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">		totalpages += spanned;</span><br><span class="line">		realtotalpages += real_size;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pgdat-&gt;node_spanned_pages = totalpages;</span><br><span class="line">	pgdat-&gt;node_present_pages = realtotalpages;</span><br><span class="line">	pr_debug(<span class="string">&quot;On node %d totalpages: %lu\n&quot;</span>, pgdat-&gt;node_id, realtotalpages);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pgdat-init-internals-初始化pgdat"><a href="#pgdat-init-internals-初始化pgdat" class="headerlink" title="pgdat_init_internals 初始化pgdat"></a>pgdat_init_internals 初始化pgdat</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __meminit <span class="title function_">pgdat_init_internals</span><span class="params">(<span class="keyword">struct</span> pglist_data *pgdat)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="comment">// 无实际执行</span></span><br><span class="line">	<span class="comment">// pgdat_resize_init(pgdat);</span></span><br><span class="line">	<span class="comment">// pgdat_kswapd_lock_init(pgdat);</span></span><br><span class="line">	<span class="comment">// pgdat_init_split_queue(pgdat);</span></span><br><span class="line">	<span class="comment">// pgdat_init_kcompactd(pgdat);</span></span><br><span class="line"></span><br><span class="line">	init_waitqueue_head(&amp;pgdat-&gt;kswapd_wait);</span><br><span class="line">	init_waitqueue_head(&amp;pgdat-&gt;pfmemalloc_wait);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NR_VMSCAN_THROTTLE; i++)</span><br><span class="line">		init_waitqueue_head(&amp;pgdat-&gt;reclaim_wait[i]);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 无实际执行</span></span><br><span class="line">	pgdat_page_ext_init(pgdat);</span><br><span class="line">	lruvec_init(&amp;pgdat-&gt;__lruvec);	<span class="comment">//LRU集合初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="free-area-init-core-初始化区域核心"><a href="#free-area-init-core-初始化区域核心" class="headerlink" title="free_area_init_core 初始化区域核心"></a>free_area_init_core 初始化区域核心</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __meminit <span class="title function_">zone_init_internals</span><span class="params">(<span class="keyword">struct</span> zone *zone, <span class="keyword">enum</span> zone_type idx, <span class="type">int</span> nid,</span></span><br><span class="line"><span class="params">							<span class="type">unsigned</span> <span class="type">long</span> remaining_pages)</span></span><br><span class="line">&#123;</span><br><span class="line">	atomic_long_set(&amp;zone-&gt;managed_pages, remaining_pages);</span><br><span class="line">	zone_set_nid(zone, nid);</span><br><span class="line">	zone-&gt;name = zone_names[idx];</span><br><span class="line">	zone-&gt;zone_pgdat = NODE_DATA(nid);</span><br><span class="line">	spin_lock_init(&amp;zone-&gt;lock);</span><br><span class="line">	zone_seqlock_init(zone);</span><br><span class="line">	zone_pcp_init(zone);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __init <span class="title function_">free_area_init_core</span><span class="params">(<span class="keyword">struct</span> pglist_data *pgdat)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">zone_type</span> <span class="title">j</span>;</span></span><br><span class="line">	<span class="type">int</span> nid = pgdat-&gt;node_id;</span><br><span class="line"></span><br><span class="line">	pgdat_init_internals(pgdat);</span><br><span class="line">	pgdat-&gt;per_cpu_nodestats = &amp;boot_nodestats;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; MAX_NR_ZONES; j++) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span> =</span> pgdat-&gt;node_zones + j;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> size = zone-&gt;spanned_pages;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 将 zone-&gt;managed_pages 初始化为 0 ，当 memblock 分配器将页面释放到 buddy 系统时，它会被重置。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		zone_init_internals(zone, j, nid, zone-&gt;present_pages);</span><br><span class="line">		<span class="comment">//没有跨页继续</span></span><br><span class="line">		<span class="keyword">if</span> (!size)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		setup_usemap(zone);</span><br><span class="line">		init_currently_empty_zone(zone, zone-&gt;zone_start_pfn, size);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="free-area-init-node-初始化节点空闲区域"><a href="#free-area-init-node-初始化节点空闲区域" class="headerlink" title="free_area_init_node 初始化节点空闲区域"></a>free_area_init_node 初始化节点空闲区域</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __init <span class="title function_">free_area_init_node</span><span class="params">(<span class="type">int</span> nid)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">pg_data_t</span> *pgdat = NODE_DATA(nid);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> start_pfn = <span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> end_pfn = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* pg_data_t should be reset to zero when it&#x27;s allocated */</span></span><br><span class="line">	WARN_ON(pgdat-&gt;nr_zones || pgdat-&gt;kswapd_highest_zoneidx);</span><br><span class="line"></span><br><span class="line">	get_pfn_range_for_nid(nid, &amp;start_pfn, &amp;end_pfn);</span><br><span class="line"></span><br><span class="line">	pgdat-&gt;node_id = nid;</span><br><span class="line">	pgdat-&gt;node_start_pfn = start_pfn;</span><br><span class="line">	pgdat-&gt;per_cpu_nodestats = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (start_pfn != end_pfn) &#123;</span><br><span class="line">		pr_info(<span class="string">&quot;Initmem setup node %d [mem %#018Lx-%#018Lx]\n&quot;</span>, nid,</span><br><span class="line">			(u64)start_pfn &lt;&lt; PAGE_SHIFT,</span><br><span class="line">			end_pfn ? ((u64)end_pfn &lt;&lt; PAGE_SHIFT) - <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		calculate_node_totalpages(pgdat, start_pfn, end_pfn);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		pr_info(<span class="string">&quot;Initmem setup node %d as memoryless\n&quot;</span>, nid);</span><br><span class="line"></span><br><span class="line">		reset_memoryless_node_totalpages(pgdat);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* Skip empty nodes </span></span><br><span class="line"><span class="comment">	if (!pgdat-&gt;node_spanned_pages) return</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	alloc_node_mem_map(pgdat);</span><br><span class="line">	<span class="comment">//CONFIG_DEFERRED_STRUCT_PAGE_INIT</span></span><br><span class="line">	pgdat_set_deferred_range(pgdat);</span><br><span class="line"></span><br><span class="line">	free_area_init_core(pgdat);</span><br><span class="line">	lru_gen_init_pgdat(pgdat);	<span class="comment">////无执行代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="calc-nr-kernel-pages-计算内核页面数量"><a href="#calc-nr-kernel-pages-计算内核页面数量" class="headerlink" title="calc_nr_kernel_pages 计算内核页面数量"></a>calc_nr_kernel_pages 计算内核页面数量</h2><ul>
<li>nr代表number数量的意思</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> nr_kernel_pages __initdata;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> nr_all_pages __initdata;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __init <span class="title function_">calc_nr_kernel_pages</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> start_pfn, end_pfn;</span><br><span class="line">	<span class="type">phys_addr_t</span> start_addr, end_addr;</span><br><span class="line">	u64 u;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HIGHMEM</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> high_zone_low = arch_zone_lowest_possible_pfn[ZONE_HIGHMEM];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	for_each_free_mem_range(u, NUMA_NO_NODE, MEMBLOCK_NONE, &amp;start_addr, &amp;end_addr, <span class="literal">NULL</span>) &#123;</span><br><span class="line">		start_pfn = PFN_UP(start_addr);</span><br><span class="line">		end_pfn   = PFN_DOWN(end_addr);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (start_pfn &lt; end_pfn) &#123;</span><br><span class="line">			nr_all_pages += end_pfn - start_pfn;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HIGHMEM</span></span><br><span class="line">			start_pfn = clamp(start_pfn, <span class="number">0</span>, high_zone_low);</span><br><span class="line">			end_pfn = clamp(end_pfn, <span class="number">0</span>, high_zone_low);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">			nr_kernel_pages += end_pfn - start_pfn;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="init-single-page-初始化单个页面"><a href="#init-single-page-初始化单个页面" class="headerlink" title="__init_single_page 初始化单个页面"></a>__init_single_page 初始化单个页面</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __meminit __init_single_page(<span class="keyword">struct</span> page *page, <span class="type">unsigned</span> <span class="type">long</span> pfn,</span><br><span class="line">				<span class="type">unsigned</span> <span class="type">long</span> zone, <span class="type">int</span> nid)</span><br><span class="line">&#123;</span><br><span class="line">	mm_zero_struct_page(page);</span><br><span class="line">	set_page_links(page, zone, nid, pfn);</span><br><span class="line">	init_page_count(page);		<span class="comment">//atomic_set(&amp;page-&gt;_refcount, v);</span></span><br><span class="line">	<span class="type">atomic_set</span>(&amp;page-&gt;_mapcount, <span class="number">-1</span>);</span><br><span class="line">	page_cpupid_reset_last(page);</span><br><span class="line">	page_kasan_tag_reset(page);</span><br><span class="line"></span><br><span class="line">	INIT_LIST_HEAD(&amp;page-&gt;lru);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WANT_PAGE_VIRTUAL</span></span><br><span class="line">	<span class="comment">/* The shift won&#x27;t overflow because ZONE_NORMAL is below 4G. */</span></span><br><span class="line">	<span class="keyword">if</span> (!is_highmem_idx(zone))</span><br><span class="line">		set_page_address(page, __va(pfn &lt;&lt; PAGE_SHIFT));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="memmap-init-range-初始化内存映射范围"><a href="#memmap-init-range-初始化内存映射范围" class="headerlink" title="memmap_init_range 初始化内存映射范围"></a>memmap_init_range 初始化内存映射范围</h2><ul>
<li>此函数是Linux内核内存管理子系统在初始化阶段的核心部分。它的主要职责是为一段物理内存范围内的每一页（Page）初始化其对应的元数据结构（struct page）。这个过程是内核从早期引导内存管理器（memblock）过渡到最终的伙伴系统（Buddy System）分配器的关键步骤。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 最初所有的页都处于保留状态 - 空闲的页会在早期引导过程结束后</span></span><br><span class="line"><span class="comment"> * 由 memblock_free_all() 函数来释放。这是一个非原子的、单次通过的初始化过程。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 所有对齐的页块（pageblock）都会被初始化为指定的迁移类型</span></span><br><span class="line"><span class="comment"> * （通常是 MIGRATE_MOVABLE）。除了设置迁移类型，不会触及相关的</span></span><br><span class="line"><span class="comment"> * zone 统计数据（例如，nr_isolate_pageblock）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> __meminit <span class="title function_">memmap_init_range</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> size, <span class="type">int</span> nid, <span class="type">unsigned</span> <span class="type">long</span> zone,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">long</span> start_pfn, <span class="type">unsigned</span> <span class="type">long</span> zone_end_pfn,</span></span><br><span class="line"><span class="params">		<span class="keyword">enum</span> meminit_context context,</span></span><br><span class="line"><span class="params">		<span class="keyword">struct</span> vmem_altmap *altmap, <span class="type">int</span> migratetype)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// pfn: 当前正在处理的页帧号（Page Frame Number）。</span></span><br><span class="line">	<span class="comment">// end_pfn: 本次调用需要初始化的页帧范围的结束地址（不包含）。</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> pfn, end_pfn = start_pfn + size;</span><br><span class="line">	<span class="comment">// 指向与一个页帧号对应的 page 结构体的指针。</span></span><br><span class="line">	<span class="comment">// page 结构体包含了内核管理一个物理页所需的所有元数据。</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 更新内核已知的最大页帧号。这对于内存管理系统确定其管辖范围至关重要。</span></span><br><span class="line">	<span class="keyword">if</span> (highest_memmap_pfn &lt; end_pfn - <span class="number">1</span>)</span><br><span class="line">		highest_memmap_pfn = end_pfn - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 对于 ZONE_DEVICE 类型的内存，此段代码处理由驱动程序请求的预留空间。</span></span><br><span class="line"><span class="comment">	 * 我们将要初始化的页面总数限制在可能包含内存映射的那些页面。</span></span><br><span class="line"><span class="comment">	 * 我们将推迟 ZONE_DEVICE 页面的初始化，直到释放热插拔锁之后。</span></span><br><span class="line"><span class="comment">	 * 在STM32这样的嵌入式系统中，这可以用于管理特殊的内存区域，</span></span><br><span class="line"><span class="comment">	 * 但不是常规SRAM初始化的主要路径。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (zone == ZONE_DEVICE) &#123;</span><br><span class="line">		<span class="comment">// 如果是 ZONE_DEVICE，必须提供 altmap 描述符。</span></span><br><span class="line">		<span class="keyword">if</span> (!altmap)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果是设备内存区域的起始，则跳过驱动程序预留的头部空间。</span></span><br><span class="line">		<span class="keyword">if</span> (start_pfn == altmap-&gt;base_pfn)</span><br><span class="line">			start_pfn += altmap-&gt;reserve;</span><br><span class="line">		<span class="comment">// 最终的结束pfn由altmap的偏移量决定。</span></span><br><span class="line">		end_pfn = altmap-&gt;base_pfn + vmem_altmap_offset(altmap);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 循环遍历指定范围内的每一个页帧号。</span></span><br><span class="line">	<span class="comment">// 注意循环的pfn++是在循环体内部手动执行的。</span></span><br><span class="line">	<span class="keyword">for</span> (pfn = start_pfn; pfn &lt; end_pfn; ) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 传递给此函数的引导时 mem_map[] 中可能存在空洞。</span></span><br><span class="line"><span class="comment">		 * 这种情况在热插拔的内存上不会发生。</span></span><br><span class="line"><span class="comment">		 * 在STM32上，这对应于物理地址空间中不连续的SRAM区域。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">// 如果是在内核启动早期进行初始化...</span></span><br><span class="line">		<span class="keyword">if</span> (context == MEMINIT_EARLY) &#123;</span><br><span class="line">			<span class="comment">// 检查当前pfn是否与已初始化的区域重叠，如果是则跳过。</span></span><br><span class="line">			<span class="keyword">if</span> (overlap_memmap_init(zone, &amp;pfn))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="comment">// 检查是否需要推迟此页的初始化（主要用于NUMA架构优化）。</span></span><br><span class="line">			<span class="comment">// 在单核STM32上，此函数通常返回false。</span></span><br><span class="line">			<span class="keyword">if</span> (defer_init(nid, pfn, zone_end_pfn)) &#123;</span><br><span class="line">				deferred_struct_pages = <span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将页帧号（pfn）转换为 page 结构体指针。</span></span><br><span class="line">		<span class="comment">// 在无MMU的系统中，`mem_map`是一个巨大的`struct page`数组，</span></span><br><span class="line">		<span class="comment">// 此操作等价于 `&amp;mem_map[pfn]`，是一个直接的数组索引操作。</span></span><br><span class="line">		page = pfn_to_page(pfn);</span><br><span class="line">		<span class="comment">// 调用核心辅助函数，初始化这一个 page 结构体的内部字段，</span></span><br><span class="line">		<span class="comment">// 如设置标志位、所属的zone和节点ID(nid)等。</span></span><br><span class="line">		__init_single_page(page, pfn, zone, nid);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 如果是为内存热插拔（hotplug）而初始化...</span></span><br><span class="line">		<span class="keyword">if</span> (context == MEMINIT_HOTPLUG) &#123;</span><br><span class="line">			<span class="comment">// ZONE_DEVICE 类型的内存页特殊处理，设置为“保留”。</span></span><br><span class="line">			<span class="keyword">if</span> (zone == ZONE_DEVICE)</span><br><span class="line">				__SetPageReserved(page);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="comment">// 普通热插拔内存页则设置为“离线”（Offline），</span></span><br><span class="line">				<span class="comment">// 在完全准备好之前，内核的其他部分不能使用它。</span></span><br><span class="line">				__SetPageOffline(page);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 通常，我们希望将页块标记为 MIGRATE_MOVABLE（可移动），</span></span><br><span class="line"><span class="comment">		 * 这样不可移动的内存分配请求就不会在系统启动期间分散得到处都是，</span></span><br><span class="line"><span class="comment">		 * 这是一种对抗内存碎片的策略。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">// 检查当前pfn是否为一个页块（pageblock）的起始地址。</span></span><br><span class="line">		<span class="comment">// 页块是比页大得多的内存管理单位。</span></span><br><span class="line">		<span class="keyword">if</span> (pageblock_aligned(pfn)) &#123;</span><br><span class="line">			<span class="comment">// 为整个页块设置迁移类型。</span></span><br><span class="line">			set_pageblock_migratetype(page, migratetype);</span><br><span class="line">			<span class="comment">// 这是一个条件调度点。初始化大量内存会很耗时，</span></span><br><span class="line">			<span class="comment">// 此调用允许内核响应更高优先级的任务，防止系统卡死。</span></span><br><span class="line">			<span class="comment">// 在单核系统上，这仍然是保持响应性的重要机制。</span></span><br><span class="line">			cond_resched();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 手动递增页帧号，继续处理下一页。</span></span><br><span class="line">		pfn++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="memmap-init-zone-range-初始化内存映射区域"><a href="#memmap-init-zone-range-初始化内存映射区域" class="headerlink" title="memmap_init_zone_range 初始化内存映射区域"></a>memmap_init_zone_range 初始化内存映射区域</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __init <span class="title function_">memmap_init_zone_range</span><span class="params">(<span class="keyword">struct</span> zone *zone,</span></span><br><span class="line"><span class="params">					  <span class="type">unsigned</span> <span class="type">long</span> start_pfn,</span></span><br><span class="line"><span class="params">					  <span class="type">unsigned</span> <span class="type">long</span> end_pfn,</span></span><br><span class="line"><span class="params">					  <span class="type">unsigned</span> <span class="type">long</span> *hole_pfn)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> zone_start_pfn = zone-&gt;zone_start_pfn;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> zone_end_pfn = zone_start_pfn + zone-&gt;spanned_pages;</span><br><span class="line">	<span class="type">int</span> nid = zone_to_nid(zone), zone_id = zone_idx(zone);</span><br><span class="line"></span><br><span class="line">	start_pfn = clamp(start_pfn, zone_start_pfn, zone_end_pfn);</span><br><span class="line">	end_pfn = clamp(end_pfn, zone_start_pfn, zone_end_pfn);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (start_pfn &gt;= end_pfn)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	memmap_init_range(end_pfn - start_pfn, nid, zone_id, start_pfn,</span><br><span class="line">			  zone_end_pfn, MEMINIT_EARLY, <span class="literal">NULL</span>, MIGRATE_MOVABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="memmap-init-初始化内存映射"><a href="#memmap-init-初始化内存映射" class="headerlink" title="memmap_init 初始化内存映射"></a>memmap_init 初始化内存映射</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __init <span class="title function_">memmap_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> start_pfn, end_pfn;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> hole_pfn = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> i, j, zone_id = <span class="number">0</span>, nid;</span><br><span class="line"></span><br><span class="line">	for_each_mem_pfn_range(i, MAX_NUMNODES, &amp;start_pfn, &amp;end_pfn, &amp;nid) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> *<span class="title">node</span> =</span> NODE_DATA(nid);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; MAX_NR_ZONES; j++) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span> =</span> node-&gt;node_zones + j;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!populated_zone(zone))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			memmap_init_zone_range(zone, start_pfn, end_pfn,</span><br><span class="line">					       &amp;hole_pfn);</span><br><span class="line">			zone_id = j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Initialize the memory map for hole in the range [memory_end,</span></span><br><span class="line"><span class="comment">	 * section_end] for SPARSEMEM and in the range [memory_end, memmap_end]</span></span><br><span class="line"><span class="comment">	 * for FLATMEM.</span></span><br><span class="line"><span class="comment">	 * Append the pages in this hole to the highest zone in the last</span></span><br><span class="line"><span class="comment">	 * node.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SPARSEMEM</span></span><br><span class="line">	end_pfn = round_up(end_pfn, PAGES_PER_SECTION);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	end_pfn = round_up(end_pfn, MAX_ORDER_NR_PAGES);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">if</span> (hole_pfn &lt; end_pfn)</span><br><span class="line">		init_unavailable_range(hole_pfn, end_pfn, zone_id, nid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="free-area-init-初始化所有pg-data-t和区域数据"><a href="#free-area-init-初始化所有pg-data-t和区域数据" class="headerlink" title="free_area_init 初始化所有pg_data_t和区域数据"></a>free_area_init 初始化所有pg_data_t和区域数据</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * free_area_init - 初始化所有pg_data_t和区域数据</span></span><br><span class="line"><span class="comment"> * @max_zone_pfn：每个区域的最大 PFN 数组</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这将为系统中的每个活动节点调用 free_area_init_node（）。</span></span><br><span class="line"><span class="comment"> * 使用 memblock_set_node（） 提供的页面范围，计算每个节点中每个区域的大小及其孔洞。</span></span><br><span class="line"><span class="comment"> * 如果两个相邻区域之间的最大 PFN 匹配，则假定该区域为空。</span></span><br><span class="line"><span class="comment"> * 例如，如果 arch_max_dma_pfn == arch_max_dma32_pfn，则假定 arch_max_dma32_pfn 没有页面。</span></span><br><span class="line"><span class="comment"> * 还假定一个区域从前一个区域结束的位置开始。例如，ZONE_DMA32 从 arch_max_dma_pfn 开始。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">free_area_init</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> *max_zone_pfn)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> start_pfn, end_pfn;</span><br><span class="line">	<span class="type">int</span> i, nid, zone;</span><br><span class="line">	<span class="type">bool</span> descending;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 记录区域边界所在的位置 */</span></span><br><span class="line">	<span class="built_in">memset</span>(arch_zone_lowest_possible_pfn, <span class="number">0</span>,</span><br><span class="line">				<span class="keyword">sizeof</span>(arch_zone_lowest_possible_pfn));</span><br><span class="line">	<span class="built_in">memset</span>(arch_zone_highest_possible_pfn, <span class="number">0</span>,</span><br><span class="line">				<span class="keyword">sizeof</span>(arch_zone_highest_possible_pfn));</span><br><span class="line"></span><br><span class="line">	start_pfn = PHYS_PFN(memblock_start_of_DRAM());</span><br><span class="line">	descending = arch_has_descending_max_zone_pfns();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_NR_ZONES; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (descending)</span><br><span class="line">			zone = MAX_NR_ZONES - i - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			zone = i;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (zone == ZONE_MOVABLE)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		end_pfn = max(max_zone_pfn[zone], start_pfn);</span><br><span class="line">		arch_zone_lowest_possible_pfn[zone] = start_pfn;</span><br><span class="line">		arch_zone_highest_possible_pfn[zone] = end_pfn;</span><br><span class="line"></span><br><span class="line">		start_pfn = end_pfn;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 查找每个节点中 ZONE_MOVABLE 开始的 PFN */</span></span><br><span class="line">	<span class="built_in">memset</span>(zone_movable_pfn, <span class="number">0</span>, <span class="keyword">sizeof</span>(zone_movable_pfn));</span><br><span class="line">	find_zone_movable_pfns_for_nodes(); <span class="comment">//寻找可移动区域的页面</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 打印出区域范围*/</span></span><br><span class="line">	pr_info(<span class="string">&quot;Zone ranges:\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_NR_ZONES; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i == ZONE_MOVABLE)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		pr_info(<span class="string">&quot;  %-8s &quot;</span>, zone_names[i]);</span><br><span class="line">		<span class="keyword">if</span> (arch_zone_lowest_possible_pfn[i] ==</span><br><span class="line">				arch_zone_highest_possible_pfn[i])</span><br><span class="line">			pr_cont(<span class="string">&quot;empty\n&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			pr_cont(<span class="string">&quot;[mem %#018Lx-%#018Lx]\n&quot;</span>,</span><br><span class="line">				(u64)arch_zone_lowest_possible_pfn[i]</span><br><span class="line">					&lt;&lt; PAGE_SHIFT,</span><br><span class="line">				((u64)arch_zone_highest_possible_pfn[i]</span><br><span class="line">					&lt;&lt; PAGE_SHIFT) - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打印出每个节点中ZONE_MOVABLE开始的 PFN */</span></span><br><span class="line">	pr_info(<span class="string">&quot;Movable zone start for each node\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_NUMNODES; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (zone_movable_pfn[i])</span><br><span class="line">			pr_info(<span class="string">&quot;  Node %d: %#018Lx\n&quot;</span>, i,</span><br><span class="line">			       (u64)zone_movable_pfn[i] &lt;&lt; PAGE_SHIFT);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 打印出早期节点 map，并相对于活动在线内存范围初始化 subsection-map，以启用内存 map 的未来 “sub-section” 扩展。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	pr_info(<span class="string">&quot;Early memory node ranges\n&quot;</span>);</span><br><span class="line">	for_each_mem_pfn_range(i, MAX_NUMNODES, &amp;start_pfn, &amp;end_pfn, &amp;nid) &#123;</span><br><span class="line">		pr_info(<span class="string">&quot;  node %3d: [mem %#018Lx-%#018Lx]\n&quot;</span>, nid,</span><br><span class="line">			(u64)start_pfn &lt;&lt; PAGE_SHIFT,</span><br><span class="line">			((u64)end_pfn &lt;&lt; PAGE_SHIFT) - <span class="number">1</span>);</span><br><span class="line">		subsection_map_init(start_pfn, end_pfn - start_pfn);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化每个节点 */</span></span><br><span class="line">	mminit_verify_pageflags_layout();</span><br><span class="line">	setup_nr_node_ids();</span><br><span class="line">	set_pageblock_order();</span><br><span class="line">	<span class="comment">/* 这三个没有执行 */</span></span><br><span class="line"></span><br><span class="line">	for_each_node(nid) &#123;</span><br><span class="line">		<span class="type">pg_data_t</span> *pgdat;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!node_online(nid))</span><br><span class="line">			alloc_offline_node_data(nid);</span><br><span class="line"></span><br><span class="line">		pgdat = NODE_DATA(nid);	<span class="comment">// &amp;contig_page_data;</span></span><br><span class="line">		free_area_init_node(nid);	<span class="comment">//初始化节点空闲区域</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 不会通过 register_one_node（） 为无内存节点创建 sysfs 层次结构，</span></span><br><span class="line"><span class="comment">		 * 因为这里它没有标记为 N_MEMORY，以后也不会在线设置。</span></span><br><span class="line"><span class="comment">		 * 好处是用户空间程序不会与无内存节点的 sysfs 文件/目录混淆。</span></span><br><span class="line"><span class="comment">		 * 当内存热插拔到此节点时，pgdat 将通过 hotadd_init_pgdat（） 完全初始化。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (pgdat-&gt;node_present_pages) &#123;</span><br><span class="line">			node_set_state(nid, N_MEMORY);	<span class="comment">//无效果</span></span><br><span class="line">			check_for_memory(pgdat);		<span class="comment">//无效果</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//无效果</span></span><br><span class="line">	for_each_node_state(nid, N_MEMORY)</span><br><span class="line">		sparse_vmemmap_init_nid_late(nid);</span><br><span class="line"></span><br><span class="line">	calc_nr_kernel_pages();	<span class="comment">//计算内核页面数量</span></span><br><span class="line">	memmap_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 为具有单个节点的系统禁用哈希分配 */</span></span><br><span class="line">	fixup_hashdist();</span><br><span class="line"></span><br><span class="line">	set_high_memory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="alloc-large-system-hash-分配大型系统哈希"><a href="#alloc-large-system-hash-分配大型系统哈希" class="headerlink" title="alloc_large_system_hash 分配大型系统哈希"></a>alloc_large_system_hash 分配大型系统哈希</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 从 bootmem 分配一个大型系统哈希表</span></span><br><span class="line"><span class="comment"> * - 假设哈希表必须包含确切的 2 次幂数量的条目</span></span><br><span class="line"><span class="comment"> * - limit 是哈希存储桶的数量，而不是总分配大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *__init <span class="title function_">alloc_large_system_hash</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *tablename,</span></span><br><span class="line"><span class="params">				     <span class="type">unsigned</span> <span class="type">long</span> bucketsize,</span></span><br><span class="line"><span class="params">				     <span class="type">unsigned</span> <span class="type">long</span> numentries,</span></span><br><span class="line"><span class="params">				     <span class="type">int</span> scale,</span></span><br><span class="line"><span class="params">				     <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">				     <span class="type">unsigned</span> <span class="type">int</span> *_hash_shift,</span></span><br><span class="line"><span class="params">				     <span class="type">unsigned</span> <span class="type">int</span> *_hash_mask,</span></span><br><span class="line"><span class="params">				     <span class="type">unsigned</span> <span class="type">long</span> low_limit,</span></span><br><span class="line"><span class="params">				     <span class="type">unsigned</span> <span class="type">long</span> high_limit)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> max = high_limit;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> log2qty, size;</span><br><span class="line">	<span class="type">void</span> *table;</span><br><span class="line">	<span class="type">gfp_t</span> gfp_flags;</span><br><span class="line">	<span class="type">bool</span> virt;</span><br><span class="line">	<span class="type">bool</span> huge;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 允许内核 cmdline 有发言权*/</span></span><br><span class="line">	<span class="keyword">if</span> (!numentries) &#123;</span><br><span class="line">		<span class="comment">/*将适用的内存大小向上舍入到最接近的兆字节 */</span></span><br><span class="line">		numentries = nr_kernel_pages;	<span class="comment">//8192</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/*当 PAGE_SIZE &gt;= 1MB 时没有必要*/</span></span><br><span class="line">		<span class="keyword">if</span> (PAGE_SIZE &lt; SZ_1M)</span><br><span class="line">			numentries = round_up(numentries, SZ_1M / PAGE_SIZE);	<span class="comment">//8192</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* limit to 1 bucket per 2^scale bytes of low memory */</span></span><br><span class="line">		<span class="keyword">if</span> (scale &gt; PAGE_SHIFT)	<span class="comment">//13 &gt; 12</span></span><br><span class="line">			numentries &gt;&gt;= (scale - PAGE_SHIFT);	<span class="comment">//4096</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			numentries &lt;&lt;= (PAGE_SHIFT - scale);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (unlikely((numentries * bucketsize) &lt; PAGE_SIZE))</span><br><span class="line">			numentries = PAGE_SIZE / bucketsize;</span><br><span class="line">	&#125;</span><br><span class="line">	numentries = roundup_pow_of_two(numentries);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* limit allocation size to 1/16 total memory by default */</span></span><br><span class="line">	<span class="keyword">if</span> (max == <span class="number">0</span>) &#123;</span><br><span class="line">		max = ((<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)nr_all_pages &lt;&lt; PAGE_SHIFT) &gt;&gt; <span class="number">4</span>;	<span class="comment">//2097152</span></span><br><span class="line">		do_div(max, bucketsize);	<span class="comment">//2097152 / 4 = 524288</span></span><br><span class="line">	&#125;</span><br><span class="line">	max = min(max, <span class="number">0x80000000U</span>LL);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (numentries &lt; low_limit)</span><br><span class="line">		numentries = low_limit;</span><br><span class="line">	<span class="keyword">if</span> (numentries &gt; max)</span><br><span class="line">		numentries = max;</span><br><span class="line"></span><br><span class="line">	log2qty = ilog2(numentries);	<span class="comment">//12</span></span><br><span class="line"></span><br><span class="line">	gfp_flags = (flags &amp; HASH_ZERO) ? GFP_ATOMIC | __GFP_ZERO : GFP_ATOMIC;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		virt = <span class="literal">false</span>;</span><br><span class="line">		size = bucketsize &lt;&lt; log2qty;	<span class="comment">//4 &lt;&lt; 12 = 16384</span></span><br><span class="line">		<span class="keyword">if</span> (flags &amp; HASH_EARLY) &#123;</span><br><span class="line">			<span class="keyword">if</span> (flags &amp; HASH_ZERO)</span><br><span class="line">				table = memblock_alloc(size, SMP_CACHE_BYTES);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				table = memblock_alloc_raw(size,</span><br><span class="line">							   SMP_CACHE_BYTES);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (get_order(size) &gt; MAX_PAGE_ORDER || hashdist) &#123;</span><br><span class="line">			table = vmalloc_huge(size, gfp_flags);</span><br><span class="line">			virt = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">if</span> (table)</span><br><span class="line">				huge = is_vm_area_hugepages(table);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * If bucketsize is not a power-of-two, we may free</span></span><br><span class="line"><span class="comment">			 * some pages at the end of hash table which</span></span><br><span class="line"><span class="comment">			 * alloc_pages_exact() automatically does</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			table = alloc_pages_exact(size, gfp_flags);</span><br><span class="line">			kmemleak_alloc(table, size, <span class="number">1</span>, gfp_flags);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">while</span> (!table &amp;&amp; size &gt; PAGE_SIZE &amp;&amp; --log2qty);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!table)</span><br><span class="line">		panic(<span class="string">&quot;Failed to allocate %s hash table\n&quot;</span>, tablename);</span><br><span class="line">	<span class="comment">//Dentry cache hash table entries: 4096 (order: 2, 16384 bytes, linear)</span></span><br><span class="line">	pr_info(<span class="string">&quot;%s hash table entries: %ld (order: %d, %lu bytes, %s)\n&quot;</span>,</span><br><span class="line">		tablename, <span class="number">1UL</span> &lt;&lt; log2qty, ilog2(size) - PAGE_SHIFT, size,</span><br><span class="line">		virt ? (huge ? <span class="string">&quot;vmalloc hugepage&quot;</span> : <span class="string">&quot;vmalloc&quot;</span>) : <span class="string">&quot;linear&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (_hash_shift)</span><br><span class="line">		*_hash_shift = log2qty;</span><br><span class="line">	<span class="keyword">if</span> (_hash_mask)</span><br><span class="line">		*_hash_mask = (<span class="number">1</span> &lt;&lt; log2qty) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="mem-debugging-and-hardening-init-内存调试和硬化初始化"><a href="#mem-debugging-and-hardening-init-内存调试和硬化初始化" class="headerlink" title="mem_debugging_and_hardening_init 内存调试和硬化初始化"></a>mem_debugging_and_hardening_init 内存调试和硬化初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_STATIC_KEY_MAYBE(CONFIG_INIT_ON_ALLOC_DEFAULT_ON, init_on_alloc);</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">want_init_on_alloc</span><span class="params">(<span class="type">gfp_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (static_branch_maybe(CONFIG_INIT_ON_ALLOC_DEFAULT_ON,</span><br><span class="line">				&amp;init_on_alloc))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> flags &amp; __GFP_ZERO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DECLARE_STATIC_KEY_MAYBE(CONFIG_INIT_ON_FREE_DEFAULT_ON, init_on_free);</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">want_init_on_free</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> static_branch_maybe(CONFIG_INIT_ON_FREE_DEFAULT_ON,</span><br><span class="line">				   &amp;init_on_free);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 启用与各种内存调试和强化选项相关的 static key。</span></span><br><span class="line"><span class="comment"> * 有些会覆盖其他 Params，并依赖于按出现顺序计算的早期参数。</span></span><br><span class="line"><span class="comment"> * 因此，我们需要首先收集已启用内容的完整情况，然后做出决策。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __init <span class="title function_">mem_debugging_and_hardening_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">bool</span> page_poisoning_requested = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">bool</span> want_check_pages = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((_init_on_alloc_enabled_early || _init_on_free_enabled_early) &amp;&amp;</span><br><span class="line">	    page_poisoning_requested) &#123;</span><br><span class="line">		pr_info(<span class="string">&quot;mem auto-init: CONFIG_PAGE_POISONING is on, &quot;</span></span><br><span class="line">			<span class="string">&quot;will take precedence over init_on_alloc and init_on_free\n&quot;</span>);</span><br><span class="line">		_init_on_alloc_enabled_early = <span class="literal">false</span>;</span><br><span class="line">		_init_on_free_enabled_early = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	 <span class="comment">/* init_on_alloc</span></span><br><span class="line"><span class="comment">		作用： 	当启用 init_on_alloc 时，内核会在每次分配内存时将分配的内存块初始化为零。</span></span><br><span class="line"><span class="comment">				这可以防止分配的内存中残留的旧数据被误用或泄露。</span></span><br><span class="line"><span class="comment">		优点： 	增强安全性，防止敏感数据泄露。</span></span><br><span class="line"><span class="comment">				避免因使用未初始化内存导致的未定义行为。</span></span><br><span class="line"><span class="comment">		缺点： 会增加内存分配的开销，因为每次分配都需要额外的时间来清零内存。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">if</span> (_init_on_alloc_enabled_early) &#123;</span><br><span class="line">		want_check_pages = <span class="literal">true</span>;</span><br><span class="line">		static_branch_enable(&amp;init_on_alloc);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		static_branch_disable(&amp;init_on_alloc);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* init_on_free</span></span><br><span class="line"><span class="comment">	作用：	当启用 init_on_free 时，内核会在每次释放内存时将内存块清零。</span></span><br><span class="line"><span class="comment">			这确保了即使内存被重新分配，也不会泄露之前存储的数据。</span></span><br><span class="line"><span class="comment">	优点：	防止敏感数据在内存释放后被其他进程或内核组件访问。</span></span><br><span class="line"><span class="comment">			提高系统的安全性，特别是在多用户环境中。</span></span><br><span class="line"><span class="comment">	缺点：	增加内存释放的开销，因为每次释放都需要额外的时间来清零内存。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">if</span> (_init_on_free_enabled_early) &#123;</span><br><span class="line">		want_check_pages = <span class="literal">true</span>;</span><br><span class="line">		static_branch_enable(&amp;init_on_free);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		static_branch_disable(&amp;init_on_free);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_KMSAN) &amp;&amp;</span><br><span class="line">	    (_init_on_alloc_enabled_early || _init_on_free_enabled_early))</span><br><span class="line">		pr_info(<span class="string">&quot;mem auto-init: please make sure init_on_alloc and init_on_free are disabled when running KMSAN\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_PAGEALLOC</span></span><br><span class="line">	<span class="keyword">if</span> (debug_pagealloc_enabled()) &#123;</span><br><span class="line">		want_check_pages = <span class="literal">true</span>;</span><br><span class="line">		static_branch_enable(&amp;_debug_pagealloc_enabled);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (debug_guardpage_minorder())</span><br><span class="line">			static_branch_enable(&amp;_debug_guardpage_enabled);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Any page debugging or hardening option also enables sanity checking</span></span><br><span class="line"><span class="comment">	 * of struct pages being allocated or freed. With CONFIG_DEBUG_VM it&#x27;s</span></span><br><span class="line"><span class="comment">	 * enabled already.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!IS_ENABLED(CONFIG_DEBUG_VM) &amp;&amp; want_check_pages)</span><br><span class="line">		static_branch_enable(&amp;check_pages_enabled);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="report-meminit-报告内存初始化"><a href="#report-meminit-报告内存初始化" class="headerlink" title="report_meminit 报告内存初始化"></a>report_meminit 报告内存初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 报告此启动的内存自动初始化状态。 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __init <span class="title function_">report_meminit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *<span class="built_in">stack</span>;</span><br><span class="line">	<span class="comment">//栈会被初始化为某种特定的模式（pattern），通常用于调试目的，以便更容易发现未初始化的堆栈使用。</span></span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_INIT_STACK_ALL_PATTERN))</span><br><span class="line">		<span class="built_in">stack</span> = <span class="string">&quot;all(pattern)&quot;</span>;</span><br><span class="line">	<span class="comment">//表示堆栈会被初始化为全零值，增强了安全性，防止未初始化的堆栈数据泄露。</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (IS_ENABLED(CONFIG_INIT_STACK_ALL_ZERO))</span><br><span class="line">		<span class="built_in">stack</span> = <span class="string">&quot;all(zero)&quot;</span>;</span><br><span class="line">	<span class="comment">//启用了 GCC 插件，用于检测和清零所有通过引用传递的结构体，防止敏感数据泄露。</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (IS_ENABLED(CONFIG_GCC_PLUGIN_STRUCTLEAK_BYREF_ALL))</span><br><span class="line">		<span class="built_in">stack</span> = <span class="string">&quot;byref_all(zero)&quot;</span>;</span><br><span class="line">	<span class="comment">//启用了 GCC 插件，用于检测和清零部分通过引用传递的结构体。</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (IS_ENABLED(CONFIG_GCC_PLUGIN_STRUCTLEAK_BYREF))</span><br><span class="line">		<span class="built_in">stack</span> = <span class="string">&quot;byref(zero)&quot;</span>;</span><br><span class="line">	<span class="comment">//启用了 GCC 插件，用于清零用户空间传递的结构体数据，防止用户空间数据泄露到内核空间。</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (IS_ENABLED(CONFIG_GCC_PLUGIN_STRUCTLEAK_USER))</span><br><span class="line">		<span class="built_in">stack</span> = <span class="string">&quot;__user(zero)&quot;</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">stack</span> = <span class="string">&quot;off&quot;</span>;</span><br><span class="line">	<span class="comment">//mem auto-init: stack:off, heap alloc:off, heap free:off</span></span><br><span class="line">	pr_info(<span class="string">&quot;mem auto-init: stack:%s, heap alloc:%s, heap free:%s\n&quot;</span>,</span><br><span class="line">		<span class="built_in">stack</span>, str_on_off(want_init_on_alloc(GFP_KERNEL)),</span><br><span class="line">		str_on_off(want_init_on_free()));</span><br><span class="line">	<span class="keyword">if</span> (want_init_on_free())</span><br><span class="line">		pr_info(<span class="string">&quot;mem auto-init: clearing system memory may take some time...\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="mm-core-init-设置内核内存分配器"><a href="#mm-core-init-设置内核内存分配器" class="headerlink" title="mm_core_init 设置内核内存分配器"></a>mm_core_init 设置内核内存分配器</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 设置内核内存分配器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">mm_core_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	arch_mm_preinit();</span><br><span class="line">	hugetlb_bootmem_alloc();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*依赖于 SMP 设置的初始化*/</span></span><br><span class="line">	BUILD_BUG_ON(MAX_ZONELISTS &gt; <span class="number">2</span>);</span><br><span class="line">	build_all_zonelists(<span class="literal">NULL</span>);</span><br><span class="line">	page_alloc_init_cpuhp();</span><br><span class="line">	alloc_tag_sec_init();</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * page_ext需要连续的页面，大于 MAX_PAGE_ORDER 的页面，除非 SPARSEMEM。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	page_ext_init_flatmem();</span><br><span class="line">	mem_debugging_and_hardening_init();</span><br><span class="line">	kfence_alloc_pool_and_metadata();</span><br><span class="line">	report_meminit();</span><br><span class="line">	kmsan_init_shadow();</span><br><span class="line">	stack_depot_early_init();</span><br><span class="line">	memblock_free_all();</span><br><span class="line">	mem_init();</span><br><span class="line">	kmem_cache_init();</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * page_owner必须在 Buddy 准备好后进行初始化，并且 afterslab 也准备好了，以便 stack_depot_init（） 正常工作</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">// page_ext_init_flatmem_late();</span></span><br><span class="line">	<span class="comment">// kmemleak_init();</span></span><br><span class="line">	<span class="comment">// ptlock_cache_init();</span></span><br><span class="line">	<span class="comment">// pgtable_cache_init();</span></span><br><span class="line">	<span class="comment">// debug_objects_mem_init();</span></span><br><span class="line">	<span class="comment">// vmalloc_init();</span></span><br><span class="line">	<span class="comment">/* 如果没有延迟的 init 现在page_ext，因为 vmap 已经完全初始化*/</span></span><br><span class="line">	<span class="comment">// if (!deferred_struct_pages)</span></span><br><span class="line">	<span class="comment">// 	page_ext_init();</span></span><br><span class="line">	<span class="comment">/* Should be run before the first non-init thread is created */</span></span><br><span class="line">	<span class="comment">// init_espfix_bsp();</span></span><br><span class="line">	<span class="comment">/* Should be run after espfix64 is set up. */</span></span><br><span class="line">	<span class="comment">// pti_init();</span></span><br><span class="line">	<span class="comment">// kmsan_init_runtime();</span></span><br><span class="line">	mm_cache_init();</span><br><span class="line">	<span class="comment">// execmem_init();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="reserve-bootmem-region-标记由引导内存分配器（bootmem-allocator）分配的内存区域中的页面为“保留”（PageReserved"><a href="#reserve-bootmem-region-标记由引导内存分配器（bootmem-allocator）分配的内存区域中的页面为“保留”（PageReserved" class="headerlink" title="reserve_bootmem_region 标记由引导内存分配器（bootmem allocator）分配的内存区域中的页面为“保留”（PageReserved"></a>reserve_bootmem_region 标记由引导内存分配器（bootmem allocator）分配的内存区域中的页面为“保留”（PageReserved</h2><ul>
<li>这些页面在初始化阶段不会被普通内存管理机制使用，通常用于内核自身的用途或特殊的硬件需求。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">mem_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __pfn_to_page(pfn)	(mem_map + ((pfn) - ARCH_PFN_OFFSET))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 遍历由引导内存分配器分配的内存范围，并将这些页面标记为 PageReserved</span></span><br><span class="line"><span class="comment"> * 被标记为 PageReserved 的页面不会被普通的内存分配器（如伙伴系统）使用</span></span><br><span class="line"><span class="comment"> * 剩余未标记的有效页面会被移交给伙伴系统（buddy page allocator）进行管理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> __meminit <span class="title function_">reserve_bootmem_region</span><span class="params">(<span class="type">phys_addr_t</span> start,</span></span><br><span class="line"><span class="params">				      <span class="type">phys_addr_t</span> end, <span class="type">int</span> nid)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> start_pfn = PFN_DOWN(start);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> end_pfn = PFN_UP(end);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (; start_pfn &lt; end_pfn; start_pfn++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (pfn_valid(start_pfn)) &#123;	<span class="comment">//检查当前页面帧号是否有效（即是否对应实际的物理内存）。</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> pfn_to_page(start_pfn);	<span class="comment">// 将页面帧号转换为对应的 struct page 结构，这是内核用于管理物理页面的核心数据结构</span></span><br><span class="line"></span><br><span class="line">			init_deferred_page(start_pfn, nid);	<span class="comment">// 初始化延迟页面（deferred page），并将其与指定的 NUMA 节点关联</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//将页面标记为 PageReserved，表示该页面已被保留，不会被普通内存分配器使用</span></span><br><span class="line">			<span class="comment">//由于此时页面尚未对外可见，因此不需要使用原子操作来设置标志位</span></span><br><span class="line">			__SetPageReserved(page);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="memblock-free-pages-释放内存块"><a href="#memblock-free-pages-释放内存块" class="headerlink" title="memblock_free_pages 释放内存块"></a>memblock_free_pages 释放内存块</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">memblock_free_pages</span><span class="params">(<span class="keyword">struct</span> page *page, <span class="type">unsigned</span> <span class="type">long</span> pfn,</span></span><br><span class="line"><span class="params">							<span class="type">unsigned</span> <span class="type">int</span> order)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//调用核心函数释放页块，并将其标记为早期内存初始化（MEMINIT_EARLY）</span></span><br><span class="line">	__free_pages_core(page, order, MEMINIT_EARLY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="set-zone-contiguous-检查一个内存区域（zone）中的所有页块（pageblock）是否都存在对应的物理页帧"><a href="#set-zone-contiguous-检查一个内存区域（zone）中的所有页块（pageblock）是否都存在对应的物理页帧" class="headerlink" title="set_zone_contiguous 检查一个内存区域（zone）中的所有页块（pageblock）是否都存在对应的物理页帧"></a>set_zone_contiguous 检查一个内存区域（zone）中的所有页块（pageblock）是否都存在对应的物理页帧</h2><ul>
<li>set_zone_contiguous 是内存管理子系统中的一个函数。它的作用是检查一个内存区域（zone）中的所有页块（pageblock）是否都存在对应的物理页帧。如果整个区域的内存是物理上连续且没有“空洞”的，它就会将该区域的 contiguous 标志位设置为 true。这个标志对于需要大块连续物理内存的设备（如一些DMA设备）或巨页（HugeTLB）分配非常重要。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置一个内存区域（zone）的 contiguous 标志位。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_zone_contiguous</span><span class="params">(<span class="keyword">struct</span> zone *zone)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 获取该内存区域的起始页帧号（PFN）。</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> block_start_pfn = zone-&gt;zone_start_pfn;</span><br><span class="line">	<span class="comment">// 用于存储每个页块结束位置的页帧号。</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> block_end_pfn;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计算第一个页块的结束页帧号。pageblock_end_pfn 接受一个起始 pfn，返回该 pfn 所在页块的结束 pfn。</span></span><br><span class="line">	block_end_pfn = pageblock_end_pfn(block_start_pfn);</span><br><span class="line">	<span class="comment">// 这是一个 for 循环，用于遍历内存区域（zone）中的每一个页块（pageblock）。</span></span><br><span class="line">	<span class="comment">// 页块是内存管理的基本单位之一，通常大小为几MB。</span></span><br><span class="line">	<span class="keyword">for</span> (; block_start_pfn &lt; zone_end_pfn(zone); <span class="comment">// 循环条件：只要页块的起始地址还在zone的范围内</span></span><br><span class="line">			block_start_pfn = block_end_pfn, <span class="comment">// 在每次迭代后，将下一个页块的起始地址更新为当前页块的结束地址</span></span><br><span class="line">			 block_end_pfn += pageblock_nr_pages) &#123; <span class="comment">// 计算理论上（不考虑zone边界）下一个页块的结束地址</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 确保页块的结束地址不会超出整个zone的边界。</span></span><br><span class="line">		<span class="comment">// 取理论上的结束地址和zone的实际结束地址中较小的一个。</span></span><br><span class="line">		block_end_pfn = min(block_end_pfn, zone_end_pfn(zone));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 这个函数是核心检查点。它会检查从 block_start_pfn 到 block_end_pfn 之间的所有页帧</span></span><br><span class="line">		<span class="comment">// 是否都存在有效的 page 结构体。在一些体系结构中，物理内存可能存在“空洞”（holes），</span></span><br><span class="line">		<span class="comment">// 即某些物理地址范围没有映射到实际的RAM。</span></span><br><span class="line">		<span class="comment">// 如果发现任何一个页块内存在空洞（即没有有效的page结构），该函数返回false。</span></span><br><span class="line">		<span class="keyword">if</span> (!__pageblock_pfn_to_page(block_start_pfn,</span><br><span class="line">					     block_end_pfn, zone))</span><br><span class="line">			<span class="comment">// 如果发现空洞，说明这个zone不是物理连续的，函数直接返回，</span></span><br><span class="line">			<span class="comment">// zone-&gt;contiguous 标志将保持默认的 false。</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		<span class="comment">// 这是一个条件调度点。如果在遍历过程中花费了太长时间，</span></span><br><span class="line">		<span class="comment">// cond_resched() 会检查是否需要进行一次调度，以允许其他更高优先级的任务运行，</span></span><br><span class="line">		<span class="comment">// 防止系统长时间无响应。</span></span><br><span class="line">		cond_resched();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We confirm that there is no hole */</span></span><br><span class="line">	<span class="comment">// 如果循环成功完成，意味着我们已经检查了zone中的所有页块，并且没有发现任何空洞。</span></span><br><span class="line">	<span class="comment">/* 我们确认了这里没有空洞 */</span></span><br><span class="line">	<span class="comment">// 将该内存区域的 contiguous 标志设置为 true，表示该区域是物理连续的。</span></span><br><span class="line">	zone-&gt;contiguous = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="page-alloc-sysctl-init"><a href="#page-alloc-sysctl-init" class="headerlink" title="page_alloc_sysctl_init"></a>page_alloc_sysctl_init</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个用于页分配器sysctl接口的控制表。</span></span><br><span class="line"><span class="comment">// `static const` 意味着此表为本文件私有，且内容在编译后不可更改。</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">ctl_table</span> <span class="title">page_alloc_sysctl_table</span>[] =</span> &#123;</span><br><span class="line">	<span class="comment">// --- 第一个条目：min_free_kbytes ---</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// .procname: 在/proc/sys/vm/下创建的文件名。</span></span><br><span class="line">		.procname	= <span class="string">&quot;min_free_kbytes&quot;</span>,</span><br><span class="line">		<span class="comment">// .data: 指向此文件所控制的内核变量的指针。</span></span><br><span class="line">		.data		= &amp;min_free_kbytes,</span><br><span class="line">		<span class="comment">// .maxlen: 该变量的最大长度（字节），用于安全检查。</span></span><br><span class="line">		.maxlen		= <span class="keyword">sizeof</span>(min_free_kbytes),</span><br><span class="line">		<span class="comment">// .mode: 在/proc中创建的文件的权限，0644表示所有者可读写，其他用户只读。</span></span><br><span class="line">		.mode		= <span class="number">0644</span>,</span><br><span class="line">		<span class="comment">// .proc_handler: 当读写此文件时调用的处理函数。</span></span><br><span class="line">		<span class="comment">// 此函数负责验证输入值并更新内核水线（watermarks）。</span></span><br><span class="line">		.proc_handler	= min_free_kbytes_sysctl_handler,</span><br><span class="line">		<span class="comment">// .extra1: 传递给处理函数的额外参数，这里为0。</span></span><br><span class="line">		.extra1		= SYSCTL_ZERO,</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">// --- 第二个条目：watermark_boost_factor ---</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// .procname: 文件名为 &quot;watermark_boost_factor&quot;。</span></span><br><span class="line">		.procname	= <span class="string">&quot;watermark_boost_factor&quot;</span>,</span><br><span class="line">		<span class="comment">// .data: 控制内核变量 `watermark_boost_factor`。此变量用于在内存压力下动态提升水线，以更积极地回收内存。</span></span><br><span class="line">		.data		= &amp;watermark_boost_factor,</span><br><span class="line">		.maxlen		= <span class="keyword">sizeof</span>(watermark_boost_factor),</span><br><span class="line">		.mode		= <span class="number">0644</span>,</span><br><span class="line">		<span class="comment">// .proc_handler: 一个通用的整数处理函数，它会检查输入值是否在extra1和extra2指定的范围内。</span></span><br><span class="line">		.proc_handler	= proc_dointvec_minmax,</span><br><span class="line">		<span class="comment">// .extra1: 允许的最小值为0。</span></span><br><span class="line">		.extra1		= SYSCTL_ZERO,</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">// --- 第三个条目：watermark_scale_factor ---</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// .procname: 文件名为 &quot;watermark_scale_factor&quot;。</span></span><br><span class="line">		.procname	= <span class="string">&quot;watermark_scale_factor&quot;</span>,</span><br><span class="line">		<span class="comment">// .data: 控制内核变量 `watermark_scale_factor`。它根据系统内存大小按比例调整水线。</span></span><br><span class="line">		.data		= &amp;watermark_scale_factor,</span><br><span class="line">		.maxlen		= <span class="keyword">sizeof</span>(watermark_scale_factor),</span><br><span class="line">		.mode		= <span class="number">0644</span>,</span><br><span class="line">		<span class="comment">// .proc_handler: 一个自定义处理函数，用于安全地更新水线缩放因子。</span></span><br><span class="line">		.proc_handler	= watermark_scale_factor_sysctl_handler,</span><br><span class="line">		<span class="comment">// .extra1: 传递给处理函数的最小值参数，这里为1。</span></span><br><span class="line">		.extra1		= SYSCTL_ONE,</span><br><span class="line">		<span class="comment">// .extra2: 传递给处理函数的最大值参数，这里为3000。</span></span><br><span class="line">		.extra2		= SYSCTL_THREE_THOUSAND,</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">// --- 第四个条目：defrag_mode ---</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// .procname: 文件名为 &quot;defrag_mode&quot;。</span></span><br><span class="line">		.procname	= <span class="string">&quot;defrag_mode&quot;</span>,</span><br><span class="line">		<span class="comment">// .data: 控制内核变量 `defrag_mode`。此变量决定内核内存碎片整理的模式，</span></span><br><span class="line">        <span class="comment">// 在STM32上，这对于获取连续的物理内存块用于DMA操作依然重要。</span></span><br><span class="line">		.data		= &amp;defrag_mode,</span><br><span class="line">		.maxlen		= <span class="keyword">sizeof</span>(defrag_mode),</span><br><span class="line">		.mode		= <span class="number">0644</span>,</span><br><span class="line">		.proc_handler	= proc_dointvec_minmax,</span><br><span class="line">		.extra1		= SYSCTL_ZERO,</span><br><span class="line">		.extra2		= SYSCTL_ONE,</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">// --- 第五个条目：percpu_pagelist_high_fraction ---</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// .procname: 文件名为 &quot;percpu_pagelist_high_fraction&quot;。</span></span><br><span class="line">		.procname	= <span class="string">&quot;percpu_pagelist_high_fraction&quot;</span>,</span><br><span class="line">		<span class="comment">// .data: 控制内核变量 `percpu_pagelist_high_fraction`。它设置了每个CPU页缓存列表的上限。</span></span><br><span class="line">		<span class="comment">// 在单核STM32上，这只影响唯一的那个CPU的页缓存。</span></span><br><span class="line">		.data		= &amp;percpu_pagelist_high_fraction,</span><br><span class="line">		.maxlen		= <span class="keyword">sizeof</span>(percpu_pagelist_high_fraction),</span><br><span class="line">		.mode		= <span class="number">0644</span>,</span><br><span class="line">		.proc_handler	= percpu_pagelist_high_fraction_sysctl_handler,</span><br><span class="line">		.extra1		= SYSCTL_ZERO,</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">// --- 第六个条目：lowmem_reserve_ratio ---</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// .procname: 文件名为 &quot;lowmem_reserve_ratio&quot;。</span></span><br><span class="line">		.procname	= <span class="string">&quot;lowmem_reserve_ratio&quot;</span>,</span><br><span class="line">		<span class="comment">// .data: 控制一个数组 `sysctl_lowmem_reserve_ratio`。</span></span><br><span class="line">		<span class="comment">// 该参数用于在不同的内存域（zone）之间预留内存，防止低地址内存（如DMA内存）被高地址内存分配请求耗尽。</span></span><br><span class="line">		.data		= &amp;sysctl_lowmem_reserve_ratio,</span><br><span class="line">		.maxlen		= <span class="keyword">sizeof</span>(sysctl_lowmem_reserve_ratio),</span><br><span class="line">		.mode		= <span class="number">0644</span>,</span><br><span class="line">		.proc_handler	= lowmem_reserve_ratio_sysctl_handler,</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 以下部分被 #ifdef CONFIG_NUMA 宏包围。</span></span><br><span class="line"><span class="comment">	 * NUMA (非一致性内存访问) 是用于大型多处理器服务器的架构。</span></span><br><span class="line"><span class="comment">	 * STM32H750是单核、统一内存访问（UMA）架构，内核编译时不会定义CONFIG_NUMA。</span></span><br><span class="line"><span class="comment">	 * 因此，以下所有条目都不会被编译进最终的内核镜像中。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	&#123;</span><br><span class="line">		.procname	= <span class="string">&quot;numa_zonelist_order&quot;</span>,</span><br><span class="line">		.data		= &amp;numa_zonelist_order,</span><br><span class="line">		.maxlen		= NUMA_ZONELIST_ORDER_LEN,</span><br><span class="line">		.mode		= <span class="number">0644</span>,</span><br><span class="line">		.proc_handler	= numa_zonelist_order_handler,</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		.procname	= <span class="string">&quot;min_unmapped_ratio&quot;</span>,</span><br><span class="line">		.data		= &amp;sysctl_min_unmapped_ratio,</span><br><span class="line">		.maxlen		= <span class="keyword">sizeof</span>(sysctl_min_unmapped_ratio),</span><br><span class="line">		.mode		= <span class="number">0644</span>,</span><br><span class="line">		.proc_handler	= sysctl_min_unmapped_ratio_sysctl_handler,</span><br><span class="line">		.extra1		= SYSCTL_ZERO,</span><br><span class="line">		.extra2		= SYSCTL_ONE_HUNDRED,</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		.procname	= <span class="string">&quot;min_slab_ratio&quot;</span>,</span><br><span class="line">		.data		= &amp;sysctl_min_slab_ratio,</span><br><span class="line">		.maxlen		= <span class="keyword">sizeof</span>(sysctl_min_slab_ratio),</span><br><span class="line">		.mode		= <span class="number">0644</span>,</span><br><span class="line">		.proc_handler	= sysctl_min_slab_ratio_sysctl_handler,</span><br><span class="line">		.extra1		= SYSCTL_ZERO,</span><br><span class="line">		.extra2		= SYSCTL_ONE_HUNDRED,</span><br><span class="line">	&#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// `__init` 是一个宏，它告诉编译器将此函数的代码放入一个特殊的&quot;.init.text&quot;段。</span></span><br><span class="line"><span class="comment">// 内核在启动过程的末尾会释放这个段的内存，因为初始化函数在启动后不再需要。</span></span><br><span class="line"><span class="comment">// 这对于像STM32这样内存资源有限的设备来说是一项重要的优化。</span></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">page_alloc_sysctl_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 调用 register_sysctl_init 函数。</span></span><br><span class="line">	<span class="comment">// 第一个参数 &quot;vm&quot; 指定了顶级目录名，即 /proc/sys/vm/。</span></span><br><span class="line">	<span class="comment">// 第二个参数是上面定义的表。</span></span><br><span class="line">	<span class="comment">// 该函数会遍历表中的每一个条目，并在/proc/sys/vm/下创建对应的文件。</span></span><br><span class="line">	register_sysctl_init(<span class="string">&quot;vm&quot;</span>, page_alloc_sysctl_table);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="page-alloc-init-late-对页分配器（Page-Allocator）子系统进行的后期初始化函数"><a href="#page-alloc-init-late-对页分配器（Page-Allocator）子系统进行的后期初始化函数" class="headerlink" title="page_alloc_init_late 对页分配器（Page Allocator）子系统进行的后期初始化函数"></a>page_alloc_init_late 对页分配器（Page Allocator）子系统进行的后期初始化函数</h2><ul>
<li>page_alloc_init_late 是Linux内核在启动过程中，对页分配器（Page Allocator）子系统进行的后期初始化函数。它在核心的伙伴系统（Buddy System）已经可以工作之后被调用，用于完成一些依赖于完整内存信息或可以被推迟的初始化任务。</li>
<li>其主要工作包括：<ul>
<li>（可选）并行初始化页描述符：在拥有大量内存的系统上，通过创建内核线程来并行初始化struct page数组，以缩短启动时间。</li>
<li>打印内存信息：在内存信息稳定后，向内核日志打印最终的内存布局和使用情况。</li>
<li>释放早期内存管理器：丢弃memblock分配器自身使用的数据结构，回收这部分内存。</li>
<li>增强安全性：通过随机化空闲页链表来增加内存布局的不可预测性，抵御某些内存攻击。</li>
<li>完成最后的配置：初始化与页分配相关的sysctl接口，允许用户在运行时查看和调整内存管理参数。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义页分配器的后期初始化函数。</span></span><br><span class="line"><span class="comment">// __init 宏表示该函数及其数据在内核初始化完成后会被释放，以节约内存。</span></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">page_alloc_init_late</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>;</span> <span class="comment">// 用于迭代内存区域（zone）的指针</span></span><br><span class="line">	<span class="type">int</span> nid; <span class="comment">// 用于迭代NUMA节点ID（node ID）的变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一个条件编译指令。下面的代码块仅在内核配置了 CONFIG_DEFERRED_STRUCT_PAGE_INIT 时才被编译。</span></span><br><span class="line"><span class="comment">// 这个配置用于拥有非常大内存的系统，它将 struct page 数组的初始化工作推迟到内核线程中并行执行，以加速启动。</span></span><br><span class="line"><span class="comment">// 对于内存较小的嵌入式系统（如STM32），通常不开启此选项。</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEFERRED_STRUCT_PAGE_INIT</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 将会有 num_node_state(N_MEMORY) 个线程被创建 */</span></span><br><span class="line">	<span class="comment">// 设置一个原子计数器，其值为系统中含有内存的NUMA节点数量。</span></span><br><span class="line">	<span class="comment">// 这个计数器用于追踪还有多少个节点的内存描述符尚未完成初始化。</span></span><br><span class="line">	<span class="type">atomic_set</span>(&amp;pgdat_init_n_undone, num_node_state(N_MEMORY));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// for_each_node_state 是一个宏，用于遍历所有指定状态的NUMA节点。</span></span><br><span class="line">	<span class="comment">// 这里遍历所有包含物理内存的节点（N_MEMORY）。</span></span><br><span class="line">	<span class="comment">// 在非NUMA系统上，这个循环只会执行一次，且 nid 为 0。</span></span><br><span class="line">	for_each_node_state(nid, N_MEMORY) &#123;</span><br><span class="line">		<span class="comment">// kthread_run 创建并启动一个内核线程。</span></span><br><span class="line">		<span class="comment">// deferred_init_memmap 是线程将要执行的函数。</span></span><br><span class="line">		<span class="comment">// NODE_DATA(nid) 是传递给该函数的参数，即节点的 pg_data_t 结构体。</span></span><br><span class="line">		<span class="comment">// &quot;pgdatinit%d&quot; 是线程的名称格式，方便调试。</span></span><br><span class="line">		kthread_run(deferred_init_memmap, NODE_DATA(nid), <span class="string">&quot;pgdatinit%d&quot;</span>, nid);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 阻塞直到所有节点的初始化全部完成 */</span></span><br><span class="line">	<span class="comment">// wait_for_completion 是一个同步原语。主启动线程会在这里等待，</span></span><br><span class="line">	<span class="comment">// 直到所有 pgdatinit 线程都完成了它们的初始化工作并调用了 complete()。</span></span><br><span class="line">	wait_for_completion(&amp;pgdat_init_all_done_comp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 我们已经初始化了剩余的延迟页面。现在永久性地禁用</span></span><br><span class="line"><span class="comment">	 * 按需（on-demand）的 struct page 初始化路径。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">// static_branch_disable 是一个性能优化。它会动态地修改代码，</span></span><br><span class="line">	<span class="comment">// 将一个条件分支（if/else）替换为无条件执行的路径，因为延迟初始化的逻辑在此之后不再需要。</span></span><br><span class="line">	static_branch_disable(&amp;deferred_pages);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 在内核启动后，基于空闲页数重新初始化一些限制 */</span></span><br><span class="line">	<span class="comment">// 此时总内存和可用内存已经完全确定，可以精确地设置文件系统的最大打开文件数等限制。</span></span><br><span class="line">	files_maxfiles_init();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// CONFIG_DEFERRED_STRUCT_PAGE_INIT 结束</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 到此为止，总内存和空闲内存的统计是稳定的。*/</span></span><br><span class="line">	<span class="comment">// 调用此函数向内核日志（dmesg）打印详细的内存使用信息。</span></span><br><span class="line">	mem_init_print_info();</span><br><span class="line">	<span class="comment">// 初始化缓冲区高速缓存（buffer cache）相关的数据结构。</span></span><br><span class="line">	buffer_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 丢弃 memblock 的私有内存 */</span></span><br><span class="line">	<span class="comment">// memblock 是内核在非常早期的启动阶段使用的内存管理器。</span></span><br><span class="line">	<span class="comment">// 此时，伙伴（buddy）页分配器已经完全接管，所以可以释放 memblock 自身所占用的管理数据结构了。</span></span><br><span class="line">	<span class="comment">// memblock_discard();</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 再次遍历所有内存节点。</span></span><br><span class="line">	<span class="comment">// for_each_node_state(nid, N_MEMORY)</span></span><br><span class="line">		<span class="comment">// 对每个节点的空闲页链表进行随机化处理。</span></span><br><span class="line">		<span class="comment">// 这是一个安全加固措施，通过打乱空闲页的分配顺序，</span></span><br><span class="line">		<span class="comment">// 使得依赖于可预测内存布局的攻击（如堆喷射）更难成功。</span></span><br><span class="line">		<span class="comment">// shuffle_free_memory(NODE_DATA(nid));</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// for_each_populated_zone 是一个宏，用于遍历所有包含物理页面的内存区域（zone）。</span></span><br><span class="line">	<span class="comment">// 例如 ZONE_DMA, ZONE_NORMAL。</span></span><br><span class="line">	for_each_populated_zone(zone)</span><br><span class="line">		<span class="comment">// 检查该区域（zone）内的所有物理内存页是否是连续的。</span></span><br><span class="line">		<span class="comment">// 如果是，则设置一个标志位（ZONE_CONTIG），这个信息可以用于优化巨页（Huge Page）的分配。</span></span><br><span class="line">		set_zone_contiguous(zone);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 在所有 struct page 初始化完毕后，初始化 page ext */</span></span><br><span class="line">	<span class="comment">// deferred_struct_pages 是一个全局变量，指示延迟初始化是否被使用。</span></span><br><span class="line">	<span class="keyword">if</span> (deferred_struct_pages)</span><br><span class="line">		<span class="comment">// page_ext_init 初始化 struct page 的扩展数据区。</span></span><br><span class="line">		<span class="comment">// page_ext 用于存储一些不常用的页信息，避免主 struct page 结构体过于臃肿。</span></span><br><span class="line">		<span class="comment">// 它必须在所有 struct page 自身都初始化完毕后才能进行。</span></span><br><span class="line">		page_ext_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化页分配器相关的 sysctl 接口。</span></span><br><span class="line">	<span class="comment">// 这将在 /proc/sys/vm/ 目录下创建一些文件（如 min_free_kbytes），</span></span><br><span class="line">	<span class="comment">// 允许系统管理员在运行时查看和调整内存管理的行为。</span></span><br><span class="line">	page_alloc_sysctl_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="mm-sysfs-init-初始化内存管理-MM-相关的sysfs接口"><a href="#mm-sysfs-init-初始化内存管理-MM-相关的sysfs接口" class="headerlink" title="mm_sysfs_init: 初始化内存管理(MM)相关的sysfs接口"></a>mm_sysfs_init: 初始化内存管理(MM)相关的sysfs接口</h2><p>此函数在内核启动过程中被调用, 其唯一且核心的作用是在<code>sysfs</code>文件系统中创建顶层的 <code>/sys/kernel/mm/</code> 目录。这个目录是一个命名空间, 作为所有与内核内存管理(Memory Management)相关的可调参数和统计信息文件的父容器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm_sysfs_init: 内存管理 sysfs 接口的初始化函数.</span></span><br><span class="line"><span class="comment"> * 这是一个静态函数, 标记为 __init, 表示它仅在内核初始化期间执行,</span></span><br><span class="line"><span class="comment"> * 在初始化完成后, 其占用的内存可能会被回收.</span></span><br><span class="line"><span class="comment"> * @return: 成功时返回0, 失败时返回负值的错误码.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">mm_sysfs_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 调用 kobject_create_and_add, 在 sysfs 中创建一个名为 &quot;mm&quot; 的目录.</span></span><br><span class="line"><span class="comment">	 * @ &quot;mm&quot;:        目录的名称.</span></span><br><span class="line"><span class="comment">	 * @ kernel_kobj: 父 kobject 的指针. kernel_kobj 代表 /sys/kernel 目录.</span></span><br><span class="line"><span class="comment">	 * 因此, 这行代码会创建 /sys/kernel/mm/ 目录.</span></span><br><span class="line"><span class="comment">	 * 返回的 kobject 指针被存入全局变量 mm_kobj, 以便其他内存管理子系统可以在此目录下创建文件.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	mm_kobj = kobject_create_and_add(<span class="string">&quot;mm&quot;</span>, kernel_kobj);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 检查目录是否创建成功. 如果失败(通常因为内存不足), 函数返回 NULL.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!mm_kobj)</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 如果创建失败, 返回 -ENOMEM (内存不足) 错误码.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 所有操作成功, 返回0.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用 postcore_initcall 宏来注册 mm_sysfs_init 函数.</span></span><br><span class="line"><span class="comment"> * 这会将该函数放入一个特定的初始化函数列表中, 确保它在内核的 &quot;post-core&quot; 阶段被调用.</span></span><br><span class="line"><span class="comment"> * 这个阶段晚于核心子系统(如sysfs和kernel_kobj)的初始化, 确保父目录 /sys/kernel 已存在.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">postcore_initcall(mm_sysfs_init);</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/wdfk-prog">Liya Huang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://wdfk-prog.space/posts/c674e474/">https://wdfk-prog.space/posts/c674e474/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://wdfk-prog.space" target="_blank">wdfk-prog的个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/linux/">linux</a><a class="post-meta__tags" href="/tags/mm/">mm</a></div><div class="post-share"><div class="social-share" data-image="/images/covers/01.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/images/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/images/alipay.png" target="_blank"><img class="post-qr-code-img" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/alipay.png" alt="支付寶"/></a><div class="post-qr-code-desc">支付寶</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/3356114e/" title="nommu"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/06.jpg" onerror="onerror=null;src='/images/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">nommu</div></div><div class="info-2"><div class="info-item-1">[TOC] mm&#x2F;nommu.c NO-MMU内存管理(NO-MMU Memory Management) 适用于无内存管理单元的系统历史与背景这项技术是为了解决什么特定问题而诞生的？这项技术是为了让Linux操作系统能够运行在没有**内存管理单元（MMU）**的简单微控制器（MCU）和嵌入式处理器上。标准的Linux内核设计严重依赖MMU来实现以下核心功能：  虚拟内存：为每个进程提供独立的、巨大的、线性的虚拟地址空间。 内存保护：利用硬件机制防止一个进程访问另一个进程或内核的内存空间，保障系统稳定性和安全性。 内存映射与分页：实现写时复制（Copy-on-Write）、按需分页（Demand Paging）和交换（Swapping）等高级内存管理技术。  许多低成本、低功耗的嵌入式处理器（如ARM Cortex-M系列）为了节省芯片面积和功耗，并不包含MMU。mm/nommu.c 及其相关代码提供了一套替代的、简化的内存管理模型，使得功能强大的Linux内核能够在这种受限的硬件上运行，这通常被称为uClinux（Micro-Controller Linux）。 它的...</div></div></div></a><a class="pagination-related" href="/posts/662716e7/" title="filemap"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/08.jpg" onerror="onerror=null;src='/images/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">filemap</div></div><div class="info-2"><div class="info-item-1">[TOC] mm&#x2F;filemap.c: Linux 页缓存 (Page Cache) 的心脏mm/filemap.c 是 Linux 内核中实现和管理页缓存 (Page Cache) 的核心源文件。页缓存是 Linux I&#x2F;O 性能的基石，它将磁盘上的文件内容缓存到物理内存（RAM）中，使得后续对同一文件的读写操作可以直接在内存中完成，从而避免了缓慢的磁盘 I&#x2F;O。 可以把 mm/filemap.c 想象成一个高效的“图书管理员”，它负责管理一个巨大的图书馆（页缓存），图书馆里的每一页书（struct page）都对应着磁盘文件上的某一页内容。  一、 核心职责mm/filemap.c 的代码几乎参与了所有与文件 I&#x2F;O 相关的内存操作，其核心职责包括：  页缓存的查找与插入 (Finding and Inserting): 当需要读取文件数据时，它负责在页缓存中查找是否已缓存了对应的页面。如果找到（Cache Hit），则直接返回内存页；如果未找到（Cache Miss），则负责分配一个新的物理页，并将其插入到页缓存中，准备从磁盘加载数据...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/0/" title="workingset"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/09.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-07</div><div class="info-item-2">workingset</div></div><div class="info-2"><div class="info-item-1">  [toc]  mm&#x2F;workingset.c 工作集检测(Working Set Detection) 提升页面回收效率的热点内存识别机制历史与背景这项技术是为了解决什么特定问题而诞生的？mm/workingset.c 中的代码是为了解决传统页面回收算法（如vmscan.c中的两阶段LRU）的一个核心痛点：无法精确区分真正的“工作集”和短暂的、非核心的内存使用。 工作集（Working Set）指的是一个进程在当前阶段为了高效运行而需要频繁访问的内存页面集合。传统LRU算法通过active&#x2F;inactive链表来近似这个集合，但存在以下问题：  抖动（Thrashing）：当内存压力增大时，一个暂时不活动的进程（例如，用户切换到了另一个窗口），其工作集页面可能会被从active链表老化到inactive链表，并最终被回收。当用户切回该进程时，进程会遭遇大量的缺页中断（page faults），需要从磁盘或交换空间重新读取其工作集，导致系统响应缓慢，磁盘I&#x2F;O飙升。workingset.c 的核心目标就是识别并保护这些被错误回收的工作集页面，从而抑...</div></div></div></a><a class="pagination-related" href="/posts/e8ec9031/" title="vmscan"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/03.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-07</div><div class="info-item-2">vmscan</div></div><div class="info-2"><div class="info-item-1">   [toc]  mm&#x2F;vmscan.c 页面回收(Page Reclaim) 内核内存管理的核心压力调节器历史与背景这项技术是为了解决什么特定问题而诞生的？mm/vmscan.c 中的代码是为了解决计算机科学中最基本的问题之一：物理内存是一种有限资源。当系统运行的应用程序和内核本身需要的内存总量超过了可用的物理RAM时，操作系统必须有一种机制来释放一些当前已分配但“不那么重要”的内存，以便为新的、更紧迫的内存请求腾出空间。 如果没有页面回收机制，系统在内存耗尽时唯一的选择就是拒绝新的内存分配请求，这将导致应用程序崩溃或系统完全停止响应。vmscan.c 实现的页面回收（Page Reclaim）算法，其核心目标是在内存压力（Memory Pressure）下，智能地选择并回收内存页面，从而保证系统的持续运行和响应能力。 它的发展经历了哪些重要的里程碑或版本迭代？Linux的页面回收算法经历了重大的演进，以适应不断变化的硬件和工作负载：  早期的LRU：最初的Linux内核使用了相当简单的“最近最少使用”（Least Recently Used, LRU）算法。 两阶...</div></div></div></a><a class="pagination-related" href="/posts/dd631879/" title="kallsyms"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/04.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-06</div><div class="info-item-2">kallsyms</div></div><div class="info-2"><div class="info-item-1">   [TOC] linux-gnu&#x2F;bits&#x2F;getopt_ext.h getopt_long: GNU 命令行长选项解析接口本代码片段是一个 C 语言头文件（getopt_ext.h，通常被 getopt.h 包含），它定义了 GNU C 库中用于解析命令行参数的 getopt_long 函数及其核心数据结构 struct option。其主要功能是为命令行程序提供一个强大且灵活的机制，使其能够支持并解析长格式的选项（例如，--all-symbols），而不仅仅是传统的单字母短格式选项（如 -a）。 实现原理分析此机制的核心是通过一个描述符结构体数组，将命令行中的字符串与程序内部的变量和行为进行声明式映射。  选项描述符 (struct option): 这是整个机制的核心数据结构。开发者需要创建一个 struct option 类型的数组，数组中的每一个元素都完整地描述了一个长选项：  const char *name: 定义了长选项的名称，即 -- 后面的字符串，例如 &quot;all-symbols&quot;。 int has_arg: 指定该选...</div></div></div></a><a class="pagination-related" href="/posts/e5a511c0/" title="mmzone"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/02.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-03</div><div class="info-item-2">mmzone</div></div><div class="info-2"><div class="info-item-1">[TOC] mm&#x2F;vmscan.c lruvec 结构体 页面回收的核心数据结构lruvec 是 Linux 内核中用于管理 LRU（Least Recently Used，最近最少使用）页面列表的一个核心数据结构。它是内存管理子系统的一部分，定义于 mm/vmscan.c 相关头文件中，主要作用是在页面回收（Page Reclamation）过程中，对不同类型、不同状态的内存页面进行分组和跟踪，是内核决定回收哪些页面的关键依据。 历史与背景这项技术是为了解决什么特定问题而诞生的？lruvec 的诞生是为了解决在现代计算机体系结构下，如何高效、精确、可扩展地管理内存页面以供回收的问题。  区分页面类型：不同类型的内存页面回收成本和策略完全不同。例如，文件页（File-backed pages）如果内容未被修改（是干净的），可以直接丢弃，需要时再从磁盘读回；而匿名页（Anonymous pages，如进程堆栈、malloc分配的内存）则必须先交换到交换空间（Swap Area）才能释放，成本更高。lruvec 需要将它们分开管理。 近似LRU算法：真正的LRU算法要求跟踪...</div></div></div></a><a class="pagination-related" href="/posts/d32d8ac9/" title="clocksource"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/04.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-03</div><div class="info-item-2">clocksource</div></div><div class="info-2"><div class="info-item-1">[TOC] clocksource 内核时钟源(Kernel Clocksource) 为内核提供统一的时间基准历史与背景这项技术是为了解决什么特定问题而诞生的？clocksource框架的诞生是为了解决Linux内核中一个根本性的问题：如何以一种统一、可移植的方式来处理多样化的硬件计时器。  硬件的多样性：不同的CPU架构和平台提供了五花八门的硬件计时器，例如x86上的TSC（时间戳计数器）、HPET（高精度事件定时器）、ACPI PM Timer，以及ARM平台上的Architected Timer等。这些计时器的精度、速度、稳定性和编程接口各不相同。 缺乏统一抽象：在clocksource框架出现之前，内核中的时间管理代码与特定的硬件架构和计时器紧密耦合。这使得将内核移植到新平台变得困难，也难以在运行时动态选择最优的计时器硬件。 对高精度的需求：随着系统应用（如实时系统、高频交易、性能剖析）对时间精度要求的提高，内核需要一个能够充分利用现代高精度计时器硬件的框架。  clocksource框架通过创建一个通用的抽象层，将这些底层硬件计时器的差异性隐藏起来，为内核的上层时间子...</div></div></div></a><a class="pagination-related" href="/posts/5a79feca/" title="dma"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/03.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-03</div><div class="info-item-2">dma</div></div><div class="info-2"><div class="info-item-1">[TOC] drivers&#x2F;dma DMA引擎与映射(DMA Engine &amp; Mapping) 内核统一的直接内存访问框架历史与背景这项技术是为了解决什么特定问题而诞生的？DMA（Direct Memory Access，直接内存访问）框架的诞生是为了解决一个根本性的性能瓶颈问题，并为内核提供一个统一、可移植的解决方案。  解决CPU性能瓶颈：在没有DMA的系统中，当外设（如网卡、磁盘）需要与内存交换大量数据时，CPU必须亲自担当“搬运工”的角色。这种方式被称为PIO（Programmed I&#x2F;O），CPU需要逐字节或逐字地从设备读取数据再写入内存，或者反之。对于高速设备，这会消耗大量的CPU周期，导致CPU无暇处理其他计算任务，严重影响系统整体性能。DMA技术通过引入一个专门的硬件控制器（DMAC），允许外设在没有CPU干预的情况下直接与内存进行数据传输，从而将CPU解放出来。 抽象硬件差异：不同的CPU架构和SoC平台，其DMA控制器的设计和编程接口千差万别。如果没有一个统一的软件框架，设备驱动程序的开发者将不得不为每一种不同的DMAC编写特定的...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/avatar.png" onerror="this.onerror=null;this.src='/images/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Liya Huang</div><div class="author-info-description">WORK-LIFE BALANCE</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">414</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">49</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">53</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/wdfk-prog"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/wdfk-prog" rel="external nofollow noreferrer" target="_blank" title="GitHub"><i class="fab fa-github" style="color: #181717;"></i></a><a class="social-icon" href="https://wdfk-prog.blog.csdn.net/" rel="external nofollow noreferrer" target="_blank" title="CSDN"><i class="fas fa-blog" style="color: #FC5531;"></i></a><a class="social-icon" href="mailto:1425075683@qq.com" rel="external nofollow noreferrer" target="_blank" title="E-mail"><i class="fas fa-envelope" style="color: #4A4A4A;"></i></a><a class="social-icon" href="/images/wechat-qrcode.jpg" target="_blank" title="微信公众号"><i class="fab fa-weixin" style="color: #07C160;"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss" style="color: #EE802F;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎光临！有任何问题或想法，欢迎在文章下留言交流，或者通过 <a href='/about/'>关于页面</a> 联系我。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%9F%BA%E7%9F%B3%EF%BC%9AFLATMEM-%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">Linux 内存模型之基石：FLATMEM 深度解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%EF%BC%9Amem-map-%E6%95%B0%E7%BB%84"><span class="toc-number">1.0.1.</span> <span class="toc-text">一、 核心原理：mem_map 数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81-%E4%BC%98%E7%82%B9%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.0.2.</span> <span class="toc-text">二、 优点与适用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81-%E7%BC%BA%E7%82%B9%E4%B8%8E%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">1.0.3.</span> <span class="toc-text">三、 缺点与局限性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81-FLATMEM-%E5%9C%A8%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%BC%94%E8%BF%9B%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.0.4.</span> <span class="toc-text">四、 FLATMEM 在内存模型演进中的位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81-%E6%80%BB%E7%BB%93"><span class="toc-number">1.0.5.</span> <span class="toc-text">五、 总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#include-linux-mm-types-h"><span class="toc-number">2.</span> <span class="toc-text">include&#x2F;linux&#x2F;mm_types.h</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MM-MT-FLAGS-%E9%85%8D%E7%BD%AE%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%BB%93%E6%9E%84%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%A1%8C%E4%B8%BA"><span class="toc-number">2.1.</span> <span class="toc-text">MM_MT_FLAGS 配置内存管理结构的多线程行为</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#include-linux-mm-h"><span class="toc-number">3.</span> <span class="toc-text">include&#x2F;linux&#x2F;mm.h</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#mm-zero-struct-page-%E8%AE%BE%E7%BD%AE%E7%BB%93%E6%9E%84%E4%BD%93%E9%A1%B5%E9%9D%A2%E4%B8%BA%E9%9B%B6"><span class="toc-number">3.1.</span> <span class="toc-text">mm_zero_struct_page 设置结构体页面为零</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%87%8F%E5%B0%91%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%BC%80%E9%94%80"><span class="toc-number">3.1.1.</span> <span class="toc-text">1. 减少函数调用开销</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96"><span class="toc-number">3.1.2.</span> <span class="toc-text">2. 编译器优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%81%BF%E5%85%8D%E9%80%9A%E7%94%A8%E6%80%A7%E5%BC%80%E9%94%80"><span class="toc-number">3.1.3.</span> <span class="toc-text">3. 避免通用性开销</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%87%8F%E5%B0%91%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B%E5%A4%B1%E8%B4%A5"><span class="toc-number">3.1.4.</span> <span class="toc-text">4. 减少分支预测失败</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">3.1.5.</span> <span class="toc-text">5. 内存对齐的优势</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#set-page-links-%E8%AE%BE%E7%BD%AE%E9%A1%B5%E9%9D%A2%E9%93%BE%E6%8E%A5"><span class="toc-number">3.2.</span> <span class="toc-text">set_page_links 设置页面链接</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mm-init-c-Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%95%E5%AF%BC%E8%80%85%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A0%B8%E5%BF%83"><span class="toc-number">4.</span> <span class="toc-text">mm&#x2F;init.c: Linux内存管理子系统的引导者与初始化核心</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">4.1.</span> <span class="toc-text">介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81-%E6%A0%B8%E5%BF%83%E8%81%8C%E8%B4%A3"><span class="toc-number">4.1.1.</span> <span class="toc-text">一、 核心职责</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81-%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90"><span class="toc-number">4.1.2.</span> <span class="toc-text">二、 核心函数深度解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-mm-init-%E6%80%BB%E6%8C%87%E6%8C%A5"><span class="toc-number">4.1.2.1.</span> <span class="toc-text">1. mm_init() - 总指挥</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-mem-init-%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A5%A0%E5%9F%BA%E8%80%85"><span class="toc-number">4.1.2.2.</span> <span class="toc-text">2. mem_init() - 伙伴系统的奠基者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-free-initmem-%E2%80%9C%E8%BF%87%E6%B2%B3%E6%8B%86%E6%A1%A5%E2%80%9D%E7%9A%84%E8%89%BA%E6%9C%AF"><span class="toc-number">4.1.2.3.</span> <span class="toc-text">3. free_initmem() - “过河拆桥”的艺术</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81-%E5%9C%A8%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-number">4.1.3.</span> <span class="toc-text">三、 在内核启动流程中的位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81-%E6%80%BB%E7%BB%93"><span class="toc-number">4.1.4.</span> <span class="toc-text">四、 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#find-usable-zone-for-movable-%E6%9F%A5%E6%89%BE%E5%8F%AF%E7%94%A8%E4%BA%8EZONE-MOVABLE%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%8C%BA%E5%9F%9F"><span class="toc-number">4.2.</span> <span class="toc-text">find_usable_zone_for_movable 查找可用于ZONE_MOVABLE页面的区域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mirrored-kernelcore-%E8%AE%BE%E7%BD%AE%E5%86%85%E6%A0%B8%E5%86%85%E5%AD%98%E7%9A%84%E9%95%9C%E5%83%8F"><span class="toc-number">4.3.</span> <span class="toc-text">mirrored_kernelcore 设置内核内存的镜像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#find-zone-movable-pfns-for-nodes-%E5%AF%BB%E6%89%BE%E5%8F%AF%E7%A7%BB%E5%8A%A8%E5%8C%BA%E5%9F%9F%E7%9A%84%E9%A1%B5%E9%9D%A2"><span class="toc-number">4.4.</span> <span class="toc-text">find_zone_movable_pfns_for_nodes 寻找可移动区域的页面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#calculate-node-totalpages-%E8%AE%A1%E7%AE%97%E8%8A%82%E7%82%B9%E6%80%BB%E9%A1%B5%E6%95%B0"><span class="toc-number">4.5.</span> <span class="toc-text">calculate_node_totalpages 计算节点总页数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pgdat-init-internals-%E5%88%9D%E5%A7%8B%E5%8C%96pgdat"><span class="toc-number">4.6.</span> <span class="toc-text">pgdat_init_internals 初始化pgdat</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#free-area-init-core-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8C%BA%E5%9F%9F%E6%A0%B8%E5%BF%83"><span class="toc-number">4.7.</span> <span class="toc-text">free_area_init_core 初始化区域核心</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#free-area-init-node-%E5%88%9D%E5%A7%8B%E5%8C%96%E8%8A%82%E7%82%B9%E7%A9%BA%E9%97%B2%E5%8C%BA%E5%9F%9F"><span class="toc-number">4.8.</span> <span class="toc-text">free_area_init_node 初始化节点空闲区域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#calc-nr-kernel-pages-%E8%AE%A1%E7%AE%97%E5%86%85%E6%A0%B8%E9%A1%B5%E9%9D%A2%E6%95%B0%E9%87%8F"><span class="toc-number">4.9.</span> <span class="toc-text">calc_nr_kernel_pages 计算内核页面数量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#init-single-page-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8D%95%E4%B8%AA%E9%A1%B5%E9%9D%A2"><span class="toc-number">4.10.</span> <span class="toc-text">__init_single_page 初始化单个页面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#memmap-init-range-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E8%8C%83%E5%9B%B4"><span class="toc-number">4.11.</span> <span class="toc-text">memmap_init_range 初始化内存映射范围</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#memmap-init-zone-range-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E5%8C%BA%E5%9F%9F"><span class="toc-number">4.12.</span> <span class="toc-text">memmap_init_zone_range 初始化内存映射区域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#memmap-init-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="toc-number">4.13.</span> <span class="toc-text">memmap_init 初始化内存映射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#free-area-init-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%89%80%E6%9C%89pg-data-t%E5%92%8C%E5%8C%BA%E5%9F%9F%E6%95%B0%E6%8D%AE"><span class="toc-number">4.14.</span> <span class="toc-text">free_area_init 初始化所有pg_data_t和区域数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#alloc-large-system-hash-%E5%88%86%E9%85%8D%E5%A4%A7%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%93%88%E5%B8%8C"><span class="toc-number">4.15.</span> <span class="toc-text">alloc_large_system_hash 分配大型系统哈希</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mem-debugging-and-hardening-init-%E5%86%85%E5%AD%98%E8%B0%83%E8%AF%95%E5%92%8C%E7%A1%AC%E5%8C%96%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">4.16.</span> <span class="toc-text">mem_debugging_and_hardening_init 内存调试和硬化初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#report-meminit-%E6%8A%A5%E5%91%8A%E5%86%85%E5%AD%98%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">4.17.</span> <span class="toc-text">report_meminit 报告内存初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mm-core-init-%E8%AE%BE%E7%BD%AE%E5%86%85%E6%A0%B8%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8"><span class="toc-number">4.18.</span> <span class="toc-text">mm_core_init 设置内核内存分配器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reserve-bootmem-region-%E6%A0%87%E8%AE%B0%E7%94%B1%E5%BC%95%E5%AF%BC%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8%EF%BC%88bootmem-allocator%EF%BC%89%E5%88%86%E9%85%8D%E7%9A%84%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%AD%E7%9A%84%E9%A1%B5%E9%9D%A2%E4%B8%BA%E2%80%9C%E4%BF%9D%E7%95%99%E2%80%9D%EF%BC%88PageReserved"><span class="toc-number">4.19.</span> <span class="toc-text">reserve_bootmem_region 标记由引导内存分配器（bootmem allocator）分配的内存区域中的页面为“保留”（PageReserved</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#memblock-free-pages-%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98%E5%9D%97"><span class="toc-number">4.20.</span> <span class="toc-text">memblock_free_pages 释放内存块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#set-zone-contiguous-%E6%A3%80%E6%9F%A5%E4%B8%80%E4%B8%AA%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%EF%BC%88zone%EF%BC%89%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E9%A1%B5%E5%9D%97%EF%BC%88pageblock%EF%BC%89%E6%98%AF%E5%90%A6%E9%83%BD%E5%AD%98%E5%9C%A8%E5%AF%B9%E5%BA%94%E7%9A%84%E7%89%A9%E7%90%86%E9%A1%B5%E5%B8%A7"><span class="toc-number">4.21.</span> <span class="toc-text">set_zone_contiguous 检查一个内存区域（zone）中的所有页块（pageblock）是否都存在对应的物理页帧</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#page-alloc-sysctl-init"><span class="toc-number">4.22.</span> <span class="toc-text">page_alloc_sysctl_init</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#page-alloc-init-late-%E5%AF%B9%E9%A1%B5%E5%88%86%E9%85%8D%E5%99%A8%EF%BC%88Page-Allocator%EF%BC%89%E5%AD%90%E7%B3%BB%E7%BB%9F%E8%BF%9B%E8%A1%8C%E7%9A%84%E5%90%8E%E6%9C%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0"><span class="toc-number">4.23.</span> <span class="toc-text">page_alloc_init_late 对页分配器（Page Allocator）子系统进行的后期初始化函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mm-sysfs-init-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-MM-%E7%9B%B8%E5%85%B3%E7%9A%84sysfs%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.24.</span> <span class="toc-text">mm_sysfs_init: 初始化内存管理(MM)相关的sysfs接口</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/1db9a982/" title="ext4"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/04.jpg" onerror="this.onerror=null;this.src='/images/404.jpg'" alt="ext4"/></a><div class="content"><a class="title" href="/posts/1db9a982/" title="ext4">ext4</a><time datetime="2025-10-07T03:18:15.310Z" title="更新于 2025-10-07 11:18:15">2025-10-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/b554c0f0/" title="mbcache"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/03.jpg" onerror="this.onerror=null;this.src='/images/404.jpg'" alt="mbcache"/></a><div class="content"><a class="title" href="/posts/b554c0f0/" title="mbcache">mbcache</a><time datetime="2025-10-07T03:16:04.099Z" title="更新于 2025-10-07 11:16:04">2025-10-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/88ab2b13/" title="fs-writeback"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/08.jpg" onerror="this.onerror=null;this.src='/images/404.jpg'" alt="fs-writeback"/></a><div class="content"><a class="title" href="/posts/88ab2b13/" title="fs-writeback">fs-writeback</a><time datetime="2025-10-07T03:08:29.811Z" title="更新于 2025-10-07 11:08:29">2025-10-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2089198e/" title="filesystems"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/03.jpg" onerror="this.onerror=null;this.src='/images/404.jpg'" alt="filesystems"/></a><div class="content"><a class="title" href="/posts/2089198e/" title="filesystems">filesystems</a><time datetime="2025-10-07T02:52:10.933Z" title="更新于 2025-10-07 10:52:10">2025-10-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/933a291e/" title="hweight"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/10.jpg" onerror="this.onerror=null;this.src='/images/404.jpg'" alt="hweight"/></a><div class="content"><a class="title" href="/posts/933a291e/" title="hweight">hweight</a><time datetime="2025-10-07T02:49:48.378Z" title="更新于 2025-10-07 10:49:48">2025-10-07</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/images/covers/01.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">文档</div><div class="footer-flex-content"><a href="/categories/linux/" target="_blank" title="🚀 linux">🚀 linux</a><a href="/categories/rt-thread/" target="_blank" title="📑 rt-thread">📑 rt-thread</a><a href="/categories/uboot/" target="_blank" title="📌 uboot">📌 uboot</a><a href="/categories/LoraWan/" target="_blank" title="⚔️ LoraWan">⚔️ LoraWan</a><a href="/categories/hpatch/" target="_blank" title="❓ hpatch">❓ hpatch</a><a href="/categories/git/" target="_blank" title="⚡️ git">⚡️ git</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/gallery/" target="_blank" title="图库">图库</a><a href="/messageboard/" target="_blank" title="留言板">留言板</a><a href="/shuoshuo/" target="_blank" title="说说">说说</a><a href="/link/" target="_blank" title="示例">示例</a><a href="/link/" target="_blank" title="友链">友链</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">框架</div><div class="footer-flex-content"><a href="https://hexo.io/zh-cn/" rel="external nofollow noreferrer" target="_blank" title="Hexo">Hexo</a><a href="https://butterfly.js.org/" rel="external nofollow noreferrer" target="_blank" title="Butterfly">Butterfly</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">贊助</div><div class="footer-flex-content"><div><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/alipay.png" alt='wdfk_prog' width='100px' height='100px'></div></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Liya Huang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo 8.0.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.1</a></span></div><div class="footer_custom_text">你好，欢迎来到我的 <a href="/about/">数字花园</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天" style="display:none"><i class="fas fa-message"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script><script>(() => {
  const abcjsInit = () => {
    const abcjsFn = () => {
      setTimeout(() => {
        const sheets = document.querySelectorAll(".abc-music-sheet")
        for (let i = 0; i < sheets.length; i++) {
          const ele = sheets[i]
          if (ele.children.length > 0) continue

          // Parse parameters from data-params attribute
          let params = {}
          const dp = ele.getAttribute("data-params")
          if (dp) {
            try {
              params = JSON.parse(dp)
            } catch (e) {
              console.error("Failed to parse data-params:", e)
            }
          }

          // Merge parsed parameters with the responsive option
          // Ensures params content appears before responsive
          const options = { ...params, responsive: "resize" }

          // Render the music score using ABCJS.renderAbc
          ABCJS.renderAbc(ele, ele.innerHTML, options)
        }
      }, 100)
    }

    if (typeof ABCJS === "object") {
      abcjsFn()
    } else {
      btf.getScript("https://cdn.jsdelivr.net/npm/abcjs/dist/abcjs-basic-min.min.js").then(abcjsFn)
    }
  }

  if (window.pjax) {
    abcjsInit()
  } else {
    window.addEventListener("load", abcjsInit)
  }

  btf.addGlobalFn("encrypt", abcjsInit, "abcjs")
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: 'Ov23livBmwx65h3XIdfT',
      clientSecret: '9f23bdaa2ea11322f9f405d77bcdc27166077a7d',
      repo: 'wdfk-prog.github.io',
      owner: 'wdfk-prog',
      admin: ['wdfk-prog'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || 'c451e7f01eb4a3b443d172172bcf0583'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script>window.newestComments = {
  changeContent: content => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<code>.*?<\/code>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g, "") // remove html tag

    if (content.length > 150) {
      content = content.substring(0, 150) + '...'
    }
    return content
  },

  generateHtml: (array, ele) => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class="aside-list-item">'

        if (true && array[i].avatar) {
          const imgAttr = 'data-lazy-src'
          const lazyloadNative = ''
          result += `<a href="${array[i].url}" class="thumbnail"><img ${imgAttr}="${array[i].avatar}" alt="${array[i].nick}" ${lazyloadNative}></a>`
        }

        result += `<div class="content">
        <a class="comment" href="${array[i].url}" title="${array[i].content}">${array[i].content}</a>
        <div class="name"><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '暂无评论'
    }

    ele.innerHTML = result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh(ele)
  },

  newestCommentInit: (name, getComment) => {
    const $dom = document.querySelector('#card-newest-comments .aside-list')
    if ($dom) {
      const data = btf.saveToLocal.get(name)
      if (data) {
        newestComments.generateHtml(JSON.parse(data), $dom)
      } else {
        getComment($dom)
      }
    }
  },

  run: (name, getComment) => {
    newestComments.newestCommentInit(name, getComment)
    btf.addGlobalFn('pjaxComplete', () => newestComments.newestCommentInit(name, getComment), name)
  }
}</script><script>window.addEventListener('load', () => {
  const keyName = 'github-newest-comments'
  const { changeContent, generateHtml, run } = window.newestComments

  const findTrueUrl = (array, ele) => {
    Promise.all(array.map(item =>
      fetch(item.url).then(resp => resp.json()).then(data => {
        let urlArray = data.body ? data.body.match(/(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?/ig) : []
        if (!Array.isArray(urlArray) || urlArray.length === 0) {
          urlArray = [`${data.html_url}`]
        }
        if (data.user.login === 'utterances-bot') {
          return urlArray.pop()
        } else {
          return urlArray.shift()
        }
      })
    )).then(res => {
        array = array.map((i,index)=> {
          return {
            ...i,
            url: res[index]
          }
        })

        btf.saveToLocal.set(keyName, JSON.stringify(array), 10/(60*24))
        generateHtml(array, ele)
    });
  }

  const getComment = ele => {
    fetch('https://api.github.com/repos/wdfk-prog/wdfk-prog.github.io/issues/comments?sort=updated&direction=desc&per_page=6&page=1',{
      "headers": {
        Accept: 'application/vnd.github.v3.html+json'
      }
    })
      .then(response => response.json())
      .then(data => {
        const githubArray = data.map(item => {
          return {
            'avatar': item.user.avatar_url,
            'content': changeContent(item.body_html || item.body),
            'nick': item.user.login,
            'url': item.issue_url,
            'date': item.updated_at
          }
        })
        findTrueUrl(githubArray, ele)
      }).catch(e => {
        console.error(e)
        ele.textContent= "无法获取评论，请确认相关配置是否正确"
      })
  }
  run(keyName, getComment)
})</script><div class="aplayer no-destroy" data-id="60198" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="false" data-volume="0.5"></div><script>
  var titleTime, OriginTitile = document.title;
  document.addEventListener("visibilitychange", function() {
    if (document.hidden) {
      titleTime = setTimeout(function() {
        document.title = "w(ﾟДﾟ)w 不要走！再看看嘛！";
      }, 300);
    } else {
      document.title = "♪(^∇^*)欢迎回来！" + OriginTitile;
      titleTime = setTimeout(function() {
        document.title = OriginTitile;
      }, 2000);
    }
  });
</script>
<script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script>(() => {
  window.ChatraID = '5cPWcnA8HKGzg5hoc'
  window.Chatra = window.Chatra || function() {
    (window.Chatra.q = window.Chatra.q || []).push(arguments)
  }

  btf.getScript('https://call.chatra.io/chatra.js').then(() => {
    const isChatBtn = true
    const isChatHideShow = true

    if (isChatBtn) {
      const close = () => {
        Chatra('minimizeWidget')
        Chatra('hide')
      }

      const open = () => {
        Chatra('openChat', true)
        Chatra('show')
      }

      window.ChatraSetup = { startHidden: true }
    
      window.chatBtnFn = () => document.getElementById('chatra').classList.contains('chatra--expanded') ? close() : open()

      document.getElementById('chat-btn').style.display = 'block'
    } else if (isChatHideShow) {
      window.chatBtn = {
        hide: () => Chatra('hide'),
        show: () => Chatra('show')
      }
    }
  })
})()</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: true,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      true
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-MF3J339H" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript></div><script src="https://cdn.jsdelivr.net/npm/echarts@5.5.1/dist/echarts.min.js"></script>
        
        <script>
            document.addEventListener("DOMContentLoaded", function() {
                const heatmapChartDom = document.getElementById('heatmapChart');
                if(heatmapChartDom){
                    const heatmapChart = echarts.init(heatmapChartDom, 'dark');
                    const cellSize = [18, 18];
                    
                    const groupByYear = (data) => {
                        const result = {};
                        data.forEach(([date, value]) => {
                            const [year] = date.split('-').map(Number);
                            if (!result[year]) {
                                result[year] = [];
                            }
                            result[year].push([date, value]);
                        });
                        return result;
                    };
                    
                    const groupedData = groupByYear([["2025-10-03",392],["2025-10-04",5],["2025-10-06",9],["2025-10-07",8]]);
                    const years = Object.keys(groupedData).reverse();
                    
                    var initYear = parseInt(heatmapChartDom.getAttribute('year')) || new Date().getFullYear();
                    const minYear = years[years.length - 1];
                    const maxYear = years[0];
                    if (initYear < minYear || initYear > maxYear) {
                        initYear = maxYear;
                    }
                    console.log('[hexo-graph]generateHeatmapChart|initYear:', initYear, 'minYear:', minYear, 'maxYear:', maxYear);
                    
                    heatmapChart.setOption({
                        grid: {},
                        tooltip: { 
                            position: 'top', 
                            formatter: params => `${params.value[0]}: ${params.value[1]} Articles` 
                        },
                        calendar: { 
                            top: '10%',
                            left: 'left', 
                            right: '8%',
                            range: initYear,
                            cellSize: cellSize, 
                            splitLine: { lineStyle: { color: '#E0E0E0', width: 1 } }, 
                            itemStyle: { borderWidth: 1, borderColor: '#E0E0E0' }, 
                            dayLabel: { show: false },
                            monthLabel: { show: true },
                            yearLabel: { show: false },
                        },
                        visualMap: { 
                            show: true,
                            right: '8%',
                            bottom: '5%',
                            type: 'piecewise',
                            orient: 'horizontal',
                            text: ['More', 'Less'],
                            min: 0,
                            max: Math.max(...groupedData[initYear].map(item => item[1])),
                            inRange: { color: ["#ACE7AE","#69C16D","#549F57"] }
                        },
                        legend: {
                            type: 'scroll',
                            icon: 'none',
                            data: years,
                            orient: 'vertical',
                            top: '5%',
                            right: 'right',
                            itemWidth: 20,
                            itemHeight: 20,
                            itemGap: 10,
                            pageIconSize: 10,
                            pageTextStyle: { fontSize: 14 },
                            selectedMode: 'single',
                        },
                        series: years.map(year => ({
                            type: 'heatmap',
                            coordinateSystem: 'calendar',
                            data: groupedData[year],
                            name: year,
                            emphasis: {
                                disabled: true,
                            },
                            silent: year !== initYear,
                        })),
                    });
                    
                    // init selected year
                    heatmapChart.dispatchAction({
                        type: 'legendSelect',
                        name: initYear,
                    });
                    
                    heatmapChart.on('legendselectchanged', function(params) {
                        console.log('[hexo-graph]generateHeatmapChart|legendselectchanged:', params);
                        const selectedYear = Object.keys(params.selected).find(key => params.selected[key]);
                        if (selectedYear && groupedData[selectedYear]) {
                            heatmapChart.setOption({
                                calendar: {
                                    range: selectedYear,
                                },
                                visualMap: {
                                    max: Math.max(...groupedData[selectedYear].map(item => item[1])),
                                },
                                series: years.map(year => ({
                                    type: 'heatmap',
                                    coordinateSystem: 'calendar',
                                    data: groupedData[year],
                                    name: year,
                                    emphasis: {
                                        disabled: true,
                                    },
                                    silent: year !== selectedYear,
                                })),
                            });
                        }
                    });
                    
                    heatmapChart.on('click', function (params) {
                        if (params.componentType === 'series') {
                            const [year, month] = params.value[0].split('-');
                            window.location.href = '/archives/' + year + '/' + month;
                        }
                    });
                }
            });
        </script>
    
        
        <script>
            document.addEventListener("DOMContentLoaded", function() {
                const monthlyChartDom = document.getElementById('monthlyChart');
                if(monthlyChartDom){
                    const monthlyChart = echarts.init(monthlyChartDom, 'dark');
                    monthlyChart.setOption({
                        xAxis: { 
                            type: 'category', 
                            data: ["2025-10"], 
                            axisLabel: { fontSize: 14, fontWeight: 'bold', fontFamily: 'Microsoft YaHei, SimSun, serif' }
                        },
                        yAxis: { type: 'value', splitLine: { lineStyle: { type: 'dashed', color: '#ccc' } } },
                        series: [{
                            name: 'Articles',
                            type: 'line',
                            data: [414],
                            smooth: true,
                            lineStyle: { color: '#5470C6', width: 2 },
                            itemStyle: { color: '#5470C6' },
                            areaStyle: { color: 'rgba(84, 112, 198, 0.4)' },
                            symbolSize: 10,
                            label: {
                                show: true,
                                position: 'top',
                                formatter: params => params.value,
                                fontSize: 14,
                                color: '#000',
                                fontWeight: 'bold',
                                fontFamily: 'Microsoft YaHei, SimSun, serif'
                            }
                        }]
                    });

                    monthlyChart.on('click', function (params) {
                        const [year, month] = params.name.split('-');
                        window.location.href = '/archives/' + year + '/' + month;
                    });
                }
            })
        </script>
    
        
        <script>
            document.addEventListener("DOMContentLoaded", function() {
                const tagsChartDom = document.getElementById('tagsChart');
                if(tagsChartDom){
                    const tagsChart = echarts.init(tagsChartDom, 'dark');
                    tagsChart.setOption({
                        tooltip: { trigger: 'item', formatter: '{b}: {c} ({d}%)' },
                        series: [{
                            type: 'pie',
                            radius: '60%',
                            data: [{"name":"linux","value":227},{"name":"uboot","value":68},{"name":"kernel","value":61},{"name":"rt-thread","value":44},{"name":"u-boot分类","value":44},{"name":"drivers","value":39},{"name":"fs","value":37},{"name":"other","value":28}],
                            label: {
                                position: 'outside',
                                formatter: '{b} {c} ({d}%)',
                                fontSize: 14,
                                fontWeight: 'bold',
                                fontFamily: 'Microsoft YaHei, SimSun, serif'
                            },
                            color: ["#5470C6","#91CC75","#FAC858","#EE6666","#73C0DE","#3BA272","#FC8452","#9A60B4"],
                            labelLine: { show: true }
                        }],
                        legend: {
                            bottom: '0',
                            left: 'center',
                            data: [{"name":"linux","value":227},{"name":"uboot","value":68},{"name":"kernel","value":61},{"name":"rt-thread","value":44},{"name":"u-boot分类","value":44},{"name":"drivers","value":39},{"name":"fs","value":37},{"name":"other","value":28}].map(tag => tag.name),
                            textStyle: { fontSize: 14, fontWeight: 'bold', fontFamily: 'Microsoft YaHei, SimSun, serif' }
                        }
                    });

                    tagsChart.on('click', function (params) {
                        window.location.href = '/tags/' + params.name;
                    });
                }
            })
        </script>
    
        
        <script>
            document.addEventListener("DOMContentLoaded", function() {
                const categoriesChartDom = document.getElementById('categoriesChart');
                if(categoriesChartDom){
                    const categoriesChart = echarts.init(categoriesChartDom, 'dark');
                    categoriesChart.setOption({
                        xAxis: { type: 'value', splitLine: { lineStyle: { type: 'dashed', color: '#ccc' } } },
                        yAxis: { 
                            type: 'category', 
                            data: [{"name":"linux","value":227},{"name":"uboot","value":68},{"name":"kernel","value":61},{"name":"rt-thread","value":44},{"name":"u-boot分类","value":44}].map(category => category.name).reverse(), 
                            axisLabel: { fontSize: 14, fontWeight: 'bold', fontFamily: 'Microsoft YaHei, SimSun, serif' }
                        },
                        series: [{
                            name: 'Category Count',
                            type: 'bar',
                            data: [{"name":"linux","value":227},{"name":"uboot","value":68},{"name":"kernel","value":61},{"name":"rt-thread","value":44},{"name":"u-boot分类","value":44}].map(category => category.value).reverse(),
                            label: {
                                show: true,
                                position: 'right',
                                formatter: params => params.value,
                                fontSize: 14,
                                color: '#000',
                                fontWeight: 'bold',
                                fontFamily: 'Microsoft YaHei, SimSun, serif'
                            },
                            itemStyle: {
                                color: new echarts.graphic.LinearGradient(0, 0, 1, 0, [
                                    { offset: 0, color: '#91CC75' },
                                    { offset: 1, color: '#73C0DE' }
                                ])
                            }
                        }]
                    });

                    categoriesChart.on('click', function (params) {
                        window.location.href = '/categories/' + params.name;
                    });
                }
            });
        </script>
    
        
        <script>
            document.addEventListener("DOMContentLoaded", function() {
                const categoriesTreeChartDom = document.getElementById('categoriesTreeChart');
                if(categoriesTreeChartDom){
                    const treeChart = echarts.init(categoriesTreeChartDom, 'dark');
                    treeChart.setOption({
                        title: {
                            text: '操作提示：单击展开分类，双击进入具体分类页面',
                            textStyle: {
                                fontSize: 12,
                                color: '#999',
                                fontWeight: 'normal'
                            },
                            bottom: 0,
                            left: 'center'
                        },
                        tooltip: {
                            trigger: 'item',
                            triggerOn: 'mousemove'
                        },
                        series: [{
                            type: 'tree',
                            data: [{"name":"Categories","children":[{"name":"uboot","children":[{"name":"other","children":[],"count":12,"path":"uboot/other"},{"name":"子目录","children":[],"count":10,"path":"uboot/子目录"},{"name":"u-boot分类","children":[{"name":"api","children":[],"count":1,"path":"uboot/u-boot分类/api"},{"name":"arch","children":[{"name":"arm","children":[],"count":2,"path":"uboot/u-boot分类/arch/arm"}],"count":3,"path":"uboot/u-boot分类/arch"},{"name":"boot","children":[],"count":4,"path":"uboot/u-boot分类/boot"},{"name":"common","children":[],"count":10,"path":"uboot/u-boot分类/common"},{"name":"cmd","children":[],"count":1,"path":"uboot/u-boot分类/cmd"},{"name":"dm","children":[],"count":15,"path":"uboot/u-boot分类/dm"},{"name":"env","children":[],"count":1,"path":"uboot/u-boot分类/env"},{"name":"fdt","children":[],"count":1,"path":"uboot/u-boot分类/fdt"},{"name":"lib","children":[],"count":4,"path":"uboot/u-boot分类/lib"},{"name":"include","children":[],"count":3,"path":"uboot/u-boot分类/include"},{"name":"test","children":[],"count":1,"path":"uboot/u-boot分类/test"}],"count":44,"path":"uboot/u-boot分类"}],"count":68,"path":"uboot"},{"name":"rt-thread","children":[{"name":"其他资料","children":[{"name":"fatfs","children":[],"count":1,"path":"rt-thread/其他资料/fatfs"}],"count":1,"path":"rt-thread/其他资料"}],"count":44,"path":"rt-thread"},{"name":"linux","children":[{"name":"fs","children":[],"count":37,"path":"linux/fs"},{"name":"lib","children":[],"count":19,"path":"linux/lib"},{"name":"mm","children":[],"count":19,"path":"linux/mm"},{"name":"kernel","children":[{"name":"time","children":[],"count":10,"path":"linux/kernel/time"},{"name":"irq","children":[],"count":5,"path":"linux/kernel/irq"},{"name":"rcu","children":[],"count":3,"path":"linux/kernel/rcu"},{"name":"lock","children":[],"count":7,"path":"linux/kernel/lock"},{"name":"sched","children":[],"count":7,"path":"linux/kernel/sched"}],"count":61,"path":"linux/kernel"},{"name":"other","children":[],"count":17,"path":"linux/other"},{"name":"scripts","children":[],"count":2,"path":"linux/scripts"},{"name":"security","children":[],"count":1,"path":"linux/security"},{"name":"include","children":[],"count":10,"path":"linux/include"},{"name":"block","children":[],"count":5,"path":"linux/block"},{"name":"drivers","children":[{"name":"clk","children":[],"count":2,"path":"linux/drivers/clk"},{"name":"base","children":[],"count":14,"path":"linux/drivers/base"},{"name":"tty","children":[],"count":2,"path":"linux/drivers/tty"}],"count":39,"path":"linux/drivers"},{"name":"arch","children":[{"name":"arm","children":[],"count":10,"path":"linux/arch/arm"}],"count":10,"path":"linux/arch"}],"count":227,"path":"linux"},{"name":"hpatch","children":[{"name":"SA-IS","children":[],"count":1,"path":"hpatch/SA-IS"},{"name":"libdivsufsort","children":[],"count":3,"path":"hpatch/libdivsufsort"}],"count":10,"path":"hpatch"},{"name":"杂谈","children":[],"count":8,"path":"杂谈"},{"name":"MCU","children":[],"count":23,"path":"MCU"},{"name":"git","children":[],"count":6,"path":"git"},{"name":"LoraWan","children":[{"name":"LoRaWAN标准","children":[{"name":"LoRaWAN-Specification_ZH_CN","children":[{"name":"LoRaWAN-Specification_ZH_CN-190102","children":[{"name":"chapter","children":[],"count":20,"path":"LoraWan/LoRaWAN标准/LoRaWAN-Specification_ZH_CN/LoRaWAN-Specification_ZH_CN-190102/chapter"}],"count":22,"path":"LoraWan/LoRaWAN标准/LoRaWAN-Specification_ZH_CN/LoRaWAN-Specification_ZH_CN-190102"}],"count":22,"path":"LoraWan/LoRaWAN标准/LoRaWAN-Specification_ZH_CN"}],"count":22,"path":"LoraWan/LoRaWAN标准"}],"count":23,"path":"LoraWan"},{"name":"freertos","children":[],"count":1,"path":"freertos"},{"name":"tmc5160","children":[],"count":1,"path":"tmc5160"}],"count":0,"path":""}],
                            initialTreeDepth: -1,
                            top: '5%',
                            bottom: '10%',
                            left: '0%',
                            right: '0%',
                            symbolSize: 15,
                            layout: 'orthogonal',
                            orient: 'TB',
                            itemStyle: {
                                color: '#91CC75',
                                borderColor: '#73C0DE'
                            },
                            label: {
                                position: 'bottom',
                                verticalAlign: 'middle',
                                align: 'center',
                                fontSize: 14,
                                distance: 28,
                                formatter: function(params) {
                                    return params.data.name + (params.data.count ? ' (' + params.data.count + ')' : '');
                                }
                            },
                            leaves: {
                                label: {
                                    position: 'top',
                                    verticalAlign: 'middle',
                                    align: 'center'
                                }
                            },
                            emphasis: {
                                focus: 'descendant'
                            },
                            expandAndCollapse: true
                        }]
                    });

                    treeChart.on('dblclick', function (params) {
                        if (params.data && params.data.path) {
                            window.location.href = '/categories/' + params.data.path;
                        }
                    });
                }
            });
        </script>
    
    <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"react":{"opacity":0.7},"log":false});</script></body></html>