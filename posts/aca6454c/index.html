<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>printk | wdfk-prog的个人博客</title><meta name="author" content="Liya Huang"><meta name="copyright" content="Liya Huang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[TOC] kernel&#x2F;printk.c 内核打印(Kernel Printing) 内核信息输出的基础设施历史与背景这项技术是为了解决什么特定问题而诞生的？kernel&#x2F;printk.c 及其核心功能 printk() 的诞生，是为了解决一个对于操作系统内核来说最根本的问题：如何从一个没有标准输出（stdout）、没有文件系统、甚至可能没有正常运行环境的受限上下文中，可靠地输出诊断信">
<meta property="og:type" content="article">
<meta property="og:title" content="printk">
<meta property="og:url" content="https://wdfk-prog.space/posts/aca6454c/index.html">
<meta property="og:site_name" content="wdfk-prog的个人博客">
<meta property="og:description" content="[TOC] kernel&#x2F;printk.c 内核打印(Kernel Printing) 内核信息输出的基础设施历史与背景这项技术是为了解决什么特定问题而诞生的？kernel&#x2F;printk.c 及其核心功能 printk() 的诞生，是为了解决一个对于操作系统内核来说最根本的问题：如何从一个没有标准输出（stdout）、没有文件系统、甚至可能没有正常运行环境的受限上下文中，可靠地输出诊断信">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wdfk-prog.space/images/covers/10.jpg">
<meta property="article:published_time" content="2025-10-03T01:01:49.000Z">
<meta property="article:modified_time" content="2025-10-03T09:23:28.859Z">
<meta property="article:author" content="Liya Huang">
<meta property="article:tag" content="kernel">
<meta property="article:tag" content="linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wdfk-prog.space/images/covers/10.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "printk",
  "url": "https://wdfk-prog.space/posts/aca6454c/",
  "image": "https://wdfk-prog.space/images/covers/10.jpg",
  "datePublished": "2025-10-03T01:01:49.000Z",
  "dateModified": "2025-10-03T09:23:28.859Z",
  "author": [
    {
      "@type": "Person",
      "name": "Liya Huang",
      "url": "https://github.com/wdfk-prog"
    }
  ]
}</script><link rel="shortcut icon" href="/images/favicon.png"><link rel="canonical" href="https://wdfk-prog.space/posts/aca6454c/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//static.cloudflareinsights.com"/><link rel="preconnect" href="//www.clarity.ms"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxxxxx"/><meta name="baidu-site-verification" content="xxxxxxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-3978542742563797',
  enable_page_level_ads: 'true'
});</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?3c49dd4913ab43efb1bfc8d12b1cded9";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-PF2CVP2PL4"></script><script>window.dataLayer = window.dataLayer || []
function gtag(){dataLayer.push(arguments)}
gtag('js', new Date())
gtag('config', 'G-PF2CVP2PL4')
btf.addGlobalFn('pjaxComplete', () => {
  gtag('config', 'G-PF2CVP2PL4', {'page_path': window.location.pathname})
}, 'google_analytics')
</script><script defer="defer" data-pjax="data-pjax" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;17ff914b5e28493597b7dc19f3356022&quot;}"></script><script>(function(c,l,a,r,i,t,y){
    c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
    t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
    y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
})(window, document, "clarity", "script", "tkaenn1tjv");
</script><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
"https://www.googletagmanager.com/gtm.js?id="+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-MF3J339H');
btf.addGlobalFn('pjaxComplete', () => {
  dataLayer.push({'event': 'pjaxComplete', 'page_title': document.title, 'page_location': location.href, 'page_path': window.location.pathname})
}, 'google_tag_manager')</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":false,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'printk',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.0.0"><link rel="alternate" href="/atom.xml" title="wdfk-prog的个人博客" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (true) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(/images/subtle-texture.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/avatar.png" onerror="this.onerror=null;this.src='/images/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">414</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">49</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">53</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book-open"></i><span> 页面</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fas fa-quote-left"></i><span> 说说</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 示例</span></a></li></ul></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/songs/"><i class="fa-fw fas fa-music"></i><span> 歌曲</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/images/covers/10.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/my-logo.png" alt="Logo"><span class="site-name">wdfk-prog的个人博客</span></a><a class="nav-page-title" href="/"><span class="site-name">printk</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book-open"></i><span> 页面</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fas fa-quote-left"></i><span> 说说</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 示例</span></a></li></ul></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/songs/"><i class="fa-fw fas fa-music"></i><span> 歌曲</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">printk<a class="post-edit-link" href="null_posts/linux/kernel/printk.md" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-10-03T01:01:49.000Z" title="发表于 2025-10-03 09:01:49">2025-10-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-03T09:23:28.859Z" title="更新于 2025-10-03 17:23:28">2025-10-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/linux/">linux</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/linux/kernel/">kernel</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">39.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>147分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/aca6454c/#post-comment"><span class="gitalk-comment-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;已经过了&quot;,&quot;messageNext&quot;:&quot;自上次更新以来，文章的内容可能已经过时&quot;,&quot;postUpdate&quot;:&quot;2025-10-03 17:23:28&quot;}" hidden></div><p>[TOC]</p>
<h1 id="kernel-printk-c-内核打印-Kernel-Printing-内核信息输出的基础设施"><a href="#kernel-printk-c-内核打印-Kernel-Printing-内核信息输出的基础设施" class="headerlink" title="kernel&#x2F;printk.c 内核打印(Kernel Printing) 内核信息输出的基础设施"></a>kernel&#x2F;printk.c 内核打印(Kernel Printing) 内核信息输出的基础设施</h1><h3 id="历史与背景"><a href="#历史与背景" class="headerlink" title="历史与背景"></a>历史与背景</h3><h4 id="这项技术是为了解决什么特定问题而诞生的？"><a href="#这项技术是为了解决什么特定问题而诞生的？" class="headerlink" title="这项技术是为了解决什么特定问题而诞生的？"></a>这项技术是为了解决什么特定问题而诞生的？</h4><p><code>kernel/printk.c</code> 及其核心功能 <code>printk()</code> 的诞生，是为了解决一个对于操作系统内核来说最根本的问题：<strong>如何从一个没有标准输出（stdout）、没有文件系统、甚至可能没有正常运行环境的受限上下文中，可靠地输出诊断信息。</strong></p>
<p>用户空间的程序可以简单地使用 <code>printf()</code> 将信息打印到终端，但内核无法这样做。内核是所有用户空间程序运行的基础，它需要一个独立于任何用户进程的日志记录机制，以应对以下场景：</p>
<ol>
<li><strong>系统启动早期</strong>：在 <code>init</code> 进程启动之前，甚至在控制台驱动初始化之前，就需要有方法来报告硬件探测、内存初始化等关键步骤的状态。</li>
<li><strong>中断和异常上下文</strong>：当内核正在处理一个硬件中断或CPU异常时，它处于一个不能睡眠、不能调用大部分内核函数的受限上下文中。此时需要一个足够安全、不会导致死锁的打印函数。</li>
<li><strong>系统崩溃（Kernel Panic）</strong>：当系统遭遇无法恢复的致命错误时，<code>printk</code> 通常是内核在“死亡”前留下最后“遗言”的唯一方式，这些信息对于事后分析崩溃原因至关重要。</li>
<li><strong>常规诊断与调试</strong>：为内核开发者和系统管理员提供一个标准的、无处不在的接口来记录驱动程序的状态、警告和错误信息。</li>
</ol>
<h4 id="它的发展经历了哪些重要的里程碑或版本迭代？"><a href="#它的发展经历了哪些重要的里程碑或版本迭代？" class="headerlink" title="它的发展经历了哪些重要的里程碑或版本迭代？"></a>它的发展经历了哪些重要的里程碑或版本迭代？</h4><p><code>printk</code> 是内核最古老、最核心的组件之一，其发展历程反映了内核自身的成熟过程。</p>
<ul>
<li><strong>基本实现</strong>：最初的 <code>printk</code> 非常简单，可能只是直接将字符写入一个硬编码的串行端口。</li>
<li><strong>环形缓冲区（Ring Buffer）的引入</strong>：这是一个决定性的里程碑。内核实现了一个固定大小的内存环形缓冲区（log buffer），<code>printk</code> 将消息写入此缓冲区，而不是直接发送到硬件。这实现了<strong>生产者（<code>printk</code>调用者）和消费者（控制台驱动）的解耦</strong>。即使没有活动的控制台，消息也能被保存下来，供日后通过 <code>dmesg</code> 命令读取。</li>
<li><strong>日志级别（Log Levels）</strong>：引入了 <code>KERN_EMERG</code>, <code>KERN_INFO</code> 等日志级别。这允许根据消息的重要性进行过滤，例如，可以配置控制台只显示 <code>KERN_WARNING</code> 及以上级别的严重消息。</li>
<li><strong>控制台抽象（Console Abstraction）</strong>：内核创建了 <code>struct console</code> 抽象层。任何可以显示字符的驱动（如串行端口驱动 <code>ttyS</code>、VGA文本模式驱动 <code>fgconsole</code>、网络控制台 <code>netconsole</code>）都可以将自己注册为一个“控制台”。当 <code>printk</code> 唤醒消费者时，所有注册的活动控制台都会从环形缓冲区中读取并显示新消息。</li>
<li><strong>并发与性能优化</strong>：在多核（SMP）系统上，多个CPU可能同时调用 <code>printk</code>。为了处理并发，引入了自旋锁 (<code>logbuf_lock</code>)。后续为了减少锁竞争，又引入了更复杂的机制，如 per-CPU 缓冲区，以提高性能。</li>
<li><strong>速率限制（Rate Limiting）</strong>：为了防止有缺陷的驱动程序疯狂打印日志（log flood）导致系统性能下降和日志被冲刷，内核引入了 <code>printk_ratelimit()</code> 机制。</li>
<li><strong>结构化与字典压缩</strong>：较新的内核版本正在尝试引入结构化日志和字典压缩技术，以减少日志的体积，并使其更易于被机器解析。</li>
</ul>
<h4 id="目前该技术的社区活跃度和主流应用情况如何？"><a href="#目前该技术的社区活跃度和主流应用情况如何？" class="headerlink" title="目前该技术的社区活跃度和主流应用情况如何？"></a>目前该技术的社区活跃度和主流应用情况如何？</h4><p><code>printk</code> 是Linux内核中<strong>最基础、最稳定、使用最广泛</strong>的功能，没有之一。</p>
<ul>
<li><strong>主流应用</strong>：它是所有内核代码（核心、驱动、文件系统等）输出日志信息的<strong>标准方式</strong>。<code>dmesg</code> 命令是每个Linux系统管理员必备的诊断工具，其内容就直接来自 <code>printk</code> 的环形缓冲区。<code>journald</code>, <code>rsyslog</code> 等用户空间日志服务也会从内核读取 <code>printk</code> 的输出。它是内核开发“Hello, World!”的第一步。</li>
</ul>
<h3 id="核心原理与设计"><a href="#核心原理与设计" class="headerlink" title="核心原理与设计"></a>核心原理与设计</h3><h4 id="它的核心工作原理是什么？"><a href="#它的核心工作原理是什么？" class="headerlink" title="它的核心工作原理是什么？"></a>它的核心工作原理是什么？</h4><p><code>printk</code> 的工作流程可以概括为“生产者-消费者”模型：</p>
<ol>
<li><p><strong>生产者（<code>printk</code> 调用）</strong>：</p>
<ul>
<li>内核代码调用 <code>printk(KERN_INFO &quot;Device initialized with IRQ %d\n&quot;, irq);</code>。</li>
<li>该函数首先会解析格式化字符串和参数，生成最终的日志消息。</li>
<li>它会为消息添加一个前缀，包含日志级别、时间戳等元数据。</li>
<li>然后，它会获取保护环形缓冲区的锁（<code>logbuf_lock</code>）。</li>
<li>消息被<strong>原子地</strong>写入到内核的全局环形日志缓冲区 (<code>log_buf</code>) 中。</li>
<li>写入完成后，释放锁。</li>
</ul>
</li>
<li><p><strong>唤醒消费者</strong>：</p>
<ul>
<li>写入新消息后，<code>printk</code> 会唤醒所有已注册的控制台（consoles）。</li>
</ul>
</li>
<li><p><strong>消费者（控制台驱动）</strong>：</p>
<ul>
<li>被唤醒的控制台驱动（例如，串口驱动）会再次获取锁，检查环形缓冲区中是否有自己尚未打印的新消息。</li>
<li>如果有，它会读取这些消息，并将其输出到它所管理的物理硬件上（如通过串口发送出去，或显示在屏幕上）。</li>
</ul>
</li>
<li><p><strong>用户空间接口</strong>：</p>
<ul>
<li>用户空间程序（如 <code>dmesg</code>）可以通过 <code>/dev/kmsg</code> 接口或 <code>syslog()</code> 系统调用，直接从内核的环形缓冲区中读取所有日志消息，无论它们是否曾被打印到物理控制台。</li>
</ul>
</li>
</ol>
<h4 id="它的主要优势体现在哪些方面？"><a href="#它的主要优势体现在哪些方面？" class="headerlink" title="它的主要优势体现在哪些方面？"></a>它的主要优势体现在哪些方面？</h4><ul>
<li><strong>可靠性和健壮性</strong>：<code>printk</code> 被设计为在内核几乎任何状态下都能工作，包括中断处理、系统恐慌等极端情况。</li>
<li><strong>简单性</strong>：其 <code>printf</code>-like 的API对C程序员来说非常熟悉，使用门槛极低。</li>
<li><strong>解耦设计</strong>：通过环形缓冲区，<code>printk</code> 的调用者无需关心消息最终将如何、以及在何处显示。</li>
<li><strong>通用性</strong>：控制台抽象层使得 <code>printk</code> 的输出可以被重定向到多种物理设备。</li>
</ul>
<h4 id="它存在哪些已知的劣势、局限性或在特定场景下的不适用性？"><a href="#它存在哪些已知的劣势、局限性或在特定场景下的不适用性？" class="headerlink" title="它存在哪些已知的劣势、局限性或在特定场景下的不适用性？"></a>它存在哪些已知的劣势、局限性或在特定场景下的不适用性？</h4><ul>
<li><strong>性能开销</strong>：<code>printk</code> 不是一个“免费”的操作。它涉及字符串格式化、获取全局锁、唤醒其他任务等，开销相对较大。在性能极其敏感的路径（如网络数据包处理路径）中频繁调用 <code>printk</code> 会严重影响系统性能。</li>
<li><strong>日志风暴（Log Flood）</strong>：一个有 bug 的驱动程序可能会在循环中不停地调用 <code>printk</code>，导致环形缓冲区被迅速填满，淹没掉其他有用的信息，并消耗大量CPU。</li>
<li><strong>信息泄露风险</strong>：开发者可能会不慎将内核的敏感信息（如内存地址、数据结构内容）打印出来，构成安全隐患。</li>
<li><strong>非结构化</strong>：传统的 <code>printk</code> 输出是纯文本，不利于自动化工具的解析和分析。</li>
</ul>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><h4 id="在哪些具体的业务或技术场景下，它是首选解决方案？"><a href="#在哪些具体的业务或技术场景下，它是首选解决方案？" class="headerlink" title="在哪些具体的业务或技术场景下，它是首选解决方案？"></a>在哪些具体的业务或技术场景下，它是首选解决方案？</h4><p><code>printk</code> 是用于内核向外界报告<strong>异步事件、状态和错误</strong>的首选和标准方案，特别是对于频率不高的事件。</p>
<ul>
<li><strong>驱动初始化和探测</strong>：报告硬件是否被成功识别，资源（IRQ, I&#x2F;O地址）是否分配成功。</li>
<li><strong>错误和警告报告</strong>：报告硬件故障、非法的操作请求、资源耗尽等异常情况。</li>
<li><strong>重要的状态变更</strong>：例如，网络接口的 <code>UP</code>&#x2F;<code>DOWN</code>，磁盘的挂载&#x2F;卸载。</li>
<li><strong>调试</strong>：在开发和调试阶段，用于追踪代码执行路径和变量值。为了避免在生产环境中产生不必要的输出，通常会使用 <code>pr_debug()</code> 或 <code>dev_dbg()</code> 等宏，它们在内核编译时若未定义<code>DEBUG</code>则会变为空操作。</li>
</ul>
<h4 id="是否有不推荐使用该技术的场景？为什么？"><a href="#是否有不推荐使用该技术的场景？为什么？" class="headerlink" title="是否有不推荐使用该技术的场景？为什么？"></a>是否有不推荐使用该技术的场景？为什么？</h4><ul>
<li><strong>性能敏感的热路径（Hot Path）</strong>：在每秒需要执行数百万次的代码路径中（如网络驱动的核心收发包函数、调度器的核心决策逻辑），应<strong>绝对避免</strong>使用 <code>printk</code>。这种场景应使用<strong>Tracepoints</strong>，它在关闭时几乎没有开销。</li>
<li><strong>高频事件</strong>：不要为每个成功处理的数据包或每个发生的硬件中断调用 <code>printk</code>。</li>
<li><strong>用户空间与内核的数据交换</strong>：<code>printk</code> 是单向的日志通道，不应用作用户空间和内核之间的双向通信机制。应使用 <code>ioctl</code>, <code>netlink</code>, <code>sysfs</code> 或 <code>procfs</code>。</li>
</ul>
<h3 id="对比分析"><a href="#对比分析" class="headerlink" title="对比分析"></a>对比分析</h3><h4 id="请将其-与-其他相似技术-进行详细对比。"><a href="#请将其-与-其他相似技术-进行详细对比。" class="headerlink" title="请将其 与 其他相似技术 进行详细对比。"></a>请将其 与 其他相似技术 进行详细对比。</h4><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>printk</code></th>
<th align="left">Tracepoints &#x2F; <code>trace_printk</code></th>
<th align="left"><code>pr_debug</code> &#x2F; <code>dev_dbg</code></th>
<th align="left"><code>procfs</code>&#x2F;<code>sysfs</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>主要用途</strong></td>
<td align="left"><strong>通用日志记录</strong> (错误、警告、信息)</td>
<td align="left"><strong>高性能追踪和调试</strong></td>
<td align="left"><strong>条件编译的调试打印</strong></td>
<td align="left"><strong>导出状态&#x2F;配置接口</strong></td>
</tr>
<tr>
<td align="left"><strong>性能开销</strong></td>
<td align="left"><strong>中到高</strong>。总是会格式化字符串并尝试获取锁。</td>
<td align="left"><strong>极低</strong> (当关闭时)。开启时，写入高效的二进制追踪缓冲区。</td>
<td align="left"><strong>零</strong> (当<code>DEBUG</code>未定义时)。宏展开为空，代码被编译掉。</td>
<td align="left"><code>read</code>&#x2F;<code>write</code>时才有开销。</td>
</tr>
<tr>
<td align="left"><strong>输出目标</strong></td>
<td align="left">内核环形缓冲区 (<code>dmesg</code>) 和控制台。</td>
<td align="left">ftrace&#x2F;perf 的二进制追踪缓冲区。</td>
<td align="left">与<code>printk</code>相同，但受编译条件限制。</td>
<td align="left">文件系统中的文件。</td>
</tr>
<tr>
<td align="left"><strong>数据格式</strong></td>
<td align="left">非结构化文本。</td>
<td align="left">结构化二进制数据。</td>
<td align="left">非结构化文本。</td>
<td align="left">结构化或非结构化文本。</td>
</tr>
<tr>
<td align="left"><strong>运行时控制</strong></td>
<td align="left">可通过控制台日志级别过滤输出。</td>
<td align="left">可通过 <code>ftrace</code> 接口动态开启&#x2F;关闭&#x2F;过滤。</td>
<td align="left">编译时决定，运行时无法开启。</td>
<td align="left">总是可读&#x2F;写。</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">报告低频、重要的系统事件和错误。</td>
<td align="left">调试性能问题，追踪高频事件。</td>
<td align="left">在开发阶段添加调试代码，发布时移除。</td>
<td align="left">向用户空间暴露内核对象的状态和配置。</td>
</tr>
</tbody></table>
<h1 id="include-linux-kern-levels-h"><a href="#include-linux-kern-levels-h" class="headerlink" title="include&#x2F;linux&#x2F;kern_levels.h"></a>include&#x2F;linux&#x2F;kern_levels.h</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_SOH	<span class="string">&quot;\001&quot;</span>		<span class="comment">/* ASCII Start Of Header */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_SOH_ASCII	<span class="string">&#x27;\001&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_EMERG	KERN_SOH <span class="string">&quot;0&quot;</span>	<span class="comment">/* 系统不可用 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_ALERT	KERN_SOH <span class="string">&quot;1&quot;</span>	<span class="comment">/* 必须立即采取作 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_CRIT	KERN_SOH <span class="string">&quot;2&quot;</span>	<span class="comment">/* 危急情况 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_ERR	KERN_SOH <span class="string">&quot;3&quot;</span>	<span class="comment">/* 错误条件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_WARNING	KERN_SOH <span class="string">&quot;4&quot;</span><span class="comment">/* 警告条件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_NOTICE	KERN_SOH <span class="string">&quot;5&quot;</span>	<span class="comment">/* 正常但严重的情况 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_INFO	KERN_SOH <span class="string">&quot;6&quot;</span>	<span class="comment">/* 信息 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_DEBUG	KERN_SOH <span class="string">&quot;7&quot;</span>	<span class="comment">/* 调试级消息 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_DEFAULT	<span class="string">&quot;&quot;</span>		<span class="comment">/* the default kernel loglevel */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *对日志打印输出的 “continued” 行的注释（仅在没有封闭的 \n 行之后完成）。仅在早期启动期间由 core/arch 代码使用（否则连续行不是 SMP 安全的）.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//text 是连续行的片段</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_CONT	KERN_SOH <span class="string">&quot;c&quot;</span></span></span><br></pre></td></tr></table></figure>

<h1 id="include-linux-printk-h"><a href="#include-linux-printk-h" class="headerlink" title="include&#x2F;linux&#x2F;printk.h"></a>include&#x2F;linux&#x2F;printk.h</h1><h2 id="printk-等级"><a href="#printk-等级" class="headerlink" title="printk 等级"></a>printk 等级</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> pr_emerg(fmt, ...) \</span></span><br><span class="line"><span class="meta">	printk(KERN_EMERG pr_fmt(fmt), ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr_alert(fmt, ...) \</span></span><br><span class="line"><span class="meta">	printk(KERN_ALERT pr_fmt(fmt), ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr_crit(fmt, ...) \</span></span><br><span class="line"><span class="meta">	printk(KERN_CRIT pr_fmt(fmt), ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr_err(fmt, ...) \</span></span><br><span class="line"><span class="meta">	printk(KERN_ERR pr_fmt(fmt), ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr_warn(fmt, ...) \</span></span><br><span class="line"><span class="meta">	printk(KERN_WARNING pr_fmt(fmt), ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr_notice(fmt, ...) \</span></span><br><span class="line"><span class="meta">	printk(KERN_NOTICE pr_fmt(fmt), ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr_info(fmt, ...) \</span></span><br><span class="line"><span class="meta">	printk(KERN_INFO pr_fmt(fmt), ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr_cont(fmt, ...) \</span></span><br><span class="line"><span class="meta">	printk(KERN_CONT fmt, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr_devel(fmt, ...) \</span></span><br><span class="line"><span class="meta">	printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr_devel(fmt, ...) \</span></span><br><span class="line"><span class="meta">	no_printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="printk-get-level-获取日志级别"><a href="#printk-get-level-获取日志级别" class="headerlink" title="printk_get_level 获取日志级别"></a>printk_get_level 获取日志级别</h2><ul>
<li>例如<code>KERN_EMERG</code>输出反馈为”0”</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">printk_get_level</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *buffer)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (buffer[<span class="number">0</span>] == KERN_SOH_ASCII &amp;&amp; buffer[<span class="number">1</span>]) &#123;</span><br><span class="line">		<span class="keyword">switch</span> (buffer[<span class="number">1</span>]) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span> ... <span class="string">&#x27;7&#x27;</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:	<span class="comment">/* KERN_CONT */</span></span><br><span class="line">			<span class="keyword">return</span> buffer[<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="printk-deferred-enter-和printk-deferred-exit"><a href="#printk-deferred-enter-和printk-deferred-exit" class="headerlink" title="printk_deferred_enter 和printk_deferred_exit"></a>printk_deferred_enter 和printk_deferred_exit</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*可被 NMI 抢占。 */</span></span><br><span class="line"><span class="type">void</span> __printk_safe_enter(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	this_cpu_inc(printk_context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 可被 NMI 抢占。 */</span></span><br><span class="line"><span class="type">void</span> __printk_safe_exit(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	this_cpu_dec(printk_context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __printk_deferred_enter(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	cant_migrate();</span><br><span class="line">	__printk_safe_enter();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __printk_deferred_exit(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	cant_migrate();</span><br><span class="line">	__printk_safe_exit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * printk_deferred_enter/exit 宏仅作为某些需要延迟所有 printk 控制台打印的代码路径的 hack 可用。必须在延迟持续时间内禁用中断。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> printk_deferred_enter() __printk_deferred_enter()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> printk_deferred_exit() __printk_deferred_exit()</span></span><br></pre></td></tr></table></figure>

<h1 id="kernel-printk-internal-h"><a href="#kernel-printk-internal-h" class="headerlink" title="kernel&#x2F;printk&#x2F;internal.h"></a>kernel&#x2F;printk&#x2F;internal.h</h1><h2 id="printk-get-console-flush-type-确定使用哪些控制台刷新方法"><a href="#printk-get-console-flush-type-确定使用哪些控制台刷新方法" class="headerlink" title="printk_get_console_flush_type 确定使用哪些控制台刷新方法"></a>printk_get_console_flush_type 确定使用哪些控制台刷新方法</h2><ol>
<li><code>have_nbcon_console</code>和<code>have_legacy_console</code>在<code>register_console</code>时设置</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 确定应在调用方的上下文中使用哪些控制台刷新方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">printk_get_console_flush_type</span><span class="params">(<span class="keyword">struct</span> console_flush_type *ft)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">memset</span>(ft, <span class="number">0</span>, <span class="keyword">sizeof</span>(*ft));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (nbcon_get_default_prio()) &#123; <span class="comment">//获取nbcon 默认优先级</span></span><br><span class="line">	<span class="keyword">case</span> NBCON_PRIO_NORMAL:</span><br><span class="line">		<span class="keyword">if</span> (have_nbcon_console &amp;&amp; !have_boot_console) &#123;</span><br><span class="line">			<span class="keyword">if</span> (printk_kthreads_running)</span><br><span class="line">				ft-&gt;nbcon_offload = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				ft-&gt;nbcon_atomic = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Legacy consoles are flushed directly when possible. */</span></span><br><span class="line">		<span class="keyword">if</span> (have_legacy_console || have_boot_console) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!is_printk_legacy_deferred())</span><br><span class="line">				ft-&gt;legacy_direct = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				ft-&gt;legacy_offload = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> NBCON_PRIO_EMERGENCY:</span><br><span class="line">		<span class="keyword">if</span> (have_nbcon_console &amp;&amp; !have_boot_console)</span><br><span class="line">			ft-&gt;nbcon_atomic = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 如果可能，将直接刷新旧控制台。 */</span></span><br><span class="line">		<span class="keyword">if</span> (have_legacy_console || have_boot_console) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!is_printk_legacy_deferred())</span><br><span class="line">				ft-&gt;legacy_direct = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				ft-&gt;legacy_offload = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> NBCON_PRIO_PANIC:</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * In panic, the nbcon consoles will directly print. But</span></span><br><span class="line"><span class="comment">		 * only allowed if there are no boot consoles.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (have_nbcon_console &amp;&amp; !have_boot_console)</span><br><span class="line">			ft-&gt;nbcon_atomic = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (have_legacy_console || have_boot_console) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * This is the same decision as NBCON_PRIO_NORMAL</span></span><br><span class="line"><span class="comment">			 * except that offloading never occurs in panic.</span></span><br><span class="line"><span class="comment">			 *</span></span><br><span class="line"><span class="comment">			 * Note that console_flush_on_panic() will flush</span></span><br><span class="line"><span class="comment">			 * legacy consoles anyway, even if unsafe.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (!is_printk_legacy_deferred())</span><br><span class="line">				ft-&gt;legacy_direct = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * In panic, if nbcon atomic printing occurs,</span></span><br><span class="line"><span class="comment">			 * the legacy consoles must remain silent until</span></span><br><span class="line"><span class="comment">			 * explicitly allowed.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (ft-&gt;nbcon_atomic &amp;&amp; !legacy_allow_panic_sync)</span><br><span class="line">				ft-&gt;legacy_direct = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		WARN_ON_ONCE(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="printk-info-flags"><a href="#printk-info-flags" class="headerlink" title="printk_info_flags"></a>printk_info_flags</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 单个 printk 记录的标志。*/</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">printk_info_flags</span> &#123;</span></span><br><span class="line">	<span class="comment">/* 始终在控制台上显示，忽略console_loglevel */</span></span><br><span class="line">	LOG_FORCE_CON = <span class="number">1</span>，</span><br><span class="line">	LOG_NEWLINE = <span class="number">2</span>， <span class="comment">/* 以换行符结尾的文本 */</span></span><br><span class="line">	LOG_CONT = <span class="number">8</span>， <span class="comment">/* text 是连续行的片段 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="console-is-usable-检查控制台是否可用"><a href="#console-is-usable-检查控制台是否可用" class="headerlink" title="console_is_usable 检查控制台是否可用"></a>console_is_usable 检查控制台是否可用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 检查给定的控制台当前是否能够并允许打印记录。</span></span><br><span class="line"><span class="comment"> * 请注意，此函数不考虑当前上下文，该上下文也可以在决定是否可以使用 @con 打印记录时发挥作用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">console_is_usable</span><span class="params">(<span class="keyword">struct</span> console *con, <span class="type">short</span> flags, <span class="type">bool</span> use_atomic)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!(flags &amp; CON_ENABLED))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((flags &amp; CON_SUSPENDED))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; CON_NBCON) &#123;</span><br><span class="line">		<span class="comment">/* The write_atomic() callback is optional. */</span></span><br><span class="line">		<span class="keyword">if</span> (use_atomic &amp;&amp; !con-&gt;write_atomic)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * For the !use_atomic case, @printk_kthreads_running is not</span></span><br><span class="line"><span class="comment">		 * checked because the write_thread() callback is also used</span></span><br><span class="line"><span class="comment">		 * via the legacy loop when the printer threads are not</span></span><br><span class="line"><span class="comment">		 * available.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (!con-&gt;write)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Console drivers may assume that per-cpu resources have been</span></span><br><span class="line"><span class="comment">	 * allocated. So unless they&#x27;re explicitly marked as being able to</span></span><br><span class="line"><span class="comment">	 * cope (CON_ANYTIME) don&#x27;t call them until this CPU is officially up.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!cpu_online(raw_smp_processor_id()) &amp;&amp; !(flags &amp; CON_ANYTIME))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="include-linux-console-h"><a href="#include-linux-console-h" class="headerlink" title="include&#x2F;linux&#x2F;console.h"></a>include&#x2F;linux&#x2F;console.h</h1><h2 id="for-each-console-遍历控制台列表"><a href="#for-each-console-遍历控制台列表" class="headerlink" title="for_each_console 遍历控制台列表"></a>for_each_console 遍历控制台列表</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HLIST_HEAD(console_list);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * for_each_console（） - 已注册控制台的迭代器</span></span><br><span class="line"><span class="comment"> * @con：用作循环光标的结构控制台指针</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 控制台列表和 &amp;console.flags 在迭代时是不可变的。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 需要举行console_list_lock。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> for_each_console(con)						\</span></span><br><span class="line"><span class="meta">	lockdep_assert_console_list_lock_held();			\</span></span><br><span class="line"><span class="meta">	hlist_for_each_entry(con, &amp;console_list, node)</span></span><br></pre></td></tr></table></figure>

<h2 id="cons-flags"><a href="#cons-flags" class="headerlink" title="cons_flags"></a>cons_flags</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * enum cons_flags - 常规控制台标志</span></span><br><span class="line"><span class="comment"> * @CON_PRINTBUFFER：由新注册的控制台使用，以避免重复输出已由引导控制台显示或用户空间通过 syslog（） syscall 读取的消息。</span></span><br><span class="line"><span class="comment"> * @CON_CONSDEV：表示控制台驱动程序正在备份</span></span><br><span class="line"><span class="comment"> * /dev/console 的</span></span><br><span class="line"><span class="comment"> * @CON_ENABLED：指示是否允许控制台打印记录。如果为 false，则控制台也不会前进到后面的记录。</span></span><br><span class="line"><span class="comment"> * @CON_BOOT：将控制台驱动程序标记为早期控制台驱动程序，在实际驱动程序可用之前，在启动期间使用该驱动程序。除非使用 “keep_bootcon” 参数，否则当注册真正的控制台驱动程序时，它将自动注销。</span></span><br><span class="line"><span class="comment"> * @CON_ANYTIME：一个用词错误的历史标志，它告诉核心代码，可以在标记为 OFFLINE 的 CPU 上调用旧版 @console：：write 回调。这具有误导性，因为它表明调用回调没有上下文限制。最初的动机是每个 CPU 区域的准备情况。</span></span><br><span class="line"><span class="comment"> * @CON_BRL：表示盲文设备由于明显的原因而免于接收 printk 垃圾邮件。</span></span><br><span class="line"><span class="comment"> * @CON_EXTENDED：控制台支持 /dev/kmesg 的扩展输出格式，需要更大的输出缓冲区。</span></span><br><span class="line"><span class="comment"> * @CON_SUSPENDED：指示控制台是否暂停。如果为 true，则不得调用 printing 回调。</span></span><br><span class="line"><span class="comment"> * @CON_NBCON：控制台可以在旧版样式console_lock约束之外运行。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">cons_flags</span> &#123;</span></span><br><span class="line">	CON_PRINTBUFFER		= BIT(<span class="number">0</span>),</span><br><span class="line">	CON_CONSDEV		= BIT(<span class="number">1</span>),</span><br><span class="line">	CON_ENABLED		= BIT(<span class="number">2</span>),</span><br><span class="line">	CON_BOOT		= BIT(<span class="number">3</span>),</span><br><span class="line">	CON_ANYTIME		= BIT(<span class="number">4</span>),</span><br><span class="line">	CON_BRL			= BIT(<span class="number">5</span>),</span><br><span class="line">	CON_EXTENDED		= BIT(<span class="number">6</span>),</span><br><span class="line">	CON_SUSPENDED		= BIT(<span class="number">7</span>),</span><br><span class="line">	CON_NBCON		= BIT(<span class="number">8</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="console-srcu-read-flags-无锁读取可能已注册控制台的标志"><a href="#console-srcu-read-flags-无锁读取可能已注册控制台的标志" class="headerlink" title="console_srcu_read_flags 无锁读取可能已注册控制台的标志"></a>console_srcu_read_flags 无锁读取可能已注册控制台的标志</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * console_srcu_read_flags - 无锁读取可能已注册控制台的标志</span></span><br><span class="line"><span class="comment"> * @con:	指向控制台结构体的指针，用于读取标志</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 无锁读取 @con-&gt;flags 提供了一致的读取值，因为最多只有一个 CPU 修改 @con-&gt;flags，</span></span><br><span class="line"><span class="comment"> * 并且该 CPU 仅使用读-修改-写操作进行修改。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 需要持有 console_srcu_read_lock，这意味着 @con 可能是一个已注册的控制台。</span></span><br><span class="line"><span class="comment"> * 持有 console_srcu_read_lock 的目的是保证控制台状态有效（CON_SUSPENDED/CON_ENABLED），</span></span><br><span class="line"><span class="comment"> * 并且如果控制台当前正在注销，确保不会运行退出/清理例程。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果调用者持有 console_list_lock 或者 _确定_ @con 未注册且不会被注册，</span></span><br><span class="line"><span class="comment"> * 调用者可以直接读取 @con-&gt;flags。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 上下文：任何上下文。</span></span><br><span class="line"><span class="comment"> * 返回值：@con-&gt;flags 字段的当前值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">short</span> <span class="title function_">console_srcu_read_flags</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> console *con)</span></span><br><span class="line">&#123;</span><br><span class="line">	WARN_ON_ONCE(!console_srcu_read_lock_is_held());</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * READ_ONCE() 与 console_srcu_write_flags() 修改已注册控制台的 @flags 时的</span></span><br><span class="line"><span class="comment">	 * WRITE_ONCE() 相匹配。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> data_race(READ_ONCE(con-&gt;flags));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="console-is-registered-locked-控制台是否已注册"><a href="#console-is-registered-locked-控制台是否已注册" class="headerlink" title="console_is_registered_locked 控制台是否已注册"></a>console_is_registered_locked 控制台是否已注册</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 举行 console_list_lock 时 console_is_registered（） 的变体。 */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">console_is_registered_locked</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> console *con)</span></span><br><span class="line">&#123;</span><br><span class="line">	lockdep_assert_console_list_lock_held();</span><br><span class="line">	<span class="keyword">return</span> !hlist_unhashed(&amp;con-&gt;node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="kernel-printk-printk-ringbuffer-h-内核打印环形缓冲区实现"><a href="#kernel-printk-printk-ringbuffer-h-内核打印环形缓冲区实现" class="headerlink" title="kernel&#x2F;printk&#x2F;printk_ringbuffer.h 内核打印环形缓冲区实现"></a>kernel&#x2F;printk&#x2F;printk_ringbuffer.h 内核打印环形缓冲区实现</h1><h2 id="prb-desc"><a href="#prb-desc" class="headerlink" title="prb_desc"></a>prb_desc</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 描述符状态查询的可能响应。*/</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">desc_state</span> &#123;</span></span><br><span class="line">	desc_miss = <span class="number">-1</span>， <span class="comment">/* ID 不匹配（伪状态） */</span></span><br><span class="line">	desc_reserved = <span class="number">0x0</span>， <span class="comment">/* 保留， 正在由编写器 */</span></span><br><span class="line">	desc_committed = <span class="number">0x1</span>， <span class="comment">/* 由编写器提交，可以重新打开 */</span></span><br><span class="line">	desc_finalized = <span class="number">0x2</span>，<span class="comment">/* 已提交，不允许进一步修改 */</span></span><br><span class="line">	desc_reusable = <span class="number">0x3</span>， <span class="comment">/* 免费，尚未被任何编写器使用 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 描述符：记录的完整元数据。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @state_var：描述符 ID 和描述符状态的按位组合。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">prb_desc</span> &#123;</span></span><br><span class="line">	<span class="comment">//最高几位为desc_state,该变量用于识别ABA问题</span></span><br><span class="line">	<span class="type">atomic_long_t</span>			state_var;	</span><br><span class="line">	<span class="comment">/* 指定数据块的逻辑位置和跨度。 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">prb_data_blk_lpos</span>	<span class="title">text_blk_lpos</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="DEFINE-PRINTKRB-定义-ringbuffer"><a href="#DEFINE-PRINTKRB-定义-ringbuffer" class="headerlink" title="_DEFINE_PRINTKRB 定义 ringbuffer"></a>_DEFINE_PRINTKRB 定义 ringbuffer</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DOC: printk_ringbuffer overview</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 数据结构</span></span><br><span class="line"><span class="comment"> * --------------</span></span><br><span class="line"><span class="comment"> * printk_ringbuffer 由三个内部环形缓冲区组成：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   desc_ring</span></span><br><span class="line"><span class="comment"> *     描述符及其元数据（如序列号、时间戳、日志级别等）的环形缓冲区，</span></span><br><span class="line"><span class="comment"> *     以及关于记录的内部状态信息和逻辑位置，指定其他环形缓冲区中文本字符串的位置。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   text_data_ring</span></span><br><span class="line"><span class="comment"> *     数据块的环形缓冲区。数据块由一个无符号长整型（ID）组成，</span></span><br><span class="line"><span class="comment"> *     它映射到 desc_ring 的索引，后跟记录的文本字符串。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 描述符的内部状态信息是允许读写者无锁同步访问数据的关键元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 实现</span></span><br><span class="line"><span class="comment"> * --------------</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 描述符环</span></span><br><span class="line"><span class="comment"> * ~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="comment"> * 描述符环是一个描述符数组。描述符包含用于跟踪 printk 记录数据的基本元数据，</span></span><br><span class="line"><span class="comment"> * 使用 blk_lpos 结构指向关联的文本数据块（参见下文的“数据环”）。</span></span><br><span class="line"><span class="comment"> * 每个描述符都分配了一个 ID，该 ID 直接映射到描述符数组的索引值，并具有一个状态。</span></span><br><span class="line"><span class="comment"> * ID 和状态按位组合到一个名为 @state_var 的单个描述符字段中，</span></span><br><span class="line"><span class="comment"> * 允许 ID 和状态同步且原子地更新。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 描述符有四种状态：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   reserved</span></span><br><span class="line"><span class="comment"> *     写入者正在修改记录。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   committed</span></span><br><span class="line"><span class="comment"> *     记录及其所有数据已写入。写入者可以重新打开描述符（将其转换回 reserved），</span></span><br><span class="line"><span class="comment"> *     但在 committed 状态下，数据是一致的。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   finalized</span></span><br><span class="line"><span class="comment"> *     记录及其所有数据已完成并可供读取。写入者无法重新打开描述符。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   reusable</span></span><br><span class="line"><span class="comment"> *     记录存在，但其文本和/或元数据可能不再可用。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 查询记录的 @state_var 需要提供要查询的描述符的 ID。</span></span><br><span class="line"><span class="comment"> * 这可能会产生第五种（伪）状态：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   miss</span></span><br><span class="line"><span class="comment"> *     被查询的描述符具有意外的 ID。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 描述符环有一个 @tail_id，包含最旧描述符的 ID，</span></span><br><span class="line"><span class="comment"> * 以及一个 @head_id，包含最新描述符的 ID。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 当需要创建一个新的描述符（并且环已满）时，</span></span><br><span class="line"><span class="comment"> * 通过首先将尾部描述符转换为 reusable 状态，</span></span><br><span class="line"><span class="comment"> * 然后使尾部数据块（对于文本环）无效，直到包括与尾部描述符关联的数据块。</span></span><br><span class="line"><span class="comment"> * 然后推进 @tail_id，接着推进 @head_id。</span></span><br><span class="line"><span class="comment"> * 最后，新描述符的 @state_var 被初始化为新的 ID 和 reserved 状态。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 只有当新的 @tail_id 处于 committed 或 reusable 查询状态时，@tail_id 才能推进。</span></span><br><span class="line"><span class="comment"> * 这使得尾部的有效序列号始终可用。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 描述符最终化</span></span><br><span class="line"><span class="comment"> * ~~~~~~~~~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="comment"> * 当写入者调用提交函数 prb_commit() 时，记录数据完全存储并在环形缓冲区内一致。</span></span><br><span class="line"><span class="comment"> * 然而，写入者可以重新打开该记录，声明独占访问权（如同 prb_reserve()），并修改该记录。</span></span><br><span class="line"><span class="comment"> * 完成后，写入者必须再次提交记录。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 为了使记录可供读者使用（并且也可供写入者回收），它必须被最终化。</span></span><br><span class="line"><span class="comment"> * 最终化的记录不能被重新打开，也永远不会变得“未最终化”。</span></span><br><span class="line"><span class="comment"> * 记录最终化可以在三种不同的场景中发生：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   1) 写入者可以通过调用 prb_final_commit() 而不是 prb_commit() 来同时提交并最终化其记录。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   2) 当一个新记录被保留并且前一个记录通过 prb_commit() 提交时，</span></span><br><span class="line"><span class="comment"> *      该前一个记录会自动最终化。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   3) 当一个记录通过 prb_commit() 提交并且已经存在一个更新的记录时，</span></span><br><span class="line"><span class="comment"> *      被提交的记录会自动最终化。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 数据环</span></span><br><span class="line"><span class="comment"> * ~~~~~~~~~</span></span><br><span class="line"><span class="comment"> * 文本数据环是由数据块组成的字节数组。数据块由 blk_lpos 结构引用，</span></span><br><span class="line"><span class="comment"> * 该结构指向数据块的起始逻辑位置和下一个相邻数据块的起始逻辑位置。</span></span><br><span class="line"><span class="comment"> * 逻辑位置直接映射到字节数组环形缓冲区的索引值。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 每个数据块由一个 ID 和后续的写入者数据组成。</span></span><br><span class="line"><span class="comment"> * ID 是与数据块关联的描述符的标识符。</span></span><br><span class="line"><span class="comment"> * 如果满足以下所有条件，则认为给定的数据块有效：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   1) 与数据块关联的描述符处于 committed 或 finalized 查询状态。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   2) 与数据块关联的描述符中的 blk_lpos 结构引用回同一数据块。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   3) 数据块位于 head/tail 逻辑位置范围内。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果数据块的写入者数据会超出字节数组的末尾，</span></span><br><span class="line"><span class="comment"> * 则仅在逻辑位置存储数据块的 ID，而完整的数据块（ID 和写入者数据）存储在字节数组的开头。</span></span><br><span class="line"><span class="comment"> * 引用的 blk_lpos 将指向 wrap 之前的 ID，</span></span><br><span class="line"><span class="comment"> * 下一个数据块将位于 wrap 之后完整数据块相邻的逻辑位置。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 数据环有一个 @tail_lpos，指向最旧数据块的起始位置，</span></span><br><span class="line"><span class="comment"> * 以及一个 @head_lpos，指向下一个（尚不存在）数据块的逻辑位置。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 当需要创建一个新的数据块（并且环已满）时，</span></span><br><span class="line"><span class="comment"> * 首先通过将其关联的描述符置于 reusable 状态并推动 @tail_lpos 超过它们，</span></span><br><span class="line"><span class="comment"> * 使尾部数据块无效。然后推动 @head_lpos 并将其与一个新的描述符关联。</span></span><br><span class="line"><span class="comment"> * 如果数据块无效，则 @tail_lpos 无法推进超过它。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 信息数组</span></span><br><span class="line"><span class="comment"> * ~~~~~~~~~~</span></span><br><span class="line"><span class="comment"> * printk 记录的一般元数据存储在 printk_info 结构中，</span></span><br><span class="line"><span class="comment"> * 这些结构存储在一个数组中，其元素数量与描述符环相同。</span></span><br><span class="line"><span class="comment"> * 每个信息与描述符环中相同索引的描述符相对应。</span></span><br><span class="line"><span class="comment"> * 信息的有效性通过在加载信息之前和之后评估相应的描述符来确认。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 用法</span></span><br><span class="line"><span class="comment"> * -----</span></span><br><span class="line"><span class="comment"> * 以下是一些简单的示例，演示了写入者和读取者的用法。</span></span><br><span class="line"><span class="comment"> * 对于示例，提供了一个全局环形缓冲区（test_rb）（这不是 printk 使用的实际环形缓冲区）：：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	DEFINE_PRINTKRB(test_rb, 15, 5);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 该环形缓冲区最多允许 32768 条记录（2 ^ 15），</span></span><br><span class="line"><span class="comment"> * 并且文本数据的大小为 1 MiB（2 ^ (15 + 5)）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例写入者代码：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	const char *textstr = &quot;message text&quot;;</span></span><br><span class="line"><span class="comment"> *	struct prb_reserved_entry e;</span></span><br><span class="line"><span class="comment"> *	struct printk_record r;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	// 指定要分配的大小</span></span><br><span class="line"><span class="comment"> *	prb_rec_init_wr(&amp;r, strlen(textstr) + 1);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	if (prb_reserve(&amp;e, &amp;test_rb, &amp;r)) &#123;</span></span><br><span class="line"><span class="comment"> *		snprintf(r.text_buf, r.text_buf_size, &quot;%s&quot;, textstr);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *		r.info-&gt;text_len = strlen(textstr);</span></span><br><span class="line"><span class="comment"> *		r.info-&gt;ts_nsec = local_clock();</span></span><br><span class="line"><span class="comment"> *		r.info-&gt;caller_id = printk_caller_id();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *		// 提交并最终化记录</span></span><br><span class="line"><span class="comment"> *		prb_final_commit(&amp;e);</span></span><br><span class="line"><span class="comment"> *	&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意，还提供了其他写入者函数，用于在记录已提交但尚未最终化时扩展记录。</span></span><br><span class="line"><span class="comment"> * 只要没有保留新记录并且调用者相同，就可以这样做。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例写入者代码（记录扩展）：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *		// 上一个示例的替代部分</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *		r.info-&gt;text_len = strlen(textstr);</span></span><br><span class="line"><span class="comment"> *		r.info-&gt;ts_nsec = local_clock();</span></span><br><span class="line"><span class="comment"> *		r.info-&gt;caller_id = printk_caller_id();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *		// 提交记录（但尚未最终化）</span></span><br><span class="line"><span class="comment"> *		prb_commit(&amp;e);</span></span><br><span class="line"><span class="comment"> *	&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	...</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	// 指定额外的 5 字节文本空间以扩展</span></span><br><span class="line"><span class="comment"> *	prb_rec_init_wr(&amp;r, 5);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	// 尝试扩展，但仅当其不超过 32 字节时</span></span><br><span class="line"><span class="comment"> *	if (prb_reserve_in_last(&amp;e, &amp;test_rb, &amp;r, printk_caller_id(), 32)) &#123;</span></span><br><span class="line"><span class="comment"> *		snprintf(&amp;r.text_buf[r.info-&gt;text_len],</span></span><br><span class="line"><span class="comment"> *			 r.text_buf_size - r.info-&gt;text_len, &quot;hello&quot;);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *		r.info-&gt;text_len += 5;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *		// 提交并最终化记录</span></span><br><span class="line"><span class="comment"> *		prb_final_commit(&amp;e);</span></span><br><span class="line"><span class="comment"> *	&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例读取者代码：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	struct printk_info info;</span></span><br><span class="line"><span class="comment"> *	struct printk_record r;</span></span><br><span class="line"><span class="comment"> *	char text_buf[32];</span></span><br><span class="line"><span class="comment"> *	u64 seq;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	prb_rec_init_rd(&amp;r, &amp;info, &amp;text_buf[0], sizeof(text_buf));</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	prb_for_each_record(0, &amp;test_rb, &amp;seq, &amp;r) &#123;</span></span><br><span class="line"><span class="comment"> *		if (info.seq != seq)</span></span><br><span class="line"><span class="comment"> *			pr_warn(&quot;lost %llu records\n&quot;, info.seq - seq);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *		if (info.text_len &gt; r.text_buf_size) &#123;</span></span><br><span class="line"><span class="comment"> *			pr_warn(&quot;record %llu text truncated\n&quot;, info.seq);</span></span><br><span class="line"><span class="comment"> *			text_buf[r.text_buf_size - 1] = 0;</span></span><br><span class="line"><span class="comment"> *		&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *		pr_info(&quot;%llu: %llu: %s\n&quot;, info.seq, info.ts_nsec,</span></span><br><span class="line"><span class="comment"> *			&amp;text_buf[0]);</span></span><br><span class="line"><span class="comment"> *	&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意，还提供了其他不太方便的读取者函数，以允许复杂的记录访问。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ABA 问题</span></span><br><span class="line"><span class="comment"> * ~~~~~~~~~~</span></span><br><span class="line"><span class="comment"> * 为了帮助避免 ABA 问题，描述符通过 ID（数组索引值与计数数组环的标记位组合）引用，</span></span><br><span class="line"><span class="comment"> * 数据块通过逻辑位置（数组索引值与计数数组环的标记位组合）引用。</span></span><br><span class="line"><span class="comment"> * 然而，在 32 位系统上，标记位的数量相对较小，因此 ABA 事件（至少在理论上）是可能的。</span></span><br><span class="line"><span class="comment"> * 例如，如果在 32 位系统上的 NMI 上下文中发生了 400 万条最大大小（1KiB）的 printk 消息，</span></span><br><span class="line"><span class="comment"> * 中断的上下文将无法识别 32 位整数完全环绕，因此表示与中断上下文期望的不同的数据块。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 为了帮助应对这种可能性，执行了额外的状态检查（例如，即使 set() 足够，也使用 cmpxchg()）。</span></span><br><span class="line"><span class="comment"> * 这些额外的检查已被注释，并希望能够捕获 32 位系统可能遇到的任何 ABA 问题。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 内存屏障</span></span><br><span class="line"><span class="comment"> * ~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="comment"> * 使用了多个内存屏障。为了简化正确性证明和生成点火测试，</span></span><br><span class="line"><span class="comment"> * 与内存屏障相关的代码行（加载、存储和相关的内存屏障）被标记为：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	LMM(function:letter)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注释仅引用“function:letter”部分。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 内存屏障对及其顺序如下：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   desc_reserve:D / desc_reserve:B</span></span><br><span class="line"><span class="comment"> *     推动描述符尾部（id），然后推动描述符头部（id）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   desc_reserve:D / data_push_tail:B</span></span><br><span class="line"><span class="comment"> *     推动数据尾部（lpos），然后设置新的描述符为 reserved（状态）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   desc_reserve:D / desc_push_tail:C</span></span><br><span class="line"><span class="comment"> *     推动描述符尾部（id），然后设置新的描述符为 reserved（状态）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   desc_reserve:D / prb_first_seq:C</span></span><br><span class="line"><span class="comment"> *     推动描述符尾部（id），然后设置新的描述符为 reserved（状态）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   desc_reserve:F / desc_read:D</span></span><br><span class="line"><span class="comment"> *     设置新的描述符 id 和 reserved（状态），然后允许写入者更改</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   data_alloc:A (或 data_realloc:A) / desc_read:D</span></span><br><span class="line"><span class="comment"> *     设置旧描述符为 reusable（状态），然后修改新的数据块区域</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   data_alloc:A (或 data_realloc:A) / data_push_tail:B</span></span><br><span class="line"><span class="comment"> *     推动数据尾部（lpos），然后修改新的数据块区域</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   _prb_commit:B / desc_read:B</span></span><br><span class="line"><span class="comment"> *     存储写入者更改，然后设置新的描述符为 committed（状态）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   desc_reopen_last:A / _prb_commit:B</span></span><br><span class="line"><span class="comment"> *     设置描述符为 reserved（状态），然后读取描述符数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   _prb_commit:B / desc_reserve:D</span></span><br><span class="line"><span class="comment"> *     设置新的描述符为 committed（状态），然后检查描述符头部（id）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   data_push_tail:D / data_push_tail:A</span></span><br><span class="line"><span class="comment"> *     设置描述符为 reusable（状态），然后推动数据尾部（lpos）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   desc_push_tail:B / desc_reserve:D</span></span><br><span class="line"><span class="comment"> *     设置描述符为 reusable（状态），然后推动描述符尾部（id）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   desc_update_last_finalized:A / desc_last_finalized_seq:A</span></span><br><span class="line"><span class="comment"> *     存储最终化记录，然后设置新的最高最终化序列号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 描述符引导</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 描述符数组经过最小初始化，以允许读取器和写入器立即使用。描述符数组初始化必须满足的要求：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 要求1</span></span><br><span class="line"><span class="comment"> * 尾部必须指向现有的（已提交或可重用的）描述符。这是 prb_first_seq（） 的实现所必需的。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 要求2</span></span><br><span class="line"><span class="comment"> * 读取器必须看到 ringbuffer 最初是空的。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 要求3</span></span><br><span class="line"><span class="comment"> * 写入器保留的第一条记录被分配了序列号 0。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 为了满足 Req1，尾部最初指向一个最小初始化的描述符（没有数据块，即数据块的 lpos @begin和 @next 值设置为 FAILED_LPOS 的无数据）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 为了满足 Req2，初始尾部描述符被初始化为可重用状态。读者将可重用的描述符识别为现有记录，但会跳过它们。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 为了满足 Req3，数组中的最后一个描述符用作初始头（和尾）描述符。这允许写入器（head 1）保留的第一条记录成为数组中的第一个描述符。（只有数组中的第一个 Descriptor 可以具有有效的序列号 0。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 首次保留描述符时，会为其分配一个序列号，其中包含数组索引的值。可以识别“首次保留”描述符，因为它的序列号为 0，但索引没有 0。（只有数组中的第一个 Descriptor 可以具有有效的序列号 0。在第一次预留之后，所有未来的预留（回收）都只涉及按数组计数递增序列号。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 黑客 #1</span></span><br><span class="line"><span class="comment"> * 仅数组中的第一个描述符允许序列号为 0。在这种情况下，无法识别它是第一次保留（设置为索引值）还是之前已保留（按数组计数递增）。这是通过在保留数组中的第一个描述符时_always_ 按数组计数递增序列号来处理的。为了满足 Req3，数组中第一个描述符的序列号被初始化为减去数组计数。然后，在第一次保留时，它递增为 0，从而满足 Req3。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 黑客 #2</span></span><br><span class="line"><span class="comment"> * prb_first_seq（） 可以由读取器随时调用，以检索尾部描述符的序列号。但是，由于 Req2 和 Req3，最初没有记录来报告其序列号（序列号为 u64，并且不小于 0）。为了处理此问题，初始尾部描述符的序列号初始化为 0。从技术上讲，这是不正确的，因为没有序列号为 0 的记录（目前），并且尾部描述符不是数组中的第一个描述符。但它允许 prb_read_valid（） 始终正确报告 _any_ 给定序列号的记录的存在。当第一次推送 tail 时，Bootstrapping 完成，从而最终指向 writer 保留的第一个 Descriptors，该 Descriptors 具有分配的序列号 0。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _DATA_SIZE(sz_bits)	(1UL &lt;&lt; (sz_bits))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _DESCS_COUNT(ct_bits)	(1U &lt;&lt; (ct_bits))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_SV_BITS		BITS_PER_LONG						<span class="comment">//描述符状态变量的位数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_FLAGS_SHIFT	(DESC_SV_BITS - 2)					<span class="comment">//FLAG所占的位数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_FLAGS_MASK		(3UL &lt;&lt; DESC_FLAGS_SHIFT)			<span class="comment">//FLAGES掩码</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_STATE(sv)		(3UL &amp; (sv &gt;&gt; DESC_FLAGS_SHIFT))	<span class="comment">//描述符状态 FLAG</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_SV(id, state)	(((unsigned long)state &lt;&lt; DESC_FLAGS_SHIFT) | id)	<span class="comment">//描述符状态变量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_ID_MASK		(~DESC_FLAGS_MASK)					<span class="comment">//描述符 ID 掩码</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_ID(sv)		((sv) &amp; DESC_ID_MASK)					<span class="comment">//描述符 ID</span></span></span><br><span class="line"><span class="comment">/* 数据环的初始@head_lpos和@tail_lpos。它在索引处</span></span><br><span class="line"><span class="comment"> * 0，并且 LPOS 值在第一次换行时将溢出 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLK0_LPOS(sz_bits)	(-(_DATA_SIZE(sz_bits)))	<span class="comment">//数据块的逻辑位置</span></span></span><br><span class="line"><span class="comment">/* 0. descbits = 5</span></span><br><span class="line"><span class="comment">1. 初始化时, head_id = DESC0_ID(descbits) = DESC_ID(-(_DESCS_COUNT(ct_bits) + 1)) = DESC_ID(-(1U &lt;&lt; (ct_bits)) + 1)</span></span><br><span class="line"><span class="comment"> = DESC_ID(-33) = 0b00011111 = 刚好是描述符数组的最后一个索引处的 ID。</span></span><br><span class="line"><span class="comment">初始化=这个值,那么第一次进入+1刚好从0开始,第二次进入+1就会溢出到0xFFFFFFFFF</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC0_ID(ct_bits)	DESC_ID(-(_DESCS_COUNT(ct_bits) + 1))	<span class="comment">//刚好是描述符数组的最后一个索引处的 ID。</span></span></span><br><span class="line"><span class="comment">/* 这个设置了最高位的状态默认为无使用 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC0_SV(ct_bits)	DESC_SV(DESC0_ID(ct_bits), desc_reusable)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 特殊数据块逻辑位置值（适用于 @prb_desc.text_blk_lpos 的字段）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - Bit0 用于标识记录是否没有数据块。（在 LPOS_DATALESS（） 宏中实现。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - Bit1 指定没有数据块的原因。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 由于数据块的元数据和对齐填充，这些特殊值永远不可能是真正的 lpos 值。（有关详细信息，请参阅 to_blk_size（）.）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FAILED_LPOS		0x1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EMPTY_LINE_LPOS		0x3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FAILED_BLK_LPOS	\</span></span><br><span class="line"><span class="meta">&#123;				\</span></span><br><span class="line"><span class="meta">	.begin	= FAILED_LPOS,	\</span></span><br><span class="line"><span class="meta">	.next	= FAILED_LPOS,	\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">- 使用外部文本数据缓冲区定义 ringbuffer。与 DEFINE_PRINTKRB（） 相同，但需要为文本数据指定外部缓冲区。 </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：指定的外部缓冲区的大小必须为：</span></span><br><span class="line"><span class="comment"> * 2 ^ （描述平均文本位）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _DEFINE_PRINTKRB(name, descbits, avgtextbits, text_buf)			\</span></span><br><span class="line"><span class="meta">static struct prb_desc _##name##_descs[_DESCS_COUNT(descbits)] = &#123;				\</span></span><br><span class="line"><span class="meta">	<span class="comment">/* 初始头和尾 */</span>								\</span></span><br><span class="line"><span class="meta">	[_DESCS_COUNT(descbits) - 1] = &#123;							\</span></span><br><span class="line"><span class="meta">		<span class="comment">/* 可 重用 */</span>									\</span></span><br><span class="line"><span class="meta">		.state_var	= ATOMIC_INIT(DESC0_SV(descbits)),				\</span></span><br><span class="line"><span class="meta">		<span class="comment">/* 无关联数据块 */</span>							\</span></span><br><span class="line"><span class="meta">		.text_blk_lpos	= FAILED_BLK_LPOS,						\</span></span><br><span class="line"><span class="meta">	&#125;,											\</span></span><br><span class="line"><span class="meta">&#125;;												\	</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">printk_info</span> _##<span class="title">name</span>##_<span class="title">infos</span>[_<span class="title">DESCS_COUNT</span>(<span class="title">descbits</span>)] =</span> &#123;				\</span><br><span class="line">	<span class="comment">/* 这将是写入器保留的第一条记录 */</span>				\</span><br><span class="line">	[<span class="number">0</span>] = &#123;											\</span><br><span class="line">		<span class="comment">/* 将在第一次预订时递增为 0 */</span>				\</span><br><span class="line">		.seq = -(u64)_DESCS_COUNT(descbits),						\</span><br><span class="line">	&#125;,											\</span><br><span class="line">	<span class="comment">/* 初始头和尾 */</span>								\</span><br><span class="line">	[_DESCS_COUNT(descbits) - <span class="number">1</span>] = &#123;							\</span><br><span class="line">		<span class="comment">/* 报告 Bootstrap 阶段的第一个 Seq 值 */</span>			\</span><br><span class="line">		.seq = <span class="number">0</span>,									\</span><br><span class="line">	&#125;,											\</span><br><span class="line">&#125;;												\</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">printk_ringbuffer</span> <span class="title">name</span> =</span> &#123;							\</span><br><span class="line">	.desc_ring = &#123;										\</span><br><span class="line">		.count_bits	= descbits,							\</span><br><span class="line">		.descs		= &amp;_#<span class="meta">#name##_descs[0],						\</span></span><br><span class="line"><span class="meta">		.infos		= &amp;_##name##_infos[0],						\</span></span><br><span class="line"><span class="meta">		.head_id	= ATOMIC_INIT(DESC0_ID(descbits)),				\</span></span><br><span class="line"><span class="meta">		.tail_id	= ATOMIC_INIT(DESC0_ID(descbits)),				\</span></span><br><span class="line"><span class="meta">		.last_finalized_seq = ATOMIC_INIT(0),						\</span></span><br><span class="line"><span class="meta">	&#125;,											\</span></span><br><span class="line"><span class="meta">	.text_data_ring = &#123;									\</span></span><br><span class="line"><span class="meta">		.size_bits	= (avgtextbits) + (descbits),					\</span></span><br><span class="line"><span class="meta">		.data		= text_buf,							\</span></span><br><span class="line"><span class="meta">		.head_lpos	= ATOMIC_LONG_INIT(BLK0_LPOS((avgtextbits) + (descbits))),	\</span></span><br><span class="line"><span class="meta">		.tail_lpos	= ATOMIC_LONG_INIT(BLK0_LPOS((avgtextbits) + (descbits))),	\</span></span><br><span class="line"><span class="meta">	&#125;,											\</span></span><br><span class="line"><span class="meta">	.fail			= ATOMIC_LONG_INIT(0),						\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="kernel-printk-printk-ringbuffer-c-内核打印环形缓冲区实现"><a href="#kernel-printk-printk-ringbuffer-c-内核打印环形缓冲区实现" class="headerlink" title="kernel&#x2F;printk&#x2F;printk_ringbuffer.c 内核打印环形缓冲区实现"></a>kernel&#x2F;printk&#x2F;printk_ringbuffer.c 内核打印环形缓冲区实现</h1><h2 id="macros"><a href="#macros" class="headerlink" title="macros"></a>macros</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DATA_SIZE(data_ring)		_DATA_SIZE((data_ring)-&gt;size_bits)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DATA_SIZE_MASK(data_ring)	(DATA_SIZE(data_ring) - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESCS_COUNT(desc_ring)		_DESCS_COUNT((desc_ring)-&gt;count_bits)	<span class="comment">//获取</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESCS_COUNT_MASK(desc_ring)	(DESCS_COUNT(desc_ring) - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Determine the data array index from a logical position. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DATA_INDEX(data_ring, lpos)	((lpos) &amp; DATA_SIZE_MASK(data_ring))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Determine the desc array index from an ID or sequence number. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_INDEX(desc_ring, n)	((n) &amp; DESCS_COUNT_MASK(desc_ring))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 确定数据数组已环绕的次数。*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DATA_WRAPS(data_ring, lpos)	((lpos) &gt;&gt; (data_ring)-&gt;size_bits)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Determine if a logical position refers to a data-less block. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LPOS_DATALESS(lpos)		((lpos) &amp; 1UL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLK_DATALESS(blk)		(LPOS_DATALESS((blk)-&gt;begin) &amp;&amp; \</span></span><br><span class="line"><span class="meta">					 LPOS_DATALESS((blk)-&gt;next))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取当前环绕的索引 0 处的逻辑位置. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DATA_THIS_WRAP_START_LPOS(data_ring, lpos) \</span></span><br><span class="line"><span class="meta">((lpos) &amp; ~DATA_SIZE_MASK(data_ring))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取与给定 ID 相同的上一个环绕索引的 ID。 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_ID_PREV_WRAP(desc_ring, id) \</span></span><br><span class="line"><span class="meta">DESC_ID((id) - DESCS_COUNT(desc_ring))</span></span><br></pre></td></tr></table></figure>

<h2 id="desc-reopen-last-尝试将最新的描述符从-committed-转换回-reserved"><a href="#desc-reopen-last-尝试将最新的描述符从-committed-转换回-reserved" class="headerlink" title="desc_reopen_last 尝试将最新的描述符从 committed 转换回 reserved"></a>desc_reopen_last 尝试将最新的描述符从 committed 转换回 reserved</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 尝试将最新的描述符从 committed 转换回 reserved，以便写入器可以再次修改记录。仅当描述符尚未最终确定且提供的 @caller_id 匹配时，才有可能执行此作。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> prb_desc *<span class="title function_">desc_reopen_last</span><span class="params">(<span class="keyword">struct</span> prb_desc_ring *desc_ring,</span></span><br><span class="line"><span class="params">					 u32 caller_id, <span class="type">unsigned</span> <span class="type">long</span> *id_out)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> prev_state_val;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">desc_state</span> <span class="title">d_state</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">prb_desc</span> <span class="title">desc</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">prb_desc</span> *<span class="title">d</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> id;</span><br><span class="line">	u32 cid;</span><br><span class="line"></span><br><span class="line">	id = atomic_long_read(&amp;desc_ring-&gt;head_id);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * To reduce unnecessarily reopening, first check if the descriptor</span></span><br><span class="line"><span class="comment">	 * state and caller ID are correct.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	d_state = desc_read(desc_ring, id, &amp;desc, <span class="literal">NULL</span>, &amp;cid);</span><br><span class="line">	<span class="keyword">if</span> (d_state != desc_committed || cid != caller_id)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	d = to_desc(desc_ring, id);</span><br><span class="line"></span><br><span class="line">	prev_state_val = DESC_SV(id, desc_committed);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!atomic_long_try_cmpxchg(&amp;d-&gt;state_var, &amp;prev_state_val,</span><br><span class="line">			DESC_SV(id, desc_reserved))) &#123; <span class="comment">/* LMM(desc_reopen_last:A) */</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	*id_out = id;</span><br><span class="line">	<span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="prb-reserve-in-last"><a href="#prb-reserve-in-last" class="headerlink" title="prb_reserve_in_last"></a>prb_reserve_in_last</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">prb_reserve_in_last</span><span class="params">(<span class="keyword">struct</span> prb_reserved_entry *e, <span class="keyword">struct</span> printk_ringbuffer *rb,</span></span><br><span class="line"><span class="params">			 <span class="keyword">struct</span> printk_record *r, u32 caller_id, <span class="type">unsigned</span> <span class="type">int</span> max_size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">prb_desc_ring</span> *<span class="title">desc_ring</span> =</span> &amp;rb-&gt;desc_ring;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">printk_info</span> *<span class="title">info</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> data_size;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">prb_desc</span> *<span class="title">d</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> id;</span><br><span class="line"></span><br><span class="line">	local_irq_save(e-&gt;irqflags);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 将最新的描述符转换回 reserved 状态. */</span></span><br><span class="line">	d = desc_reopen_last(desc_ring, caller_id, &amp;id);</span><br><span class="line">	<span class="keyword">if</span> (!d) &#123;</span><br><span class="line">		local_irq_restore(e-&gt;irqflags);</span><br><span class="line">		<span class="keyword">goto</span> fail_reopen;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 现在 writer 拥有独占访问权限：LMM（prb_reserve_in_last：A）*/</span></span><br><span class="line"></span><br><span class="line">	info = to_info(desc_ring, id);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 在此处设置 @e 字段，以便从现在开始出现任何故障时可以使用 prb_commit（）。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	e-&gt;rb = rb;</span><br><span class="line">	e-&gt;id = id;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * desc_reopen_last() checked the caller_id, but there was no</span></span><br><span class="line"><span class="comment">	 * exclusive access at that point. The descriptor may have</span></span><br><span class="line"><span class="comment">	 * changed since then.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (caller_id != info-&gt;caller_id)</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (BLK_DATALESS(&amp;d-&gt;text_blk_lpos)) &#123;	<span class="comment">//数据块没有数据</span></span><br><span class="line">		<span class="keyword">if</span> (WARN_ON_ONCE(info-&gt;text_len != <span class="number">0</span>)) &#123;</span><br><span class="line">			pr_warn_once(<span class="string">&quot;wrong text_len value (%hu, expecting 0)\n&quot;</span>,</span><br><span class="line">				     info-&gt;text_len);</span><br><span class="line">			info-&gt;text_len = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!data_check_size(&amp;rb-&gt;text_data_ring, r-&gt;text_buf_size))</span><br><span class="line">			<span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (r-&gt;text_buf_size &gt; max_size)</span><br><span class="line">			<span class="keyword">goto</span> fail;</span><br><span class="line">		<span class="comment">// 分配新的数据块</span></span><br><span class="line">		r-&gt;text_buf = data_alloc(rb, r-&gt;text_buf_size,</span><br><span class="line">					 &amp;d-&gt;text_blk_lpos, id);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;<span class="comment">//数据块有数据</span></span><br><span class="line">		<span class="comment">//获取数据块的大小</span></span><br><span class="line">		<span class="keyword">if</span> (!get_data(&amp;rb-&gt;text_data_ring, &amp;d-&gt;text_blk_lpos, &amp;data_size))</span><br><span class="line">			<span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 增加缓冲区大小以包含原始大小。如果元数据 （@text_len） 不合理，请使用完整的数据块大小。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (WARN_ON_ONCE(info-&gt;text_len &gt; data_size)) &#123;</span><br><span class="line">			pr_warn_once(<span class="string">&quot;wrong text_len value (%hu, expecting &lt;=%u)\n&quot;</span>,</span><br><span class="line">				     info-&gt;text_len, data_size);</span><br><span class="line">			info-&gt;text_len = data_size;</span><br><span class="line">		&#125;</span><br><span class="line">		r-&gt;text_buf_size += info-&gt;text_len;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!data_check_size(&amp;rb-&gt;text_data_ring, r-&gt;text_buf_size))</span><br><span class="line">			<span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (r-&gt;text_buf_size &gt; max_size)</span><br><span class="line">			<span class="keyword">goto</span> fail;</span><br><span class="line">		<span class="comment">// 重新分配数据块</span></span><br><span class="line">		r-&gt;text_buf = data_realloc(rb, r-&gt;text_buf_size,</span><br><span class="line">					   &amp;d-&gt;text_blk_lpos, id);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (r-&gt;text_buf_size &amp;&amp; !r-&gt;text_buf)</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">	r-&gt;info = info;</span><br><span class="line"></span><br><span class="line">	e-&gt;text_space = space_used(&amp;rb-&gt;text_data_ring, &amp;d-&gt;text_blk_lpos);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">fail:</span><br><span class="line">	prb_commit(e);</span><br><span class="line">	<span class="comment">/* prb_commit() re-enabled interrupts. */</span></span><br><span class="line">fail_reopen:</span><br><span class="line">	<span class="comment">/* 向调用方明确表示重新预留失败。 */</span></span><br><span class="line">	<span class="built_in">memset</span>(r, <span class="number">0</span>, <span class="keyword">sizeof</span>(*r));</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="to-blk-size-分配对齐的区域并添加指针所需的空间"><a href="#to-blk-size-分配对齐的区域并添加指针所需的空间" class="headerlink" title="to_blk_size 分配对齐的区域并添加指针所需的空间"></a>to_blk_size 分配对齐的区域并添加指针所需的空间</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Increase the data size to account for data block meta data plus any</span></span><br><span class="line"><span class="comment"> * padding so that the adjacent data block is aligned on the ID size.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">to_blk_size</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">prb_data_block</span> *<span class="title">db</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	size += <span class="keyword">sizeof</span>(*db);</span><br><span class="line">	size = ALIGN(size, <span class="keyword">sizeof</span>(db-&gt;id));</span><br><span class="line">	<span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="data-check-size-检查数据大小是否可以存入"><a href="#data-check-size-检查数据大小是否可以存入" class="headerlink" title="data_check_size 检查数据大小是否可以存入"></a>data_check_size 检查数据大小是否可以存入</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 储备金大小的健全性检查器。ringbuffer 代码假定数据块不超过 ringbuffer 可容纳的最大可能大小。此函数提供基本大小检查，以便假设是安全的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">data_check_size</span><span class="params">(<span class="keyword">struct</span> prb_data_ring *data_ring, <span class="type">unsigned</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">prb_data_block</span> *<span class="title">db</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 确保对齐填充大小可能适合数据数组。尽可能大的数据块仍必须至少为下一个数据块的 ID 留出空间。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	size = to_blk_size(size);	<span class="comment">//分配对齐的块区域并添加指针所需的空间</span></span><br><span class="line">	<span class="keyword">if</span> (size &gt; DATA_SIZE(data_ring) <span class="comment">//_DATA_SIZE((data_ring)-&gt;size_bits)</span></span><br><span class="line">	- <span class="keyword">sizeof</span>(db-&gt;id))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="get-desc-state-查询描述符的状态。"><a href="#get-desc-state-查询描述符的状态。" class="headerlink" title="get_desc_state 查询描述符的状态。"></a>get_desc_state 查询描述符的状态。</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 查询描述符的状态。 */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">enum</span> desc_state <span class="title function_">get_desc_state</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> id,</span></span><br><span class="line"><span class="params">				      <span class="type">unsigned</span> <span class="type">long</span> state_val)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (id != DESC_ID(state_val))</span><br><span class="line">		<span class="keyword">return</span> desc_miss;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> DESC_STATE(state_val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="desc-read-获取指定描述符的副本并返回其查询状态"><a href="#desc-read-获取指定描述符的副本并返回其查询状态" class="headerlink" title="desc_read 获取指定描述符的副本并返回其查询状态"></a>desc_read 获取指定描述符的副本并返回其查询状态</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 获取指定描述符的副本并返回其查询状态。</span></span><br><span class="line"><span class="comment"> * 如果 Descriptor 处于不一致状态（miss 或 reserved），</span></span><br><span class="line"><span class="comment"> * 则调用方只能期望 Descriptor 的 @state_var 字段有效。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 可以选择性地检索序列号和caller_id。与所有非state_var数据一样，它们仅在描述符处于一致状态时有效。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">enum</span> desc_state <span class="title function_">desc_read</span><span class="params">(<span class="keyword">struct</span> prb_desc_ring *desc_ring,</span></span><br><span class="line"><span class="params">				 <span class="type">unsigned</span> <span class="type">long</span> id, <span class="keyword">struct</span> prb_desc *desc_out,</span></span><br><span class="line"><span class="params">				 u64 *seq_out, u32 *caller_id_out)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">printk_info</span> *<span class="title">info</span> =</span> to_info(desc_ring, id);	<span class="comment">//&amp;desc_ring-&gt;infos[id];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">prb_desc</span> *<span class="title">desc</span> =</span> to_desc(desc_ring, id);		<span class="comment">//&amp;desc_ring-&gt;descs[id];</span></span><br><span class="line">	<span class="type">atomic_long_t</span> *state_var = &amp;desc-&gt;state_var;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">desc_state</span> <span class="title">d_state</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> state_val;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 检查描述符状态。 */</span></span><br><span class="line">	state_val = atomic_long_read(state_var); <span class="comment">/* LMM(desc_read:A) */</span></span><br><span class="line">	d_state = get_desc_state(id, state_val);</span><br><span class="line">	<span class="keyword">if</span> (d_state == desc_miss || d_state == desc_reserved) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 描述符处于不一致状态。至少设置 @state_var，以便调用方可以看到不一致状态的详细信息。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 保证在复制描述符内容之前加载状态。这样可以避免复制可能不适用于 Descriptor 状态的过时 Descriptor 内容。这与 _prb_commit：B 配对。</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 记忆障碍参与：</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 如果 desc_read：A 读取 _prb_commit：B，则 desc_read：C 读取 _prb_commit：A。</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *依赖：</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * WMB 从 _prb_commit：A 到 _prb_commit：B 匹配</span></span><br><span class="line"><span class="comment">	 * RWB 从 desc_read：A 到 desc_read：C</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	smp_rmb(); <span class="comment">/* LMM(desc_read:B) */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Copy the descriptor data. The data is not valid until the</span></span><br><span class="line"><span class="comment">	 * state has been re-checked. A memcpy() for all of @desc</span></span><br><span class="line"><span class="comment">	 * cannot be used because of the atomic_t @state_var field.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (desc_out) &#123;</span><br><span class="line">		<span class="built_in">memcpy</span>(&amp;desc_out-&gt;text_blk_lpos, &amp;desc-&gt;text_blk_lpos,</span><br><span class="line">		       <span class="keyword">sizeof</span>(desc_out-&gt;text_blk_lpos)); <span class="comment">/* LMM(desc_read:C) */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (seq_out)</span><br><span class="line">		*seq_out = info-&gt;seq; <span class="comment">/* also part of desc_read:C */</span></span><br><span class="line">	<span class="keyword">if</span> (caller_id_out)</span><br><span class="line">		*caller_id_out = info-&gt;caller_id; <span class="comment">/* also part of desc_read:C */</span></span><br><span class="line"></span><br><span class="line">	smp_rmb(); <span class="comment">/* LMM(desc_read:D) */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *数据已复制。返回当前描述符状态，该状态自上述加载以来可能已更改。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	state_val = atomic_long_read(state_var); <span class="comment">/* LMM(desc_read:E) */</span></span><br><span class="line">	d_state = get_desc_state(id, state_val);</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> (desc_out)</span><br><span class="line">		atomic_long_set(&amp;desc_out-&gt;state_var, state_val);</span><br><span class="line">	<span class="keyword">return</span> d_state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="data-push-tail-将数据环形缓冲区的尾部推进到至少-lpos-的位置。此函数会将与尾部推进超出其关联数据块的描述符置为可重用状态"><a href="#data-push-tail-将数据环形缓冲区的尾部推进到至少-lpos-的位置。此函数会将与尾部推进超出其关联数据块的描述符置为可重用状态" class="headerlink" title="data_push_tail 将数据环形缓冲区的尾部推进到至少 @lpos 的位置。此函数会将与尾部推进超出其关联数据块的描述符置为可重用状态"></a>data_push_tail 将数据环形缓冲区的尾部推进到至少 @lpos 的位置。此函数会将与尾部推进超出其关联数据块的描述符置为可重用状态</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将数据环形缓冲区的尾部推进到至少 @lpos 的位置。此函数会将与尾部推进超出其关联数据块的描述符置为可重用状态。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">data_push_tail</span><span class="params">(<span class="keyword">struct</span> printk_ringbuffer *rb, <span class="type">unsigned</span> <span class="type">long</span> lpos)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">prb_data_ring</span> *<span class="title">data_ring</span> =</span> &amp;rb-&gt;text_data_ring;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> tail_lpos_new;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> tail_lpos;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> next_lpos;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果 @lpos 来自无数据块，则无需操作。 */</span></span><br><span class="line">	<span class="keyword">if</span> (LPOS_DATALESS(lpos))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	tail_lpos = atomic_long_read(&amp;data_ring-&gt;tail_lpos); <span class="comment">/* LMM(data_push_tail:A) */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 循环直到尾部 lpos 达到或超过 @lpos。此条件可能已经满足，从而无需执行来自 data_push_tail:D 的完整内存屏障。</span></span><br><span class="line"><span class="comment">	 * 然而，由于此 CPU 看到了新的尾部 lpos，任何变为可重用状态的描述符状态必须已经可见。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">while</span> ((lpos - tail_lpos) - <span class="number">1</span> &lt; DATA_SIZE(data_ring)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 将与 @lpos 之前数据块相关联的所有描述符置为可重用状态。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!data_make_reusable(rb, tail_lpos, lpos, &amp;next_lpos)) &#123;</span><br><span class="line">			smp_rmb(); <span class="comment">/* LMM(data_push_tail:B) */</span></span><br><span class="line"></span><br><span class="line">			tail_lpos_new = atomic_long_read(&amp;data_ring-&gt;tail_lpos</span><br><span class="line">							); <span class="comment">/* LMM(data_push_tail:C) */</span></span><br><span class="line">			<span class="keyword">if</span> (tail_lpos_new == tail_lpos)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 另一个 CPU 推进了尾部。重试。 */</span></span><br><span class="line">			tail_lpos = tail_lpos_new;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (atomic_long_try_cmpxchg(&amp;data_ring-&gt;tail_lpos, &amp;tail_lpos,</span><br><span class="line">						next_lpos)) &#123; <span class="comment">/* LMM(data_push_tail:D) */</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="desc-push-tail-推进描述符环的尾部"><a href="#desc-push-tail-推进描述符环的尾部" class="headerlink" title="desc_push_tail 推进描述符环的尾部"></a>desc_push_tail 推进描述符环的尾部</h2><ol>
<li>读取最后一个节点的状态</li>
<li>判断最后一个节点的状态.</li>
<li>如果最后一个节点的状态是desc_miss,则判断ID是否恰好比预期 ID 晚 1 个换行，则它正在由另一个写入器保留，并且必须被视为保留。</li>
<li>如果最后一个节点的状态是desc_reserved,则返回false,表示描述符正在由编写器</li>
<li>如果最后一个节点的状态是desc_committed,则返回false,表示描述符已提交，可以重新打开</li>
<li>如果最后一个节点的状态是desc_finalized,则将描述符设置为可重用状态</li>
<li>如果最后一个节点的状态是desc_reusable,则表示free，尚未被任何作者使用</li>
<li>desc_finalized 和 desc_reusable 状态的描述符可以被推送到下一个描述符。</li>
<li>进行数据块的失效操作,使其关联的描述符可供回收。</li>
<li>在将 tail 推向 next 之前，请检查 @tail_id 之后的下一个 Descriptors，</li>
<li>如果下一个描述符小于或等于 @head_id因此不存在将尾部推过头部的风险。可以进行推进操作。</li>
<li>否则,则重新检查尾部 ID。@tail_id后面的描述符未处于允许的尾部状态。但是，如果尾部此后被另一个 CPU 移动，则无关紧要。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 推进 desc ring tail。此函数将尾部前进一个描述符，从而使最早的描述符无效。</span></span><br><span class="line"><span class="comment"> * 在推进尾部之前，尾部描述符是可重用的，并且所有数据块（包括描述符的数据块）都无效（即数据环尾部被推过描述符的数据块，使其可重用）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">desc_push_tail</span><span class="params">(<span class="keyword">struct</span> printk_ringbuffer *rb,</span></span><br><span class="line"><span class="params">			   <span class="type">unsigned</span> <span class="type">long</span> tail_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">prb_desc_ring</span> *<span class="title">desc_ring</span> =</span> &amp;rb-&gt;desc_ring;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">desc_state</span> <span class="title">d_state</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">prb_desc</span> <span class="title">desc</span>;</span></span><br><span class="line">	<span class="comment">//读取最后一个节点的状态</span></span><br><span class="line">	d_state = desc_read(desc_ring, tail_id, &amp;desc, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (d_state) &#123;</span><br><span class="line">	<span class="keyword">case</span> desc_miss:	<span class="comment">//最后一个节点的状态 ID 不匹配（伪状态</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 *如果 ID 恰好比预期 ID 晚 1 个换行，则它正在由另一个写入器保留，并且必须被视为保留。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (DESC_ID(atomic_long_read(&amp;desc.state_var)) ==</span><br><span class="line">		    DESC_ID_PREV_WRAP(desc_ring, tail_id)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * ID 已更改。另一个作者一定已经推动了尾巴并回收了描述符。返回 Success 是因为调用方只对正在推送的指定尾部感兴趣，而事实确实如此。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">case</span> desc_reserved:		<span class="comment">//描述符正在由编写器</span></span><br><span class="line">	<span class="keyword">case</span> desc_committed:	<span class="comment">//描述符已提交，可以重新打开</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">case</span> desc_finalized:	<span class="comment">// committed，不允许进一步修改</span></span><br><span class="line">		desc_make_reusable(desc_ring, tail_id);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> desc_reusable:		<span class="comment">//free，尚未被任何作者使用</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 数据块必须先失效，然后才能使其关联的描述符可供回收。以后无法使它们失效，因为一旦其关联的描述符消失，就无法信任数据块。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!data_push_tail(rb, desc.text_blk_lpos.next))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 在将 tail 推向 next 之前，请检查 @tail_id 之后的下一个 Descriptors，</span></span><br><span class="line"><span class="comment">	 * 因为 tail 必须始终处于 finalized 或 reusable 状态。prb_first_seq（） 的实现依赖于此。</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 成功读取意味着下一个描述符小于或等于 @head_id因此不存在将尾部推过头部的风险。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	d_state = desc_read(desc_ring, DESC_ID(tail_id + <span class="number">1</span>), &amp;desc,</span><br><span class="line">			    <span class="literal">NULL</span>, <span class="literal">NULL</span>); <span class="comment">/* LMM(desc_push_tail:A) */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (d_state == desc_finalized || d_state == desc_reusable) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 确保在推送尾部 ID 之前存储任何已转换为可重用的描述符状态。这允许验证回收的描述符状态。</span></span><br><span class="line"><span class="comment">		 * 需要一个完整的内存屏障，因为其他 CPU 可能已使描述符状态可重用。这与 desc_reserve：D 配对。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		atomic_long_cmpxchg(&amp;desc_ring-&gt;tail_id, tail_id,</span><br><span class="line">				    DESC_ID(tail_id + <span class="number">1</span>)); <span class="comment">/* LMM(desc_push_tail:B) */</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		smp_rmb(); <span class="comment">/* LMM(desc_push_tail:C) */</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/*重新检查尾部 ID。@tail_id后面的描述符未处于允许的尾部状态。但是，如果尾部此后被另一个 CPU 移动，则无关紧要。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (atomic_long_read(&amp;desc_ring-&gt;tail_id) == tail_id) <span class="comment">/* LMM(desc_push_tail:D) */</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="desc-reserve-返回新描述符，必要时使最旧的描述符失效。"><a href="#desc-reserve-返回新描述符，必要时使最旧的描述符失效。" class="headerlink" title="desc_reserve 返回新描述符，必要时使最旧的描述符失效。"></a>desc_reserve 返回新描述符，必要时使最旧的描述符失效。</h2><ol>
<li>原子读取描述符环的头部 ID。</li>
<li>判断上一次环绕索引的 ID 是否与当前尾部 ID 一致,则尝试将尾部 ID 向前推进以为新描述符腾出空间。</li>
<li>尝试xchg写入head_id为新值</li>
<li>这时候分配了未被使用的desc</li>
<li>判断desc-&gt;state_var不是未使用状态,则证明程序出现了问题,发出警告</li>
<li>写入desc-&gt;state_var为DESC_SV(id, desc_reserved) 也就是将描述符的状态设置为保留状态。</li>
<li>给出id_out可以被进行使用</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 保留新描述符，必要时使最旧的描述符失效。 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">desc_reserve</span><span class="params">(<span class="keyword">struct</span> printk_ringbuffer *rb, <span class="type">unsigned</span> <span class="type">long</span> *id_out)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">prb_desc_ring</span> *<span class="title">desc_ring</span> =</span> &amp;rb-&gt;desc_ring;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> prev_state_val;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> id_prev_wrap;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">prb_desc</span> *<span class="title">desc</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> head_id;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> id;</span><br><span class="line">	<span class="comment">/*  &quot;Litmus Memory Model&quot;，是一种用于描述内存屏障行为的标记。 */</span></span><br><span class="line">	head_id = atomic_long_read(&amp;desc_ring-&gt;head_id); <span class="comment">/* LMM(desc_reserve:A) */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="comment">/* 每次进入+1,获取下一个描述符 ID</span></span><br><span class="line"><span class="comment">		当descbits = 5时</span></span><br><span class="line"><span class="comment">		第一次进入head_id = DESC_ID(32 + 1) = 0 */</span></span><br><span class="line">		id = DESC_ID(head_id + <span class="number">1</span>);</span><br><span class="line">		<span class="comment">/* 获取与给定 ID 相同的上一个环绕索引的 ID。</span></span><br><span class="line"><span class="comment">		例如第一次进入id_prev_wrap = -32 = 0*/</span></span><br><span class="line">		id_prev_wrap = DESC_ID_PREV_WRAP(desc_ring, id);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 确保在读取尾部 ID 之前读取头部 ID。由于尾部 ID 在头部 ID 之前更新，因此可以保证 @id_prev_wrap 永远不会领先于尾部 ID。这与 desc_reserve：D 配对。</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * 内存屏障参与：</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * 如果 desc_reserve：A 读取 desc_reserve：D，则 desc_reserve：C 读取 desc_push_tail：B。</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 *依赖：</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * 从 desc_push_tail：B 到 desc_reserve：D 匹配的 MB</span></span><br><span class="line"><span class="comment">		 * RMB从 desc_reserve：A 到 desc_reserve：C</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * 注意：desc_push_tail：B 和 desc_reserve：D 可以是不同的 CPU。但是，desc_reserve：D CPU（执行完整内存屏障）之前必须见过 desc_push_tail：B。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		smp_rmb(); <span class="comment">/* LMM(desc_reserve:B) */</span></span><br><span class="line">		<span class="comment">/* 初始化为32 与head_id一致*/</span></span><br><span class="line">		<span class="keyword">if</span> (id_prev_wrap == atomic_long_read(&amp;desc_ring-&gt;tail_id</span><br><span class="line">						    )) &#123; <span class="comment">/* LMM(desc_reserve:C) */</span></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * 通过前进尾部为新描述符腾出空间。</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (!desc_push_tail(rb, id_prev_wrap))</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 1.保证在验证回收的描述符状态之前读取尾部 ID。读取内存屏障就足够了。这与 desc_push_tail：B 配对。</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * 记忆障碍参与：</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * 如果 desc_reserve：C 从 desc_push_tail：B 读取，则 desc_reserve：E 从 desc_make_reusable：A 读取。</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 *依赖：</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * MB 从 desc_make_reusable：A 到 desc_push_tail：B 匹配 </span></span><br><span class="line"><span class="comment">		 * RMB 从 desc_reserve：C 到 desc_reserve：E</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * 注意：desc_make_reusable：A 和 desc_push_tail：B 可以是不同的 CPU。但是，desc_push_tail：B CPU（执行完整内存屏障）之前必须见过 desc_make_reusable：A。</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * 2.确保在存储头部 ID 之前存储尾部 ID。这与 desc_reserve：B 配对。</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * 3.确保在回收描述符之前存储任何数据环尾部更改。数据环尾部更改可以通过 desc_push_tail（）-&gt;data_push_tail（） 进行。需要一个完整的内存屏障，因为另一个 CPU 可能已经推送了数据环尾部。这与 data_push_tail：B 配对。</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * 4.确保在回收描述符之前存储新的尾部 ID。需要一个完整的内存屏障，因为另一个 CPU 可能已经推送了尾部 ID。这与 desc_push_tail：C 配对，这也与 prb_first_seq：C 配对。</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * 5.确保在尝试完成上一个描述符之前存储 head ID。这与 _prb_commit：B 配对。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">	&#125; <span class="keyword">while</span> (!atomic_long_try_cmpxchg(&amp;desc_ring-&gt;head_id, &amp;head_id, id)); <span class="comment">/* LMM(desc_reserve:D) */</span></span><br><span class="line">    <span class="comment">/* 再次读取desc_ring-&gt;head_id,判断与head_id是否一致,一致则将id付给desc_ring-&gt;head_id</span></span><br><span class="line"><span class="comment">    true是发生交换，否则@false */</span></span><br><span class="line"></span><br><span class="line">	desc = to_desc(desc_ring, id);  <span class="comment">//&amp;desc_ring-&gt;descs[id];</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 如果描述符已被回收，请验证旧状态 val。请参阅“ABA 问题”，了解执行此验证的原因。</span></span><br><span class="line"><span class="comment">        ABA 问题是并发编程中的一个经典问题，通常发生在使用无锁数据结构时。具体来说：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        一个线程（线程 A）读取了某个共享变量的值（例如 val）。</span></span><br><span class="line"><span class="comment">        在线程 A 进行进一步操作之前，另一个线程（线程 B）修改了该变量的值，并随后将其恢复为线程 A 最初读取的值。</span></span><br><span class="line"><span class="comment">        线程 A 再次检查该变量时，发现值没有变化（仍然是 A），因此错误地认为变量的状态没有被修改。</span></span><br><span class="line"><span class="comment">        这种情况下，线程 A 无法察觉到变量经历了从 A -&gt; B -&gt; A 的变化过程，可能导致数据不一致或逻辑错误。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        验证旧状态的目的</span></span><br><span class="line"><span class="comment">        通过验证描述符的旧状态，可以检测到描述符是否已经被回收并重新使用。这种验证通常结合某种机制（例如版本号或序列号）来解决 ABA 问题。例如：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        在描述符中附加一个版本号，每次回收时递增版本号。</span></span><br><span class="line"><span class="comment">        在线程操作描述符时，同时检查描述符的值和版本号是否匹配。</span></span><br><span class="line"><span class="comment">        这种方法可以有效避免 ABA 问题，因为即使描述符的值恢复为原始值，版本号的变化仍然可以被检测到。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        应用场景</span></span><br><span class="line"><span class="comment">        这种验证机制在以下场景中尤为重要：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        环形缓冲区：描述符可能被多个生产者和消费者线程并发访问。</span></span><br><span class="line"><span class="comment">        无锁队列或栈：这些数据结构依赖于原子操作和状态验证来确保线程安全。</span></span><br><span class="line"><span class="comment">        内核开发：在操作系统内核中，描述符通常用于管理资源（如内存块或 I/O 请求），需要特别注意并发访问问题</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	prev_state_val = atomic_long_read(&amp;desc-&gt;state_var); <span class="comment">/* LMM(desc_reserve:E) */</span></span><br><span class="line">	<span class="keyword">if</span> (prev_state_val &amp;&amp;</span><br><span class="line">	    get_desc_state(id_prev_wrap, prev_state_val) != desc_reusable) &#123;</span><br><span class="line">		WARN_ON_ONCE(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 为描述符分配一个新 ID，并将其状态设置为 reserved。</span></span><br><span class="line"><span class="comment">	 * 请参阅“ABA 问题”，了解为什么使用 cmpxchg（） 而不是 set（）。</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 确保在进行任何其他更改之前存储新的描述符 ID 和状态。一个写内存屏障就足够了。这与 desc_read：D 配对。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!atomic_long_try_cmpxchg(&amp;desc-&gt;state_var, &amp;prev_state_val,</span><br><span class="line">			DESC_SV(id, desc_reserved))) &#123; <span class="comment">/* LMM(desc_reserve:F) */</span></span><br><span class="line">		WARN_ON_ONCE(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 现在可以修改 @desc 中的数据：LMM（desc_reserve：G） */</span></span><br><span class="line">	*id_out = id;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="get-next-lpos-确定数据块的结尾"><a href="#get-next-lpos-确定数据块的结尾" class="headerlink" title="get_next_lpos 确定数据块的结尾"></a>get_next_lpos 确定数据块的结尾</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 确定数据块的结尾。 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">get_next_lpos</span><span class="params">(<span class="keyword">struct</span> prb_data_ring *data_ring,</span></span><br><span class="line"><span class="params">				   <span class="type">unsigned</span> <span class="type">long</span> lpos, <span class="type">unsigned</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> begin_lpos;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> next_lpos;</span><br><span class="line">	<span class="comment">//根据当前数据块的起始位置（lpos）和大小（size），计算数据块的结束位置</span></span><br><span class="line">	begin_lpos = lpos;</span><br><span class="line">	next_lpos = lpos + size;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 首先检查数据块是否没有环绕。</span></span><br><span class="line"><span class="comment">	如果数据块没有跨越缓冲区的边界，则直接返回计算的结束位置*/</span></span><br><span class="line">	<span class="keyword">if</span> (DATA_WRAPS(data_ring, begin_lpos) == DATA_WRAPS(data_ring, next_lpos))</span><br><span class="line">		<span class="keyword">return</span> next_lpos;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*环绕数据块在开始时存储其数据。</span></span><br><span class="line"><span class="comment">	如果数据块跨越了缓冲区的边界（发生了“环绕”），则调整结束位置，使其指向缓冲区的起始位置加上数据块的大小 */</span></span><br><span class="line">	<span class="keyword">return</span> (DATA_THIS_WRAP_START_LPOS(data_ring, next_lpos) + size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="data-alloc-分配一个新的数据块，如果有必要会使最旧的数据块失效"><a href="#data-alloc-分配一个新的数据块，如果有必要会使最旧的数据块失效" class="headerlink" title="data_alloc 分配一个新的数据块，如果有必要会使最旧的数据块失效"></a>data_alloc 分配一个新的数据块，如果有必要会使最旧的数据块失效</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 分配一个新的数据块，如果有必要会使最旧的数据块失效。</span></span><br><span class="line"><span class="comment"> * 此函数还会将数据块与指定的描述符关联起来。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *<span class="title function_">data_alloc</span><span class="params">(<span class="keyword">struct</span> printk_ringbuffer *rb, <span class="type">unsigned</span> <span class="type">int</span> size,</span></span><br><span class="line"><span class="params">			<span class="keyword">struct</span> prb_data_blk_lpos *blk_lpos, <span class="type">unsigned</span> <span class="type">long</span> id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">prb_data_ring</span> *<span class="title">data_ring</span> =</span> &amp;rb-&gt;text_data_ring;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">prb_data_block</span> *<span class="title">blk</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> begin_lpos;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> next_lpos;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 对于空行不会创建数据块。相反，读取器将识别这些特殊的 lpos 值并适当地处理它。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		blk_lpos-&gt;begin = EMPTY_LINE_LPOS;</span><br><span class="line">		blk_lpos-&gt;next = EMPTY_LINE_LPOS;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	size = to_blk_size(size);</span><br><span class="line"></span><br><span class="line">	begin_lpos = atomic_long_read(&amp;data_ring-&gt;head_lpos);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		next_lpos = get_next_lpos(data_ring, begin_lpos, size);	<span class="comment">//确定数据块的结尾</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!data_push_tail(rb, next_lpos - DATA_SIZE(data_ring))) &#123;</span><br><span class="line">			<span class="comment">/* 分配失败，指定一个无数据块。 */</span></span><br><span class="line">			blk_lpos-&gt;begin = FAILED_LPOS;</span><br><span class="line">			blk_lpos-&gt;next = FAILED_LPOS;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 1. 确保任何已转换为可重用状态的描述符状态在修改新分配的数据区域之前已存储。</span></span><br><span class="line"><span class="comment">		 *    需要一个完整的内存屏障，因为其他 CPU 可能已将描述符状态设置为可重用。</span></span><br><span class="line"><span class="comment">		 *    请参阅 data_push_tail:A 了解为什么可重用状态是可见的。这与 desc_read:D 配对。</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * 2. 确保任何更新的尾部 lpos 在修改新分配的数据区域之前已存储。</span></span><br><span class="line"><span class="comment">		 *    另一个 CPU 可能正在 data_make_reusable() 中并从该区域读取块 ID。</span></span><br><span class="line"><span class="comment">		 *    data_make_reusable() 可以处理读取垃圾块 ID 值，但随后它必须能够加载新的尾部 lpos。</span></span><br><span class="line"><span class="comment">		 *    需要一个完整的内存屏障，因为其他 CPU 可能已更新了尾部 lpos。这与 data_push_tail:B 配对。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">	&#125; <span class="keyword">while</span> (!atomic_long_try_cmpxchg(&amp;data_ring-&gt;head_lpos, &amp;begin_lpos, next_lpos)); <span class="comment">/* LMM(data_alloc:A) */</span></span><br><span class="line"></span><br><span class="line">	blk = to_block(data_ring, begin_lpos);</span><br><span class="line">	blk-&gt;id = id; <span class="comment">/* LMM(data_alloc:B) */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (DATA_WRAPS(data_ring, begin_lpos) != DATA_WRAPS(data_ring, next_lpos)) &#123;</span><br><span class="line">		<span class="comment">/* 环绕的数据块将其数据存储在开头。 */</span></span><br><span class="line">		blk = to_block(data_ring, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 为了一致性，在环绕块上存储 ID。</span></span><br><span class="line"><span class="comment">		 * printk_ringbuffer 实际上并不使用它。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		blk-&gt;id = id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	blk_lpos-&gt;begin = begin_lpos;</span><br><span class="line">	blk_lpos-&gt;next = next_lpos;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;blk-&gt;data[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="prb-commit-将数据状态设置为提交"><a href="#prb-commit-将数据状态设置为提交" class="headerlink" title="prb_commit 将数据状态设置为提交"></a>prb_commit 将数据状态设置为提交</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 提交数据（可能完成数据）并恢复中断。 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> _prb_commit(<span class="keyword">struct</span> prb_reserved_entry *e, <span class="type">unsigned</span> <span class="type">long</span> state_val)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">prb_desc_ring</span> *<span class="title">desc_ring</span> =</span> &amp;e-&gt;rb-&gt;desc_ring;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">prb_desc</span> *<span class="title">d</span> =</span> to_desc(desc_ring, e-&gt;id);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> prev_state_val = DESC_SV(e-&gt;id, desc_reserved);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Now the writer has finished all writing: LMM(_prb_commit:A) */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!atomic_long_try_cmpxchg(&amp;d-&gt;state_var, &amp;prev_state_val,</span><br><span class="line">			DESC_SV(e-&gt;id, state_val))) &#123; <span class="comment">/* LMM(_prb_commit:B) */</span></span><br><span class="line">		WARN_ON_ONCE(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*restore interrupts，则 reserve/commit 窗口已完成。*/</span></span><br><span class="line">	local_irq_restore(e-&gt;irqflags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * prb_commit（） - 将（以前保留的）数据提交到环形缓冲区。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @e：包含保留数据信息的条目。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这是 writer 可用于提交数据的公共函数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 请注意，在最终确定之前，读者无法获得数据。当为下一条记录预留空间时，会自动进行定稿。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 请参阅 prb_final_commit（） 以获取此函数的立即完成的版本。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 上下文：任何上下文。启用本地中断。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">prb_commit</span><span class="params">(<span class="keyword">struct</span> prb_reserved_entry *e)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">prb_desc_ring</span> *<span class="title">desc_ring</span> =</span> &amp;e-&gt;rb-&gt;desc_ring;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> head_id;</span><br><span class="line"></span><br><span class="line">	_prb_commit(e, desc_committed);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 如果此 descriptor 不再是 head （即已分配新记录），则不再允许扩展此记录的数据，因此必须完成该记录。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	head_id = atomic_long_read(&amp;desc_ring-&gt;head_id); <span class="comment">/* LMM(prb_commit:A) */</span></span><br><span class="line">	<span class="keyword">if</span> (head_id != e-&gt;id)</span><br><span class="line">		desc_make_final(e-&gt;rb, e-&gt;id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="prb-reserve-在环形缓冲区中保留空间"><a href="#prb-reserve-在环形缓冲区中保留空间" class="headerlink" title="prb_reserve 在环形缓冲区中保留空间"></a>prb_reserve 在环形缓冲区中保留空间</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * prb_reserve（） - 在环形缓冲区中保留空间。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @e：要设置的入口结构。</span></span><br><span class="line"><span class="comment"> * @rb：用于保留数据的 ringbuffer。</span></span><br><span class="line"><span class="comment"> * @r：要为其分配缓冲区的记录结构。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这是写入器可用于保留数据的公共函数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 写入器通过设置 @r 的 @text_buf_size 字段来指定要保留的文本大小。为了确保 @r 的正确初始化，应使用 prb_rec_init_wr（）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 上下文：任何上下文。成功时禁用本地中断。返回：如果至少可以分配文本数据，则为 true，否则为 false。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 成功后，@r 的 @info 和 @text_buf 字段将由此函数设置，并应由 writer 在提交前填写。同样在成功时，可以在 @e 上使用 prb_record_text_space（） 来查询用于文本数据块的实际空间。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 重要提示：写入器需要正确设置 @info-&gt;text_len 才能读取和/或扩展数据。其值初始化为 0。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">prb_reserve</span><span class="params">(<span class="keyword">struct</span> prb_reserved_entry *e, <span class="keyword">struct</span> printk_ringbuffer *rb,</span></span><br><span class="line"><span class="params">		 <span class="keyword">struct</span> printk_record *r)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">prb_desc_ring</span> *<span class="title">desc_ring</span> =</span> &amp;rb-&gt;desc_ring;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">printk_info</span> *<span class="title">info</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">prb_desc</span> *<span class="title">d</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> id;</span><br><span class="line">	u64 seq;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!data_check_size(&amp;rb-&gt;text_data_ring, r-&gt;text_buf_size))</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 保留状态的描述符在desc_ring完全环绕后充当所有进一步预留的阻止程序。在 reserve/commit 窗口期间禁用中断，以最大程度地减少发生这种情况的可能性。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	local_irq_save(e-&gt;irqflags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!desc_reserve(rb, &amp;id)) &#123;	<span class="comment">//返回新描述符，必要时使最旧的描述符失效。</span></span><br><span class="line">		<span class="comment">/* 跟踪描述符预留失败. */</span></span><br><span class="line">		atomic_long_inc(&amp;rb-&gt;fail);</span><br><span class="line">		local_irq_restore(e-&gt;irqflags);</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	d = to_desc(desc_ring, id);</span><br><span class="line">	info = to_info(desc_ring, id);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 所有@info字段（@seq 字段除外）都将被清除，并且必须由编写器填写。在清除之前保存@seq，因为它用于确定新的序列号。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	seq = info-&gt;seq;</span><br><span class="line">	<span class="built_in">memset</span>(info, <span class="number">0</span>, <span class="keyword">sizeof</span>(*info));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 在此处设置 @e 字段，以便在文本数据分配失败时可以使用 prb_commit（）。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	e-&gt;rb = rb;</span><br><span class="line">	e-&gt;id = id;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 如果序列号 “从未设置” ，则初始化序列号。否则，只需将其增加 full wrap 即可。</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 如果 @seq 的值为 0，则认为 @infos[0] 的值为 _except_，则认为该值为 0，这是由 Ringbuffer 初始值设定项专门设置的，因此始终被视为已设置。</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 请参阅 printk_ringbuffer.h 中的 “Bootstrap” 注释块，了解有关初始值设定项如何引导描述符的详细信息。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (seq == <span class="number">0</span> &amp;&amp; DESC_INDEX(desc_ring, id) != <span class="number">0</span>)</span><br><span class="line">		info-&gt;seq = DESC_INDEX(desc_ring, id);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		info-&gt;seq = seq + DESCS_COUNT(desc_ring);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 新数据即将被保留。一旦发生这种情况，以前的描述符将无法再扩展。现在完成前面的描述符，以便读者可以使用它。（对于 seq==0，没有前面的描述符。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (info-&gt;seq &gt; <span class="number">0</span>)</span><br><span class="line">		desc_make_final(rb, DESC_ID(id - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">	r-&gt;text_buf = data_alloc(rb, r-&gt;text_buf_size, &amp;d-&gt;text_blk_lpos, id);</span><br><span class="line">	<span class="comment">/* 如果文本数据分配失败，则状态修改为提交无数据记录。 */</span></span><br><span class="line">	<span class="keyword">if</span> (r-&gt;text_buf_size &amp;&amp; !r-&gt;text_buf) &#123;</span><br><span class="line">		prb_commit(e);</span><br><span class="line">		<span class="comment">/* prb_commit（） 重新启用中断。 */</span></span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	r-&gt;info = info;	<span class="comment">//这里将描述符的信息结构体赋值给r-&gt;info,用于将外面的信息传递给内核</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 记录 record 使用的全文空间。 */</span></span><br><span class="line">	<span class="comment">//返回数据块使用的字节数</span></span><br><span class="line">	e-&gt;text_space = space_used(&amp;rb-&gt;text_data_ring, &amp;d-&gt;text_blk_lpos);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">	<span class="comment">/* 向调用方明确表示预留失败。*/</span></span><br><span class="line">	<span class="built_in">memset</span>(r, <span class="number">0</span>, <span class="keyword">sizeof</span>(*r));</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="prb-rec-init-wr-初始化用于写入记录的缓冲区。"><a href="#prb-rec-init-wr-初始化用于写入记录的缓冲区。" class="headerlink" title="prb_rec_init_wr 初始化用于写入记录的缓冲区。"></a>prb_rec_init_wr 初始化用于写入记录的缓冲区。</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * prb_rec_init_wr() -初始化用于写入记录的缓冲区。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @r:             The record to initialize.</span></span><br><span class="line"><span class="comment"> * @text_buf_size: The needed text buffer size.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">prb_rec_init_wr</span><span class="params">(<span class="keyword">struct</span> printk_record *r,</span></span><br><span class="line"><span class="params">				   <span class="type">unsigned</span> <span class="type">int</span> text_buf_size)</span></span><br><span class="line">&#123;</span><br><span class="line">	r-&gt;info = <span class="literal">NULL</span>;</span><br><span class="line">	r-&gt;text_buf = <span class="literal">NULL</span>;</span><br><span class="line">	r-&gt;text_buf_size = text_buf_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="prb-first-seq-获取尾部描述符的序列号"><a href="#prb-first-seq-获取尾部描述符的序列号" class="headerlink" title="prb_first_seq 获取尾部描述符的序列号"></a>prb_first_seq 获取尾部描述符的序列号</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取尾部描述符的序列号。 */</span></span><br><span class="line">u64 <span class="title function_">prb_first_seq</span><span class="params">(<span class="keyword">struct</span> printk_ringbuffer *rb)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">prb_desc_ring</span> *<span class="title">desc_ring</span> =</span> &amp;rb-&gt;desc_ring;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">desc_state</span> <span class="title">d_state</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">prb_desc</span> <span class="title">desc</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> id;</span><br><span class="line">	u64 seq;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		id = atomic_long_read(&amp;rb-&gt;desc_ring.tail_id); <span class="comment">/* LMM(prb_first_seq:A) */</span></span><br><span class="line"></span><br><span class="line">		d_state = desc_read(desc_ring, id, &amp;desc, &amp;seq, <span class="literal">NULL</span>); <span class="comment">/* LMM(prb_first_seq:B) */</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * T他的循环不会是无限的，因为 tail is_always_处于 finalized 或 reusable 状态。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (d_state == desc_finalized || d_state == desc_reusable)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		smp_rmb(); <span class="comment">/* LMM(prb_first_seq:C) */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> seq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ulseq-to-u64seq-将-32-位序列号转换为-64-位序列号"><a href="#ulseq-to-u64seq-将-32-位序列号转换为-64-位序列号" class="headerlink" title="__ulseq_to_u64seq 将 32 位序列号转换为 64 位序列号"></a>__ulseq_to_u64seq 将 32 位序列号转换为 64 位序列号</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> u64 __ulseq_to_u64seq(<span class="keyword">struct</span> printk_ringbuffer *rb, u32 ulseq)</span><br><span class="line">&#123;</span><br><span class="line">	u64 rb_first_seq = prb_first_seq(rb);	<span class="comment">//获取尾部描述符的序列号</span></span><br><span class="line">	u64 seq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 提供的序列只是 ringbuffer 序列的低 32 位。它需要扩展到 64 位。从 ringbuffer 中获取第一个序列号并将其折叠。</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 在控制台中具有 32 位表示就足够了。如果控制台在 ringbuffer 后面获得超过 2^31 条记录，那么这是最少的问题。</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 此外，对环形缓冲区的访问始终是安全的。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	seq = rb_first_seq - (s32)((u32)rb_first_seq - ulseq);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> seq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="desc-last-finalized-seq-获取最后一个已完成的序列号"><a href="#desc-last-finalized-seq-获取最后一个已完成的序列号" class="headerlink" title="desc_last_finalized_seq 获取最后一个已完成的序列号"></a>desc_last_finalized_seq 获取最后一个已完成的序列号</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @last_finalized_seq 的值保证了所有记录直到并包括此序列号都已完成并可以读取。</span></span><br><span class="line"><span class="comment"> * 唯一的例外是那些已经被覆盖的过旧记录。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 同时保证 @last_finalized_seq 只会递增。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 请注意，紧随未完成记录之后的已完成记录不会被报告，因为它们尚未对读取器可用。</span></span><br><span class="line"><span class="comment"> * 例如，通过 printk() 存储的新记录如果紧随未完成记录之后，将不会对打印机可用。</span></span><br><span class="line"><span class="comment"> * 然而，一旦该未完成记录变为完成状态，@last_finalized_seq 将被适当地更新，</span></span><br><span class="line"><span class="comment"> * 并且完整的已完成记录集将对打印机可用。而且，由于每个 printk() 调用者</span></span><br><span class="line"><span class="comment"> * 要么直接打印，要么触发所有可用未打印记录的延迟打印，因此所有 printk() 消息</span></span><br><span class="line"><span class="comment"> * 都会被打印。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> u64 <span class="title function_">desc_last_finalized_seq</span><span class="params">(<span class="keyword">struct</span> printk_ringbuffer *rb)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">prb_desc_ring</span> *<span class="title">desc_ring</span> =</span> &amp;rb-&gt;desc_ring;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> ulseq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 保证在加载关联记录之前加载序列号，以确保该记录可以被此 CPU 看到。</span></span><br><span class="line"><span class="comment">	 * 这与 desc_update_last_finalized:A 配对。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ulseq = atomic_long_read_acquire(&amp;desc_ring-&gt;last_finalized_seq</span><br><span class="line">					); <span class="comment">/* LMM(desc_last_finalized_seq:A) */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> __ulseq_to_u64seq(rb, ulseq);	<span class="comment">//将 32 位序列号转换为 64 位序列号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="desc-read-finalized-seq-获取指定描述符的副本"><a href="#desc-read-finalized-seq-获取指定描述符的副本" class="headerlink" title="desc_read_finalized_seq 获取指定描述符的副本"></a>desc_read_finalized_seq 获取指定描述符的副本</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这是 desc_read（） 的扩展版本。它获取指定描述符的副本。但是，它还会验证记录是否已完成并且序列号是否@seq。成功后，返回 0。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 错误返回值：</span></span><br><span class="line"><span class="comment"> * -EINVAL：序列号为 @seq 的最终记录不存在。</span></span><br><span class="line"><span class="comment"> * -ENOENT：序列号为 @seq 的最终记录存在，但其数据</span></span><br><span class="line"><span class="comment"> * 不可用。这是一个有效的记录，因此读者应该</span></span><br><span class="line"><span class="comment"> * 继续下一条记录。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">desc_read_finalized_seq</span><span class="params">(<span class="keyword">struct</span> prb_desc_ring *desc_ring,</span></span><br><span class="line"><span class="params">				   <span class="type">unsigned</span> <span class="type">long</span> id, u64 seq,</span></span><br><span class="line"><span class="params">				   <span class="keyword">struct</span> prb_desc *desc_out)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">prb_data_blk_lpos</span> *<span class="title">blk_lpos</span> =</span> &amp;desc_out-&gt;text_blk_lpos;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">desc_state</span> <span class="title">d_state</span>;</span></span><br><span class="line">	u64 s;</span><br><span class="line"></span><br><span class="line">	d_state = desc_read(desc_ring, id, desc_out, &amp;s, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 意外的@id （desc_miss） 或 @seq 不匹配意味着记录不存在。</span></span><br><span class="line"><span class="comment">	 处于 reserved 或 committed 状态的描述符表示该记录对于读取器尚不存在。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (d_state == desc_miss ||</span><br><span class="line">	    d_state == desc_reserved ||</span><br><span class="line">	    d_state == desc_committed ||</span><br><span class="line">	    s != seq) &#123;</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 处于可重用状态的描述符可能不再具有其数据可用;将其报告为存在但丢失了数据。或者，该记录实际上可能是丢失数据的记录。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (d_state == desc_reusable ||</span><br><span class="line">	    (blk_lpos-&gt;begin == FAILED_LPOS &amp;&amp; blk_lpos-&gt;next == FAILED_LPOS)) &#123;</span><br><span class="line">		<span class="keyword">return</span> -ENOENT;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="get-data-给定-blk-lpos，从数据块返回指向写入器数据的指针，并计算数据部分的大小"><a href="#get-data-给定-blk-lpos，从数据块返回指向写入器数据的指针，并计算数据部分的大小" class="headerlink" title="get_data 给定@blk_lpos，从数据块返回指向写入器数据的指针，并计算数据部分的大小"></a>get_data 给定@blk_lpos，从数据块返回指向写入器数据的指针，并计算数据部分的大小</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">- 给定@blk_lpos，从数据块返回指向写入器数据的指针，并计算数据部分的大小。如果 @blk_lpos 指定永远不合法的值，则返回 NULL 指针。 </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment">- 此函数 （由读取器使用） 对 lpos 值执行严格验证，以可能检测编写器代码中的 bug。如果检测到内部错误，则会触发 WARN_ON_ONCE（）。 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *<span class="title function_">get_data</span><span class="params">(<span class="keyword">struct</span> prb_data_ring *data_ring,</span></span><br><span class="line"><span class="params">			    <span class="keyword">struct</span> prb_data_blk_lpos *blk_lpos,</span></span><br><span class="line"><span class="params">			    <span class="type">unsigned</span> <span class="type">int</span> *data_size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">prb_data_block</span> *<span class="title">db</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 无数据块描述。 */</span></span><br><span class="line">	<span class="keyword">if</span> (BLK_DATALESS(blk_lpos)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 只是空行的记录也是有效的，即使它们没有数据块。对于此类记录，显式返回空字符串数据以表示成功。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (blk_lpos-&gt;begin == EMPTY_LINE_LPOS &amp;&amp;</span><br><span class="line">		    blk_lpos-&gt;next == EMPTY_LINE_LPOS) &#123;</span><br><span class="line">			*data_size = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 数据丢失、无效或不可用。*/</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 常规数据块：小于 @next 的 @begin 且采用相同的换行. */</span></span><br><span class="line">	<span class="keyword">if</span> (DATA_WRAPS(data_ring, blk_lpos-&gt;begin) == DATA_WRAPS(data_ring, blk_lpos-&gt;next) &amp;&amp;</span><br><span class="line">	    blk_lpos-&gt;begin &lt; blk_lpos-&gt;next) &#123;</span><br><span class="line">		db = to_block(data_ring, blk_lpos-&gt;begin);</span><br><span class="line">		*data_size = blk_lpos-&gt;next - blk_lpos-&gt;begin;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 环绕数据块：@begin 是 @next 后面的一个环绕。 */</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (DATA_WRAPS(data_ring, blk_lpos-&gt;begin + DATA_SIZE(data_ring)) ==</span><br><span class="line">		   DATA_WRAPS(data_ring, blk_lpos-&gt;next)) &#123;</span><br><span class="line">		db = to_block(data_ring, <span class="number">0</span>);</span><br><span class="line">		*data_size = DATA_INDEX(data_ring, blk_lpos-&gt;next);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 非法区块描述。*/</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		WARN_ON_ONCE(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 有效的数据块将始终与 ID 大小保持一致。*/</span></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON_ONCE(blk_lpos-&gt;begin != ALIGN(blk_lpos-&gt;begin, <span class="keyword">sizeof</span>(db-&gt;id))) ||</span><br><span class="line">	    WARN_ON_ONCE(blk_lpos-&gt;next != ALIGN(blk_lpos-&gt;next, <span class="keyword">sizeof</span>(db-&gt;id)))) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*有效的数据块将始终至少具有一个 ID。*/</span></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON_ONCE(*data_size &lt; <span class="keyword">sizeof</span>(db-&gt;id)))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 从 size 中减去块 ID 空间以反映数据大小。 */</span></span><br><span class="line">	*data_size -= <span class="keyword">sizeof</span>(db-&gt;id);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;db-&gt;data[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="copy-data-给定-blk-lpos，将预期的数据-len复制到提供的缓冲区中"><a href="#copy-data-给定-blk-lpos，将预期的数据-len复制到提供的缓冲区中" class="headerlink" title="copy_data 给定@blk_lpos，将预期的数据@len复制到提供的缓冲区中"></a>copy_data 给定@blk_lpos，将预期的数据@len复制到提供的缓冲区中</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 给定@blk_lpos，将预期的数据@len复制到提供的缓冲区中。</span></span><br><span class="line"><span class="comment"> * 如果提供了 @line_count，则计算数据中的行数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 此函数（由读取器使用）对数据大小执行严格验证，以可能检测到写入器代码中的 bug。如果检测到内部错误，则会触发 WARN_ON_ONCE（）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">copy_data</span><span class="params">(<span class="keyword">struct</span> prb_data_ring *data_ring,</span></span><br><span class="line"><span class="params">		      <span class="keyword">struct</span> prb_data_blk_lpos *blk_lpos, u16 len, <span class="type">char</span> *buf,</span></span><br><span class="line"><span class="params">		      <span class="type">unsigned</span> <span class="type">int</span> buf_size, <span class="type">unsigned</span> <span class="type">int</span> *line_count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> data_size;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *data;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 调用方可能不需要任何数据。 */</span></span><br><span class="line">	<span class="keyword">if</span> ((!buf || !buf_size) &amp;&amp; !line_count)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="comment">//给定@blk_lpos，从数据块返回指向写入器数据的指针，并计算数据部分的大小</span></span><br><span class="line">	data = get_data(data_ring, blk_lpos, &amp;data_size);</span><br><span class="line">	<span class="keyword">if</span> (!data)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 实际值不能低于预期。由于尾随对齐填充，它可能超出预期。</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 请注意，可能会出现无效的 @len 值，因为调用方在允许的数据争用期间加载值。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (data_size &lt; (<span class="type">unsigned</span> <span class="type">int</span>)len)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 呼叫者对行数感兴趣？*/</span></span><br><span class="line">	<span class="keyword">if</span> (line_count)</span><br><span class="line">		*line_count = count_lines(data, len);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Caller interested in the data content? */</span></span><br><span class="line">	<span class="keyword">if</span> (!buf || !buf_size)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	data_size = <span class="type">min_t</span>(<span class="type">unsigned</span> <span class="type">int</span>, buf_size, len);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;buf[<span class="number">0</span>], data, data_size); <span class="comment">/* LMM(copy_data:A) */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="prb-read-将带有-seq-的记录中的-ringbuffer-数据复制到提供的-r-缓冲区"><a href="#prb-read-将带有-seq-的记录中的-ringbuffer-数据复制到提供的-r-缓冲区" class="headerlink" title="prb_read 将带有 @seq 的记录中的 ringbuffer 数据复制到提供的 @r 缓冲区"></a>prb_read 将带有 @seq 的记录中的 ringbuffer 数据复制到提供的 @r 缓冲区</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将带有 @seq 的记录中的 ringbuffer 数据复制到提供的 @r 缓冲区。成功后，返回 0。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 有关错误返回值，请参阅 desc_read_finalized_seq（）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">prb_read</span><span class="params">(<span class="keyword">struct</span> printk_ringbuffer *rb, u64 seq,</span></span><br><span class="line"><span class="params">		    <span class="keyword">struct</span> printk_record *r, <span class="type">unsigned</span> <span class="type">int</span> *line_count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">prb_desc_ring</span> *<span class="title">desc_ring</span> =</span> &amp;rb-&gt;desc_ring;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">printk_info</span> *<span class="title">info</span> =</span> to_info(desc_ring, seq);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">prb_desc</span> *<span class="title">rdesc</span> =</span> to_desc(desc_ring, seq);</span><br><span class="line">	<span class="type">atomic_long_t</span> *state_var = &amp;rdesc-&gt;state_var;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">prb_desc</span> <span class="title">desc</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> id;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*提取 ID，用于指定要读取的描述符。 */</span></span><br><span class="line">	id = DESC_ID(atomic_long_read(state_var));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 获取正确描述符的本地副本（如果可用）。 */</span></span><br><span class="line">	err = desc_read_finalized_seq(desc_ring, id, seq, &amp;desc);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 如果 @r 为 NULL，则调用方仅对记录的可用性感兴趣。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (err || !r)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果需要，请复制元数据。 */</span></span><br><span class="line">	<span class="keyword">if</span> (r-&gt;info)</span><br><span class="line">		<span class="built_in">memcpy</span>(r-&gt;info, info, <span class="keyword">sizeof</span>(*(r-&gt;info)));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 复制文本数据。如果失败，则为无数据记录。 */</span></span><br><span class="line">	<span class="comment">//给定@blk_lpos，将预期的数据@len复制到提供的缓冲区中</span></span><br><span class="line">	<span class="keyword">if</span> (!copy_data(&amp;rb-&gt;text_data_ring, &amp;desc.text_blk_lpos, info-&gt;text_len,</span><br><span class="line">		       r-&gt;text_buf, r-&gt;text_buf_size, line_count)) &#123;</span><br><span class="line">		<span class="keyword">return</span> -ENOENT;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 确保记录仍处于最终状态并具有相同的@seq. */</span></span><br><span class="line">	<span class="keyword">return</span> desc_read_finalized_seq(desc_ring, id, seq, &amp;desc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="prb-next-reserve-seq-获取最近保留记录之后的序列号。"><a href="#prb-next-reserve-seq-获取最近保留记录之后的序列号。" class="headerlink" title="prb_next_reserve_seq 获取最近保留记录之后的序列号。"></a>prb_next_reserve_seq 获取最近保留记录之后的序列号。</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * prb_next_reserve_seq() - 获取最近保留记录之后的序列号。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @rb:  要从中获取序列号的环形缓冲区。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这是提供给读取器的公共函数，用于查看将分配给下一个保留记录的序列号。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 请注意，根据情况，此值可能等于或高于 prb_next_seq() 返回的序列号。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 上下文：任何上下文。</span></span><br><span class="line"><span class="comment"> * 返回：将分配给下一条记录的序列号。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">u64 <span class="title function_">prb_next_reserve_seq</span><span class="params">(<span class="keyword">struct</span> printk_ringbuffer *rb)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">prb_desc_ring</span> *<span class="title">desc_ring</span> =</span> &amp;rb-&gt;desc_ring;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> last_finalized_id;</span><br><span class="line">	<span class="type">atomic_long_t</span> *state_var;</span><br><span class="line">	u64 last_finalized_seq;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> head_id;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">prb_desc</span> <span class="title">desc</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> diff;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">prb_desc</span> *<span class="title">d</span>;</span></span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 可能无法读取 @head_id 的序列号。</span></span><br><span class="line"><span class="comment">	 * 因此，使用 @last_finalized_seq 的 ID 来计算 @head_id 的序列号。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">try_again:</span><br><span class="line">	last_finalized_seq = desc_last_finalized_seq(rb);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * @head_id 在 @last_finalized_seq 之后加载，以确保它指向具有</span></span><br><span class="line"><span class="comment">	 * @last_finalized_seq 或更新的记录。</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 内存屏障参与：</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 如果 desc_last_finalized_seq:A 从 desc_update_last_finalized:A 读取，</span></span><br><span class="line"><span class="comment">	 * 则 prb_next_reserve_seq:A 从 desc_reserve:D 读取。</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 依赖：</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * RELEASE 从 desc_reserve:D 到 desc_update_last_finalized:A 匹配</span></span><br><span class="line"><span class="comment">	 * ACQUIRE 从 desc_last_finalized_seq:A 到 prb_next_reserve_seq:A</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 注意：desc_reserve:D 和 desc_update_last_finalized:A 可以是不同的 CPU。</span></span><br><span class="line"><span class="comment">	 * 然而，执行释放操作的 desc_update_last_finalized:A CPU 必须之前已经看到 desc_read:C，</span></span><br><span class="line"><span class="comment">	 * 这意味着 desc_reserve:D 可以被看到。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	head_id = atomic_long_read(&amp;desc_ring-&gt;head_id); <span class="comment">/* LMM(prb_next_reserve_seq:A) */</span></span><br><span class="line"></span><br><span class="line">	d = to_desc(desc_ring, last_finalized_seq);</span><br><span class="line">	state_var = &amp;d-&gt;state_var;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 提取 ID，用于指定要读取的描述符。 */</span></span><br><span class="line">	last_finalized_id = DESC_ID(atomic_long_read(state_var));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 确保 @last_finalized_id 是正确的。 */</span></span><br><span class="line">	err = desc_read_finalized_seq(desc_ring, last_finalized_id, last_finalized_seq, &amp;desc);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (err == -EINVAL) &#123;</span><br><span class="line">		<span class="keyword">if</span> (last_finalized_seq == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * 尚未有记录被最终确定或保留。</span></span><br><span class="line"><span class="comment">			 *</span></span><br><span class="line"><span class="comment">			 * @head_id 被初始化为使第一次递增将生成第一条记录 (seq=0)。</span></span><br><span class="line"><span class="comment">			 * 单独处理它以避免下面的负 @diff。</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (head_id == DESC0_ID(desc_ring-&gt;count_bits))</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * 一个或多个描述符已经被保留。使用第一个描述符的 ID (@seq=0)</span></span><br><span class="line"><span class="comment">			 * 作为下面 @diff 的计算依据。</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			last_finalized_id = DESC0_ID(desc_ring-&gt;count_bits) + <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* 记录可能已被覆盖。重试。 */</span></span><br><span class="line">			<span class="keyword">goto</span> try_again;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 已知描述符 ID 的差值，用于计算相关的序列号。 */</span></span><br><span class="line">	diff = head_id - last_finalized_id;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * @head_id 指向最近保留的记录，但此函数返回将分配给</span></span><br><span class="line"><span class="comment">	 * 下一个（尚未保留）记录的序列号。因此需要 +1。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> (last_finalized_seq + diff + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="prb-read-valid-非阻塞读取记录"><a href="#prb-read-valid-非阻塞读取记录" class="headerlink" title="_prb_read_valid 非阻塞读取记录"></a>_prb_read_valid 非阻塞读取记录</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 非阻塞读取记录。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 成功时，@seq 将更新为已读取的记录，并且（如果提供）@r 和 @line_count 将包含读取/计算的数据。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 失败时，@seq 将更新为尚未对读取器可用的记录，但它将是读取器下一个可用的记录。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：当当前 CPU 处于 panic 状态时，此函数将跳过任何不存在/未完成的记录，以允许 panic CPU 打印所有已完成的记录。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> _prb_read_valid(<span class="keyword">struct</span> printk_ringbuffer *rb, u64 *seq,</span><br><span class="line">			    <span class="keyword">struct</span> printk_record *r, <span class="type">unsigned</span> <span class="type">int</span> *line_count)</span><br><span class="line">&#123;</span><br><span class="line">	u64 tail_seq;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="comment">//将带有 @seq 的记录中的 ringbuffer 数据复制到提供的 @r 缓冲区</span></span><br><span class="line">	<span class="keyword">while</span> ((err = prb_read(rb, *seq, r, line_count))) &#123;</span><br><span class="line">		tail_seq = prb_first_seq(rb);	<span class="comment">//获取尾部描述符的序列号</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (*seq &lt; tail_seq) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * 在尾巴后面。赶上并重试。这可能发生在 -ENOENT 和 -EINVAL 情况下。</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			*seq = tail_seq;</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (err == -ENOENT) &#123;</span><br><span class="line">			<span class="comment">/* 记录存在，但数据丢失。跳。 */</span></span><br><span class="line">			(*seq)++;</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * 不存在/未完成的记录。必须停止。</span></span><br><span class="line"><span class="comment">			 *</span></span><br><span class="line"><span class="comment">			 * 在 panic 情况下，不能期望未完成的记录会变为完成状态。</span></span><br><span class="line"><span class="comment">			 * 但可能存在其他需要在 panic 情况下打印的已完成记录。</span></span><br><span class="line"><span class="comment">			 * 如果这是 panic CPU，则跳过此不存在/未完成的记录，</span></span><br><span class="line"><span class="comment">			 * 除非它位于或超过头部，在这种情况下无法继续。</span></span><br><span class="line"><span class="comment">			 *</span></span><br><span class="line"><span class="comment">			 * 请注意，在这里时，panic CPU 上打印的新消息是已完成的。</span></span><br><span class="line"><span class="comment">			 * 唯一的例外可能是没有尾随换行符的最后一条消息。</span></span><br><span class="line"><span class="comment">			 * 但它的序列号将是 &quot;prb_next_reserve_seq() - 1&quot; 返回的值。</span></span><br><span class="line"><span class="comment">			 * prb_next_reserve_seq 获取最近保留记录之后的序列号。</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (this_cpu_in_panic() &amp;&amp; ((*seq + <span class="number">1</span>) &lt; prb_next_reserve_seq(rb)))</span><br><span class="line">				(*seq)++;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="desc-update-last-finalized-将-last-finalized-seq-更新为这些记录中的最新记录"><a href="#desc-update-last-finalized-将-last-finalized-seq-更新为这些记录中的最新记录" class="headerlink" title="desc_update_last_finalized 将 @last_finalized_seq 更新为这些记录中的最新记录"></a>desc_update_last_finalized 将 @last_finalized_seq 更新为这些记录中的最新记录</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 检查是否有紧跟在 @last_finalized_seq 之后的记录已完成。如果是这样，请将 @last_finalized_seq 更新为这些记录中的最新记录。不允许跳过尚未完成的记录。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">desc_update_last_finalized</span><span class="params">(<span class="keyword">struct</span> printk_ringbuffer *rb)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">prb_desc_ring</span> *<span class="title">desc_ring</span> =</span> &amp;rb-&gt;desc_ring;</span><br><span class="line">	u64 old_seq = desc_last_finalized_seq(rb);	<span class="comment">//获取最后一个已完成的序列号</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> oldval;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> newval;</span><br><span class="line">	u64 finalized_seq;</span><br><span class="line">	u64 try_seq;</span><br><span class="line"></span><br><span class="line">try_again:</span><br><span class="line">	finalized_seq = old_seq;</span><br><span class="line">	try_seq = finalized_seq + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 尝试查找以后的最终记录。*/</span></span><br><span class="line">	<span class="comment">//非阻塞读取记录</span></span><br><span class="line">	<span class="keyword">while</span> (_prb_read_valid(rb, &amp;try_seq, <span class="literal">NULL</span>, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">		finalized_seq = try_seq;</span><br><span class="line">		try_seq++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果未找到以后的最终记录，则无需更新。*/</span></span><br><span class="line">	<span class="keyword">if</span> (finalized_seq == old_seq)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	oldval = __u64seq_to_ulseq(old_seq);</span><br><span class="line">	newval = __u64seq_to_ulseq(finalized_seq);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!atomic_long_try_cmpxchg_release(&amp;desc_ring-&gt;last_finalized_seq,</span><br><span class="line">				&amp;oldval, newval)) &#123; <span class="comment">/* LMM(desc_update_last_finalized:A) */</span></span><br><span class="line">		old_seq = __ulseq_to_u64seq(rb, oldval);</span><br><span class="line">		<span class="keyword">goto</span> try_again;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="prb-final-commit-将（以前保留的）数据提交并完成到环形缓冲区"><a href="#prb-final-commit-将（以前保留的）数据提交并完成到环形缓冲区" class="headerlink" title="prb_final_commit 将（以前保留的）数据提交并完成到环形缓冲区"></a>prb_final_commit 将（以前保留的）数据提交并完成到环形缓冲区</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * prb_final_commit（） - 将（以前保留的）数据提交并完成到环形缓冲区。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @e：包含保留数据信息的条目。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这是 writer 可用于提交 finalize 数据的公共函数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 最终确定后，数据将立即提供给读者。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 仅当无意使用 prb_reserve_in_last（） 扩展此数据时，才应使用此函数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 上下文：任何上下文。启用本地中断。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">prb_final_commit</span><span class="params">(<span class="keyword">struct</span> prb_reserved_entry *e)</span></span><br><span class="line">&#123;</span><br><span class="line">	_prb_commit(e, desc_finalized);</span><br><span class="line"></span><br><span class="line">	desc_update_last_finalized(e-&gt;rb);	<span class="comment">//更新 @last_finalized_seq</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="kernel-printk-printk-safe-c-安全打印"><a href="#kernel-printk-printk-safe-c-安全打印" class="headerlink" title="kernel&#x2F;printk&#x2F;printk_safe.c 安全打印"></a>kernel&#x2F;printk&#x2F;printk_safe.c 安全打印</h1><h2 id="force-con-强制输出到控制台"><a href="#force-con-强制输出到控制台" class="headerlink" title="force_con 强制输出到控制台"></a>force_con 强制输出到控制台</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* printk 消息永远不会被禁止显示的上下文 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">atomic_t</span> force_con;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printk_force_console_enter</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">atomic_inc</span>(&amp;force_con);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printk_force_console_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">atomic_dec</span>(&amp;force_con);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_printk_force_console</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="type">atomic_read</span>(&amp;force_con);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="kernel-printk-nbcon-c-Non-Blocking-Console-非阻塞控制台"><a href="#kernel-printk-nbcon-c-Non-Blocking-Console-非阻塞控制台" class="headerlink" title="kernel&#x2F;printk&#x2F;nbcon.c Non-Blocking Console 非阻塞控制台"></a>kernel&#x2F;printk&#x2F;nbcon.c Non-Blocking Console 非阻塞控制台</h1><h2 id="nbcon-get-cpu-emergency-nesting-获取每个-CPU-的-nbcon-紧急嵌套计数"><a href="#nbcon-get-cpu-emergency-nesting-获取每个-CPU-的-nbcon-紧急嵌套计数" class="headerlink" title="nbcon_get_cpu_emergency_nesting 获取每个 CPU 的 nbcon 紧急嵌套计数"></a>nbcon_get_cpu_emergency_nesting 获取每个 CPU 的 nbcon 紧急嵌套计数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Track the nbcon emergency nesting per CPU. */</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">DEFINE_PER_CPU</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span>, nbcon_pcpu_emergency_nesting)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> early_nbcon_pcpu_emergency_nesting __initdata;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __ref <span class="type">unsigned</span> <span class="type">int</span> *<span class="title function_">nbcon_get_cpu_emergency_nesting</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *__printk_percpu_data_ready 的值在正常上下文中和 SMP 初始化之前设置。因此，在 nbcon 紧急区域内，它永远不会改变.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!printk_percpu_data_ready()) <span class="comment">//start_kernel 到 setup_log_buf之前不为true</span></span><br><span class="line">		<span class="keyword">return</span> &amp;early_nbcon_pcpu_emergency_nesting;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> raw_cpu_ptr(&amp;nbcon_pcpu_emergency_nesting);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="nbcon-get-default-prio-获取nbcon-默认优先级"><a href="#nbcon-get-default-prio-获取nbcon-默认优先级" class="headerlink" title="nbcon_get_default_prio 获取nbcon 默认优先级"></a>nbcon_get_default_prio 获取nbcon 默认优先级</h2><ol>
<li>初始化setup_log_buf之前为<code>NBCON_PRIO_EMERGENCY</code>,之后为<code>NBCON_PRIO_NORMAL</code>。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> nbcon_prio <span class="title function_">nbcon_get_default_prio</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> *cpu_emergency_nesting;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (this_cpu_in_panic())   <span class="comment">//当前 CPU 处于 panic 状态</span></span><br><span class="line">		<span class="keyword">return</span> NBCON_PRIO_PANIC;</span><br><span class="line"></span><br><span class="line">	cpu_emergency_nesting = nbcon_get_cpu_emergency_nesting();</span><br><span class="line">	<span class="keyword">if</span> (*cpu_emergency_nesting)</span><br><span class="line">		<span class="keyword">return</span> NBCON_PRIO_EMERGENCY;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> NBCON_PRIO_NORMAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="非阻塞控制台-nbcon-的所有权获取机制"><a href="#非阻塞控制台-nbcon-的所有权获取机制" class="headerlink" title="非阻塞控制台(nbcon)的所有权获取机制"></a>非阻塞控制台(nbcon)的所有权获取机制</h2><p>此代码片段是Linux内核非阻塞控制台(nbcon)子系统的<strong>心脏</strong>, 它实现了一套极其精巧、健壮、且分级的<strong>所有权获取(acquire)机制</strong>。这套机制的根本原理是<strong>允许多个不同优先级、不同上下文(包括可休眠的、中断、NMI、系统恐慌等)的代码, 能够安全、高效地竞争同一个物理控制台(如UART)的”打印权”</strong>。</p>
<p>这是一个为解决最极端并发情况而设计的微型状态机, 其核心是围绕一个原子的<code>nbcon_state</code>变量进行转换, 以确保在任何时刻只有一个执行上下文可以向硬件写入数据。</p>
<hr>
<h3 id="核心概念-struct-nbcon-state"><a href="#核心概念-struct-nbcon-state" class="headerlink" title="核心概念: struct nbcon_state"></a>核心概念: <code>struct nbcon_state</code></h3><p>这是一个打包在单个原子变量中的状态机。它包含了所有权的关键信息:</p>
<ul>
<li><code>prio</code>: 当前所有者的优先级 (最高的是<code>PANIC</code>, 最低的是<code>NONE</code>)。</li>
<li><code>req_prio</code>: <strong>请求</strong>所有权的、更高优先级等待者的优先级。</li>
<li><code>unsafe</code>: 一个标志, 表示控制台硬件可能处于不一致的状态(例如, 在一个原子写操作的中间被抢占)。</li>
<li><code>cpu</code>: 当前所有者所在的CPU核心。</li>
<li><code>unsafe_takeover</code>: 一个标志, 表示发生过一次”不安全的强制接管”。</li>
</ul>
<hr>
<h3 id="nbcon-context-try-acquire-所有权获取的总入口"><a href="#nbcon-context-try-acquire-所有权获取的总入口" class="headerlink" title="nbcon_context_try_acquire: 所有权获取的总入口"></a><code>nbcon_context_try_acquire</code>: 所有权获取的总入口</h3><p>此函数是所有打印操作的入口点。它按顺序尝试三种不同的策略来获取控制台的所有权。</p>
<p><strong>原理与工作流程:</strong> 它是一个三级瀑布模型: <strong>尝试直接获取 -&gt; 失败则尝试礼貌地接管 -&gt; 再失败则尝试强制抢占</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">nbcon_context_try_acquire</span><span class="params">(<span class="keyword">struct</span> nbcon_context *ctxt, <span class="type">bool</span> is_reacquire)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">console</span> *<span class="title">con</span> =</span> ctxt-&gt;console;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nbcon_state</span> <span class="title">cur</span>;</span></span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">	nbcon_state_read(con, &amp;cur); <span class="comment">/* 读取当前的状态 */</span></span><br><span class="line">try_again:</span><br><span class="line">	<span class="comment">/* 策略1: 尝试直接获取 */</span></span><br><span class="line">	err = nbcon_context_try_acquire_direct(ctxt, &amp;cur, is_reacquire);</span><br><span class="line">	<span class="keyword">if</span> (err != -EBUSY) <span class="comment">/* 如果不是&quot;繁忙&quot;错误, 说明已成功或发生不可恢复错误 */</span></span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 策略2: 如果直接获取因&quot;繁忙&quot;而失败, 尝试礼貌地请求&quot;交接&quot;(handover) */</span></span><br><span class="line">	err = nbcon_context_try_acquire_handover(ctxt, &amp;cur);</span><br><span class="line">	<span class="keyword">if</span> (err == -EAGAIN) <span class="comment">/* 如果handover期间状态变化, 重新从策略1开始 */</span></span><br><span class="line">		<span class="keyword">goto</span> try_again;</span><br><span class="line">	<span class="keyword">if</span> (err != -EBUSY) <span class="comment">/* 如果不是&quot;繁忙&quot;错误, 结束 */</span></span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 策略3: 如果handover也因&quot;繁忙&quot;而失败, 尝试最后的手段: &quot;强制抢占&quot;(hostile takeover) */</span></span><br><span class="line">	err = nbcon_context_try_acquire_hostile(ctxt, &amp;cur);</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> (err) <span class="comment">/* 如果最终有任何错误, 返回false */</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 获取成功. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 为当前上下文分配正确的打印缓冲区 (恐慌时使用专用缓冲区) */</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="type">atomic_read</span>(&amp;panic_cpu) == cpu)</span><br><span class="line">		ctxt-&gt;pbufs = &amp;panic_nbcon_pbufs;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		ctxt-&gt;pbufs = con-&gt;pbufs;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 设置本轮打印的起始日志序列号 */</span></span><br><span class="line">	ctxt-&gt;seq = nbcon_seq_read(ctxt-&gt;console);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="策略-2-nbcon-context-try-acquire-handover-礼貌的交接"><a href="#策略-2-nbcon-context-try-acquire-handover-礼貌的交接" class="headerlink" title="策略 2: nbcon_context_try_acquire_handover (礼貌的交接)"></a>策略 2: <code>nbcon_context_try_acquire_handover</code> (礼貌的交接)</h3><p>当直接获取因控制台繁忙而失败时, 此函数被调用。它适用于<strong>一个高优先级上下文需要从一个正在”不安全”区域内打印的低优先级上下文中接管控制台</strong>的场景。</p>
<p><strong>原理:</strong> “敲门并等待”。它不会粗暴地抢占, 而是先原子地设置<code>req_prio</code>字段, 向当前所有者发出一个”交接请求”。然后它进入一个带超时的自旋等待循环, 等待当前所有者在退出”不安全”区域时检查到这个请求, 并主动释放所有权。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">nbcon_context_try_acquire_handover</span><span class="params">(<span class="keyword">struct</span> nbcon_context *ctxt,</span></span><br><span class="line"><span class="params">					      <span class="keyword">struct</span> nbcon_state *cur)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// ... 省略大量前置检查 ...</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 步骤1: &quot;敲门&quot; - 设置交接请求.</span></span><br><span class="line"><span class="comment">	 * 通过cmpxchg原子地将ctxt-&gt;prio写入到状态的req_prio字段.</span></span><br><span class="line"><span class="comment">	 * 如果失败(说明状态已变), 返回-EAGAIN让上层重试.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	new.atom = cur-&gt;atom;</span><br><span class="line">	new.req_prio = ctxt-&gt;prio;</span><br><span class="line">	<span class="keyword">if</span> (!nbcon_state_try_cmpxchg(con, cur, &amp;new))</span><br><span class="line">		<span class="keyword">return</span> -EAGAIN;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 步骤2: &quot;等待&quot; - 进入带超时的自旋等待循环. */</span></span><br><span class="line">	<span class="keyword">for</span> (timeout = ctxt-&gt;spinwait_max_us; timeout &gt;= <span class="number">0</span>; timeout--) &#123;</span><br><span class="line">		<span class="comment">/* 在循环中, 反复调用 _requested 函数尝试获取. */</span></span><br><span class="line">		request_err = nbcon_context_try_acquire_requested(ctxt, cur);</span><br><span class="line">		<span class="keyword">if</span> (!request_err) <span class="comment">/* 如果获取成功, 返回0. */</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (request_err == -EPERM) <span class="comment">/* 如果被更高优先级抢单, 退出. */</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		udelay(<span class="number">1</span>); <span class="comment">/* 短暂延迟, 避免烧尽CPU. */</span></span><br><span class="line">		nbcon_state_read(con, cur); <span class="comment">/* 重新读取状态. */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 步骤3: &quot;清理&quot; - 如果超时或被抢单, 必须撤销自己的请求.</span></span><br><span class="line"><span class="comment">	 * 这是一个复杂的do-while循环, 确保能原子地将req_prio清零,</span></span><br><span class="line"><span class="comment">	 * 或者在清理过程中&quot;幸运地&quot;获取到锁.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">// ... 省略清理逻辑 ...</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> request_err; <span class="comment">/* 返回超时或被抢单的错误. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>nbcon_context_try_acquire_requested</code> (交接的助手)</strong>: 此函数在<code>handover</code>的等待循环中被反复调用。它检查当前所有者是否已经释放了锁(<code>cur-&gt;prio == NBCON_PRIO_NONE</code>), 并且自己是否仍然是合法的等待者。如果条件满足, 它就执行最终的原子交换来获取所有权。</p>
<hr>
<h3 id="策略-3-nbcon-context-try-acquire-hostile-强制抢占"><a href="#策略-3-nbcon-context-try-acquire-hostile-强制抢占" class="headerlink" title="策略 3: nbcon_context_try_acquire_hostile (强制抢占)"></a>策略 3: <code>nbcon_context_try_acquire_hostile</code> (强制抢占)</h3><p>这是最后的、最极端的手段, 只有在系统<code>panic</code>时才被允许。</p>
<p><strong>原理:</strong> “破门而入”。它完全无视当前的所有者和状态, 使用一个<code>do-while</code>循环来<strong>强行</strong>用<code>cmpxchg</code>将状态机设置为自己拥有。它会继承并设置<code>unsafe</code>和<code>unsafe_takeover</code>标志, 明确记录下这次粗暴的抢占, 并警告系统后续的打印可能是在一个不一致的硬件状态下进行的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">nbcon_context_try_acquire_hostile</span><span class="params">(<span class="keyword">struct</span> nbcon_context *ctxt,</span></span><br><span class="line"><span class="params">					     <span class="keyword">struct</span> nbcon_state *cur)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 检查是否允许强制抢占, 且优先级是否为PANIC. */</span></span><br><span class="line">	<span class="keyword">if</span> (!ctxt-&gt;allow_unsafe_takeover || WARN_ON_ONCE(ctxt-&gt;prio != NBCON_PRIO_PANIC))</span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 使用do-while循环, 保证cmpxchg最终能成功. */</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		new.atom = cur-&gt;atom;</span><br><span class="line">		new.cpu			= cpu;</span><br><span class="line">		new.prio		= ctxt-&gt;prio;</span><br><span class="line">		<span class="comment">/* 继承并设置所有&quot;不安全&quot;标志. */</span></span><br><span class="line">		new.unsafe		|= cur-&gt;unsafe_takeover;</span><br><span class="line">		new.unsafe_takeover	|= cur-&gt;unsafe;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">while</span> (!nbcon_state_try_cmpxchg(con, cur, &amp;new));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="printk日志序列号的64位到32位转换与重建"><a href="#printk日志序列号的64位到32位转换与重建" class="headerlink" title="printk日志序列号的64位到32位转换与重建"></a><code>printk</code>日志序列号的64位到32位转换与重建</h2><p>此代码片段展示了Linux内核<code>printk</code>子系统中一个非常精巧的优化设计, 它解决了如何在只存储一个32位”进度标记”的情况下, 可靠地重建出完整的64位日志序列号的问题。</p>
<p><strong>核心原理:</strong><br>内核的主日志环形缓冲区(<code>printk ring buffer</code>, <code>prb</code>)使用一个永不回绕的64位序列号(<code>u64seq</code>)来唯一标识每一条日志记录。然而, 为每一个控制台(console)都维护一个64位的原子变量来记录其打印进度是非常昂贵的, 尤其是在32位系统上。为了优化, 内核为每个非阻塞控制台(nbcon)只存储了一个32位的原子进度标记(<code>ulseq</code>)。</p>
<p>此代码的核心原理就是<strong>基于一个”就近原则”的滑动窗口算法, 从一个32位的局部进度标记, 可靠地推断出它在64位全局序列号空间中的确切位置</strong>。这个算法的基石是以下这个非常合理的假设: <strong>任何一个控制台的处理进度, 相对于<code>printk</code>主缓冲区的当前内容, 其滞后或超前的记录数都不会超过2^31 (约21亿条)</strong>。</p>
<hr>
<h3 id="ulseq-to-u64seq-32位到64位序列号的重建引擎"><a href="#ulseq-to-u64seq-32位到64位序列号的重建引擎" class="headerlink" title="__ulseq_to_u64seq: 32位到64位序列号的重建引擎"></a><code>__ulseq_to_u64seq</code>: 32位到64位序列号的重建引擎</h3><p>这是实现上述原理的核心算法。它利用有符号和无符号整数算术的特性来巧妙地解决歧义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * __ulseq_to_u64seq: 将一个32位的 ulseq 重建为64位的 u64seq.</span></span><br><span class="line"><span class="comment"> * @rb: 指向 printk 环形缓冲区的指针.</span></span><br><span class="line"><span class="comment"> * @ulseq: 从控制台读取的32位进度标记.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> u64 __ulseq_to_u64seq(<span class="keyword">struct</span> printk_ringbuffer *rb, u32 ulseq)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 获取环形缓冲区中现存的&quot;第一条&quot;(最老)记录的完整64位序列号. */</span></span><br><span class="line">	u64 rb_first_seq = prb_first_seq(rb);</span><br><span class="line">	u64 seq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 提供的序列号只是环形缓冲区序列号的低32位.</span></span><br><span class="line"><span class="comment">	 * 它需要被扩展到64位. 我们获取环形缓冲区中的第一个序列号并将其折叠.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 在控制台中保留一个32位的表示就足够了.</span></span><br><span class="line"><span class="comment">	 * 如果一个控制台真的落后环形缓冲区超过2^31条记录,</span></span><br><span class="line"><span class="comment">	 * 那么这已经是最小的问题了(意味着大量日志已丢失).</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 此外, 对环形缓冲区的访问总是安全的.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 这是核心重建算法 */</span></span><br><span class="line">	seq = rb_first_seq - (s32)((u32)rb_first_seq - ulseq);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> seq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>算法解析:</strong><br><code>seq = rb_first_seq - (s32)((u32)rb_first_seq - ulseq);</code></p>
<ol>
<li><code>(u32)rb_first_seq</code>: 取出缓冲区中最老记录的64位序列号的<strong>低32位</strong>。</li>
<li><code>((u32)rb_first_seq - ulseq)</code>: 计算这两个32位无符号整数的差值。由于无符号算术的回绕特性, 这个差值正确地表示了它们之间的距离, 即使发生了32位的回绕。</li>
<li><code>(s32)(...)</code>: <strong>这是最关键的一步</strong>。它将上一步得到的无符号差值强制转换为一个<strong>有符号的32位整数</strong>。<ul>
<li>如果<code>ulseq</code>稍微落后于<code>rb_first_seq</code>的低32位, 这个差值会是一个很大的正数, 转换后会成为一个小的负数(代表”落后了少量”)。</li>
<li>如果<code>ulseq</code>稍微领先于<code>rb_first_seq</code>的低32位, 这个差值会是一个小的正数(代表”领先了少量”)。</li>
</ul>
</li>
<li><code>rb_first_seq - (s32)(...)</code>: 从完整的64位基准序列号中减去这个有符号的32位”偏移量”。<ul>
<li>减去一个负数等于加上一个正数, 这就将落后的序列号正确地向前调整。</li>
<li>减去一个正数, 这就将领先的序列号正确地向后调整。</li>
</ul>
</li>
</ol>
<p>通过这种方式, 函数总能找到距离<code>rb_first_seq</code>“最近”的那个64位序列号, 其低32位与<code>ulseq</code>完全匹配, 从而完成了精确的重建。</p>
<hr>
<h3 id="nbcon-seq-read-安全地读取控制台进度"><a href="#nbcon-seq-read-安全地读取控制台进度" class="headerlink" title="nbcon_seq_read: 安全地读取控制台进度"></a><code>nbcon_seq_read</code>: 安全地读取控制台进度</h3><p>这是一个上层的API函数, 负责从一个给定的控制台安全地读取其32位的进度标记, 并调用重建函数将其转换为完整的64位序列号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * nbcon_seq_read - 读取当前控制台的序列号</span></span><br><span class="line"><span class="comment"> * @con:	要读取序列号的控制台</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回:	在 @con 上将要打印的下一条记录的序列号.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">u64 <span class="title function_">nbcon_seq_read</span><span class="params">(<span class="keyword">struct</span> console *con)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 使用 atomic_long_read 原子地读取存储在控制台私有数据中的32位进度标记.</span></span><br><span class="line"><span class="comment">	 * &quot;原子地&quot;是关键, 它确保了即使在单核抢占式系统上, 读取操作也不会被中断</span></span><br><span class="line"><span class="comment">	 * 或其他任务的写入操作干扰, 从而避免了读取到不一致的撕裂值.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> nbcon_seq = atomic_long_read(&amp;ACCESS_PRIVATE(con, nbcon_seq));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 将读取到的32位值传递给重建函数, 得到完整的64位序列号并返回.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> __ulseq_to_u64seq(prb, nbcon_seq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="其他辅助宏"><a href="#其他辅助宏" class="headerlink" title="其他辅助宏"></a>其他辅助宏</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * __u64seq_to_ulseq: 将64位序列号转换为32位进度标记的简单宏.</span></span><br><span class="line"><span class="comment"> * 这在更新控制台进度时使用, 它简单地截取低32位.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __u64seq_to_ulseq(u64seq) ((u32)u64seq)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ULSEQ_MAX: 计算一个32位序列号的最大有效值.</span></span><br><span class="line"><span class="comment"> * 它的值是环形缓冲区起始序列号加上2^31. 这可能用于边界检查, 以判断一个控制台</span></span><br><span class="line"><span class="comment"> * 是否已经落后得太远, 以至于其状态已不可信.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ULSEQ_MAX(rb) __u64seq_to_ulseq(prb_first_seq(rb) + 0x80000000UL)</span></span><br></pre></td></tr></table></figure>

<h2 id="nbcon-context-release-安全地释放非阻塞控制台的所有权"><a href="#nbcon-context-release-安全地释放非阻塞控制台的所有权" class="headerlink" title="nbcon_context_release: 安全地释放非阻塞控制台的所有权"></a>nbcon_context_release: 安全地释放非阻塞控制台的所有权</h2><p>此函数是Linux内核非阻塞控制台(<code>nbcon</code>)所有权机制的另一半, 是<code>nbcon_context_try_acquire</code>的配对操作。它的核心原理是<strong>提供一个原子性的、有条件的、并且健壮的方法来 relinquishment (放弃) 一个先前获取到的控制台”打印权”</strong>。</p>
<p>这个函数的设计核心是安全, 它必须能正确处理一种关键的并发情况: 在一个上下文正准备释放所有权时, 一个更高优先级的上下文(如NMI或系统恐慌)可能会突然”抢占”这个所有权。此函数通过一个比较并交换(Compare-and-Swap, CAS)的循环来优雅地处理这种情况。</p>
<p><strong>工作流程详解:</strong></p>
<ol>
<li><strong>读取当前状态</strong>: 函数首先调用<code>nbcon_state_read</code>来获取控制台当前最新的原子状态<code>cur</code>。</li>
<li><strong>进入CAS循环</strong>: 函数进入一个<code>do-while</code>循环。这个循环的目的是保证状态更新的原子性, 如果在循环体内, 当我们准备写入新状态时, 发现原子状态已经被其他上下文修改了, <code>cmpxchg</code>就会失败, 循环会重试。</li>
<li><strong>验证所有权</strong>: 在循环内部, <strong>最关键的第一步</strong>是调用<code>nbcon_owner_matches</code>。这个检查会验证”当前这个执行上下文(<code>ctxt</code>)是否仍然是<code>cur</code>状态所记录的那个合法所有者”。<ul>
<li>如果不是(返回<code>false</code>), 这意味着在我们读取<code>cur</code>之后, 已经有一个更高优先级的上下文抢占了所有权。在这种情况下, 我们已经无权可放, 也没有必要再做任何操作, 函数会立即<code>break</code>跳出循环。</li>
</ul>
</li>
<li><strong>准备新状态</strong>: 如果所有权被验证, 函数会准备一个新的目标状态<code>new</code>。<ul>
<li>最重要的改变是 <code>new.prio = NBCON_PRIO_NONE;</code>。这将优先级设置为”无所有者”, 从而向系统宣告该控制台现在可用了。</li>
<li><strong>保留”不安全”标记</strong>: 它会执行 <code>new.unsafe |= cur.unsafe_takeover;</code>。这是一个关键的”污点”传播机制。如果此控制台之前经历过一次”不安全的强制接管”, <code>unsafe_takeover</code>标志就会被设置。此代码确保了这个标志一旦被设置, 就会被永久地保留在<code>unsafe</code>标志中。这意味着, 一个曾被粗暴对待过的控制台, 会被永久性地标记为”不安全”, 以防止后续的常规打印上下文在可能不一致的硬件状态上进行操作。</li>
</ul>
</li>
<li><strong>原子更新</strong>: 函数调用<code>nbcon_state_try_cmpxchg(con, &amp;cur, &amp;new)</code>来尝试原子地将控制台的状态从<code>cur</code>更新为<code>new</code>。只有当控制台的当前状态仍然是<code>cur</code>时, 这个操作才会成功。</li>
<li><strong>清理上下文</strong>: 在循环结束后(无论是否成功更新), 函数会将上下文中的打印缓冲区指针<code>pbufs</code>清空(<code>ctxt-&gt;pbufs = NULL;</code>), 这是一个良好的实践, 可以防止调用者在此上下文被释放后, 仍然错误地通过它访问缓冲区。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * nbcon_context_release - 释放控制台</span></span><br><span class="line"><span class="comment"> * @ctxt:	从 nbcon_context_try_acquire() 获取到的nbcon上下文</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">nbcon_context_release</span><span class="params">(<span class="keyword">struct</span> nbcon_context *ctxt)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> cpu = smp_processor_id();</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">console</span> *<span class="title">con</span> =</span> ctxt-&gt;console;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nbcon_state</span> <span class="title">cur</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nbcon_state</span> <span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 读取控制台的当前原子状态. */</span></span><br><span class="line">	nbcon_state_read(con, &amp;cur);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 进入一个 do-while 循环, 以原子方式更新状态.</span></span><br><span class="line"><span class="comment">	 * 循环条件是 &quot;当比较并交换失败时, 继续循环&quot;.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 关键检查: 确认我们(当前的cpu和优先级)是否仍然是当前的所有者.</span></span><br><span class="line"><span class="comment">		 * 如果不是, 说明所有权已经被更高优先级的上下文抢占了, 我们无权释放.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!nbcon_owner_matches(&amp;cur, cpu, ctxt-&gt;prio))</span><br><span class="line">			<span class="keyword">break</span>; <span class="comment">/* 跳出循环, 不做任何事. */</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 准备要写入的新状态. */</span></span><br><span class="line">		new.atom = cur.atom;</span><br><span class="line">		<span class="comment">/* 将优先级设置为&quot;无所有者&quot;, 表示释放锁. */</span></span><br><span class="line">		new.prio = NBCON_PRIO_NONE;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 如果 unsafe_takeover 标志被设置了, 它将被保留下来,</span></span><br><span class="line"><span class="comment">		 * 以便该状态保持永久性的不安全.</span></span><br><span class="line"><span class="comment">		 * 这是一种&quot;污点&quot;传播机制.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		new.unsafe |= cur.unsafe_takeover;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 尝试原子地将状态从 cur 更新为 new. 如果失败, 重新读取 cur 并重试. */</span></span><br><span class="line">	&#125; <span class="keyword">while</span> (!nbcon_state_try_cmpxchg(con, &amp;cur, &amp;new));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 清理上下文中的缓冲区指针, 防止悬空引用. */</span></span><br><span class="line">	ctxt-&gt;pbufs = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="nbcon-context-can-proceed-非阻塞控制台-nbcon-所有权检查与礼让机制"><a href="#nbcon-context-can-proceed-非阻塞控制台-nbcon-所有权检查与礼让机制" class="headerlink" title="nbcon_context_can_proceed: 非阻塞控制台(nbcon)所有权检查与礼让机制"></a><code>nbcon_context_can_proceed</code>: 非阻塞控制台(nbcon)所有权检查与礼让机制</h2><p>此函数是Linux内核非阻塞控制台(<code>nbcon</code>)子系统中<strong>实现”协作式多任务”(Cooperative Multitasking)的核心决策逻辑</strong>。它在<code>nbcon</code>打印流程的各个关键检查点被调用, 其核心原理是<strong>回答一个关键问题: “我这个当前的打印上下文, 是否还有权继续向前执行?”</strong>。</p>
<p>这个函数不仅仅是一个简单的所有权检查, 它还内置了<strong>主动礼让(yield)给更高优先级等待者</strong>的机制, 这是实现<code>nbcon</code>在复杂抢占场景下既能高效工作又不会死锁的关键。</p>
<hr>
<h3 id="nbcon-context-can-proceed-核心决策逻辑"><a href="#nbcon-context-can-proceed-核心决策逻辑" class="headerlink" title="nbcon_context_can_proceed: 核心决策逻辑"></a><code>nbcon_context_can_proceed</code>: 核心决策逻辑</h3><p><strong>原理与工作流程:</strong><br>函数按照一个精心设计的决策树来判断是否可以继续:</p>
<ol>
<li><p><strong>基础所有权检查</strong>: <code>if (!nbcon_owner_matches(cur, cpu, ctxt-&gt;prio))</code></p>
<ul>
<li><strong>问题:</strong> “我还是不是记录在案的那个所有者?”</li>
<li><strong>逻辑:</strong> 这是最基础的检查。如果<code>nbcon_state</code>中记录的所有者CPU和优先级与当前上下文不匹配, 意味着所有权已经被(通常是更高优先级的)上下文<strong>强制抢占</strong>了。此时必须立即返回<code>false</code>, 表示”停止一切”。</li>
</ul>
</li>
<li><p><strong>无等待者检查</strong>: <code>if (cur-&gt;req_prio == NBCON_PRIO_NONE)</code></p>
<ul>
<li><strong>问题:</strong> “有人在等我吗?”</li>
<li><strong>逻辑:</strong> 如果通过了所有权检查, 并且<code>req_prio</code>字段为<code>NONE</code>, 表示没有其他上下文正在请求”交接”(handover)。在这种最常见的情况下, 当前所有者可以安全地继续执行, 函数返回<code>true</code>。</li>
</ul>
</li>
<li><p><strong>“不安全区域”特权</strong>: <code>if (cur-&gt;unsafe)</code></p>
<ul>
<li><strong>问题:</strong> “我是否正处于一个’不安全’的操作序列中?”</li>
<li><strong>逻辑:</strong> 即使有更高优先级的上下文在等待(<code>req_prio != NONE</code>), 如果当前所有者正处于”不安全区域”(<code>cur-&gt;unsafe == true</code>), 它<strong>也被允许继续执行</strong>。</li>
<li><strong>原理:</strong> 这是为了防止活锁(livelock)。如果不允许在不安全区内继续, 那么一个高优先级请求者可能会导致低优先级所有者永远无法完成其原子操作序列(例如, 无法完成一次完整的日志发射), 从而永远无法退出不安全区来释放锁。此规则保证了当前所有者至少能完成其最小的原子工作单元。当它尝试退出不安全区时(<code>nbcon_context_exit_unsafe</code>), <code>can_proceed</code>会被再次调用, 届时它将因为<code>cur-&gt;unsafe</code>为<code>false</code>而进入下面的礼让逻辑。</li>
</ul>
</li>
<li><p><strong>主动礼让 (Yielding)</strong>:</p>
<ul>
<li><strong>场景:</strong> 如果代码执行到这里, 意味着: (a)我们是合法所有者, (b)有更高优先级的上下文在等待, (c)我们当前处于”安全”状态。</li>
<li><strong>决策:</strong> 这是”礼貌”的体现。在这种情况下, 我们<strong>不应该</strong>继续执行任何耗时的操作。函数会<strong>主动调用<code>nbcon_context_release(ctxt)</code>来释放自己持有的锁</strong>, 为更高优先级的等待者让路。</li>
<li><strong>返回值:</strong> 在主动释放锁之后, 函数返回<code>false</code>。这告知调用者”你不再拥有所有权, 必须中止当前操作并从头开始”。</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">nbcon_context_can_proceed</span><span class="params">(<span class="keyword">struct</span> nbcon_context *ctxt, <span class="keyword">struct</span> nbcon_state *cur)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> cpu = smp_processor_id();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 决策1: 基础所有权检查. 如果我不再是所有者, 立即返回false. */</span></span><br><span class="line">	<span class="keyword">if</span> (!nbcon_owner_matches(cur, cpu, ctxt-&gt;prio))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 决策2: 检查是否有等待者. 如果没有, 可以继续. */</span></span><br><span class="line">	<span class="keyword">if</span> (cur-&gt;req_prio == NBCON_PRIO_NONE)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 决策3: 检查是否在不安全区内.</span></span><br><span class="line"><span class="comment">	 * 即使有等待者, 在不安全区内的所有者也必须被允许继续,</span></span><br><span class="line"><span class="comment">	 * 以完成其原子操作序列. 它将在退出不安全区时执行交接.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (cur-&gt;unsafe)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 如果执行到这里, 说明我们在安全状态, 且有更高优先级的上下文在等待.</span></span><br><span class="line"><span class="comment">	 * 这是一个让出所有权的&quot;安全点&quot;.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 健全性检查: 等待者的优先级必须高于当前所有者. */</span></span><br><span class="line">	WARN_ON_ONCE(cur-&gt;req_prio &lt;= cur-&gt;prio);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 决策4: 主动礼让.</span></span><br><span class="line"><span class="comment">	 * 调用 nbcon_context_release() 来释放锁, 为等待者让路.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	nbcon_context_release(ctxt);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 在释放锁之后, 我们不再拥有所有权, 因此返回false,</span></span><br><span class="line"><span class="comment">	 * 强制上层调用栈中止当前操作.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="nbcon-can-proceed-便捷的API封装"><a href="#nbcon-can-proceed-便捷的API封装" class="headerlink" title="nbcon_can_proceed: 便捷的API封装"></a><code>nbcon_can_proceed</code>: 便捷的API封装</h3><p>这是一个上层的、导出的API函数, 它为<code>nbcon</code>的使用者(主要是驱动的回调函数)提供了一个简洁的接口。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * nbcon_can_proceed - 检查所有权是否可以继续</span></span><br><span class="line"><span class="comment"> * @wctxt:	传递给写函数的回调上下文</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * (函数注释与 nbcon_context_can_proceed 相同)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">nbcon_can_proceed</span><span class="params">(<span class="keyword">struct</span> nbcon_write_context *wctxt)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 从写上下文中提取出核心上下文. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nbcon_context</span> *<span class="title">ctxt</span> =</span> &amp;ACCESS_PRIVATE(wctxt, ctxt);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">console</span> *<span class="title">con</span> =</span> ctxt-&gt;console;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nbcon_state</span> <span class="title">cur</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 读取最新的状态. */</span></span><br><span class="line">	nbcon_state_read(con, &amp;cur);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 调用核心决策逻辑并返回其结果. */</span></span><br><span class="line">	<span class="keyword">return</span> nbcon_context_can_proceed(ctxt, &amp;cur);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(nbcon_can_proceed);</span><br></pre></td></tr></table></figure>

<h2 id="nbcon-上下文的”不安全区域”进出机制"><a href="#nbcon-上下文的”不安全区域”进出机制" class="headerlink" title="nbcon 上下文的”不安全区域”进出机制"></a><code>nbcon</code> 上下文的”不安全区域”进出机制</h2><p>此代码片段揭示了Linux内核非阻塞控制台(<code>nbcon</code>)子系统中一个极其精细的内部同步原语。它的核心原理是<strong>为<code>nbcon</code>的打印操作定义一个”不安全区域”(unsafe section)的边界, 并提供一个原子性的、可被抢占的进入和退出该区域的方法</strong>。</p>
<p><strong>“不安全区域”是什么?</strong><br>在<code>nbcon_emit_next_record</code>函数中, 从获取下一条日志记录开始, 到最终调用驱动的<code>write</code>回调函数并将日志输出到硬件为止, 这个过程构成了一个关键的操作序列。在这个序列的执行过程中, 硬件的状态(例如UART的FIFO填充状态)和软件的状态(例如指向缓冲区的指针)可能是暂时不一致的。如果这个序列在中间被打断(被更高优先级的上下文抢占), 那么整个控制台就处于一个”不安全”的状态。</p>
<p><code>nbcon_context_enter_unsafe</code>和<code>nbcon_context_exit_unsafe</code>这两个宏所封装的<code>__nbcon_context_update_unsafe</code>函数, 就如同这个”不安全区域”的”门卫”。它不仅负责开关门(设置&#x2F;清除状态位), 更重要的是, 它在开关门的每一步都会检查是否有人(更高优先级的上下文)正在”敲门”要求进入。</p>
<hr>
<h3 id="nbcon-context-update-unsafe-核心实现"><a href="#nbcon-context-update-unsafe-核心实现" class="headerlink" title="__nbcon_context_update_unsafe: 核心实现"></a><code>__nbcon_context_update_unsafe</code>: 核心实现</h3><p>此函数是这个”门卫”的核心逻辑。它负责原子地更新<code>nbcon_state</code>中的<code>unsafe</code>位, 并且在每一步都检查当前上下文是否仍然有权继续操作。</p>
<p><strong>原理与工作流程:</strong><br>它的核心是一个<strong>带有抢占检查的比较并交换(Compare-and-Swap, CAS)循环</strong>。</p>
<ol>
<li><strong>读取当前状态</strong>: 函数首先获取控制台最新的原子状态<code>cur</code>。</li>
<li><strong>CAS循环</strong>: 进入一个<code>do-while</code>循环以保证更新的原子性。</li>
<li><strong>“污点”检查 (Latch Mechanism)</strong>: <code>if (!unsafe &amp;&amp; cur.unsafe_takeover)</code><ul>
<li>这是进入循环后的第一道检查。它实现了一个”污点”或”闩锁”机制。</li>
<li><code>!unsafe</code>为真意味着我们正尝试<strong>退出</strong>不安全区(即调用<code>exit_unsafe</code>)。</li>
<li>但如果<code>cur.unsafe_takeover</code>为真(表示此控制台曾被粗暴地强制接管过), 那么此函数<strong>拒绝清除<code>unsafe</code>标志</strong>。</li>
<li><strong>原理:</strong> 一旦发生过强制接管, 控制台的硬件状态就可能已永久性地损坏或不一致, 内核会将其永久标记为”不安全”, 不再允许任何常规的打印操作进入, 以免造成更大的破坏。</li>
</ul>
</li>
<li><strong>抢占检查</strong>: <code>if (!nbcon_context_can_proceed(ctxt, &amp;cur))</code><ul>
<li>这是最关键的抢占检测点。在尝试修改状态之前, 它会检查: “我这个上下文, 是否仍然是合法的所有者, 并且没有更高优先级的上下文正在请求交接?”</li>
<li>如果<code>can_proceed</code>返回<code>false</code>, 意味着所有权已经被(或即将被)抢占。函数必须<strong>立即返回<code>false</code></strong>, 通知调用者(“你已经丢失所有权, 马上停止你正在做的一切!”)。</li>
</ul>
</li>
<li><strong>原子更新</strong>: 如果通过了所有检查, 函数会准备一个新的状态<code>new</code>, 其中<code>new.unsafe</code>被设置为期望的值(进入时为<code>true</code>, 退出时为<code>false</code>), 然后调用<code>nbcon_state_try_cmpxchg</code>尝试原子地更新状态。如果失败(因为状态被其他上下文改变了), CAS循环会重试。</li>
<li><strong>最终检查</strong>: 即使成功更新了<code>unsafe</code>位, 在函数返回前, 它<strong>再一次</strong>调用<code>nbcon_context_can_proceed</code>并返回其结果。这提供了双重保险, 确保即使在CAS操作成功的瞬间, 所有权也未被抢占。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* __nbcon_context_update_unsafe: 更新 con-&gt;nbcon_state 中的 unsafe 位 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> __nbcon_context_update_unsafe(<span class="keyword">struct</span> nbcon_context *ctxt, <span class="type">bool</span> unsafe)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">console</span> *<span class="title">con</span> =</span> ctxt-&gt;console;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nbcon_state</span> <span class="title">cur</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nbcon_state</span> <span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 读取控制台的当前原子状态. */</span></span><br><span class="line">	nbcon_state_read(con, &amp;cur);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 使用do-while循环来原子地更新状态. */</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * &quot;污点&quot;检查: 如果我们尝试清除unsafe标志(!unsafe),</span></span><br><span class="line"><span class="comment">		 * 但之前发生过一次&quot;不安全的强制接管&quot;, 那么不允许清除.</span></span><br><span class="line"><span class="comment">		 * 控制台将永久保持不安全状态.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!unsafe &amp;&amp; cur.unsafe_takeover)</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 抢占检查: 在尝试修改之前, 检查我们是否还有权继续.</span></span><br><span class="line"><span class="comment">		 * 如果有更高优先级的请求者, 我们必须立即中止.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!nbcon_context_can_proceed(ctxt, &amp;cur))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 准备要写入的新状态. */</span></span><br><span class="line">		new.atom = cur.atom;</span><br><span class="line">		new.unsafe = unsafe; <span class="comment">/* 设置新的unsafe值. */</span></span><br><span class="line">	<span class="comment">/* 尝试原子地将状态从 cur 更新为 new. 如果失败, 重新读取 cur 并重试. */</span></span><br><span class="line">	&#125; <span class="keyword">while</span> (!nbcon_state_try_cmpxchg(con, &amp;cur, &amp;new));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果CAS成功, 更新我们的本地状态副本. */</span></span><br><span class="line">	cur.atom = new.atom;</span><br><span class="line">out:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 最终检查: 即使我们成功更新了位, 也要最后再检查一次我们是否仍然拥有所有权.</span></span><br><span class="line"><span class="comment">	 * 这可以捕获在CAS操作期间发生的极细微的竞争.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> nbcon_context_can_proceed(ctxt, &amp;cur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="便捷宏封装"><a href="#便捷宏封装" class="headerlink" title="便捷宏封装"></a>便捷宏封装</h3><p>这两个宏的作用是提供清晰、易读的API, 让调用代码(<code>nbcon_emit_next_record</code>)的意图一目了然, 就像使用锁一样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * nbcon_context_enter_unsafe: 宏, 用于进入不安全区域.</span></span><br><span class="line"><span class="comment"> * 它调用核心函数, 并传递 true 来设置 unsafe 位.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> nbcon_context_enter_unsafe(c)	__nbcon_context_update_unsafe(c, true)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * nbcon_context_exit_unsafe: 宏, 用于退出不安全区域.</span></span><br><span class="line"><span class="comment"> * 它调用核心函数, 并传递 false 来尝试清除 unsafe 位.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> nbcon_context_exit_unsafe(c)	__nbcon_context_update_unsafe(c, false)</span></span><br></pre></td></tr></table></figure>

<h2 id="printk-get-next-message-printk-环形缓冲区的格式化读取器"><a href="#printk-get-next-message-printk-环形缓冲区的格式化读取器" class="headerlink" title="printk_get_next_message: printk 环形缓冲区的格式化读取器"></a>printk_get_next_message: <code>printk</code> 环形缓冲区的格式化读取器</h2><p>此函数是Linux内核日志系统(<code>printk</code>)的核心组成部分, 它的根本原理是<strong>充当一个从内核主日志环形缓冲区(<code>printk ring buffer</code>, <code>prb</code>)到各个控制台驱动程序之间的”格式化桥梁”</strong>。它负责根据请求, 安全地从环形缓冲区中取出下一条有效的原始日志记录, 并根据不同的需求(如是否为扩展格式、是否需要过滤日志级别)将其转换成一段人类可读的、准备发送到硬件的字符串。</p>
<p>这是一个纯粹的软件逻辑函数, 不涉及任何硬件访问, 但它实现了<code>printk</code>流程中几个至关重要的功能:</p>
<p><strong>详细工作流程与原理:</strong></p>
<ol>
<li><p><strong>缓冲区策略 (Buffer Strategy)</strong>: 函数首先根据<code>is_extended</code>标志决定其工作缓冲区。</p>
<ul>
<li><strong>标准格式 (<code>is_extended</code>为<code>false</code>)</strong>: 它直接将环形缓冲区中的原始日志文本读入最终的输出缓冲区(<code>outbuf</code>)。后续的格式化(如添加时间戳)将以**原地(in-place)**的方式完成。</li>
<li><strong>扩展格式 (<code>is_extended</code>为<code>true</code>)</strong>: 由于扩展格式的头部信息更复杂, 为了避免在构建头部时覆盖原始文本, 它首先将原始日志文本读入一个临时的”草稿缓冲区”(<code>scratchbuf</code>), 然后再将格式化的头部和来自草稿缓冲区的文本组合成最终结果, 放入<code>outbuf</code>中。</li>
</ul>
</li>
<li><p><strong>读取并处理间隙 (<code>prb_read_valid</code>)</strong>: 这是核心的数据检索步骤。它调用<code>prb_read_valid</code>并传入一个期望的序列号<code>seq</code>。</p>
<ul>
<li><strong>原理:</strong> <code>prb_read_valid</code>非常健壮, 它会尝试读取序列号为<code>seq</code>的记录。如果<code>seq</code>指向的记录因为环形缓冲区被覆盖而已经不存在了, 它<strong>会自动向前搜索并返回第一条仍然有效的记录</strong>。</li>
<li>如果没有任何有效的记录可读, 函数返回<code>false</code>, 表示读取结束。</li>
</ul>
</li>
<li><p><strong>计算丢弃数 (<code>pmsg-&gt;dropped</code>)</strong>: <code>pmsg-&gt;dropped = r.info-&gt;seq - seq;</code> 这是一个非常精妙的计算。它用<strong>实际读到的记录序列号</strong>减去<strong>期望读取的序列号</strong>, 其差值就精确地等于因为缓冲区被覆盖而丢失的记录数量。<code>nbcon_emit_next_record</code>等上层函数会利用这个值来打印<code>[... dropped ...]</code>信息。</p>
</li>
<li><p><strong>日志级别过滤 (<code>suppress_message_printing</code>)</strong>: 如果<code>may_suppress</code>标志为真(意味着调用者允许过滤), 并且记录本身没有被标记为<code>LOG_FORCE_CON</code>(强制输出到控制台), 函数就会调用<code>suppress_message_printing</code>来检查记录的日志级别是否低于当前控制台配置的日志级别。如果需要被过滤, 函数会直接<code>goto out</code>, 导致最终输出的字符串长度为0, 从而有效地跳过了这条消息。</p>
</li>
<li><p><strong>格式化输出</strong>: 如果消息未被过滤, 函数会根据<code>is_extended</code>标志, 调用相应的格式化函数(<code>info_print_ext_header</code>, <code>msg_print_ext_body</code>, <code>record_print_text</code>)来构建最终的输出字符串, 包括时间戳、日志级别、设备信息和消息正文。</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 读取并格式化指定的记录 (如果指定记录不可用, 则读取其后的第一条可用记录).</span></span><br><span class="line"><span class="comment"> * @pmsg: 指向一个 printk_message 结构体, 将用于存放格式化结果. 其pbufs成员必须指向一个有效的缓冲区.</span></span><br><span class="line"><span class="comment"> * @seq: 要读取和格式化的记录的序列号. 如果不可用, 将读取下一个有效的记录.</span></span><br><span class="line"><span class="comment"> * @is_extended: 布尔值, 指定是否应将消息格式化为扩展控制台输出.</span></span><br><span class="line"><span class="comment"> * @may_suppress: 布尔值, 指定是否可以根据日志级别抑制记录的打印.</span></span><br><span class="line"><span class="comment"> * 返回: 如果没有可用的记录, 返回false. 否则返回true, 并且@pmsg的所有字段都有效.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">printk_get_next_message</span><span class="params">(<span class="keyword">struct</span> printk_message *pmsg, u64 seq,</span></span><br><span class="line"><span class="params">			     <span class="type">bool</span> is_extended, <span class="type">bool</span> may_suppress)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">printk_buffers</span> *<span class="title">pbufs</span> =</span> pmsg-&gt;pbufs;</span><br><span class="line">	<span class="type">const</span> <span class="type">size_t</span> scratchbuf_sz = <span class="keyword">sizeof</span>(pbufs-&gt;scratchbuf);</span><br><span class="line">	<span class="type">const</span> <span class="type">size_t</span> outbuf_sz = <span class="keyword">sizeof</span>(pbufs-&gt;outbuf);</span><br><span class="line">	<span class="type">char</span> *scratchbuf = &amp;pbufs-&gt;scratchbuf[<span class="number">0</span>];</span><br><span class="line">	<span class="type">char</span> *outbuf = &amp;pbufs-&gt;outbuf[<span class="number">0</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">printk_info</span> <span class="title">info</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">printk_record</span> <span class="title">r</span>;</span></span><br><span class="line">	<span class="type">size_t</span> len = <span class="number">0</span>;</span><br><span class="line">	<span class="type">bool</span> force_con;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 缓冲区策略:</span></span><br><span class="line"><span class="comment">	 * 扩展消息需要一个单独的缓冲区来读取原始文本, 所以使用scratchbuf.</span></span><br><span class="line"><span class="comment">	 * 普通消息是原地格式化的, 所以直接将原始文本读入outbuf.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (is_extended)</span><br><span class="line">		prb_rec_init_rd(&amp;r, &amp;info, scratchbuf, scratchbuf_sz);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		prb_rec_init_rd(&amp;r, &amp;info, outbuf, outbuf_sz);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 读取并处理间隙:</span></span><br><span class="line"><span class="comment">	 * 从环形缓冲区(prb)中读取序列号&gt;=seq的第一条有效记录.</span></span><br><span class="line"><span class="comment">	 * 如果没有可读的记录, 返回false.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!prb_read_valid(prb, seq, &amp;r))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 记录我们实际读到的序列号. */</span></span><br><span class="line">	pmsg-&gt;seq = r.info-&gt;seq;</span><br><span class="line">	<span class="comment">/* 计算从期望的seq到实际读到的seq之间跳过了多少条记录. */</span></span><br><span class="line">	pmsg-&gt;dropped = r.info-&gt;seq - seq;</span><br><span class="line">	<span class="comment">/* 检查记录是否带有&quot;强制输出到控制台&quot;的标志. */</span></span><br><span class="line">	force_con = r.info-&gt;flags &amp; LOG_FORCE_CON;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 日志级别过滤:</span></span><br><span class="line"><span class="comment">	 * 如果记录不是强制输出, 并且允许抑制, 并且其级别高于控制台日志级别,</span></span><br><span class="line"><span class="comment">	 * 则跳过格式化步骤.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!force_con &amp;&amp; may_suppress &amp;&amp; suppress_message_printing(r.info-&gt;level))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 格式化输出:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (is_extended) &#123;</span><br><span class="line">		<span class="comment">/* 扩展格式: 先打印头部, 再打印消息体. */</span></span><br><span class="line">		len = info_print_ext_header(outbuf, outbuf_sz, r.info);</span><br><span class="line">		len += msg_print_ext_body(outbuf + len, out_sz - len,</span><br><span class="line">					  &amp;r.text_buf[<span class="number">0</span>], r.info-&gt;text_len, &amp;r.info-&gt;dev_info);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* 普通格式: 原地格式化, 添加时间戳等前缀. */</span></span><br><span class="line">		len = record_print_text(&amp;r, console_msg_format &amp; MSG_FORMAT_SYSLOG, printk_time);</span><br><span class="line">	&#125;</span><br><span class="line">out:</span><br><span class="line">	<span class="comment">/* 记录最终格式化字符串的长度. 如果被过滤, len将为0. */</span></span><br><span class="line">	pmsg-&gt;outbuf_len = len;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">/* 成功处理一条记录. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="nbcon-emit-next-record-发射单条非阻塞控制台-nbcon-日志记录"><a href="#nbcon-emit-next-record-发射单条非阻塞控制台-nbcon-日志记录" class="headerlink" title="nbcon_emit_next_record: 发射单条非阻塞控制台(nbcon)日志记录"></a>nbcon_emit_next_record: 发射单条非阻塞控制台(nbcon)日志记录</h2><p>此函数是Linux内核非阻塞控制台(<code>nbcon</code>)子系统中<strong>负责实际打印工作的引擎</strong>。它的核心原理是<strong>在一个已获取所有权的上下文中, 安全地从主<code>printk</code>环形缓冲区中取出下一条日志记录, 对其进行必要的格式化(如添加”丢弃”或”重放”标记), 然后调用底层控制台驱动提供的<code>.write_atomic()</code>或<code>.write_thread()</code>回调函数将其发送到硬件, 最后再安全地更新控制台的打印进度</strong>。</p>
<p>这是一个极其健壮和复杂的函数, 因为它被设计为在任何时刻都可能被更高优先级的上下文”抢占”打印权。因此, 它的每一步操作都充满了防御性检查, 以确保它不会在丢失所有权后继续进行任何操作。</p>
<p><strong>工作流程详解:</strong></p>
<ol>
<li><p><strong>进入”不安全”区域 &amp; 获取消息</strong>: 函数首先调用<code>nbcon_context_enter_unsafe()</code>。这会检查是否有更高优先级的上下文请求交接, 如果有, 函数会立即放弃并返回<code>false</code>。如果安全, 它会调用<code>printk_get_next_message()</code>从<code>printk</code>环形缓冲区中获取下一条格式化的日志记录。如果缓冲区中没有更多可处理的记录, 它会正常退出并返回<code>true</code>。</p>
</li>
<li><p><strong>添加”丢弃”标记</strong>: 如果<code>printk</code>核心为了到达下一条有效记录而跳过了一些损坏或丢失的记录, 或者此控制台本身之前就丢弃过消息, 此函数会计算出总共丢弃的数量, 并调用<code>console_prepend_dropped()</code>在当前要打印的消息前加上一个类似<code>&quot;[... 42 dropped messages ...]</code>的前缀。这对于用户理解日志的不连续性至关重要。</p>
</li>
<li><p><strong>处理”重放”情况</strong>: 这是一个精妙的容错机制。如果一个低优先级的打印上下文被高优先级的抢占, 打印了一条消息, 然后低优先级上下文又重新获得了所有权, 它可能会尝试打印同一条消息。为了避免重复输出, 函数会检查当前要打印的记录序列号是否与”上一个被打印的序列号”(<code>nbcon_prev_seq</code>)相同。如果相同, 它会调用<code>console_prepend_replay()</code>为消息加上<code>&quot;[replay]&quot;</code>前缀, 而不是重复打印完整消息。</p>
</li>
<li><p><strong>调用驱动回调</strong>: 在完成所有前缀添加后, 函数会根据上下文(<code>use_atomic</code>)决定是调用驱动提供的原子<code>write_atomic()</code>函数, 还是可休眠的<code>write_thread()</code>函数, 将最终的日志内容传递给驱动程序, 由驱动程序负责将其写入物理硬件(如UART的FIFO)。</p>
</li>
<li><p><strong>所有权丢失检测</strong>: 在调用驱动之后, 它会检查<code>wctxt-&gt;outbuf</code>是否被驱动清空。这是驱动向<code>nbcon</code>核心发信号的一种方式, 表示驱动在<code>write</code>回调内部自己检测到所有权丢失并重新获取了它。如果发生这种情况, 此函数也会认为所有权已丢失, 并立即中止。</p>
</li>
<li><p><strong>更新状态</strong>: 如果消息被成功发送(或被跳过), 函数会再次进入一个”不安全”区域, 来原子地更新此控制台的两个关键状态:</p>
<ul>
<li>重置<code>con-&gt;dropped</code>计数器, 因为丢弃信息已经被打印出去了。</li>
<li>调用<code>nbcon_seq_try_update()</code>将控制台的进度标记(<code>nbcon_seq</code>)更新为下一条记录的序列号。这是整个流程中最重要的”推进”步骤。</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">nbcon_emit_next_record</span><span class="params">(<span class="keyword">struct</span> nbcon_write_context *wctxt, <span class="type">bool</span> use_atomic)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nbcon_context</span> *<span class="title">ctxt</span> =</span> &amp;ACCESS_PRIVATE(wctxt, ctxt);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">console</span> *<span class="title">con</span> =</span> ctxt-&gt;console;</span><br><span class="line">	<span class="type">bool</span> is_extended = console_srcu_read_flags(con) &amp; CON_EXTENDED;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">printk_message</span> <span class="title">pmsg</span> =</span> &#123;</span><br><span class="line">		.pbufs = ctxt-&gt;pbufs,</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> con_dropped;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nbcon_state</span> <span class="title">cur</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> dropped;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> ulseq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 健全性检查: 确保函数被正确调用. */</span></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON_ONCE((use_atomic &amp;&amp; !con-&gt;write_atomic) ||</span><br><span class="line">			 !(console_srcu_read_flags(con) &amp; CON_NBCON))) &#123;</span><br><span class="line">		nbcon_context_release(ctxt); <span class="comment">/* 释放所有权并中止. */</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 步骤1: 进入&quot;不安全&quot;区域. 这会检查是否有更高优先级的请求者.</span></span><br><span class="line"><span class="comment">	 * 如果我们被抢占了, 就不能继续.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!nbcon_context_enter_unsafe(ctxt))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 从printk环形缓冲区获取下一条消息. */</span></span><br><span class="line">	ctxt-&gt;backlog = printk_get_next_message(&amp;pmsg, ctxt-&gt;seq, is_extended, <span class="literal">true</span>);</span><br><span class="line">	<span class="keyword">if</span> (!ctxt-&gt;backlog) <span class="comment">/* 如果没有更多消息, 退出不安全区并成功返回. */</span></span><br><span class="line">		<span class="keyword">return</span> nbcon_context_exit_unsafe(ctxt);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 步骤2: 处理丢弃的消息.</span></span><br><span class="line"><span class="comment">	 * 计算总丢弃数, 并在消息前添加&quot;[... dropped ...]&quot;前缀.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	con_dropped = data_race(READ_ONCE(con-&gt;dropped));</span><br><span class="line">	dropped = con_dropped + pmsg.dropped;</span><br><span class="line">	<span class="keyword">if</span> (dropped &amp;&amp; !is_extended)</span><br><span class="line">		console_prepend_dropped(&amp;pmsg, dropped);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 步骤3: 处理重放情况.</span></span><br><span class="line"><span class="comment">	 * 检查我们是否在尝试打印一条已经被更高优先级上下文打印过的消息.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ulseq = atomic_long_read(&amp;ACCESS_PRIVATE(con, nbcon_prev_seq));</span><br><span class="line">	<span class="keyword">if</span> (__ulseq_to_u64seq(prb, ulseq) == pmsg.seq) &#123;</span><br><span class="line">		console_prepend_replay(&amp;pmsg); <span class="comment">/* 如果是, 只添加&quot;[replay]&quot;前缀. */</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* 否则, 我们是第一个打印此消息的, 尝试更新&quot;上一条&quot;序列号. */</span></span><br><span class="line">		nbcon_state_read(con, &amp;cur);</span><br><span class="line">		<span class="keyword">if</span> (!nbcon_context_can_proceed(ctxt, &amp;cur))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">/* 再次检查所有权. */</span></span><br><span class="line"></span><br><span class="line">		atomic_long_try_cmpxchg(&amp;ACCESS_PRIVATE(con, nbcon_prev_seq), &amp;ulseq,</span><br><span class="line">					__u64seq_to_ulseq(pmsg.seq));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 退出第一个不安全区域. */</span></span><br><span class="line">	<span class="keyword">if</span> (!nbcon_context_exit_unsafe(ctxt))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果只是跳过的记录(没有内容), 直接去更新状态. */</span></span><br><span class="line">	<span class="keyword">if</span> (pmsg.outbuf_len == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> update_con;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 步骤4: 调用驱动回调函数.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	nbcon_write_context_set_buf(wctxt, &amp;pmsg.pbufs-&gt;outbuf[<span class="number">0</span>], pmsg.outbuf_len);</span><br><span class="line">	<span class="keyword">if</span> (use_atomic)</span><br><span class="line">		con-&gt;write_atomic(con, wctxt);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		con-&gt;write_thread(con, wctxt);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 步骤5: 检查驱动是否在回调中丢失并重新获取了所有权. */</span></span><br><span class="line">	<span class="keyword">if</span> (!wctxt-&gt;outbuf) &#123;</span><br><span class="line">		nbcon_context_release(ctxt);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">update_con:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 步骤6: 更新状态. 再次进入不安全区域来原子地更新进度.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!nbcon_context_enter_unsafe(ctxt))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果丢弃信息已打印, 重置控制台的丢弃计数器. */</span></span><br><span class="line">	<span class="keyword">if</span> (dropped != con_dropped) &#123;</span><br><span class="line">		WRITE_ONCE(con-&gt;dropped, dropped);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 尝试将控制台的进度序列号更新到下一条记录. */</span></span><br><span class="line">	nbcon_seq_try_update(ctxt, pmsg.seq + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 退出不安全区并返回所有权状态. */</span></span><br><span class="line">	<span class="keyword">return</span> nbcon_context_exit_unsafe(ctxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="非阻塞控制台-nbcon-的原子刷新-单个控制台实现"><a href="#非阻塞控制台-nbcon-的原子刷新-单个控制台实现" class="headerlink" title="非阻塞控制台(nbcon)的原子刷新: 单个控制台实现"></a>非阻塞控制台(nbcon)的原子刷新: 单个控制台实现</h2><p>此代码片段深入到Linux内核非阻塞控制台(nbcon)原子刷新机制的<strong>最底层</strong>。它包含了负责刷新<strong>单个</strong>指定控制台的核心逻辑。其根本原理是<strong>一个高度健壮、具备所有权协商和循环处理能力的微型状态机, 专门用于在不可休眠的原子上下文中, 将日志从内核缓冲区驱动到硬件</strong>。</p>
<p>这套机制是为应对最严苛的系统环境(如<code>panic</code>, NMI)而设计的, 因此其复杂性体现在对所有权、并发和日志追赶问题的处理上。</p>
<hr>
<h3 id="nbcon-atomic-flush-pending-con-核心执行逻辑"><a href="#nbcon-atomic-flush-pending-con-核心执行逻辑" class="headerlink" title="__nbcon_atomic_flush_pending_con: 核心执行逻辑"></a><code>__nbcon_atomic_flush_pending_con</code>: 核心执行逻辑</h3><p>此函数是实际执行刷新工作的”引擎”。它尝试获取控制台的所有权, 然后在一个循环中逐条记录地输出日志。</p>
<p><strong>原理与工作流程:</strong></p>
<ol>
<li><strong>上下文初始化</strong>: 创建并初始化一个<code>nbcon_write_context</code>。这个结构体包含了刷新操作所需的所有状态, 如目标控制台、优先级、超时等。</li>
<li><strong>获取所有权</strong>: 调用<code>nbcon_context_try_acquire</code>尝试获取该控制台的”打印权”。这是一个<strong>非阻塞的锁获取</strong>操作。如果失败(返回<code>false</code>), 意味着另一个上下文(可能是更高优先级的NMI, 或另一个CPU核心)正在使用此控制台, 函数会立即返回<code>-EPERM</code>(权限错误), 表示本次尝试失败。</li>
<li><strong>打印循环</strong>: 如果成功获取所有权, 函数进入一个<code>while</code>循环, 只要当前控制台的处理进度还没达到目标序列号<code>stop_seq</code>, 循环就会继续。</li>
<li><strong>单条记录发射</strong>: 在循环内部, 它调用<code>nbcon_emit_next_record</code>。这个函数负责:<ul>
<li>从<code>printk</code>环形缓冲区读取下一条可用的日志记录。</li>
<li>调用控制台驱动提供的<code>.write_atomic()</code>回调函数, 将记录内容发送到硬件。</li>
<li>如果在执行过程中, 打印权被更高优先级的上下文”抢占”(takeover)了, <code>nbcon_emit_next_record</code>会返回<code>false</code>。此时, 循环必须终止, 函数返回<code>-EAGAIN</code>, 告知上层”请重试或放弃, 因为其他人接管了”。</li>
</ul>
</li>
<li><strong>处理”空洞”</strong>: 如果<code>printk</code>缓冲区中没有更多可读的记录了(<code>!ctxt-&gt;backlog</code>), 但我们仍未达到目标序列号<code>stop_seq</code>, 这意味着有其他CPU核心<strong>预留</strong>了一个日志槽位但还<strong>没有完全写入数据</strong>。在原子上下文中, 我们绝不能等待它完成。因此, 函数会设置<code>-ENOENT</code>(无此条目)错误并跳出循环。</li>
<li><strong>释放所有权</strong>: 无论循环是如何退出的(成功完成、被抢占、遇到空洞), 最后都必须调用<code>nbcon_context_release</code>来释放之前获取的打印权。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* __nbcon_atomic_flush_pending_con: 使用write_atomic()回调刷新指定的nbcon控制台 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __nbcon_atomic_flush_pending_con(<span class="keyword">struct</span> console *con, u64 stop_seq,</span><br><span class="line">					    <span class="type">bool</span> allow_unsafe_takeover)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nbcon_write_context</span> <span class="title">wctxt</span> =</span> &#123; &#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nbcon_context</span> *<span class="title">ctxt</span> =</span> &amp;ACCESS_PRIVATE(&amp;wctxt, ctxt);</span><br><span class="line">	<span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化写操作的上下文. */</span></span><br><span class="line">	ctxt-&gt;console			= con;</span><br><span class="line">	ctxt-&gt;spinwait_max_us		= <span class="number">2000</span>; <span class="comment">/* 尝试获取锁时的自旋等待超时. */</span></span><br><span class="line">	ctxt-&gt;prio			= nbcon_get_default_prio(); <span class="comment">/* 获取默认的优先级. */</span></span><br><span class="line">	ctxt-&gt;allow_unsafe_takeover	= allow_unsafe_takeover; <span class="comment">/* 是否允许不安全的抢占. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 步骤1: 尝试获取控制台的打印权. */</span></span><br><span class="line">	<span class="keyword">if</span> (!nbcon_context_try_acquire(ctxt, <span class="literal">false</span>))</span><br><span class="line">		<span class="keyword">return</span> -EPERM; <span class="comment">/* 如果失败, 返回权限错误. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 步骤2: 循环打印, 直到赶上目标序列号. */</span></span><br><span class="line">	<span class="keyword">while</span> (nbcon_seq_read(con) &lt; stop_seq) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 步骤3: 发射下一条记录. 如果所有权被抢占, 此函数返回false.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!nbcon_emit_next_record(&amp;wctxt, <span class="literal">true</span>))</span><br><span class="line">			<span class="keyword">return</span> -EAGAIN; <span class="comment">/* 返回&quot;请重试&quot;, 因为其他人接管了. */</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 步骤4: 检查是否还有待处理的日志. */</span></span><br><span class="line">		<span class="keyword">if</span> (!ctxt-&gt;backlog) &#123;</span><br><span class="line">			<span class="comment">/* 如果没有了, 但仍未达到目标, 说明遇到了未写完的&quot;空洞&quot;记录. */</span></span><br><span class="line">			<span class="keyword">if</span> (nbcon_seq_read(con) &lt; stop_seq)</span><br><span class="line">				err = -ENOENT; <span class="comment">/* 设置&quot;无此条目&quot;错误. */</span></span><br><span class="line">			<span class="keyword">break</span>; <span class="comment">/* 退出循环. */</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 步骤5: 释放打印权. */</span></span><br><span class="line">	nbcon_context_release(ctxt);</span><br><span class="line">	<span class="keyword">return</span> err; <span class="comment">/* 返回0或-ENOENT. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="nbcon-atomic-flush-pending-con-带安全封装和重试逻辑的包装器"><a href="#nbcon-atomic-flush-pending-con-带安全封装和重试逻辑的包装器" class="headerlink" title="nbcon_atomic_flush_pending_con: 带安全封装和重试逻辑的包装器"></a><code>nbcon_atomic_flush_pending_con</code>: 带安全封装和重试逻辑的包装器</h3><p>此函数是<code>__nbcon_atomic_flush_pending_con</code>的一个包装器, 它增加了两个至关重要的特性: <strong>中断安全</strong>和<strong>日志追赶(tail-chasing)</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* nbcon_atomic_flush_pending_con: 刷新指定的nbcon控制台, 带安全封装. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">nbcon_atomic_flush_pending_con</span><span class="params">(<span class="keyword">struct</span> console *con, u64 stop_seq,</span></span><br><span class="line"><span class="params">					   <span class="type">bool</span> allow_unsafe_takeover)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">console_flush_type</span> <span class="title">ft</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">again: <span class="comment">/* 用于日志追赶的goto标签. */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 关键特性1: 中断安全.</span></span><br><span class="line"><span class="comment">	 * 原子刷新不使用常规的驱动锁(因为可能休眠), 所以必须禁用本地中断.</span></span><br><span class="line"><span class="comment">	 * 这可以防止在持有nbcon所有权锁时, 本地CPU又发生中断并尝试打印,</span></span><br><span class="line"><span class="comment">	 * 从而导致在同一个CPU上对自己持有的锁产生死锁.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	local_irq_save(flags);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 调用核心执行逻辑. */</span></span><br><span class="line">	err = __nbcon_atomic_flush_pending_con(con, stop_seq, allow_unsafe_takeover);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 恢复之前的中断状态. */</span></span><br><span class="line">	local_irq_restore(flags);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 错误处理:</span></span><br><span class="line"><span class="comment">	 * 如果返回-EPERM或-EAGAIN, 说明有其他上下文接管了, 我们直接退出即可.</span></span><br><span class="line"><span class="comment">	 * 如果返回-ENOENT, 我们不能等待那个&quot;空洞&quot;记录, 也要退出, 避免死锁.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 关键特性2: 日志追赶 (Tail-chasing).</span></span><br><span class="line"><span class="comment">	 * 如果我们成功完成了刷新, 但在我们刷新期间又有新的日志被加入,</span></span><br><span class="line"><span class="comment">	 * 并且系统中没有一个后台打印线程(nbcon_offload)可以处理它们,</span></span><br><span class="line"><span class="comment">	 * 那么我们这个原子上下文就有责任继续把这些新日志也打印完.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	printk_get_console_flush_type(&amp;ft);</span><br><span class="line">	<span class="keyword">if</span> (!ft.nbcon_offload &amp;&amp;</span><br><span class="line">	    prb_read_valid(prb, nbcon_seq_read(con), <span class="literal">NULL</span>)) &#123;</span><br><span class="line">		<span class="comment">/* 更新目标序列号到最新的日志末尾. */</span></span><br><span class="line">		stop_seq = prb_next_reserve_seq(prb);</span><br><span class="line">		<span class="comment">/* 跳回到开头, 重新开始一轮刷新. */</span></span><br><span class="line">		<span class="keyword">goto</span> again;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="非阻塞控制台-nbcon-的原子刷新机制"><a href="#非阻塞控制台-nbcon-的原子刷新机制" class="headerlink" title="非阻塞控制台(nbcon)的原子刷新机制"></a>非阻塞控制台(nbcon)的原子刷新机制</h2><p>此代码片段展示了Linux内核中一种现代化、高性能的控制台输出机制——<strong>非阻塞控制台(Non-Blocking Console, nbcon)<strong>的原子刷新功能。它的核心原理是</strong>提供一种在原子上下文(atomic context, 如中断处理程序、持有自旋锁的代码、系统恐慌panic等)中, 能够安全、快速地将内核日志缓冲区中的待处理消息(backlog)强制输出到硬件的方法</strong>。</p>
<p>这与传统的、可能休眠的控制台输出机制形成鲜明对比。在紧急情况下(如系统即将崩溃), 内核不能调用任何可能导致睡眠的函数, 因此需要一套完全不同的、”原子”的输出路径。<code>nbcon</code>为此而生, 它要求控制台驱动程序提供一个特殊的<code>write_atomic()</code>回调函数, 这个函数必须保证在任何情况下都不会休眠。</p>
<p><code>nbcon_atomic_flush_pending</code>系列函数就是这个机制的触发器。它不适用于常规日志输出, 而是专门为内核的紧急路径(如<code>kmsg_dump</code>, <code>panic()</code>)设计的。</p>
<hr>
<h3 id="nbcon-atomic-flush-pending-核心实现"><a href="#nbcon-atomic-flush-pending-核心实现" class="headerlink" title="__nbcon_atomic_flush_pending: 核心实现"></a><code>__nbcon_atomic_flush_pending</code>: 核心实现</h3><p>这是执行原子刷新的底层工作函数。它负责遍历所有已注册的控制台, 筛选出符合条件的非阻塞控制台, 并对它们逐一执行刷新操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * __nbcon_atomic_flush_pending - 使用 write_atomic() 回调函数刷新所有nbcon控制台</span></span><br><span class="line"><span class="comment"> * @stop_seq:			刷新到此序列号的记录为止</span></span><br><span class="line"><span class="comment"> * @allow_unsafe_takeover:	布尔值, 是否允许不安全的强制接管</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __nbcon_atomic_flush_pending(u64 stop_seq, <span class="type">bool</span> allow_unsafe_takeover)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">console</span> *<span class="title">con</span>;</span></span><br><span class="line">	<span class="type">int</span> cookie;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 使用 SRCU (Sleepable Read-Copy Update) 锁来安全地遍历全局控制台列表.</span></span><br><span class="line"><span class="comment">	 * SRCU 是一种允许读者在遍历时可以睡眠的读写锁机制.</span></span><br><span class="line"><span class="comment">	 * 在这里, 虽然我们处于原子上下文, 但这是访问全局控制台列表的标准、安全方式.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	cookie = console_srcu_read_lock();</span><br><span class="line">	for_each_console_srcu(con) &#123;</span><br><span class="line">		<span class="comment">/* 读取当前控制台的标志位. */</span></span><br><span class="line">		<span class="type">short</span> flags = console_srcu_read_flags(con);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 筛选条件1: 检查是否为非阻塞控制台 (CON_NBCON). 如果不是, 跳过. */</span></span><br><span class="line">		<span class="keyword">if</span> (!(flags &amp; CON_NBCON))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 筛选条件2: 检查此控制台在原子上下文中是否可用. */</span></span><br><span class="line">		<span class="keyword">if</span> (!console_is_usable(con, flags, <span class="literal">true</span>))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 筛选条件3: 检查此控制台是否已经处理完所有需要刷新的记录. 如果是, 跳过. */</span></span><br><span class="line">		<span class="keyword">if</span> (nbcon_seq_read(con) &gt;= stop_seq)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 对于所有通过筛选的nbcon控制台, 调用其私有的原子刷新函数.</span></span><br><span class="line"><span class="comment">		 * 这个函数内部会循环调用驱动提供的 write_atomic() 回调,</span></span><br><span class="line"><span class="comment">		 * 将日志从内核缓冲区输出到硬件, 直到达到 stop_seq.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		nbcon_atomic_flush_pending_con(con, stop_seq, allow_unsafe_takeover);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 遍历完成, 释放 SRCU 读锁定. */</span></span><br><span class="line">	console_srcu_read_unlock(cookie);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="nbcon-atomic-flush-pending-便捷的API封装"><a href="#nbcon-atomic-flush-pending-便捷的API封装" class="headerlink" title="nbcon_atomic_flush_pending: 便捷的API封装"></a><code>nbcon_atomic_flush_pending</code>: 便捷的API封装</h3><p>这是一个上层的、导出的API函数, 它为内核的紧急路径提供了一个简洁的调用接口。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * nbcon_atomic_flush_pending - 使用 write_atomic() 回调函数刷新所有nbcon控制台</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 将积压的日志刷新到当前最新的那条记录. 在刷新期间任何新加入的记录,</span></span><br><span class="line"><span class="comment"> * 如果有其他上下文可以处理刷新, 则不会被本次刷新处理. 这是为了避免</span></span><br><span class="line"><span class="comment"> * 单个CPU因为其他CPU持续添加记录而无限制地进行打印.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">nbcon_atomic_flush_pending</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 调用核心实现函数, 并传入:</span></span><br><span class="line"><span class="comment">	 * - stop_seq: prb_next_reserve_seq(prb)</span></span><br><span class="line"><span class="comment">	 *   此函数获取printk环形缓冲区中下一条将要被写入的记录的序列号.</span></span><br><span class="line"><span class="comment">	 *   这意味着本次刷新操作的目标是&quot;清空当前所有的待处理日志&quot;.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * - allow_unsafe_takeover: false</span></span><br><span class="line"><span class="comment">	 *   这表示本次刷新是一个&quot;协作式&quot;的刷新. 如果发现有其他CPU核心</span></span><br><span class="line"><span class="comment">	 *   也正在刷新这个控制台, 本次调用不会强行&quot;接管&quot;刷新工作.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	__nbcon_atomic_flush_pending(prb_next_reserve_seq(prb), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="kernel-printk-printk-c-内核消息打印"><a href="#kernel-printk-printk-c-内核消息打印" class="headerlink" title="kernel&#x2F;printk&#x2F;printk.c 内核消息打印"></a>kernel&#x2F;printk&#x2F;printk.c 内核消息打印</h1><h2 id="oops-in-progress-指示当前是否正在处理内核错误"><a href="#oops-in-progress-指示当前是否正在处理内核错误" class="headerlink" title="oops_in_progress 指示当前是否正在处理内核错误"></a>oops_in_progress 指示当前是否正在处理内核错误</h2><p><code>oops_in_progress</code> 是 Linux 内核中的一个全局变量，用于指示当前是否正在处理内核 “oops”（内核错误）。以下是对其功能和用途的详细解释：</p>
<ol>
<li><p><strong>内核 “oops” 的概念</strong>：</p>
<ul>
<li>在 Linux 内核中，”oops” 是一种严重的错误，通常表示内核代码中发生了非法操作，例如访问无效内存地址或触发了断言失败。</li>
<li>当发生 “oops” 时，内核会打印错误信息（通过 <code>printk</code>），记录问题的详细信息，并尝试继续运行（如果可能的话），而不是立即崩溃。</li>
</ul>
</li>
<li><p><strong><code>oops_in_progress</code> 的作用</strong>：</p>
<ul>
<li><code>oops_in_progress</code> 是一个标志变量，用于指示当前是否正在处理 “oops” 错误。</li>
<li>当内核开始处理 “oops” 时，会将 <code>oops_in_progress</code> 设置为非零值，表示系统处于错误处理状态。</li>
<li>在错误处理完成后，<code>oops_in_progress</code> 会被重置为零。</li>
</ul>
</li>
<li><p><strong>防止递归错误</strong>：</p>
<ul>
<li>在处理 “oops” 的过程中，内核可能会调用其他函数（例如日志记录或调试工具）。如果这些函数再次触发错误，可能会导致递归 “oops” 或系统崩溃。</li>
<li>通过检查 <code>oops_in_progress</code> 的状态，内核可以避免在处理 “oops” 时再次触发某些操作，从而防止递归错误的发生。</li>
</ul>
</li>
<li><p><strong>典型使用场景</strong>：</p>
<ul>
<li><code>oops_in_progress</code> 通常与内核日志记录（<code>printk</code>）和调试机制配合使用。在记录 “oops” 信息时，内核会检查该标志，以决定是否需要限制某些操作。</li>
<li>例如，如果系统正在处理 “oops”，某些非关键的日志可能会被跳过，以避免进一步的干扰。</li>
</ul>
</li>
<li><p><strong>与系统稳定性相关</strong>：</p>
<ul>
<li><code>oops_in_progress</code> 的存在使得内核在处理严重错误时能够更好地控制系统行为，尽量避免系统完全崩溃。</li>
<li>在某些情况下，内核可能会尝试继续运行，即使发生了 “oops”。这对于嵌入式系统或关键任务系统尤为重要，因为它们可能需要尽量保持运行状态。</li>
</ul>
</li>
</ol>
<p>总的来说，<code>oops_in_progress</code> 是 Linux 内核中一个关键的全局变量，用于管理和协调 “oops” 错误的处理过程。它在提高系统稳定性和防止递归错误方面起到了重要作用。</p>
<h2 id="printk-delay-当CONFIG-BOOT-PRINTK-DELAY配置时-每条消息延时打印配置"><a href="#printk-delay-当CONFIG-BOOT-PRINTK-DELAY配置时-每条消息延时打印配置" class="headerlink" title="printk_delay 当CONFIG_BOOT_PRINTK_DELAY配置时 每条消息延时打印配置"></a>printk_delay 当CONFIG_BOOT_PRINTK_DELAY配置时 每条消息延时打印配置</h2><ol>
<li>当CONFIG_BOOT_PRINTK_DELAY配置时 每条消息延时打印配置</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">printk_delay</span><span class="params">(<span class="type">int</span> level)</span></span><br><span class="line">&#123;</span><br><span class="line">	boot_delay_msec(level); </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(printk_delay_msec)) &#123;</span><br><span class="line">		<span class="type">int</span> m = printk_delay_msec;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (m--) &#123;</span><br><span class="line">			mdelay(<span class="number">1</span>);</span><br><span class="line">			touch_nmi_watchdog();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="printk-recursion-counter-返回指向调用方-CPU-上下文的专用计数器的指针"><a href="#printk-recursion-counter-返回指向调用方-CPU-上下文的专用计数器的指针" class="headerlink" title="__printk_recursion_counter 返回指向调用方 CPU 上下文的专用计数器的指针"></a>__printk_recursion_counter 返回指向调用方 CPU 上下文的专用计数器的指针</h2><ol>
<li>根据当前 CPU 是否处于 NMI（非屏蔽中断）上下文来选择使用哪个递归计数器。</li>
<li>根据当前是否完成了 <code>printk</code> 的每 CPU 数据准备来选择使用哪个递归计数器。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> u8 *__printk_recursion_counter(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HAVE_NMI	<span class="comment">//是否支持 NMI(非屏蔽中断)</span></span></span><br><span class="line">	<span class="keyword">if</span> (in_nmi()) &#123;		<span class="comment">//NMI计数不为0</span></span><br><span class="line">		<span class="keyword">if</span> (printk_percpu_data_ready())</span><br><span class="line">			<span class="keyword">return</span> this_cpu_ptr(&amp;printk_count_nmi);</span><br><span class="line">		<span class="keyword">return</span> &amp;printk_count_nmi_early;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">if</span> (printk_percpu_data_ready())</span><br><span class="line">		<span class="keyword">return</span> this_cpu_ptr(&amp;printk_count);</span><br><span class="line">	<span class="keyword">return</span> &amp;printk_count_early;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="printk-enter-irqsave-屏蔽中断并检查递归调用次数判断是否允许打印-失败不会禁用"><a href="#printk-enter-irqsave-屏蔽中断并检查递归调用次数判断是否允许打印-失败不会禁用" class="headerlink" title="printk_enter_irqsave 屏蔽中断并检查递归调用次数判断是否允许打印,失败不会禁用"></a>printk_enter_irqsave 屏蔽中断并检查递归调用次数判断是否允许打印,失败不会禁用</h2><ol>
<li>检测递归调用的次数，超过<code>PRINTK_MAX_RECURSION</code>则返回false。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 	递归是有限的，以保持输出的理智。</span></span><br><span class="line"><span class="comment">	printk（） 不应要求超过 1 级递归</span></span><br><span class="line"><span class="comment">	（例如，允许 printk（） 触发 WARN），但如果存在某些 printk 内部错误，</span></span><br><span class="line"><span class="comment">	例如 ringbuffer 验证检查失败，则使用更高的值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINTK_MAX_RECURSION 3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> printk_enter_irqsave(recursion_ptr, flags)	\</span></span><br><span class="line"><span class="meta">(&#123;							\</span></span><br><span class="line"><span class="meta">	bool success = true;				\</span></span><br><span class="line"><span class="meta">							\</span></span><br><span class="line"><span class="meta">	typecheck(u8 *, recursion_ptr);			\</span></span><br><span class="line"><span class="meta">	<span class="comment">/* 返回当前中断状态并禁用中断 */</span></span></span><br><span class="line">	local_irq_save(flags);				\</span><br><span class="line">	<span class="comment">//返回指向调用方 CPU 上下文的专用计数器的指针</span></span><br><span class="line">	(recursion_ptr) = __printk_recursion_counter();	\</span><br><span class="line">	<span class="keyword">if</span> (*(recursion_ptr) &gt; PRINTK_MAX_RECURSION) &#123;	\</span><br><span class="line">		<span class="comment">//失败恢复中断</span></span><br><span class="line">		local_irq_restore(flags);		\</span><br><span class="line">		success = <span class="literal">false</span>;			\</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;					\</span><br><span class="line">		(*(recursion_ptr))++;			\</span><br><span class="line">	&#125;						\</span><br><span class="line">	success;					\</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="printk-parse-prefix-提取日志级别或控制标志。"><a href="#printk-parse-prefix-提取日志级别或控制标志。" class="headerlink" title="printk_parse_prefix 提取日志级别或控制标志。"></a>printk_parse_prefix 提取日志级别或控制标志。</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * printk_parse_prefix - 解析级别和控制标志。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @text：已终止的短信。</span></span><br><span class="line"><span class="comment"> * @level：指向当前级别值的指针将被更新。</span></span><br><span class="line"><span class="comment"> * @flags：指向当前 printk_info 标志的指针将被更新。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果调用方对解析的值不感兴趣，则 @level 可能为 NULL。否则，必须将 @level 指向的变量设置为 LOGLEVEL_DEFAULT 才能使用解析的值进行更新。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果调用方对解析的值不感兴趣，则 @flags 可能为 NULL。否则，@flags 指向的变量将与解析的值进行 OR 运算。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回：解析的电平和控制标志的长度。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">u16 <span class="title function_">printk_parse_prefix</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *text, <span class="type">int</span> *level,</span></span><br><span class="line"><span class="params">			<span class="keyword">enum</span> printk_info_flags *flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	u16 prefix_len = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> kern_level;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (*text) &#123;	<span class="comment">//传入的text会增加一个/0退出</span></span><br><span class="line">		kern_level = printk_get_level(text);	<span class="comment">//获取日志等级</span></span><br><span class="line">		<span class="keyword">if</span> (!kern_level)	<span class="comment">//没有日志等级退出</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> (kern_level) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span> ... <span class="string">&#x27;7&#x27;</span>:</span><br><span class="line">			<span class="comment">//传入level需要的话必须设置为LOGLEVEL_DEFAULT</span></span><br><span class="line">			<span class="keyword">if</span> (level &amp;&amp; *level == LOGLEVEL_DEFAULT)</span><br><span class="line">				*level = kern_level - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:	<span class="comment">/* KERN_CONT */</span></span><br><span class="line">			<span class="keyword">if</span> (flags)</span><br><span class="line">				*flags |= LOG_CONT;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		prefix_len += <span class="number">2</span>;</span><br><span class="line">		text += <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> prefix_len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="printk-ringbuffer-静态-动态"><a href="#printk-ringbuffer-静态-动态" class="headerlink" title="printk_ringbuffer 静态 动态"></a>printk_ringbuffer 静态 动态</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* record buffer */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_ALIGN __alignof__(unsigned long)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LOG_BUF_LEN (1 &lt;&lt; CONFIG_LOG_BUF_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_BUF_LEN_MAX ((u32)1 &lt;&lt; 31)</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> __log_buf[__LOG_BUF_LEN] __aligned(LOG_ALIGN);</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *log_buf = __log_buf;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">- 定义平均消息大小。这仅影响可用的描述符数量。低估比高估要好（可用描述符太多总比不够好）。 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRB_AVGBITS 5	<span class="comment">/* 32 个字符的平均长度 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_LOG_BUF_SHIFT &lt;= PRB_AVGBITS</span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> CONFIG_LOG_BUF_SHIFT value too small.</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">_DEFINE_PRINTKRB(printk_rb_static, CONFIG_LOG_BUF_SHIFT - PRB_AVGBITS,</span><br><span class="line">		 PRB_AVGBITS, &amp;__log_buf[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">printk_ringbuffer</span> <span class="title">printk_rb_dynamic</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">printk_ringbuffer</span> *<span class="title">prb</span> =</span> &amp;printk_rb_static;</span><br></pre></td></tr></table></figure>

<h2 id="truncate-msg-截断消息"><a href="#truncate-msg-截断消息" class="headerlink" title="truncate_msg 截断消息"></a>truncate_msg 截断消息</h2><ol>
<li>log_buf中仅有一半的缓冲区可用</li>
<li>如果发生截断,则在消息末尾添加<code>&lt;truncated&gt;</code>,启用警告消息（如果有空间）.</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">- 定义我们最多可以接受多少 log buffer。该值必须大于 2。请注意，当索引指向中间时，只有一半的缓冲区可用。 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_LOG_TAKE_PART 4</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> trunc_msg[] = <span class="string">&quot;&lt;truncated&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">truncate_msg</span><span class="params">(u16 *text_len, u16 *trunc_msg_len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *消息不应占用整个缓冲区。否则，它可能会过早地被删除。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u32 max_text_len = log_buf_len / MAX_LOG_TAKE_PART;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (*text_len &gt; max_text_len)</span><br><span class="line">		*text_len = max_text_len;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 启用警告消息（如果有空间） */</span></span><br><span class="line">	*trunc_msg_len = <span class="built_in">strlen</span>(trunc_msg);</span><br><span class="line">	<span class="keyword">if</span> (*text_len &gt;= *trunc_msg_len)</span><br><span class="line">		*text_len -= *trunc_msg_len;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		*trunc_msg_len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="vprintk-store-打印消息到环形缓冲区"><a href="#vprintk-store-打印消息到环形缓冲区" class="headerlink" title="vprintk_store 打印消息到环形缓冲区"></a>vprintk_store 打印消息到环形缓冲区</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4 表示格式字符串是函数的第 4 个参数（从 1 开始计数，包括 this 指针或隐式参数）。</span></span><br><span class="line"><span class="comment">//0 表示该函数没有可变参数列表（即没有类似 ... 的参数）。如果存在可变参数列表，则需要指定其起始位置</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">vprintk_store</span><span class="params">(<span class="type">int</span> facility, <span class="type">int</span> level,</span></span><br><span class="line"><span class="params">		  <span class="type">const</span> <span class="keyword">struct</span> dev_printk_info *dev_info,</span></span><br><span class="line"><span class="params">		  <span class="type">const</span> <span class="type">char</span> *fmt, va_list args)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">prb_reserved_entry</span> <span class="title">e</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">printk_info_flags</span> <span class="title">flags</span> =</span> <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">printk_record</span> <span class="title">r</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> irqflags;</span><br><span class="line">	u16 trunc_msg_len = <span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> prefix_buf[<span class="number">8</span>];</span><br><span class="line">	u8 *recursion_ptr;</span><br><span class="line">	u16 reserve_size;</span><br><span class="line">	va_list args2;</span><br><span class="line">	u32 caller_id;</span><br><span class="line">	u16 text_len;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	u64 ts_nsec;</span><br><span class="line">	<span class="comment">//屏蔽中断并检查递归调用次数判断是否允许打印,失败不会禁用</span></span><br><span class="line">	<span class="keyword">if</span> (!printk_enter_irqsave(recursion_ptr, irqflags))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 由于 printk（） 的持续时间可能因消息和环形缓冲区的状态而异，因此现在获取时间戳，使其接近 printk（） 的调用。这为调用方提供了更具确定性的时间戳。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ts_nsec = local_clock();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* return in_task() ? task_pid_nr(current) : 0x80000000 + smp_processor_id(); */</span></span><br><span class="line">	caller_id = printk_caller_id();	<span class="comment">//0x80000000 + smp_processor_id()[0] 中断调用</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * sprintf 需要放在最前面，因为 syslog 前缀可能作为参数传入。必须保留一个额外的字节，以便以后进入保留缓冲区的 vscnprintf（） 有空间终止 &#x27;\0&#x27;，这不被 vsnprintf（） 计算在内。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	va_copy(args2, args);</span><br><span class="line">	reserve_size = vsnprintf(&amp;prefix_buf[<span class="number">0</span>], <span class="keyword">sizeof</span>(prefix_buf), fmt, args2) + <span class="number">1</span>;</span><br><span class="line">	va_end(args2);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (reserve_size &gt; PRINTKRB_RECORD_MAX)</span><br><span class="line">		reserve_size = PRINTKRB_RECORD_MAX;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 提取日志级别或控制标志。 */</span></span><br><span class="line">	<span class="keyword">if</span> (facility == <span class="number">0</span>)</span><br><span class="line">		printk_parse_prefix(&amp;prefix_buf[<span class="number">0</span>], &amp;level, &amp;flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (level == LOGLEVEL_DEFAULT)</span><br><span class="line">		level = default_message_loglevel;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev_info)</span><br><span class="line">		flags |= LOG_NEWLINE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (is_printk_force_console())	<span class="comment">//强制输出到控制台</span></span><br><span class="line">		flags |= LOG_FORCE_CON;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; LOG_CONT) &#123;	<span class="comment">//text 是连续行的片段 可能需要与之前的日志拼接</span></span><br><span class="line">		prb_rec_init_wr(&amp;r, reserve_size);</span><br><span class="line">		<span class="keyword">if</span> (prb_reserve_in_last(&amp;e, prb, &amp;r, caller_id, PRINTKRB_RECORD_MAX)) &#123;</span><br><span class="line">			text_len = printk_sprint(&amp;r.text_buf[r.info-&gt;text_len], reserve_size,</span><br><span class="line">						 facility, &amp;flags, fmt, args);</span><br><span class="line">			r.info-&gt;text_len += text_len;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (flags &amp; LOG_FORCE_CON)</span><br><span class="line">				r.info-&gt;flags |= LOG_FORCE_CON;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (flags &amp; LOG_NEWLINE) &#123;</span><br><span class="line">				r.info-&gt;flags |= LOG_NEWLINE;</span><br><span class="line">				prb_final_commit(&amp;e);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				prb_commit(&amp;e);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ret = text_len;</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 在每次调用 prb_reserve（） 之前显式初始化记录 prb_reserve_in_last（） 和 prb_reserve（） 在失败时故意使 th 结构失效。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	prb_rec_init_wr(&amp;r, reserve_size);</span><br><span class="line">	<span class="keyword">if</span> (!prb_reserve(&amp;e, prb, &amp;r)) &#123;	<span class="comment">//保留空间失败</span></span><br><span class="line">		<span class="comment">/*如果消息对于空缓冲区来说太长，则截断消息 */</span></span><br><span class="line">		truncate_msg(&amp;reserve_size, &amp;trunc_msg_len);</span><br><span class="line"></span><br><span class="line">		prb_rec_init_wr(&amp;r, reserve_size + trunc_msg_len);</span><br><span class="line">		<span class="keyword">if</span> (!prb_reserve(&amp;e, prb, &amp;r))</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 填充消息*/</span></span><br><span class="line">	text_len = printk_sprint(&amp;r.text_buf[<span class="number">0</span>], reserve_size, facility, &amp;flags, fmt, args);</span><br><span class="line">	<span class="keyword">if</span> (trunc_msg_len)</span><br><span class="line">		<span class="built_in">memcpy</span>(&amp;r.text_buf[text_len], trunc_msg, trunc_msg_len);</span><br><span class="line">	<span class="comment">//prb_reserve时将实际的描述符的info传递给了r,这里的赋值将会存储下来</span></span><br><span class="line">	r.info-&gt;text_len = text_len + trunc_msg_len;</span><br><span class="line">	r.info-&gt;facility = facility;</span><br><span class="line">	r.info-&gt;level = level &amp; <span class="number">7</span>;</span><br><span class="line">	r.info-&gt;flags = flags &amp; <span class="number">0x1f</span>;</span><br><span class="line">	r.info-&gt;ts_nsec = ts_nsec;</span><br><span class="line">	r.info-&gt;caller_id = caller_id;</span><br><span class="line">	<span class="keyword">if</span> (dev_info)</span><br><span class="line">		<span class="built_in">memcpy</span>(&amp;r.info-&gt;dev_info, dev_info, <span class="keyword">sizeof</span>(r.info-&gt;dev_info));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 没有尾随换行符的消息则可以继续添加到当前缓冲区中 */</span></span><br><span class="line">	<span class="keyword">if</span> (!(flags &amp; LOG_NEWLINE))</span><br><span class="line">		prb_commit(&amp;e);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		prb_final_commit(&amp;e);	<span class="comment">//完成缓存可以使用了</span></span><br><span class="line"></span><br><span class="line">	ret = text_len + trunc_msg_len;</span><br><span class="line">out:</span><br><span class="line">	printk_exit_irqrestore(recursion_ptr, irqflags);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="vprintk-emit-打印消息发送"><a href="#vprintk-emit-打印消息发送" class="headerlink" title="vprintk_emit 打印消息发送"></a>vprintk_emit 打印消息发送</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage <span class="type">int</span> <span class="title function_">vprintk_emit</span><span class="params">(<span class="type">int</span> facility, <span class="type">int</span> level,</span></span><br><span class="line"><span class="params">			    <span class="type">const</span> <span class="keyword">struct</span> dev_printk_info *dev_info,</span></span><br><span class="line"><span class="params">			    <span class="type">const</span> <span class="type">char</span> *fmt, va_list args)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">console_flush_type</span> <span class="title">ft</span>;</span></span><br><span class="line">	<span class="type">int</span> printed_len;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Suppress unimportant messages after panic happens */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(suppress_printk))   <span class="comment">//panic函数置一</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The messages on the panic CPU are the most important. If</span></span><br><span class="line"><span class="comment">	 * non-panic CPUs are generating any messages, they will be</span></span><br><span class="line"><span class="comment">	 * silently dropped.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (other_cpu_in_panic() &amp;&amp; !panic_triggering_all_cpu_backtrace)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   	<span class="comment">//初始化时不处理</span></span><br><span class="line">	printk_get_console_flush_type(&amp;ft); <span class="comment">//确定使用哪些控制台刷新方法</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*如果从调度器调用，我们不能调用 up（）。 */</span></span><br><span class="line">	<span class="keyword">if</span> (level == LOGLEVEL_SCHED) &#123;</span><br><span class="line">		level = LOGLEVEL_DEFAULT;</span><br><span class="line">		ft.legacy_offload |= ft.legacy_direct;</span><br><span class="line">		ft.legacy_direct = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	printk_delay(level); <span class="comment">//当CONFIG_BOOT_PRINTK_DELAY配置时 每条消息延时打印配置</span></span><br><span class="line"></span><br><span class="line">	printed_len = vprintk_store(facility, level, dev_info, fmt, args);	<span class="comment">//打印消息到环形缓冲区</span></span><br><span class="line">	<span class="keyword">if</span> (ft.nbcon_atomic)</span><br><span class="line">		nbcon_atomic_flush_pending();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ft.nbcon_offload)</span><br><span class="line">		nbcon_kthreads_wake();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ft.legacy_direct) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * The caller may be holding system-critical or</span></span><br><span class="line"><span class="comment">		 * timing-sensitive locks. Disable preemption during</span></span><br><span class="line"><span class="comment">		 * printing of all remaining records to all consoles so that</span></span><br><span class="line"><span class="comment">		 * this context can return as soon as possible. Hopefully</span></span><br><span class="line"><span class="comment">		 * another printk() caller will take over the printing.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		preempt_disable();</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Try to acquire and then immediately release the console</span></span><br><span class="line"><span class="comment">		 * semaphore. The release will print out buffers. With the</span></span><br><span class="line"><span class="comment">		 * spinning variant, this context tries to take over the</span></span><br><span class="line"><span class="comment">		 * printing from another printing context.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (console_trylock_spinning())</span><br><span class="line">			console_unlock();</span><br><span class="line">		preempt_enable();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ft.legacy_offload)</span><br><span class="line">		defer_console_output();</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		wake_up_klogd();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> printed_len;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(vprintk_emit);</span><br></pre></td></tr></table></figure>

<h2 id="printk-内核日志打印函数"><a href="#printk-内核日志打印函数" class="headerlink" title="printk 内核日志打印函数"></a>printk 内核日志打印函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> printk(fmt, ...) printk_index_wrap(_printk, fmt, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> printk_deferred(fmt, ...)					\</span></span><br><span class="line"><span class="meta">	printk_index_wrap(_printk_deferred, fmt, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">vprintk_deferred</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, va_list args)</span></span><br><span class="line">&#123;</span><br><span class="line">   	<span class="comment">//不是从设备驱动中调用的</span></span><br><span class="line">	<span class="keyword">return</span> vprintk_emit(<span class="number">0</span>, LOGLEVEL_SCHED, <span class="literal">NULL</span>, fmt, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _printk_deferred(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span><br><span class="line">&#123;</span><br><span class="line">	va_list args;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">	va_start(args, fmt);</span><br><span class="line">	r = vprintk_deferred(fmt, args);</span><br><span class="line">	va_end(args);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ignore-loglevel"><a href="#ignore-loglevel" class="headerlink" title="ignore_loglevel"></a>ignore_loglevel</h2><ol>
<li><code>ignore_loglevel</code> 是一个布尔变量，用于指示是否忽略内核的日志级别设置。</li>
<li>如果设置为 true，则内核将忽略日志级别设置，并将所有内核消息打印到控制台。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> __read_mostly ignore_loglevel;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">ignore_loglevel_setup</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">	ignore_loglevel = <span class="literal">true</span>;</span><br><span class="line">	pr_info(<span class="string">&quot;debug: ignoring loglevel setting.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">early_param(<span class="string">&quot;ignore_loglevel&quot;</span>, ignore_loglevel_setup);</span><br><span class="line">module_param(ignore_loglevel, <span class="type">bool</span>, S_IRUGO | S_IWUSR);</span><br><span class="line">MODULE_PARM_DESC(ignore_loglevel,</span><br><span class="line">		 <span class="string">&quot;ignore loglevel setting (prints all kernel messages to the console)&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="—————-控制台——————————————"><a href="#—————-控制台——————————————" class="headerlink" title="—————-控制台——————————————-"></a>—————-控制台——————————————-</h2><h2 id="suppress-message-printing-禁止打印消息"><a href="#suppress-message-printing-禁止打印消息" class="headerlink" title="suppress_message_printing 禁止打印消息"></a>suppress_message_printing 禁止打印消息</h2><ol>
<li><code>suppress_message_printing</code> 函数用于检查是否应该禁止打印消息。</li>
<li>如果当前的日志级别大于等于 <code>console_loglevel</code> 且 <code>ignore_loglevel</code> 为假，则返回 true，表示禁止打印消息。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* printk&#x27;s without a loglevel use this.. */</span></span><br><span class="line"><span class="comment">//内核中日志消息的默认等级</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MESSAGE_LOGLEVEL_DEFAULT CONFIG_MESSAGE_LOGLEVEL_DEFAULT		<span class="comment">//4</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 默认曾经是硬编码的 7，安静的曾经是硬编码的 4，</span></span><br><span class="line"><span class="comment"> * 我们现在允许从 Kernel Config 中设置两者。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//控制台日志输出等级,只有小于这个值的消息才会输出到控制台</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONSOLE_LOGLEVEL_DEFAULT CONFIG_CONSOLE_LOGLEVEL_DEFAULT		<span class="comment">//7</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONSOLE_LOGLEVEL_QUIET	 CONFIG_CONSOLE_LOGLEVEL_QUIET</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> console_loglevel (console_printk[0])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> default_message_loglevel (console_printk[1])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> minimum_console_loglevel (console_printk[2])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> default_console_loglevel (console_printk[3])</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> console_printk[<span class="number">4</span>] = &#123;</span><br><span class="line">	CONSOLE_LOGLEVEL_DEFAULT,	<span class="comment">/* console_loglevel */</span></span><br><span class="line">	MESSAGE_LOGLEVEL_DEFAULT,	<span class="comment">/* default_message_loglevel */</span></span><br><span class="line">	CONSOLE_LOGLEVEL_MIN,		<span class="comment">/* minimum_console_loglevel */</span></span><br><span class="line">	CONSOLE_LOGLEVEL_DEFAULT,	<span class="comment">/* default_console_loglevel */</span></span><br><span class="line">&#125;;</span><br><span class="line">EXPORT_SYMBOL_GPL(console_printk);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">suppress_message_printing</span><span class="params">(<span class="type">int</span> level)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (level &gt;= console_loglevel &amp;&amp; !ignore_loglevel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="console-list-lock-console-list-unlock-控制台列表锁定和解锁"><a href="#console-list-lock-console-list-unlock-控制台列表锁定和解锁" class="headerlink" title="console_list_lock console_list_unlock 控制台列表锁定和解锁"></a>console_list_lock console_list_unlock 控制台列表锁定和解锁</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * console_list_lock - 锁定控制台列表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 对于控制台列表或控制台&gt;标志更新</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_list_lock</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 在 unregister_console（） 和 console_force_preferred_locked（） 中，</span></span><br><span class="line"><span class="comment">	 * synchronize_srcu（） 在按住console_list_lock的情况下调用。因此，不允许在持有srcu_lock的情况下进行console_list_lock。</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 只有在启用适当的调试选项时，才能检测此上下文是否真的位于读取端关键部分。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	WARN_ON_ONCE(debug_lockdep_rcu_enabled() &amp;&amp;</span><br><span class="line">		     srcu_read_lock_held(&amp;console_srcu));</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;console_mutex);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(console_list_lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * console_list_unlock - Unlock the console list</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Counterpart to console_list_lock()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_list_unlock</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	mutex_unlock(&amp;console_mutex);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(console_list_unlock);</span><br></pre></td></tr></table></figure>

<h2 id="try-enable-default-console-尝试无条件启用控制台"><a href="#try-enable-default-console-尝试无条件启用控制台" class="headerlink" title="try_enable_default_console 尝试无条件启用控制台"></a>try_enable_default_console 尝试无条件启用控制台</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">console_call_setup</span><span class="params">(<span class="keyword">struct</span> console *newcon, <span class="type">char</span> *options)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!newcon-&gt;setup)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Synchronize with possible boot console. */</span></span><br><span class="line">	console_lock();</span><br><span class="line">	err = newcon-&gt;setup(newcon, options);</span><br><span class="line">	console_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 尝试无条件启用控制台 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">try_enable_default_console</span><span class="params">(<span class="keyword">struct</span> console *newcon)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (newcon-&gt;index &lt; <span class="number">0</span>)</span><br><span class="line">		newcon-&gt;index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (console_call_setup(newcon, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	newcon-&gt;flags |= CON_ENABLED;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (newcon-&gt;device)</span><br><span class="line">		newcon-&gt;flags |= CON_CONSDEV;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="try-enable-preferred-console-尝试启用首选控制台"><a href="#try-enable-preferred-console-尝试启用首选控制台" class="headerlink" title="try_enable_preferred_console 尝试启用首选控制台"></a>try_enable_preferred_console 尝试启用首选控制台</h2><ol>
<li>控制台没初始化时，跳过匹配</li>
<li>控制台使能且不需要用户指定,返回0</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 由 register_console（） 调用，以尝试将新注册的控制台与命令行或 add_preferred_console（） 选择的任何控制台进行匹配，并设置/启用它。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 需要注意静态启用的控制台，例如 netconsole</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">try_enable_preferred_console</span><span class="params">(<span class="keyword">struct</span> console *newcon,</span></span><br><span class="line"><span class="params">					<span class="type">bool</span> user_specified)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">console_cmdline</span> *<span class="title">c</span>;</span></span><br><span class="line">	<span class="type">int</span> i, err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>, c = console_cmdline;</span><br><span class="line">	     i &lt; MAX_CMDLINECONSOLES &amp;&amp; (c-&gt;name[<span class="number">0</span>] || c-&gt;devname[<span class="number">0</span>]);</span><br><span class="line">	     i++, c++) &#123;</span><br><span class="line">		<span class="comment">/* Console not yet initialized? */</span></span><br><span class="line">		<span class="keyword">if</span> (!c-&gt;name[<span class="number">0</span>])</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span> (c-&gt;user_specified != user_specified)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span> (!newcon-&gt;match ||</span><br><span class="line">		    newcon-&gt;match(newcon, c-&gt;name, c-&gt;index, c-&gt;options) != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">/* default matching */</span></span><br><span class="line">			BUILD_BUG_ON(<span class="keyword">sizeof</span>(c-&gt;name) != <span class="keyword">sizeof</span>(newcon-&gt;name));</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">strcmp</span>(c-&gt;name, newcon-&gt;name) != <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span> (newcon-&gt;index &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">			    newcon-&gt;index != c-&gt;index)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span> (newcon-&gt;index &lt; <span class="number">0</span>)</span><br><span class="line">				newcon-&gt;index = c-&gt;index;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (_braille_register_console(newcon, c))</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">			err = console_call_setup(newcon, c-&gt;options);</span><br><span class="line">			<span class="keyword">if</span> (err)</span><br><span class="line">				<span class="keyword">return</span> err;</span><br><span class="line">		&#125;</span><br><span class="line">		newcon-&gt;flags |= CON_ENABLED;</span><br><span class="line">		<span class="keyword">if</span> (i == preferred_console)</span><br><span class="line">			newcon-&gt;flags |= CON_CONSDEV;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Some consoles, such as pstore and netconsole, can be enabled even</span></span><br><span class="line"><span class="comment">	 * without matching. Accept the pre-enabled consoles only when match()</span></span><br><span class="line"><span class="comment">	 * and setup() had a chance to be called.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (newcon-&gt;flags &amp; CON_ENABLED &amp;&amp; c-&gt;user_specified ==	user_specified)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> -ENOENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="get-init-console-seq-返回新注册的控制台的起始序列号"><a href="#get-init-console-seq-返回新注册的控制台的起始序列号" class="headerlink" title="get_init_console_seq 返回新注册的控制台的起始序列号"></a>get_init_console_seq 返回新注册的控制台的起始序列号</h2><ol>
<li>引导控制台直接使用 @syslog_seq 作为起始序列号。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*返回新注册的控制台的起始序列号。 */</span></span><br><span class="line"><span class="type">static</span> u64 <span class="title function_">get_init_console_seq</span><span class="params">(<span class="keyword">struct</span> console *newcon, <span class="type">bool</span> bootcon_registered)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">console</span> *<span class="title">con</span>;</span></span><br><span class="line">	<span class="type">bool</span> handover;</span><br><span class="line">	u64 init_seq;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (newcon-&gt;flags &amp; (CON_PRINTBUFFER | CON_BOOT)) &#123;</span><br><span class="line">		<span class="comment">/* 获取 @syslog_seq 的一致副本。 */</span></span><br><span class="line">		mutex_lock(&amp;syslog_lock);</span><br><span class="line">		init_seq = syslog_seq;</span><br><span class="line">		mutex_unlock(&amp;syslog_lock);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* Begin with next message added to ringbuffer. */</span></span><br><span class="line">		init_seq = prb_next_seq(prb);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If any enabled boot consoles are due to be unregistered</span></span><br><span class="line"><span class="comment">		 * shortly, some may not be caught up and may be the same</span></span><br><span class="line"><span class="comment">		 * device as @newcon. Since it is not known which boot console</span></span><br><span class="line"><span class="comment">		 * is the same device, flush all consoles and, if necessary,</span></span><br><span class="line"><span class="comment">		 * start with the message of the enabled boot console that is</span></span><br><span class="line"><span class="comment">		 * the furthest behind.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (bootcon_registered &amp;&amp; !keep_bootcon) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Hold the console_lock to stop console printing and</span></span><br><span class="line"><span class="comment">			 * guarantee safe access to console-&gt;seq.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			console_lock();</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Flush all consoles and set the console to start at</span></span><br><span class="line"><span class="comment">			 * the next unprinted sequence number.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (!console_flush_all(<span class="literal">true</span>, &amp;init_seq, &amp;handover)) &#123;</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * Flushing failed. Just choose the lowest</span></span><br><span class="line"><span class="comment">				 * sequence of the enabled boot consoles.</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line"></span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * If there was a handover, this context no</span></span><br><span class="line"><span class="comment">				 * longer holds the console_lock.</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				<span class="keyword">if</span> (handover)</span><br><span class="line">					console_lock();</span><br><span class="line"></span><br><span class="line">				init_seq = prb_next_seq(prb);</span><br><span class="line">				for_each_console(con) &#123;</span><br><span class="line">					u64 seq;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">if</span> (!(con-&gt;flags &amp; CON_BOOT) ||</span><br><span class="line">					    !(con-&gt;flags &amp; CON_ENABLED)) &#123;</span><br><span class="line">						<span class="keyword">continue</span>;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">if</span> (con-&gt;flags &amp; CON_NBCON)</span><br><span class="line">						seq = nbcon_seq_read(con);</span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">						seq = con-&gt;seq;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">if</span> (seq &lt; init_seq)</span><br><span class="line">						init_seq = seq;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			console_unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> init_seq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="register-console-注册控制台-unregister-console-locked-注销控制台"><a href="#register-console-注册控制台-unregister-console-locked-注销控制台" class="headerlink" title="register_console 注册控制台 unregister_console_locked 注销控制台"></a>register_console 注册控制台 unregister_console_locked 注销控制台</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">unregister_console_locked</span><span class="params">(<span class="keyword">struct</span> console *console)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 控制台驱动程序在内核初始化期间调用此例程，以使用 printk（） 注册控制台打印过程，并打印在初始化控制台驱动程序之前由内核打印的任何消息。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这可能发生在启动过程的早期（因为early_printk） - 有时在 setup_arch（） 完成之前 - 小心使用的内核功能 - 它们可能还没有初始化。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 有两种类型的控制台 - bootconsoles （early_printk） 和 “real” consoles（所有不是 bootconsole 的东西），它们的处理方式不同。</span></span><br><span class="line"><span class="comment"> * - 任何时候都可以注册任意数量的引导控制台。</span></span><br><span class="line"><span class="comment"> * - 一旦注册了“真实”控制台，所有引导控制台将自动取消注册。</span></span><br><span class="line"><span class="comment"> * - 一旦注册了 “真实” 控制台，任何注册 bootconsole 的尝试都将被拒绝</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">register_console</span><span class="params">(<span class="keyword">struct</span> console *newcon)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">bool</span> use_device_lock = (newcon-&gt;flags &amp; CON_NBCON) &amp;&amp; newcon-&gt;write_atomic;</span><br><span class="line">	<span class="type">bool</span> bootcon_registered = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">bool</span> realcon_registered = <span class="literal">false</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">console</span> *<span class="title">con</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">	u64 init_seq;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">	console_list_lock();</span><br><span class="line"></span><br><span class="line">	for_each_console(con) &#123;	<span class="comment">//遍历控制台列表</span></span><br><span class="line">		<span class="keyword">if</span> (WARN(con == newcon, <span class="string">&quot;console &#x27;%s%d&#x27; already registered\n&quot;</span>,</span><br><span class="line">					 con-&gt;name, con-&gt;index)) &#123;</span><br><span class="line">			<span class="keyword">goto</span> unlock;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (con-&gt;flags &amp; CON_BOOT)</span><br><span class="line">			bootcon_registered = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			realcon_registered = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 当已经有真正的引导控制台时，不要注册引导控制台。*/</span></span><br><span class="line">	<span class="keyword">if</span> ((newcon-&gt;flags &amp; CON_BOOT) &amp;&amp; realcon_registered) &#123;</span><br><span class="line">		pr_info(<span class="string">&quot;Too late to register bootconsole %s%d\n&quot;</span>,</span><br><span class="line">			newcon-&gt;name, newcon-&gt;index);</span><br><span class="line">		<span class="keyword">goto</span> unlock;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (newcon-&gt;flags &amp; CON_NBCON) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Ensure the nbcon console buffers can be allocated</span></span><br><span class="line"><span class="comment">		 * before modifying any global data.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!nbcon_alloc(newcon))</span><br><span class="line">			<span class="keyword">goto</span> unlock;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 看看我们是否要默认启用这个控制台驱动程序。</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 当命令行、设备树或 SPCR 首选控制台时，不会。</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 第一个具有 tty 绑定（驱动程序）的真正控制台获胜。在找到合适的控制台之前，可能会启用更多控制台。</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 请注意，具有 tty 绑定的主机将设置 CON_CONSDEV 标志，并且将排在列表中的第一个。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (preferred_console &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">//链表为空或者第一个控制台不是设备或者第一个控制台是引导控制台</span></span><br><span class="line">		<span class="keyword">if</span> (hlist_empty(&amp;console_list) || !console_first()-&gt;device ||</span><br><span class="line">		    console_first()-&gt;flags &amp; CON_BOOT) &#123;</span><br><span class="line">			try_enable_default_console(newcon);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 查看此控制台是否与我们在命令行上选择的控制台匹配 */</span></span><br><span class="line">	err = try_enable_preferred_console(newcon, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果没有，请尝试与平台默认值匹配 */</span></span><br><span class="line">	<span class="keyword">if</span> (err == -ENOENT)</span><br><span class="line">		err = try_enable_preferred_console(newcon, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* printk（） 消息不会打印到盲文控制台。 */</span></span><br><span class="line">	<span class="keyword">if</span> (err || newcon-&gt;flags &amp; CON_BRL) &#123;</span><br><span class="line">		<span class="keyword">if</span> (newcon-&gt;flags &amp; CON_NBCON)</span><br><span class="line">			nbcon_free(newcon);</span><br><span class="line">		<span class="keyword">goto</span> unlock;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 如果我们有一个 bootconsole，并且要切换到真正的控制台，请不要再次打印所有内容，</span></span><br><span class="line"><span class="comment">	 * 因为当 boot console 和真正的 console 是相同的物理设备时，看到两次开始的 boot 消息很烦人</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (bootcon_registered &amp;&amp;</span><br><span class="line">		<span class="comment">//控制台不是引导控制台,且具有设备绑定</span></span><br><span class="line">	    ((newcon-&gt;flags &amp; (CON_CONSDEV | CON_BOOT)) == CON_CONSDEV)) &#123;</span><br><span class="line">		newcon-&gt;flags &amp;= ~CON_PRINTBUFFER;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	newcon-&gt;dropped = <span class="number">0</span>;</span><br><span class="line">	init_seq = get_init_console_seq(newcon, bootcon_registered);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (newcon-&gt;flags &amp; CON_NBCON) &#123;</span><br><span class="line">		have_nbcon_console = <span class="literal">true</span>;</span><br><span class="line">		nbcon_seq_force(newcon, init_seq);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		have_legacy_console = <span class="literal">true</span>;</span><br><span class="line">		newcon-&gt;seq = init_seq;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (newcon-&gt;flags &amp; CON_BOOT)</span><br><span class="line">		have_boot_console = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If another context is actively using the hardware of this new</span></span><br><span class="line"><span class="comment">	 * console, it will not be aware of the nbcon synchronization. This</span></span><br><span class="line"><span class="comment">	 * is a risk that two contexts could access the hardware</span></span><br><span class="line"><span class="comment">	 * simultaneously if this new console is used for atomic printing</span></span><br><span class="line"><span class="comment">	 * and the other context is still using the hardware.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Use the driver synchronization to ensure that the hardware is not</span></span><br><span class="line"><span class="comment">	 * in use while this new console transitions to being registered.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (use_device_lock)</span><br><span class="line">		newcon-&gt;device_lock(newcon, &amp;flags);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 将此控制台放在列表中 - 将首选驱动程序放在列表的开头。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (hlist_empty(&amp;console_list)) &#123;</span><br><span class="line">		<span class="comment">/* 确保始终为头部设置 CON_CONSDEV. */</span></span><br><span class="line">		newcon-&gt;flags |= CON_CONSDEV;</span><br><span class="line">		hlist_add_head_rcu(&amp;newcon-&gt;node, &amp;console_list);</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (newcon-&gt;flags &amp; CON_CONSDEV) &#123;</span><br><span class="line">		<span class="comment">/* Only the new head can have CON_CONSDEV set. */</span></span><br><span class="line">		console_srcu_write_flags(console_first(), console_first()-&gt;flags &amp; ~CON_CONSDEV);</span><br><span class="line">		hlist_add_head_rcu(&amp;newcon-&gt;node, &amp;console_list);</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		hlist_add_behind_rcu(&amp;newcon-&gt;node, console_list.first);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 无需在此处同步 SRCU！调用方不依赖于非所有上下文都能在 nregister_console（） 完成之前看到新控制台。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 这个新控制台现已注册. */</span></span><br><span class="line">	<span class="keyword">if</span> (use_device_lock)</span><br><span class="line">		newcon-&gt;device_unlock(newcon, flags);</span><br><span class="line"></span><br><span class="line">	console_sysfs_notify();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 通过在启用真实控制台后取消注册引导控制台，我们会在所有控制台上收到“console xxx enabled”消息</span></span><br><span class="line"><span class="comment">	 * - 引导控制台、真实控制台等 - 这是为了确保最终用户知道内核的日志缓冲区中可能有一些内容进入了引导控制台（他们在真实控制台上看不到）</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	con_printk(KERN_INFO, newcon, <span class="string">&quot;enabled\n&quot;</span>);	<span class="comment">//打印消息日志</span></span><br><span class="line">	<span class="keyword">if</span> (bootcon_registered &amp;&amp;</span><br><span class="line">		<span class="comment">//控制台不是引导控制台,且具有设备绑定</span></span><br><span class="line">	    ((newcon-&gt;flags &amp; (CON_CONSDEV | CON_BOOT)) == CON_CONSDEV) &amp;&amp;</span><br><span class="line">	    !keep_bootcon) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">		hlist_for_each_entry_safe(con, tmp, &amp;console_list, node) &#123;</span><br><span class="line">			<span class="keyword">if</span> (con-&gt;flags &amp; CON_BOOT)</span><br><span class="line">				unregister_console_locked(con);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 已更改控制台列表，可能需要启动/停止打印机线程. */</span></span><br><span class="line">	printk_kthreads_check_locked();</span><br><span class="line">unlock:</span><br><span class="line">	console_list_unlock();</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(register_console);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Must be called under console_list_lock(). */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">unregister_console_locked</span><span class="params">(<span class="keyword">struct</span> console *console)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">bool</span> use_device_lock = (console-&gt;flags &amp; CON_NBCON) &amp;&amp; console-&gt;write_atomic;</span><br><span class="line">	<span class="type">bool</span> found_legacy_con = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">bool</span> found_nbcon_con = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">bool</span> found_boot_con = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">console</span> *<span class="title">c</span>;</span></span><br><span class="line">	<span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line">	lockdep_assert_console_list_lock_held();</span><br><span class="line"></span><br><span class="line">	con_printk(KERN_INFO, console, <span class="string">&quot;disabled\n&quot;</span>);</span><br><span class="line">	<span class="comment">//A11Y_BRAILLE_CONSOLE 盲文控制台支持</span></span><br><span class="line">	res = _braille_unregister_console(console);</span><br><span class="line">	<span class="keyword">if</span> (res &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	<span class="keyword">if</span> (res &gt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!console_is_registered_locked(console))</span><br><span class="line">		res = -ENODEV;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (console_is_usable(console, console-&gt;flags, <span class="literal">true</span>))	<span class="comment">//检查控制台是否可用</span></span><br><span class="line">		__pr_flush(console, <span class="number">1000</span>, <span class="literal">true</span>);	<span class="comment">//等待打印完成</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 无条件禁用它*/</span></span><br><span class="line">	console_srcu_write_flags(console, console-&gt;flags &amp; ~CON_ENABLED);	<span class="comment">//无锁读取可能已注册控制台的标志</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (res &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Use the driver synchronization to ensure that the hardware is not</span></span><br><span class="line"><span class="comment">	 * in use while this console transitions to being unregistered.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (use_device_lock)</span><br><span class="line">		console-&gt;device_lock(console, &amp;flags);</span><br><span class="line"></span><br><span class="line">	hlist_del_init_rcu(&amp;console-&gt;node);	<span class="comment">//从链表上删除当前节点</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (use_device_lock)</span><br><span class="line">		console-&gt;device_unlock(console, flags);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * &lt;遗留&gt;</span></span><br><span class="line"><span class="comment">	 * 如果这不是最后一个主机，并且已设置CON_CONSDEV，我们需要在下一个首选主机上进行设置。</span></span><br><span class="line"><span class="comment">	 * &lt;/遗留&gt;</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 以上内容毫无意义，因为不能保证下一个控制台连接了任何设备。哦，好吧......</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!hlist_empty(&amp;console_list) &amp;&amp; console-&gt;flags &amp; CON_CONSDEV)</span><br><span class="line">		console_srcu_write_flags(console_first(), console_first()-&gt;flags | CON_CONSDEV);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 确保所有 SRCU 列表遍历都已完成。所有上下文都必须无法在列表中看到此控制台，以便可以安全地执行任何退出/清理例程。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	synchronize_srcu(&amp;console_srcu);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (console-&gt;flags &amp; CON_NBCON)</span><br><span class="line">		nbcon_free(console);</span><br><span class="line"></span><br><span class="line">	console_sysfs_notify();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (console-&gt;<span class="built_in">exit</span>)</span><br><span class="line">		res = console-&gt;<span class="built_in">exit</span>(console);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 此主机消失后，跟踪已注册主机类型的全局标记可能已更改。更新它们。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	for_each_console(c) &#123;</span><br><span class="line">		<span class="keyword">if</span> (c-&gt;flags &amp; CON_BOOT)</span><br><span class="line">			found_boot_con = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (c-&gt;flags &amp; CON_NBCON)</span><br><span class="line">			found_nbcon_con = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			found_legacy_con = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!found_boot_con)</span><br><span class="line">		have_boot_console = found_boot_con;</span><br><span class="line">	<span class="keyword">if</span> (!found_legacy_con)</span><br><span class="line">		have_legacy_console = found_legacy_con;</span><br><span class="line">	<span class="keyword">if</span> (!found_nbcon_con)</span><br><span class="line">		have_nbcon_console = found_nbcon_con;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 更改了控制台列表，可能需要启动/停止打印机线程。 */</span></span><br><span class="line">	printk_kthreads_check_locked();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">unregister_console</span><span class="params">(<span class="keyword">struct</span> console *console)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line">	console_list_lock();</span><br><span class="line">	res = unregister_console_locked(console);</span><br><span class="line">	console_list_unlock();</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(unregister_console);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="setup-log-buf"><a href="#setup-log-buf" class="headerlink" title="setup_log_buf"></a>setup_log_buf</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">setup_log_buf</span><span class="params">(<span class="type">int</span> early)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">printk_info</span> *<span class="title">new_infos</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> new_descs_count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">prb_desc</span> *<span class="title">new_descs</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">printk_info</span> <span class="title">info</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">printk_record</span> <span class="title">r</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> text_size;</span><br><span class="line">	<span class="type">size_t</span> new_descs_size;</span><br><span class="line">	<span class="type">size_t</span> new_infos_size;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">	<span class="type">char</span> *new_log_buf;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">free</span>;</span><br><span class="line">	u64 seq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *一些 arch 多次调用 setup_log_buf（） - 第一次是非常早期的，例如从 setup_arch（） 开始，第二次 - 当 percpu_areas 初始化时。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!early)</span><br><span class="line">		set_percpu_data_ready();	<span class="comment">//__printk_percpu_data_ready = true;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (log_buf != __log_buf)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!early &amp;&amp; !new_log_buf_len)</span><br><span class="line">		log_buf_add_cpu();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!new_log_buf_len) &#123;</span><br><span class="line">		<span class="comment">/* Show the memory stats only once. */</span></span><br><span class="line">		<span class="keyword">if</span> (!early)</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	print_log_buf_usage_stats();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="console-init"><a href="#console-init" class="headerlink" title="console_init"></a>console_init</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">               <span class="number">0x00000000c02a34bc</span>                __con_initcall_start = .</span><br><span class="line">*(.con_initcall.init)</span><br><span class="line">               <span class="number">0x00000000c02a34bc</span>                __con_initcall_end = .</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 该函数在系统启动的早期阶段被调用，此时内核的许多子系统尚未完全初始化。</span></span><br><span class="line"><span class="comment"> * 因此，console_init 主要负责基础的控制台初始化，以便后续的启动过程能够输出调试信息或错误消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">console_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">initcall_t</span> call;</span><br><span class="line">	<span class="type">initcall_entry_t</span> *ce;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化默认的 TTY（终端）行规程.</span></span><br><span class="line"><span class="comment">	 * 行规程是 TTY 子系统的一部分，用于处理终端输入和输出的基本行为，例如回显字符、行编辑等 */</span></span><br><span class="line">	n_tty_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * set up the console device so that later boot sequences can</span></span><br><span class="line"><span class="comment">	 * inform about problems etc..</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ce = __con_initcall_start;</span><br><span class="line">	trace_initcall_level(<span class="string">&quot;console&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span> (ce &lt; __con_initcall_end) &#123;</span><br><span class="line">		call = initcall_from_entry(ce);</span><br><span class="line">		trace_initcall_start(call);</span><br><span class="line">		ret = call();</span><br><span class="line">		trace_initcall_finish(call, ret);</span><br><span class="line">		ce++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="printk-set-kthreads-ready"><a href="#printk-set-kthreads-ready" class="headerlink" title="printk_set_kthreads_ready"></a>printk_set_kthreads_ready</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * printk_kthreads_check_locked - 检查并适当地启动nbcon kthreads</span></span><br><span class="line"><span class="comment"> * @...</span></span><br><span class="line"><span class="comment"> * 必须在持有 console_list_lock() 的情况下调用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">printk_kthreads_check_locked</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* ... 省略变量定义 ... */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 确保锁已被持有，这是一个调试断言。*/</span></span><br><span class="line">	lockdep_assert_console_list_lock_held();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * **门控条件1**: 如果系统还未准备好启动kthreads，直接返回。</span></span><br><span class="line"><span class="comment">	 * printk_kthreads_ready 这个全局标志由下面的 printk_set_kthreads_ready 设置。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!printk_kthreads_ready)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * **逻辑块1: 处理传统(Legacy)控制台线程**</span></span><br><span class="line"><span class="comment">	 * 如果当前系统中有任何传统控制台或启动控制台...</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (have_legacy_console || have_boot_console) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * ...并且我们还没有创建传统控制台的专有kthread，</span></span><br><span class="line"><span class="comment">		 * 并且系统强制要求为传统控制台创建一个kthread(force_legacy_kthread)，</span></span><br><span class="line"><span class="comment">		 * 并且创建这个线程失败了(legacy_kthread_create返回假)...</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!printk_legacy_kthread &amp;&amp;</span><br><span class="line">		    force_legacy_kthread() &amp;&amp;</span><br><span class="line">		    !legacy_kthread_create()) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * **灾难性失败处理**：如果连为传统控制台创建kthread都失败了，</span></span><br><span class="line"><span class="comment">			 * 说明系统处于一种不健康的状态。为了安全，必须注销掉所有</span></span><br><span class="line"><span class="comment">			 * 传统的控制台，因为它们无法再以非阻塞方式工作。</span></span><br><span class="line"><span class="comment">			 * nbcon控制台不受影响，它们有自己的线程。</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			hlist_for_each_entry_safe(con, tmp, &amp;console_list, node) &#123;</span><br><span class="line">				<span class="keyword">if</span> (con-&gt;flags &amp; CON_NBCON)</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				unregister_console_locked(con);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (printk_legacy_kthread) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * **清理逻辑**: 如果系统中已经没有任何传统或启动控制台了，</span></span><br><span class="line"><span class="comment">		 * 但我们之前创建的那个传统kthread还在运行，现在就停止并清理它。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		kthread_stop(printk_legacy_kthread);</span><br><span class="line">		printk_legacy_kthread = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * **门控条件2: 等待启动控制台退出**</span></span><br><span class="line"><span class="comment">	 * 只要系统中还有任何启动控制台(have_boot_console)，或者一个nbcon都还没注册，</span></span><br><span class="line"><span class="comment">	 * 我们就绝对不能启动打印线程。这是因为无法同步启动代码和常规驱动</span></span><br><span class="line"><span class="comment">	 * 对硬件的访问。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (have_boot_console || !have_nbcon_console) &#123;</span><br><span class="line">		<span class="comment">/* 如果所有nbcon都注销了，要确保清理这个标志。*/</span></span><br><span class="line">		printk_kthreads_running = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果线程已经都在运行了，就没必要再做了。*/</span></span><br><span class="line">	<span class="keyword">if</span> (printk_kthreads_running)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * **逻辑块2: 为所有nbcon控制台创建线程**</span></span><br><span class="line"><span class="comment">	 * 走到这里，说明所有条件都已满足：系统准备好了，启动控制台已退场，</span></span><br><span class="line"><span class="comment">	 * 并且至少有一个nbcon控制台存在。</span></span><br><span class="line"><span class="comment">	 * 现在遍历所有控制台，为每一个标记为CON_NBCON的控制台创建其专属的打印线程。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	hlist_for_each_entry_safe(con, tmp, &amp;console_list, node) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!(con-&gt;flags &amp; CON_NBCON))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 如果为某个nbcon创建线程失败，就注销掉这个无法工作的控制台。*/</span></span><br><span class="line">		<span class="keyword">if</span> (!nbcon_kthread_create(con))</span><br><span class="line">			unregister_console_locked(con);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 所有线程创建完毕，设置全局标志，表示我们现在处于异步打印模式。*/</span></span><br><span class="line">	printk_kthreads_running = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * printk_set_kthreads_ready - 在启动时设置kthreads已准备好的标志</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">printk_set_kthreads_ready</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 注册一个系统核心操作集(syscore_ops)。这通常用于系统挂起(suspend)和</span></span><br><span class="line"><span class="comment">	 * 恢复(resume)时的回调。在这里，它确保了在系统休眠前，</span></span><br><span class="line"><span class="comment">	 * printk相关的状态可以被正确地挂起，在恢复后又能被正确地恢复。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	register_syscore_ops(&amp;printk_syscore_ops);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 获取保护全局控制台列表的锁。*/</span></span><br><span class="line">	console_list_lock();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* **核心动作**: 设置全局标志，表示系统环境已准备好，可以启动kthreads了。*/</span></span><br><span class="line">	printk_kthreads_ready = <span class="literal">true</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 立刻调用一次状态机引擎。因为现在 ready 标志刚被设置，</span></span><br><span class="line"><span class="comment">	 * 这是一个检查状态并可能启动线程的第一个机会。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	printk_kthreads_check_locked();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 释放锁。*/</span></span><br><span class="line">	console_list_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 初始化成功</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 确保这个初始化函数在内核启动早期被调用。*/</span></span><br><span class="line">early_initcall(printk_set_kthreads_ready);</span><br></pre></td></tr></table></figure>

<h2 id="pr-flush-同步并等待内核日志输出"><a href="#pr-flush-同步并等待内核日志输出" class="headerlink" title="pr_flush: 同步并等待内核日志输出"></a>pr_flush: 同步并等待内核日志输出</h2><p>此函数 (<code>pr_flush</code>) 及其核心实现 (<code>__pr_flush</code>) 提供了一个关键的同步机制, 用于<strong>确保所有先前由<code>printk</code>产生的内核日志消息, 已经被系统中所有可用的控制台(console)驱动程序实际处理并发送出去</strong>。</p>
<p><code>printk</code>本身是一个非常快速的操作, 它只是将日志数据放入一个内核环形缓冲区(<code>printk ring buffer</code>)中。而真正将这些数据输出到物理设备(如UART串口、显示器、网络控制台)的任务, 是由独立的控制台驱动在后台异步完成的。此函数的核心原理就是<strong>作为一个同步点, 阻塞当前的执行流程, 直到所有控制台驱动的处理进度都”追上”了调用<code>pr_flush</code>时的日志缓冲区的位置</strong>。</p>
<p>这在系统即将关机或崩溃的时刻至关重要。例如, 在<code>kernel_power_off</code>中调用<code>pr_flush</code>, 是为了保证在物理断电前, 像”Powering down…”这样的最后一条日志消息以及任何相关的错误信息, 能够被真实地从UART等接口发送出去, 而不是永远地丢失在内存缓冲区中, 这对于事后调试至关重要。</p>
<hr>
<h3 id="pr-flush-核心实现"><a href="#pr-flush-核心实现" class="headerlink" title="__pr_flush: 核心实现"></a><code>__pr_flush</code>: 核心实现</h3><p>此函数包含了等待所有控制台追上进度的核心循环逻辑。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如果指定了@con, 则只等待那个控制台. 否则等待所有控制台.</span></span><br><span class="line"><span class="comment"> * @timeout_ms: 超时时间(毫秒).</span></span><br><span class="line"><span class="comment"> * @reset_on_progress: 如果看到有进展, 是否重置超时.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> __pr_flush(<span class="keyword">struct</span> console *con, <span class="type">int</span> timeout_ms, <span class="type">bool</span> reset_on_progress)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 将毫秒超时转换为内核内部的jiffies计数. */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> timeout_jiffies = msecs_to_jiffies(timeout_ms);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> remaining_jiffies = timeout_jiffies;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">console_flush_type</span> <span class="title">ft</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">console</span> *<span class="title">c</span>;</span></span><br><span class="line">	u64 last_diff = <span class="number">0</span>;</span><br><span class="line">	u64 printk_seq;</span><br><span class="line">	<span class="type">short</span> flags;</span><br><span class="line">	<span class="type">int</span> cookie;</span><br><span class="line">	u64 diff;</span><br><span class="line">	u64 seq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 保护性检查: 在调度器运行之前, 无法睡眠, 故此函数无法工作. */</span></span><br><span class="line">	<span class="keyword">if</span> (system_state &lt; SYSTEM_SCHEDULING)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 静态检查注解, 表明此函数可能会睡眠. */</span></span><br><span class="line">	might_sleep();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 获取&quot;目标序列号&quot;. 这是printk环形缓冲区中下一条记录的序列号.</span></span><br><span class="line"><span class="comment">	 * 我们的目标就是等待所有控制台都处理完序列号小于此值的记录.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	seq = prb_next_reserve_seq(prb);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 强制触发一次所有控制台的刷新, 以确保它们开始处理挂起的日志.</span></span><br><span class="line"><span class="comment">	 * 这段代码处理了现代非阻塞控制台(nbcon)和传统控制台的不同刷新机制.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	printk_get_console_flush_type(&amp;ft);</span><br><span class="line">	<span class="keyword">if</span> (ft.nbcon_atomic)</span><br><span class="line">		nbcon_atomic_flush_pending();</span><br><span class="line">	<span class="keyword">if</span> (ft.legacy_direct) &#123;</span><br><span class="line">		console_lock();</span><br><span class="line">		console_unlock();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 进入主等待循环. */</span></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> begin_jiffies;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> slept_jiffies;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 在每轮循环开始时, 重置&quot;差距&quot;计数器. */</span></span><br><span class="line">		diff = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 获取全局控制台锁, 以安全地访问全局控制台列表和每个控制台的seq成员.</span></span><br><span class="line"><span class="comment">		 * 在单核抢占式系统上, 这能防止在遍历时被其他任务抢占, 保证数据一致性.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		console_lock();</span><br><span class="line"></span><br><span class="line">		cookie = console_srcu_read_lock();</span><br><span class="line">		<span class="comment">/* 使用SRC_U安全地遍历所有已注册的控制台. */</span></span><br><span class="line">		for_each_console_srcu(c) &#123;</span><br><span class="line">			<span class="comment">/* 如果指定了单个控制台, 则跳过其他所有控制台. */</span></span><br><span class="line">			<span class="keyword">if</span> (con &amp;&amp; con != c)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			flags = console_srcu_read_flags(c);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * 如果控制台当前不可用(例如, 未完全初始化或已关闭),</span></span><br><span class="line"><span class="comment">			 * 我们不能期望它能取得进展, 所以在计算差距时跳过它.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (!console_is_usable(c, flags, <span class="literal">true</span>) &amp;&amp;</span><br><span class="line">			    !console_is_usable(c, flags, <span class="literal">false</span>)) &#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 读取每个控制台当前已经处理到的日志序列号. */</span></span><br><span class="line">			<span class="keyword">if</span> (flags &amp; CON_NBCON) &#123;</span><br><span class="line">				printk_seq = nbcon_seq_read(c);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				printk_seq = c-&gt;seq;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * 如果控制台的进度落后于我们的目标序列号,</span></span><br><span class="line"><span class="comment">			 * 则将差距累加到总差距diff中.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (printk_seq &lt; seq)</span><br><span class="line">				diff += seq - printk_seq;</span><br><span class="line">		&#125;</span><br><span class="line">		console_srcu_read_unlock(cookie);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 如果总差距相比上一轮减小了(意味着有控制台取得了进展),</span></span><br><span class="line"><span class="comment">		 * 并且调用者要求了, 那么就重置超时计时器.</span></span><br><span class="line"><span class="comment">		 * 这对于慢速控制台很有用, 只要它在工作, 我们就愿意等.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (diff != last_diff &amp;&amp; reset_on_progress)</span><br><span class="line">			remaining_jiffies = timeout_jiffies;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 释放控制台锁. */</span></span><br><span class="line">		console_unlock();</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 循环退出条件:</span></span><br><span class="line"><span class="comment">		 * 1. diff == 0: 所有控制台都已追上, 任务完成.</span></span><br><span class="line"><span class="comment">		 * 2. remaining_jiffies == 0: 超时.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (diff == <span class="number">0</span> || remaining_jiffies == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 短暂睡眠(1毫秒), 让出CPU, 给控制台驱动的后台任务或中断有机会执行,</span></span><br><span class="line"><span class="comment">		 * 以便它们能继续处理日志并取得进展.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		begin_jiffies = jiffies;</span><br><span class="line">		msleep(<span class="number">1</span>);</span><br><span class="line">		slept_jiffies = jiffies - begin_jiffies; <span class="comment">/* 计算实际睡眠的时间. */</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 从剩余时间中减去实际睡眠的时间. */</span></span><br><span class="line">		remaining_jiffies -= min(slept_jiffies, remaining_jiffies);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 更新上一轮的差距值, 用于下一轮的进展判断. */</span></span><br><span class="line">		last_diff = diff;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果循环退出时总差距为0, 说明所有日志都已刷出, 返回true. 否则返回false. */</span></span><br><span class="line">	<span class="keyword">return</span> (diff == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="pr-flush-便捷的API封装"><a href="#pr-flush-便捷的API封装" class="headerlink" title="pr_flush: 便捷的API封装"></a><code>pr_flush</code>: 便捷的API封装</h3><p>这是一个上层的、导出的API函数, 它为内核其他部分的调用者提供了一个更简洁的接口。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * pr_flush() - 等待打印线程追上进度.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @timeout_ms:        等待的最大时间(毫秒).</span></span><br><span class="line"><span class="comment"> * @reset_on_progress: 如果看到有进展, 是否重置超时.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * timeout_ms为0表示不等待. -1表示无限等待.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果@reset_on_progress为true, 只要任何打印机被看到取得了进展,</span></span><br><span class="line"><span class="comment"> * 超时就会被重置.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 上下文: 进程上下文. 在获取控制台锁时可能会睡眠.</span></span><br><span class="line"><span class="comment"> * 返回: 如果所有可用的打印机都已追上, 返回true.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">pr_flush</span><span class="params">(<span class="type">int</span> timeout_ms, <span class="type">bool</span> reset_on_progress)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 这是一个简单的封装, 它调用核心实现函数 __pr_flush,</span></span><br><span class="line"><span class="comment">	 * 并为第一个参数(要等待的特定控制台)传递 NULL, 表示等待所有控制台.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> __pr_flush(<span class="literal">NULL</span>, timeout_ms, reset_on_progress);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="console-prepend-message-在日志消息前插入文本"><a href="#console-prepend-message-在日志消息前插入文本" class="headerlink" title="console_prepend_message: 在日志消息前插入文本"></a><code>console_prepend_message</code>: 在日志消息前插入文本</h2><p>此代码片段展示了Linux内核<code>printk</code>日志系统中一个非常实用的内部工具函数: <code>console_prepend_message</code>。它的核心原理是<strong>提供一个安全、高效的方法, 在一段已经存在的日志消息字符串之前, 插入一个新的、格式化的前缀字符串</strong>。</p>
<p>这个函数是实现<code>printk</code>高级功能的基石, 例如打印”[… dropped messages …]”或”[replay]”等提示信息。它通过一个巧妙的内存操作序列来完成工作, 而不是代价高昂的字符串拼接。</p>
<hr>
<h3 id="console-prepend-message-核心实现"><a href="#console-prepend-message-核心实现" class="headerlink" title="console_prepend_message: 核心实现"></a><code>console_prepend_message</code>: 核心实现</h3><p><strong>工作流程与原理:</strong></p>
<ol>
<li><p><strong>格式化前缀</strong>: 函数首先像<code>printf</code>一样工作。它接受一个格式化字符串<code>fmt</code>和可变参数<code>...</code>, 并使用<code>vscnprintf</code>将格式化后的前缀字符串生成到一个临时的”草稿缓冲区”(<code>scratchbuf</code>)中。<code>vscnprintf</code>是<code>vsprintf</code>的安全版本, 它能防止缓冲区溢出。</p>
</li>
<li><p><strong>空间检查与截断</strong>: 这是保证缓冲区安全的关键步骤。</p>
<ul>
<li>它首先检查前缀的长度<code>len</code>加上一个最大的可能前缀(用于应对极端情况)是否会超出整个输出缓冲区<code>outbuf</code>的大小。如果会, 这是一个严重的配置错误, 函数会打印一个警告并直接返回。</li>
<li>接着, 它检查现有消息的长度<code>pmsg-&gt;outbuf_len</code>加上前缀的长度<code>len</code>是否会超出输出缓冲区。如果会, 这意味着没有足够的空间同时容纳前缀和完整的原始消息。在这种情况下, 它会<strong>截断(truncate)原始消息</strong>, 从尾部缩短它, 以便为前缀腾出空间。它确保了在截断后, 原始消息仍然是以<code>\0</code>结尾的合法字符串。</li>
</ul>
</li>
<li><p><strong>内存移动 (<code>memmove</code>)</strong>: 这是整个函数最高效、最核心的操作。它调用<code>memmove</code>, 将<code>outbuf</code>中现有的整个日志消息(包括其结尾的<code>\0</code>)<strong>向后移动<code>len</code>个字节</strong>。<code>memmove</code>是一个可以安全处理源和目标内存区域重叠的内存复制函数, 这正是这里所需的情景。执行后, <code>outbuf</code>的开头就空出了<code>len</code>个字节的”空隙”。</p>
</li>
<li><p><strong>前缀拷贝 (<code>memcpy</code>)</strong>: 最后, 它调用<code>memcpy</code>将之前在<code>scratchbuf</code>中生成的前缀字符串, 拷贝到<code>outbuf</code>开头刚刚腾出的”空隙”中。</p>
</li>
<li><p><strong>更新长度</strong>: 它将前缀的长度<code>len</code>加到<code>pmsg-&gt;outbuf_len</code>上, 以正确反映新的、更长的消息的总长度。</p>
</li>
</ol>
<p>通过这种”移动-拷贝”的方式, <code>console_prepend_message</code>避免了需要分配新内存或进行多次字符串操作的传统拼接方法, 实现了非常高效的字符串前插功能。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 在 @pmsg-&gt;pbufs-&gt;outbuf 中的消息前插入文本. 这是通过移动现有消息,</span></span><br><span class="line"><span class="comment"> * 然后插入 scratchbuf 中的消息来实现的.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @pmsg 是原始的 printk 消息.</span></span><br><span class="line"><span class="comment"> * @fmt 是将要前插的消息的 printf 格式.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果 @pmsg-&gt;pbufs-&gt;outbuf 中空间不足, 现有消息文本将被充分截断.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果 @pmsg-&gt;pbufs-&gt;outbuf 被修改, @pmsg-&gt;outbuf_len 会被更新.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__printf(<span class="number">2</span>, <span class="number">3</span>) <span class="comment">/* GCC属性, 告知编译器此函数类似printf, 会检查格式化字符串和参数的匹配性. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">console_prepend_message</span><span class="params">(<span class="keyword">struct</span> printk_message *pmsg, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 获取指向各个缓冲区的指针和它们的大小. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">printk_buffers</span> *<span class="title">pbufs</span> =</span> pmsg-&gt;pbufs;</span><br><span class="line">	<span class="type">const</span> <span class="type">size_t</span> scratchbuf_sz = <span class="keyword">sizeof</span>(pbufs-&gt;scratchbuf);</span><br><span class="line">	<span class="type">const</span> <span class="type">size_t</span> outbuf_sz = <span class="keyword">sizeof</span>(pbufs-&gt;outbuf);</span><br><span class="line">	<span class="type">char</span> *scratchbuf = &amp;pbufs-&gt;scratchbuf[<span class="number">0</span>];</span><br><span class="line">	<span class="type">char</span> *outbuf = &amp;pbufs-&gt;outbuf[<span class="number">0</span>];</span><br><span class="line">	va_list args;</span><br><span class="line">	<span class="type">size_t</span> len;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 步骤1: 使用可变参数, 将要前插的前缀格式化到 scratchbuf 中. */</span></span><br><span class="line">	va_start(args, fmt);</span><br><span class="line">	len = vscnprintf(scratchbuf, scratchbuf_sz, fmt, args);</span><br><span class="line">	va_end(args);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 步骤2: 空间检查与截断.</span></span><br><span class="line"><span class="comment">	 * 这是一个健全性检查, 确保缓冲区至少能容纳前缀和一个最大的标准前缀.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON_ONCE(len + PRINTK_PREFIX_MAX &gt;= outbuf_sz))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果(原始消息 + 前缀)的总长度会超出缓冲区. */</span></span><br><span class="line">	<span class="keyword">if</span> (pmsg-&gt;outbuf_len + len &gt;= outbuf_sz) &#123;</span><br><span class="line">		<span class="comment">/* 截断原始消息, 为前缀和结尾的&#x27;\0&#x27;留出空间. */</span></span><br><span class="line">		pmsg-&gt;outbuf_len = outbuf_sz - (len + <span class="number">1</span>);</span><br><span class="line">		outbuf[pmsg-&gt;outbuf_len] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 步骤3: 内存移动. 将原始消息整体向后移动 len 个字节.</span></span><br><span class="line"><span class="comment">	 * pmsg-&gt;outbuf_len + 1 包括了结尾的&#x27;\0&#x27;.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	memmove(outbuf + len, outbuf, pmsg-&gt;outbuf_len + <span class="number">1</span>);</span><br><span class="line">	<span class="comment">/* 步骤4: 前缀拷贝. 将 scratchbuf 中的前缀拷贝到 outbuf 开头的空隙中. */</span></span><br><span class="line">	<span class="built_in">memcpy</span>(outbuf, scratchbuf, len);</span><br><span class="line">	<span class="comment">/* 步骤5: 更新总长度. */</span></span><br><span class="line">	pmsg-&gt;outbuf_len += len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="console-prepend-dropped-便捷的API封装"><a href="#console-prepend-dropped-便捷的API封装" class="headerlink" title="console_prepend_dropped: 便捷的API封装"></a><code>console_prepend_dropped</code>: 便捷的API封装</h3><p>这是一个上层的、具体的应用函数。它使用<code>console_prepend_message</code>来生成一条关于丢弃消息的特定前缀。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 在 @pmsg-&gt;pbufs-&gt;outbuf 中的消息前插入一条&quot;丢弃消息&quot;的提示.</span></span><br><span class="line"><span class="comment"> * @pmsg-&gt;outbuf_len 会被相应地更新.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @pmsg 是要被前插的printk消息.</span></span><br><span class="line"><span class="comment"> * @dropped 是要在丢弃消息中报告的丢弃计数.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_prepend_dropped</span><span class="params">(<span class="keyword">struct</span> printk_message *pmsg, <span class="type">unsigned</span> <span class="type">long</span> dropped)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 调用核心前插函数, 并提供一个具体的格式化字符串和参数.</span></span><br><span class="line"><span class="comment">	 * 这会生成类似 &quot;** 42 printk messages dropped **\n&quot; 的字符串,</span></span><br><span class="line"><span class="comment">	 * 并将其插入到 pmsg 的消息之前.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	console_prepend_message(pmsg, <span class="string">&quot;** %lu printk messages dropped **\n&quot;</span>, dropped);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="printk-日志文本格式化与前缀注入"><a href="#printk-日志文本格式化与前缀注入" class="headerlink" title="printk 日志文本格式化与前缀注入"></a><code>printk</code> 日志文本格式化与前缀注入</h2><p>此代码片段展示了Linux内核<code>printk</code>日志系统中负责<strong>最终文本格式化</strong>的两个核心内部函数。它们的作用是将从环形缓冲区中取出的、”原始”的日志记录, 转换为最终将在控制台上显示的、带有时间戳和日志级别等前缀信息的、并且正确处理了多行消息的字符串。</p>
<p><code>record_print_text</code>是这个过程的”引擎”, 而<code>info_print_prefix</code>是它的”零件供应商”。</p>
<hr>
<h3 id="info-print-prefix-生成单行前缀"><a href="#info-print-prefix-生成单行前缀" class="headerlink" title="info_print_prefix: 生成单行前缀"></a><code>info_print_prefix</code>: 生成单行前缀</h3><p>此函数是一个简单、专一的辅助函数。它的原理是<strong>根据传入的参数, 将日志记录的元数据(metadata)格式化成一个标准的前缀字符串</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* info_print_prefix: 生成单行的日志前缀. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span> <span class="title function_">info_print_prefix</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> printk_info  *info, <span class="type">bool</span> syslog,</span></span><br><span class="line"><span class="params">				<span class="type">bool</span> time, <span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">size_t</span> len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果需要syslog格式, 添加 &lt;facility|level&gt; 前缀, 如 &quot;&lt;6&gt;&quot;. */</span></span><br><span class="line">	<span class="keyword">if</span> (syslog)</span><br><span class="line">		len = print_syslog((info-&gt;facility &lt;&lt; <span class="number">3</span>) | info-&gt;level, buf);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果需要时间戳, 添加 &quot;[ 123.456789] &quot; 格式的时间戳. */</span></span><br><span class="line">	<span class="keyword">if</span> (time)</span><br><span class="line">		len += print_time(info-&gt;ts_nsec, buf + len);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 添加调用者信息(如果配置了). */</span></span><br><span class="line">	len += print_caller(info-&gt;caller_id, buf + len);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果添加了任何前缀信息, 确保后面有一个空格作为分隔. */</span></span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_PRINTK_CALLER) || time) &#123;</span><br><span class="line">		buf[len++] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		buf[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> len; <span class="comment">/* 返回生成的前缀的总长度. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="record-print-text-核心的”原地”文本格式化引擎"><a href="#record-print-text-核心的”原地”文本格式化引擎" class="headerlink" title="record_print_text: 核心的”原地”文本格式化引擎"></a><code>record_print_text</code>: 核心的”原地”文本格式化引擎</h3><p>这是整个格式化流程中最复杂、最精妙的部分。它的核心原理是<strong>在一个单一的缓冲区内, 通过一系列高效的<code>memmove</code>操作, 实现为多行日志的每一行都正确地注入前缀, 同时优雅地处理缓冲区空间不足时的截断问题</strong>。这种”原地”(in-place)操作避免了为格式化分配额外内存的开销, 这在资源受限的内核环境中至关重要。</p>
<p><strong>工作流程与原理:</strong></p>
<ol>
<li><p><strong>生成标准前缀</strong>: 函数首先调用<code>info_print_prefix</code>生成一个本次日志所有行都将使用的标准前缀(如<code>&quot;&lt;6&gt;[ 123.456789] &quot;</code>), 并将其存储在一个临时的栈上缓冲区<code>prefix</code>中。</p>
</li>
<li><p><strong>进入多行处理循环 (<code>for(;;)</code>):</strong> 函数的核心是一个循环, 它将日志文本视为一个或多个由<code>\n</code>分隔的行。</p>
<ul>
<li><strong>查找换行符</strong>: <code>next = memchr(text, &#39;\n&#39;, text_len);</code> 它在剩余的文本中查找下一个换行符, 以确定当前行的边界和长度(<code>line_len</code>)。</li>
<li><strong>空间检查与截断</strong>: 在处理每一行之前, 它都会进行一次精确的空间计算, 检查”已格式化长度 + 前缀长度 + 剩余文本长度 + 结尾换行符 + 结尾\0”是否会超出缓冲区。<ul>
<li>如果会, 它会<strong>截断(truncate)剩余文本的长度</strong>(<code>text_len</code>), 仅保留足以容纳当前行和前缀的空间。<code>truncated</code>标志被设置, 循环将在处理完这最后一行后终止。</li>
<li>这个检查保证了缓冲区绝对不会溢出。</li>
</ul>
</li>
<li><strong>“原地”前缀注入 (<code>memmove</code>&#x2F;<code>memcpy</code>)</strong>: 这是最关键的算法。<br>a. <code>memmove(text + prefix_len, text, text_len);</code> : 它将<strong>整个剩余的文本</strong>(包括多行)向后移动<code>prefix_len</code>个字节, 在当前行的开头腾出一个与前缀等长的”空隙”。<br>b. <code>memcpy(text, prefix, prefix_len);</code> : 它将之前生成的标准前缀拷贝到这个”空隙”中。<ul>
<li>经过这两步, 当前行就已经被成功地加上了前缀。</li>
</ul>
</li>
<li><strong>更新指针和长度</strong>: 函数会更新已格式化总长度<code>len</code>, 并将<code>text</code>指针移动到下一行的起始位置, 同时从<code>text_len</code>中减去已处理的长度, 准备处理下一行。</li>
</ul>
</li>
<li><p><strong>处理结尾</strong>: 当循环结束时(无论是正常处理完所有行还是因为截断而提前终止):</p>
<ul>
<li><strong>添加尾部换行符</strong>: <code>vprintk_store</code>在存储日志时会去掉用户输入的最后一个<code>\n</code>, 以便内部处理。此函数负责在所有行都被处理完后, 将这个<code>\n</code>重新添加回来, 保证日志输出的格式正确。</li>
<li><strong>添加字符串终结符</strong>: 最后, 它在已格式化文本的末尾写入一个<code>\0</code>, 确保它是一个合法的C字符串。</li>
</ul>
</li>
</ol>
<p><strong>在STM32H750上的意义:</strong></p>
<p>这个函数对于确保在STM32的串口或其他控制台上看到的日志格式正确、可读、且信息完整至关重要。</p>
<ul>
<li><strong>时间戳和日志级别</strong>: 开发者通过配置内核, 可以选择是否显示时间戳和syslog级别。这个函数就是将这些配置转化为实际输出的地方。在调试实时性问题时, 精确到纳秒的时间戳(<code>info-&gt;ts_nsec</code>)是无价的。</li>
<li><strong>处理多行日志</strong>: 嵌入式开发中, 经常需要打印包含多行的数据结构或状态信息。这个函数保证了即使是多行消息, 每一行的开头都会有正确的前缀, 保持了日志的可读性。</li>
<li><strong>内存效率</strong>: “原地”操作的算法设计, 对于像STM32这样内存资源相对宝贵的MCU来说, 避免了不必要的动态内存分配, 降低了内存碎片风险, 提高了系统的稳定性和效率。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">size_t</span> <span class="title function_">record_print_text</span><span class="params">(<span class="keyword">struct</span> printk_record *r, <span class="type">bool</span> syslog,</span></span><br><span class="line"><span class="params">				<span class="type">bool</span> time)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">size_t</span> text_len = r-&gt;info-&gt;text_len;</span><br><span class="line">	<span class="type">size_t</span> buf_size = r-&gt;text_buf_size;</span><br><span class="line">	<span class="type">char</span> *text = r-&gt;text_buf;</span><br><span class="line">	<span class="type">char</span> prefix[PRINTK_PREFIX_MAX]; <span class="comment">// 栈上临时缓冲区, 用于存放前缀</span></span><br><span class="line">	<span class="type">bool</span> truncated = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">size_t</span> prefix_len;</span><br><span class="line">	<span class="type">size_t</span> line_len;</span><br><span class="line">	<span class="type">size_t</span> len = <span class="number">0</span>; <span class="comment">// 已格式化的总长度</span></span><br><span class="line">	<span class="type">char</span> *next;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果原始消息因缓冲区不足而被截断, 则只处理可用的部分. */</span></span><br><span class="line">	<span class="keyword">if</span> (text_len &gt; buf_size)</span><br><span class="line">		text_len = buf_size;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 步骤1: 生成本次日志所有行共用的标准前缀. */</span></span><br><span class="line">	prefix_len = info_print_prefix(r-&gt;info, syslog, time, prefix);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 步骤2: 进入多行处理循环. */</span></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="comment">/* 查找下一行. */</span></span><br><span class="line">		next = <span class="built_in">memchr</span>(text, <span class="string">&#x27;\n&#x27;</span>, text_len);</span><br><span class="line">		<span class="keyword">if</span> (next) &#123;</span><br><span class="line">			line_len = next - text; <span class="comment">// 当前行长度 (不含\n)</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (truncated) <span class="comment">/* 如果之前已发生截断, 不再处理最后不完整的行. */</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			line_len = text_len;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 空间检查与截断. */</span></span><br><span class="line">		<span class="keyword">if</span> (len + prefix_len + text_len + <span class="number">1</span> + <span class="number">1</span> &gt; buf_size) &#123;</span><br><span class="line">			<span class="keyword">if</span> (len + prefix_len + line_len + <span class="number">1</span> + <span class="number">1</span> &gt; buf_size)</span><br><span class="line">				<span class="keyword">break</span>; <span class="comment">/* 连当前行都放不下了, 放弃. */</span></span><br><span class="line"></span><br><span class="line">			text_len = buf_size - len - prefix_len - <span class="number">1</span> - <span class="number">1</span>;</span><br><span class="line">			truncated = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* &quot;原地&quot;前缀注入. */</span></span><br><span class="line">		memmove(text + prefix_len, text, text_len); <span class="comment">// 向后移动整个剩余文本.</span></span><br><span class="line">		<span class="built_in">memcpy</span>(text, prefix, prefix_len);          <span class="comment">// 在开头插入前缀.</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 更新已格式化长度. */</span></span><br><span class="line">		len += prefix_len + line_len + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (text_len == line_len) &#123;</span><br><span class="line">			<span class="comment">/* 这是最后一行, 添加被vprintk_store移除的尾部换行符. */</span></span><br><span class="line">			text[prefix_len + line_len] = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 更新指针和长度, 准备处理下一行. */</span></span><br><span class="line">		text += prefix_len + line_len + <span class="number">1</span>;</span><br><span class="line">		text_len -= line_len + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 步骤3: 确保字符串以&#x27;\0&#x27;结尾. */</span></span><br><span class="line">	<span class="keyword">if</span> (buf_size &gt; <span class="number">0</span>)</span><br><span class="line">		r-&gt;text_buf[len] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> len; <span class="comment">/* 返回最终格式化后的字符串长度. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/wdfk-prog">Liya Huang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://wdfk-prog.space/posts/aca6454c/">https://wdfk-prog.space/posts/aca6454c/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://wdfk-prog.space" target="_blank">wdfk-prog的个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/linux/">linux</a><a class="post-meta__tags" href="/tags/kernel/">kernel</a></div><div class="post-share"><div class="social-share" data-image="/images/covers/10.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/images/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/images/alipay.png" target="_blank"><img class="post-qr-code-img" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/alipay.png" alt="支付寶"/></a><div class="post-qr-code-desc">支付寶</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/6eeb3e80/" title="usermode_helper"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/05.jpg" onerror="onerror=null;src='/images/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">usermode_helper</div></div><div class="info-2"><div class="info-item-1">[TOC] kernel&#x2F;usermode_helper.c 用户模式助手(Usermode Helper) 内核执行用户空间程序的桥梁历史与背景这项技术是为了解决什么特定问题而诞生的？kernel/usermode_helper.c 及其提供的API（最著名的是call_usermodehelper()）是为了解决一个在内核设计中经典而棘手的问题：内核在某些情况下，需要执行一个用户空间的程序来完成某项任务，但又不能直接调用execve()系统调用。 内核运行在一个高度特权、独立的地址空间中，它没有C库、没有shell、也不能直接执行用户空间的可执行文件。然而，在很多场景下，内核需要借助用户空间工具的灵活性和丰富的功能。例如：  加载固件（Firmware）：当一个设备驱动程序初始化时，它可能需要从磁盘加载一个“固件”二进制文件到设备内存中。内核自身不应该包含读取各种文件系统（ext4, xfs等）的复杂逻辑。更合理的做法是，委托一个用户空间程序去文件系统中找到固件文件，并将其内容通过一个简单的接口（如sysfs）回传给内核。 动态设备创建：当内核检测到一个新的磁盘分区...</div></div></div></a><a class="pagination-related" href="/posts/740c95f5/" title="signal"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/04.jpg" onerror="onerror=null;src='/images/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">signal</div></div><div class="info-2"><div class="info-item-1">[TOC] kernel&#x2F;signal.c 信号处理(Signal Handling) 进程间异步通信与事件通知历史与背景这项技术是为了解决什么特定问题而诞生的？kernel/signal.c 及其相关文件构成了Linux内核的信号处理子系统。这项技术源自早期的Unix，它的诞生是为了解决进程间一种基础而重要的通信需求：异步事件通知。 在操作系统中，经常会发生一些需要通知特定进程的、非预期的“事件”。这些事件可能源自：  用户交互：用户在终端按下Ctrl-C，需要通知前台进程终止。 内核异常：一个进程执行了非法操作，如除以零或访问无效内存，内核需要通知该进程它犯了一个错误（SIGFPE, SIGSEGV）。 进程间协作：一个进程需要通知另一个进程某个条件已经满足，或者请求其执行某个操作（例如，父进程通过kill()命令通知子进程）。 系统管理：管理员使用kill命令向一个守护进程发送SIGHUP信号，请求它重新加载配置文件。  如果没有信号机制，这些场景将难以处理。信号提供了一种轻量级、异步、单向的通信方式，它模仿了硬件中断：当一个信号被“递送”（deliver）给一个...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/dd631879/" title="kallsyms"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/04.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-06</div><div class="info-item-2">kallsyms</div></div><div class="info-2"><div class="info-item-1">   [TOC] linux-gnu&#x2F;bits&#x2F;getopt_ext.h getopt_long: GNU 命令行长选项解析接口本代码片段是一个 C 语言头文件（getopt_ext.h，通常被 getopt.h 包含），它定义了 GNU C 库中用于解析命令行参数的 getopt_long 函数及其核心数据结构 struct option。其主要功能是为命令行程序提供一个强大且灵活的机制，使其能够支持并解析长格式的选项（例如，--all-symbols），而不仅仅是传统的单字母短格式选项（如 -a）。 实现原理分析此机制的核心是通过一个描述符结构体数组，将命令行中的字符串与程序内部的变量和行为进行声明式映射。  选项描述符 (struct option): 这是整个机制的核心数据结构。开发者需要创建一个 struct option 类型的数组，数组中的每一个元素都完整地描述了一个长选项：  const char *name: 定义了长选项的名称，即 -- 后面的字符串，例如 &quot;all-symbols&quot;。 int has_arg: 指定该选...</div></div></div></a><a class="pagination-related" href="/posts/d32d8ac9/" title="clocksource"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/04.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-03</div><div class="info-item-2">clocksource</div></div><div class="info-2"><div class="info-item-1">[TOC] clocksource 内核时钟源(Kernel Clocksource) 为内核提供统一的时间基准历史与背景这项技术是为了解决什么特定问题而诞生的？clocksource框架的诞生是为了解决Linux内核中一个根本性的问题：如何以一种统一、可移植的方式来处理多样化的硬件计时器。  硬件的多样性：不同的CPU架构和平台提供了五花八门的硬件计时器，例如x86上的TSC（时间戳计数器）、HPET（高精度事件定时器）、ACPI PM Timer，以及ARM平台上的Architected Timer等。这些计时器的精度、速度、稳定性和编程接口各不相同。 缺乏统一抽象：在clocksource框架出现之前，内核中的时间管理代码与特定的硬件架构和计时器紧密耦合。这使得将内核移植到新平台变得困难，也难以在运行时动态选择最优的计时器硬件。 对高精度的需求：随着系统应用（如实时系统、高频交易、性能剖析）对时间精度要求的提高，内核需要一个能够充分利用现代高精度计时器硬件的框架。  clocksource框架通过创建一个通用的抽象层，将这些底层硬件计时器的差异性隐藏起来，为内核的上层时间子...</div></div></div></a><a class="pagination-related" href="/posts/5a79feca/" title="dma"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/03.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-03</div><div class="info-item-2">dma</div></div><div class="info-2"><div class="info-item-1">[TOC] drivers&#x2F;dma DMA引擎与映射(DMA Engine &amp; Mapping) 内核统一的直接内存访问框架历史与背景这项技术是为了解决什么特定问题而诞生的？DMA（Direct Memory Access，直接内存访问）框架的诞生是为了解决一个根本性的性能瓶颈问题，并为内核提供一个统一、可移植的解决方案。  解决CPU性能瓶颈：在没有DMA的系统中，当外设（如网卡、磁盘）需要与内存交换大量数据时，CPU必须亲自担当“搬运工”的角色。这种方式被称为PIO（Programmed I&#x2F;O），CPU需要逐字节或逐字地从设备读取数据再写入内存，或者反之。对于高速设备，这会消耗大量的CPU周期，导致CPU无暇处理其他计算任务，严重影响系统整体性能。DMA技术通过引入一个专门的硬件控制器（DMAC），允许外设在没有CPU干预的情况下直接与内存进行数据传输，从而将CPU解放出来。 抽象硬件差异：不同的CPU架构和SoC平台，其DMA控制器的设计和编程接口千差万别。如果没有一个统一的软件框架，设备驱动程序的开发者将不得不为每一种不同的DMAC编写特定的...</div></div></div></a><a class="pagination-related" href="/posts/ba80502e/" title="cpu"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/02.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-03</div><div class="info-item-2">cpu</div></div><div class="info-2"><div class="info-item-1">[TOC] include&#x2F;linux&#x2F;cpumask.hcpumask_check 验证当前cpu数量是否超过了配置的最大cpu数量,并返回cpu1234567891011121314151617// 验证当前cpu数量是否超过了配置的最大cpu数量static __always_inline void cpu_max_bits_warn(unsigned int cpu, unsigned int bits)&#123;#ifdef CONFIG_DEBUG_PER_CPU_MAPS	WARN_ON_ONCE(cpu &gt;= bits);#endif /* CONFIG_DEBUG_PER_CPU_MAPS */&#125;/* verify cpu argument to cpumask_* operators *///验证当前cpu数量是否超过了配置的最大cpu数量static __always_inline unsigned int cpumask_check(unsigned int cpu)&#123;    //small_cpumask_...</div></div></div></a><a class="pagination-related" href="/posts/feb74a0/" title="utsname_sysctl"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/04.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-07</div><div class="info-item-2">utsname_sysctl</div></div><div class="info-2"><div class="info-item-1">   [TOC]  kernel&#x2F;utsname_sysctl.c UTS命名空间与Sysctl接口 管理和暴露系统标识信息历史与背景这项技术是为了解决什么特定问题而诞生的？这项技术是为了提供一个标准化的、可在运行时动态查询和修改系统核心标识信息的机制而诞生的。这些标识信息，统称为UTS（UNIX Time-sharing System）名称，包括：  主机名 (Hostname) 和 域名 (Domainname)：在网络中唯一标识一台机器。 操作系统发布版本 (OS Release) 和 版本号 (Version)：允许软件检查其运行的内核版本，以确定兼容性或是否存在特定功能&#x2F;错误。 硬件架构 (Machine)：指明系统运行的CPU架构（如 x86_64, aarch64）。  utsname_sysctl.c 的核心任务是：  提供访问接口：允许用户空间程序和管理员通过 uname(2) 系统调用和 /proc/sys/kernel/ 文件系统接口来读取这些信息。 提供配置能力：尤其是对于主机名和域名，系统必须提供一种在运行时进行修改的方法，而无需重启...</div></div></div></a><a class="pagination-related" href="/posts/2c09369a/" title="seccomp"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/06.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-07</div><div class="info-item-2">seccomp</div></div><div class="info-2"><div class="info-item-1">  [toc]  kernel&#x2F;seccomp.c 安全计算模式(Secure Computing Mode) 系统调用防火墙历史与背景这项技术是为了解决什么特定问题而诞生的？Seccomp（Secure Computing Mode）是为了解决一个核心的安全问题而诞生的：如何安全地运行不可信的代码。 在复杂的软件环境中，一个进程被赋予了访问数百个系统调用（syscall）的能力，这些系统调用是用户空间程序与内核交互的接口。 然而，大多数程序在其整个生命周期中只需要使用这些系统调用中的一小部分。 如果一个程序（例如，一个处理外部输入的Web浏览器渲染进程）被恶意代码攻陷，攻击者就可以利用那些该程序本不需要、但内核依然暴露给它的系统调用来进一步攻击和破坏整个系统。 Seccomp通过提供一种机制来限制一个进程可以调用的系统调用集合，从而减少内核的攻击面。 它的核心思想是实施“最小权限原则”：只授予程序执行其核心功能所必需的最小权限集合。 这样，即使程序被攻破，攻击者能造成的损害也因为其可用的系统调用极其有限而受到严格控制。 这对于构建应用程序沙箱（sandbox）至关重要...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/avatar.png" onerror="this.onerror=null;this.src='/images/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Liya Huang</div><div class="author-info-description">WORK-LIFE BALANCE</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">414</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">49</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">53</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/wdfk-prog"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/wdfk-prog" rel="external nofollow noreferrer" target="_blank" title="GitHub"><i class="fab fa-github" style="color: #181717;"></i></a><a class="social-icon" href="https://wdfk-prog.blog.csdn.net/" rel="external nofollow noreferrer" target="_blank" title="CSDN"><i class="fas fa-blog" style="color: #FC5531;"></i></a><a class="social-icon" href="mailto:1425075683@qq.com" rel="external nofollow noreferrer" target="_blank" title="E-mail"><i class="fas fa-envelope" style="color: #4A4A4A;"></i></a><a class="social-icon" href="/images/wechat-qrcode.jpg" target="_blank" title="微信公众号"><i class="fab fa-weixin" style="color: #07C160;"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss" style="color: #EE802F;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎光临！有任何问题或想法，欢迎在文章下留言交流，或者通过 <a href='/about/'>关于页面</a> 联系我。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#kernel-printk-c-%E5%86%85%E6%A0%B8%E6%89%93%E5%8D%B0-Kernel-Printing-%E5%86%85%E6%A0%B8%E4%BF%A1%E6%81%AF%E8%BE%93%E5%87%BA%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD"><span class="toc-number">1.</span> <span class="toc-text">kernel&#x2F;printk.c 内核打印(Kernel Printing) 内核信息输出的基础设施</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%86%E5%8F%B2%E4%B8%8E%E8%83%8C%E6%99%AF"><span class="toc-number">1.0.1.</span> <span class="toc-text">历史与背景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%99%E9%A1%B9%E6%8A%80%E6%9C%AF%E6%98%AF%E4%B8%BA%E4%BA%86%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E7%89%B9%E5%AE%9A%E9%97%AE%E9%A2%98%E8%80%8C%E8%AF%9E%E7%94%9F%E7%9A%84%EF%BC%9F"><span class="toc-number">1.0.1.1.</span> <span class="toc-text">这项技术是为了解决什么特定问题而诞生的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%83%E7%9A%84%E5%8F%91%E5%B1%95%E7%BB%8F%E5%8E%86%E4%BA%86%E5%93%AA%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9A%84%E9%87%8C%E7%A8%8B%E7%A2%91%E6%88%96%E7%89%88%E6%9C%AC%E8%BF%AD%E4%BB%A3%EF%BC%9F"><span class="toc-number">1.0.1.2.</span> <span class="toc-text">它的发展经历了哪些重要的里程碑或版本迭代？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E5%89%8D%E8%AF%A5%E6%8A%80%E6%9C%AF%E7%9A%84%E7%A4%BE%E5%8C%BA%E6%B4%BB%E8%B7%83%E5%BA%A6%E5%92%8C%E4%B8%BB%E6%B5%81%E5%BA%94%E7%94%A8%E6%83%85%E5%86%B5%E5%A6%82%E4%BD%95%EF%BC%9F"><span class="toc-number">1.0.1.3.</span> <span class="toc-text">目前该技术的社区活跃度和主流应用情况如何？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.0.2.</span> <span class="toc-text">核心原理与设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%83%E7%9A%84%E6%A0%B8%E5%BF%83%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.0.2.1.</span> <span class="toc-text">它的核心工作原理是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%83%E7%9A%84%E4%B8%BB%E8%A6%81%E4%BC%98%E5%8A%BF%E4%BD%93%E7%8E%B0%E5%9C%A8%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2%EF%BC%9F"><span class="toc-number">1.0.2.2.</span> <span class="toc-text">它的主要优势体现在哪些方面？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%83%E5%AD%98%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%B7%B2%E7%9F%A5%E7%9A%84%E5%8A%A3%E5%8A%BF%E3%80%81%E5%B1%80%E9%99%90%E6%80%A7%E6%88%96%E5%9C%A8%E7%89%B9%E5%AE%9A%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E4%B8%8D%E9%80%82%E7%94%A8%E6%80%A7%EF%BC%9F"><span class="toc-number">1.0.2.3.</span> <span class="toc-text">它存在哪些已知的劣势、局限性或在特定场景下的不适用性？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.0.3.</span> <span class="toc-text">使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%85%B7%E4%BD%93%E7%9A%84%E4%B8%9A%E5%8A%A1%E6%88%96%E6%8A%80%E6%9C%AF%E5%9C%BA%E6%99%AF%E4%B8%8B%EF%BC%8C%E5%AE%83%E6%98%AF%E9%A6%96%E9%80%89%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="toc-number">1.0.3.1.</span> <span class="toc-text">在哪些具体的业务或技术场景下，它是首选解决方案？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E5%90%A6%E6%9C%89%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E8%AF%A5%E6%8A%80%E6%9C%AF%E7%9A%84%E5%9C%BA%E6%99%AF%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.0.3.2.</span> <span class="toc-text">是否有不推荐使用该技术的场景？为什么？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90"><span class="toc-number">1.0.4.</span> <span class="toc-text">对比分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E5%B0%86%E5%85%B6-%E4%B8%8E-%E5%85%B6%E4%BB%96%E7%9B%B8%E4%BC%BC%E6%8A%80%E6%9C%AF-%E8%BF%9B%E8%A1%8C%E8%AF%A6%E7%BB%86%E5%AF%B9%E6%AF%94%E3%80%82"><span class="toc-number">1.0.4.1.</span> <span class="toc-text">请将其 与 其他相似技术 进行详细对比。</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#include-linux-kern-levels-h"><span class="toc-number">2.</span> <span class="toc-text">include&#x2F;linux&#x2F;kern_levels.h</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#include-linux-printk-h"><span class="toc-number">3.</span> <span class="toc-text">include&#x2F;linux&#x2F;printk.h</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#printk-%E7%AD%89%E7%BA%A7"><span class="toc-number">3.1.</span> <span class="toc-text">printk 等级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#printk-get-level-%E8%8E%B7%E5%8F%96%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB"><span class="toc-number">3.2.</span> <span class="toc-text">printk_get_level 获取日志级别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#printk-deferred-enter-%E5%92%8Cprintk-deferred-exit"><span class="toc-number">3.3.</span> <span class="toc-text">printk_deferred_enter 和printk_deferred_exit</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#kernel-printk-internal-h"><span class="toc-number">4.</span> <span class="toc-text">kernel&#x2F;printk&#x2F;internal.h</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#printk-get-console-flush-type-%E7%A1%AE%E5%AE%9A%E4%BD%BF%E7%94%A8%E5%93%AA%E4%BA%9B%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%88%B7%E6%96%B0%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.</span> <span class="toc-text">printk_get_console_flush_type 确定使用哪些控制台刷新方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#printk-info-flags"><span class="toc-number">4.2.</span> <span class="toc-text">printk_info_flags</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#console-is-usable-%E6%A3%80%E6%9F%A5%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%98%AF%E5%90%A6%E5%8F%AF%E7%94%A8"><span class="toc-number">4.3.</span> <span class="toc-text">console_is_usable 检查控制台是否可用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#include-linux-console-h"><span class="toc-number">5.</span> <span class="toc-text">include&#x2F;linux&#x2F;console.h</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#for-each-console-%E9%81%8D%E5%8E%86%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%88%97%E8%A1%A8"><span class="toc-number">5.1.</span> <span class="toc-text">for_each_console 遍历控制台列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cons-flags"><span class="toc-number">5.2.</span> <span class="toc-text">cons_flags</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#console-srcu-read-flags-%E6%97%A0%E9%94%81%E8%AF%BB%E5%8F%96%E5%8F%AF%E8%83%BD%E5%B7%B2%E6%B3%A8%E5%86%8C%E6%8E%A7%E5%88%B6%E5%8F%B0%E7%9A%84%E6%A0%87%E5%BF%97"><span class="toc-number">5.3.</span> <span class="toc-text">console_srcu_read_flags 无锁读取可能已注册控制台的标志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#console-is-registered-locked-%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%98%AF%E5%90%A6%E5%B7%B2%E6%B3%A8%E5%86%8C"><span class="toc-number">5.4.</span> <span class="toc-text">console_is_registered_locked 控制台是否已注册</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#kernel-printk-printk-ringbuffer-h-%E5%86%85%E6%A0%B8%E6%89%93%E5%8D%B0%E7%8E%AF%E5%BD%A2%E7%BC%93%E5%86%B2%E5%8C%BA%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.</span> <span class="toc-text">kernel&#x2F;printk&#x2F;printk_ringbuffer.h 内核打印环形缓冲区实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#prb-desc"><span class="toc-number">6.1.</span> <span class="toc-text">prb_desc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DEFINE-PRINTKRB-%E5%AE%9A%E4%B9%89-ringbuffer"><span class="toc-number">6.2.</span> <span class="toc-text">_DEFINE_PRINTKRB 定义 ringbuffer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#kernel-printk-printk-ringbuffer-c-%E5%86%85%E6%A0%B8%E6%89%93%E5%8D%B0%E7%8E%AF%E5%BD%A2%E7%BC%93%E5%86%B2%E5%8C%BA%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.</span> <span class="toc-text">kernel&#x2F;printk&#x2F;printk_ringbuffer.c 内核打印环形缓冲区实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#macros"><span class="toc-number">7.1.</span> <span class="toc-text">macros</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#desc-reopen-last-%E5%B0%9D%E8%AF%95%E5%B0%86%E6%9C%80%E6%96%B0%E7%9A%84%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%BB%8E-committed-%E8%BD%AC%E6%8D%A2%E5%9B%9E-reserved"><span class="toc-number">7.2.</span> <span class="toc-text">desc_reopen_last 尝试将最新的描述符从 committed 转换回 reserved</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#prb-reserve-in-last"><span class="toc-number">7.3.</span> <span class="toc-text">prb_reserve_in_last</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#to-blk-size-%E5%88%86%E9%85%8D%E5%AF%B9%E9%BD%90%E7%9A%84%E5%8C%BA%E5%9F%9F%E5%B9%B6%E6%B7%BB%E5%8A%A0%E6%8C%87%E9%92%88%E6%89%80%E9%9C%80%E7%9A%84%E7%A9%BA%E9%97%B4"><span class="toc-number">7.4.</span> <span class="toc-text">to_blk_size 分配对齐的区域并添加指针所需的空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#data-check-size-%E6%A3%80%E6%9F%A5%E6%95%B0%E6%8D%AE%E5%A4%A7%E5%B0%8F%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%AD%98%E5%85%A5"><span class="toc-number">7.5.</span> <span class="toc-text">data_check_size 检查数据大小是否可以存入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#get-desc-state-%E6%9F%A5%E8%AF%A2%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%9A%84%E7%8A%B6%E6%80%81%E3%80%82"><span class="toc-number">7.6.</span> <span class="toc-text">get_desc_state 查询描述符的状态。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#desc-read-%E8%8E%B7%E5%8F%96%E6%8C%87%E5%AE%9A%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%9A%84%E5%89%AF%E6%9C%AC%E5%B9%B6%E8%BF%94%E5%9B%9E%E5%85%B6%E6%9F%A5%E8%AF%A2%E7%8A%B6%E6%80%81"><span class="toc-number">7.7.</span> <span class="toc-text">desc_read 获取指定描述符的副本并返回其查询状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#data-push-tail-%E5%B0%86%E6%95%B0%E6%8D%AE%E7%8E%AF%E5%BD%A2%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E5%B0%BE%E9%83%A8%E6%8E%A8%E8%BF%9B%E5%88%B0%E8%87%B3%E5%B0%91-lpos-%E7%9A%84%E4%BD%8D%E7%BD%AE%E3%80%82%E6%AD%A4%E5%87%BD%E6%95%B0%E4%BC%9A%E5%B0%86%E4%B8%8E%E5%B0%BE%E9%83%A8%E6%8E%A8%E8%BF%9B%E8%B6%85%E5%87%BA%E5%85%B6%E5%85%B3%E8%81%94%E6%95%B0%E6%8D%AE%E5%9D%97%E7%9A%84%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%BD%AE%E4%B8%BA%E5%8F%AF%E9%87%8D%E7%94%A8%E7%8A%B6%E6%80%81"><span class="toc-number">7.8.</span> <span class="toc-text">data_push_tail 将数据环形缓冲区的尾部推进到至少 @lpos 的位置。此函数会将与尾部推进超出其关联数据块的描述符置为可重用状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#desc-push-tail-%E6%8E%A8%E8%BF%9B%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%8E%AF%E7%9A%84%E5%B0%BE%E9%83%A8"><span class="toc-number">7.9.</span> <span class="toc-text">desc_push_tail 推进描述符环的尾部</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#desc-reserve-%E8%BF%94%E5%9B%9E%E6%96%B0%E6%8F%8F%E8%BF%B0%E7%AC%A6%EF%BC%8C%E5%BF%85%E8%A6%81%E6%97%B6%E4%BD%BF%E6%9C%80%E6%97%A7%E7%9A%84%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%A4%B1%E6%95%88%E3%80%82"><span class="toc-number">7.10.</span> <span class="toc-text">desc_reserve 返回新描述符，必要时使最旧的描述符失效。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#get-next-lpos-%E7%A1%AE%E5%AE%9A%E6%95%B0%E6%8D%AE%E5%9D%97%E7%9A%84%E7%BB%93%E5%B0%BE"><span class="toc-number">7.11.</span> <span class="toc-text">get_next_lpos 确定数据块的结尾</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#data-alloc-%E5%88%86%E9%85%8D%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E5%9D%97%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%9C%89%E5%BF%85%E8%A6%81%E4%BC%9A%E4%BD%BF%E6%9C%80%E6%97%A7%E7%9A%84%E6%95%B0%E6%8D%AE%E5%9D%97%E5%A4%B1%E6%95%88"><span class="toc-number">7.12.</span> <span class="toc-text">data_alloc 分配一个新的数据块，如果有必要会使最旧的数据块失效</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#prb-commit-%E5%B0%86%E6%95%B0%E6%8D%AE%E7%8A%B6%E6%80%81%E8%AE%BE%E7%BD%AE%E4%B8%BA%E6%8F%90%E4%BA%A4"><span class="toc-number">7.13.</span> <span class="toc-text">prb_commit 将数据状态设置为提交</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#prb-reserve-%E5%9C%A8%E7%8E%AF%E5%BD%A2%E7%BC%93%E5%86%B2%E5%8C%BA%E4%B8%AD%E4%BF%9D%E7%95%99%E7%A9%BA%E9%97%B4"><span class="toc-number">7.14.</span> <span class="toc-text">prb_reserve 在环形缓冲区中保留空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#prb-rec-init-wr-%E5%88%9D%E5%A7%8B%E5%8C%96%E7%94%A8%E4%BA%8E%E5%86%99%E5%85%A5%E8%AE%B0%E5%BD%95%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA%E3%80%82"><span class="toc-number">7.15.</span> <span class="toc-text">prb_rec_init_wr 初始化用于写入记录的缓冲区。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#prb-first-seq-%E8%8E%B7%E5%8F%96%E5%B0%BE%E9%83%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%9A%84%E5%BA%8F%E5%88%97%E5%8F%B7"><span class="toc-number">7.16.</span> <span class="toc-text">prb_first_seq 获取尾部描述符的序列号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ulseq-to-u64seq-%E5%B0%86-32-%E4%BD%8D%E5%BA%8F%E5%88%97%E5%8F%B7%E8%BD%AC%E6%8D%A2%E4%B8%BA-64-%E4%BD%8D%E5%BA%8F%E5%88%97%E5%8F%B7"><span class="toc-number">7.17.</span> <span class="toc-text">__ulseq_to_u64seq 将 32 位序列号转换为 64 位序列号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#desc-last-finalized-seq-%E8%8E%B7%E5%8F%96%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%B7%B2%E5%AE%8C%E6%88%90%E7%9A%84%E5%BA%8F%E5%88%97%E5%8F%B7"><span class="toc-number">7.18.</span> <span class="toc-text">desc_last_finalized_seq 获取最后一个已完成的序列号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#desc-read-finalized-seq-%E8%8E%B7%E5%8F%96%E6%8C%87%E5%AE%9A%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%9A%84%E5%89%AF%E6%9C%AC"><span class="toc-number">7.19.</span> <span class="toc-text">desc_read_finalized_seq 获取指定描述符的副本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#get-data-%E7%BB%99%E5%AE%9A-blk-lpos%EF%BC%8C%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%9D%97%E8%BF%94%E5%9B%9E%E6%8C%87%E5%90%91%E5%86%99%E5%85%A5%E5%99%A8%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8C%87%E9%92%88%EF%BC%8C%E5%B9%B6%E8%AE%A1%E7%AE%97%E6%95%B0%E6%8D%AE%E9%83%A8%E5%88%86%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">7.20.</span> <span class="toc-text">get_data 给定@blk_lpos，从数据块返回指向写入器数据的指针，并计算数据部分的大小</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#copy-data-%E7%BB%99%E5%AE%9A-blk-lpos%EF%BC%8C%E5%B0%86%E9%A2%84%E6%9C%9F%E7%9A%84%E6%95%B0%E6%8D%AE-len%E5%A4%8D%E5%88%B6%E5%88%B0%E6%8F%90%E4%BE%9B%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA%E4%B8%AD"><span class="toc-number">7.21.</span> <span class="toc-text">copy_data 给定@blk_lpos，将预期的数据@len复制到提供的缓冲区中</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#prb-read-%E5%B0%86%E5%B8%A6%E6%9C%89-seq-%E7%9A%84%E8%AE%B0%E5%BD%95%E4%B8%AD%E7%9A%84-ringbuffer-%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6%E5%88%B0%E6%8F%90%E4%BE%9B%E7%9A%84-r-%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">7.22.</span> <span class="toc-text">prb_read 将带有 @seq 的记录中的 ringbuffer 数据复制到提供的 @r 缓冲区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#prb-next-reserve-seq-%E8%8E%B7%E5%8F%96%E6%9C%80%E8%BF%91%E4%BF%9D%E7%95%99%E8%AE%B0%E5%BD%95%E4%B9%8B%E5%90%8E%E7%9A%84%E5%BA%8F%E5%88%97%E5%8F%B7%E3%80%82"><span class="toc-number">7.23.</span> <span class="toc-text">prb_next_reserve_seq 获取最近保留记录之后的序列号。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#prb-read-valid-%E9%9D%9E%E9%98%BB%E5%A1%9E%E8%AF%BB%E5%8F%96%E8%AE%B0%E5%BD%95"><span class="toc-number">7.24.</span> <span class="toc-text">_prb_read_valid 非阻塞读取记录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#desc-update-last-finalized-%E5%B0%86-last-finalized-seq-%E6%9B%B4%E6%96%B0%E4%B8%BA%E8%BF%99%E4%BA%9B%E8%AE%B0%E5%BD%95%E4%B8%AD%E7%9A%84%E6%9C%80%E6%96%B0%E8%AE%B0%E5%BD%95"><span class="toc-number">7.25.</span> <span class="toc-text">desc_update_last_finalized 将 @last_finalized_seq 更新为这些记录中的最新记录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#prb-final-commit-%E5%B0%86%EF%BC%88%E4%BB%A5%E5%89%8D%E4%BF%9D%E7%95%99%E7%9A%84%EF%BC%89%E6%95%B0%E6%8D%AE%E6%8F%90%E4%BA%A4%E5%B9%B6%E5%AE%8C%E6%88%90%E5%88%B0%E7%8E%AF%E5%BD%A2%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">7.26.</span> <span class="toc-text">prb_final_commit 将（以前保留的）数据提交并完成到环形缓冲区</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#kernel-printk-printk-safe-c-%E5%AE%89%E5%85%A8%E6%89%93%E5%8D%B0"><span class="toc-number">8.</span> <span class="toc-text">kernel&#x2F;printk&#x2F;printk_safe.c 安全打印</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#force-con-%E5%BC%BA%E5%88%B6%E8%BE%93%E5%87%BA%E5%88%B0%E6%8E%A7%E5%88%B6%E5%8F%B0"><span class="toc-number">8.1.</span> <span class="toc-text">force_con 强制输出到控制台</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#kernel-printk-nbcon-c-Non-Blocking-Console-%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%8E%A7%E5%88%B6%E5%8F%B0"><span class="toc-number">9.</span> <span class="toc-text">kernel&#x2F;printk&#x2F;nbcon.c Non-Blocking Console 非阻塞控制台</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#nbcon-get-cpu-emergency-nesting-%E8%8E%B7%E5%8F%96%E6%AF%8F%E4%B8%AA-CPU-%E7%9A%84-nbcon-%E7%B4%A7%E6%80%A5%E5%B5%8C%E5%A5%97%E8%AE%A1%E6%95%B0"><span class="toc-number">9.1.</span> <span class="toc-text">nbcon_get_cpu_emergency_nesting 获取每个 CPU 的 nbcon 紧急嵌套计数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nbcon-get-default-prio-%E8%8E%B7%E5%8F%96nbcon-%E9%BB%98%E8%AE%A4%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">9.2.</span> <span class="toc-text">nbcon_get_default_prio 获取nbcon 默认优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%8E%A7%E5%88%B6%E5%8F%B0-nbcon-%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83%E8%8E%B7%E5%8F%96%E6%9C%BA%E5%88%B6"><span class="toc-number">9.3.</span> <span class="toc-text">非阻塞控制台(nbcon)的所有权获取机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5-struct-nbcon-state"><span class="toc-number">9.3.1.</span> <span class="toc-text">核心概念: struct nbcon_state</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nbcon-context-try-acquire-%E6%89%80%E6%9C%89%E6%9D%83%E8%8E%B7%E5%8F%96%E7%9A%84%E6%80%BB%E5%85%A5%E5%8F%A3"><span class="toc-number">9.3.2.</span> <span class="toc-text">nbcon_context_try_acquire: 所有权获取的总入口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%96%E7%95%A5-2-nbcon-context-try-acquire-handover-%E7%A4%BC%E8%B2%8C%E7%9A%84%E4%BA%A4%E6%8E%A5"><span class="toc-number">9.3.3.</span> <span class="toc-text">策略 2: nbcon_context_try_acquire_handover (礼貌的交接)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%96%E7%95%A5-3-nbcon-context-try-acquire-hostile-%E5%BC%BA%E5%88%B6%E6%8A%A2%E5%8D%A0"><span class="toc-number">9.3.4.</span> <span class="toc-text">策略 3: nbcon_context_try_acquire_hostile (强制抢占)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#printk%E6%97%A5%E5%BF%97%E5%BA%8F%E5%88%97%E5%8F%B7%E7%9A%8464%E4%BD%8D%E5%88%B032%E4%BD%8D%E8%BD%AC%E6%8D%A2%E4%B8%8E%E9%87%8D%E5%BB%BA"><span class="toc-number">9.4.</span> <span class="toc-text">printk日志序列号的64位到32位转换与重建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ulseq-to-u64seq-32%E4%BD%8D%E5%88%B064%E4%BD%8D%E5%BA%8F%E5%88%97%E5%8F%B7%E7%9A%84%E9%87%8D%E5%BB%BA%E5%BC%95%E6%93%8E"><span class="toc-number">9.4.1.</span> <span class="toc-text">__ulseq_to_u64seq: 32位到64位序列号的重建引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nbcon-seq-read-%E5%AE%89%E5%85%A8%E5%9C%B0%E8%AF%BB%E5%8F%96%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BF%9B%E5%BA%A6"><span class="toc-number">9.4.2.</span> <span class="toc-text">nbcon_seq_read: 安全地读取控制台进度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%BE%85%E5%8A%A9%E5%AE%8F"><span class="toc-number">9.4.3.</span> <span class="toc-text">其他辅助宏</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nbcon-context-release-%E5%AE%89%E5%85%A8%E5%9C%B0%E9%87%8A%E6%94%BE%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%8E%A7%E5%88%B6%E5%8F%B0%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83"><span class="toc-number">9.5.</span> <span class="toc-text">nbcon_context_release: 安全地释放非阻塞控制台的所有权</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nbcon-context-can-proceed-%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%8E%A7%E5%88%B6%E5%8F%B0-nbcon-%E6%89%80%E6%9C%89%E6%9D%83%E6%A3%80%E6%9F%A5%E4%B8%8E%E7%A4%BC%E8%AE%A9%E6%9C%BA%E5%88%B6"><span class="toc-number">9.6.</span> <span class="toc-text">nbcon_context_can_proceed: 非阻塞控制台(nbcon)所有权检查与礼让机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#nbcon-context-can-proceed-%E6%A0%B8%E5%BF%83%E5%86%B3%E7%AD%96%E9%80%BB%E8%BE%91"><span class="toc-number">9.6.1.</span> <span class="toc-text">nbcon_context_can_proceed: 核心决策逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nbcon-can-proceed-%E4%BE%BF%E6%8D%B7%E7%9A%84API%E5%B0%81%E8%A3%85"><span class="toc-number">9.6.2.</span> <span class="toc-text">nbcon_can_proceed: 便捷的API封装</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nbcon-%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E2%80%9D%E4%B8%8D%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F%E2%80%9D%E8%BF%9B%E5%87%BA%E6%9C%BA%E5%88%B6"><span class="toc-number">9.7.</span> <span class="toc-text">nbcon 上下文的”不安全区域”进出机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#nbcon-context-update-unsafe-%E6%A0%B8%E5%BF%83%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.7.1.</span> <span class="toc-text">__nbcon_context_update_unsafe: 核心实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%BF%E6%8D%B7%E5%AE%8F%E5%B0%81%E8%A3%85"><span class="toc-number">9.7.2.</span> <span class="toc-text">便捷宏封装</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#printk-get-next-message-printk-%E7%8E%AF%E5%BD%A2%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%AF%BB%E5%8F%96%E5%99%A8"><span class="toc-number">9.8.</span> <span class="toc-text">printk_get_next_message: printk 环形缓冲区的格式化读取器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nbcon-emit-next-record-%E5%8F%91%E5%B0%84%E5%8D%95%E6%9D%A1%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%8E%A7%E5%88%B6%E5%8F%B0-nbcon-%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95"><span class="toc-number">9.9.</span> <span class="toc-text">nbcon_emit_next_record: 发射单条非阻塞控制台(nbcon)日志记录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%8E%A7%E5%88%B6%E5%8F%B0-nbcon-%E7%9A%84%E5%8E%9F%E5%AD%90%E5%88%B7%E6%96%B0-%E5%8D%95%E4%B8%AA%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.10.</span> <span class="toc-text">非阻塞控制台(nbcon)的原子刷新: 单个控制台实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#nbcon-atomic-flush-pending-con-%E6%A0%B8%E5%BF%83%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%91"><span class="toc-number">9.10.1.</span> <span class="toc-text">__nbcon_atomic_flush_pending_con: 核心执行逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nbcon-atomic-flush-pending-con-%E5%B8%A6%E5%AE%89%E5%85%A8%E5%B0%81%E8%A3%85%E5%92%8C%E9%87%8D%E8%AF%95%E9%80%BB%E8%BE%91%E7%9A%84%E5%8C%85%E8%A3%85%E5%99%A8"><span class="toc-number">9.10.2.</span> <span class="toc-text">nbcon_atomic_flush_pending_con: 带安全封装和重试逻辑的包装器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%8E%A7%E5%88%B6%E5%8F%B0-nbcon-%E7%9A%84%E5%8E%9F%E5%AD%90%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6"><span class="toc-number">9.11.</span> <span class="toc-text">非阻塞控制台(nbcon)的原子刷新机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#nbcon-atomic-flush-pending-%E6%A0%B8%E5%BF%83%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.11.1.</span> <span class="toc-text">__nbcon_atomic_flush_pending: 核心实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nbcon-atomic-flush-pending-%E4%BE%BF%E6%8D%B7%E7%9A%84API%E5%B0%81%E8%A3%85"><span class="toc-number">9.11.2.</span> <span class="toc-text">nbcon_atomic_flush_pending: 便捷的API封装</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#kernel-printk-printk-c-%E5%86%85%E6%A0%B8%E6%B6%88%E6%81%AF%E6%89%93%E5%8D%B0"><span class="toc-number">10.</span> <span class="toc-text">kernel&#x2F;printk&#x2F;printk.c 内核消息打印</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#oops-in-progress-%E6%8C%87%E7%A4%BA%E5%BD%93%E5%89%8D%E6%98%AF%E5%90%A6%E6%AD%A3%E5%9C%A8%E5%A4%84%E7%90%86%E5%86%85%E6%A0%B8%E9%94%99%E8%AF%AF"><span class="toc-number">10.1.</span> <span class="toc-text">oops_in_progress 指示当前是否正在处理内核错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#printk-delay-%E5%BD%93CONFIG-BOOT-PRINTK-DELAY%E9%85%8D%E7%BD%AE%E6%97%B6-%E6%AF%8F%E6%9D%A1%E6%B6%88%E6%81%AF%E5%BB%B6%E6%97%B6%E6%89%93%E5%8D%B0%E9%85%8D%E7%BD%AE"><span class="toc-number">10.2.</span> <span class="toc-text">printk_delay 当CONFIG_BOOT_PRINTK_DELAY配置时 每条消息延时打印配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#printk-recursion-counter-%E8%BF%94%E5%9B%9E%E6%8C%87%E5%90%91%E8%B0%83%E7%94%A8%E6%96%B9-CPU-%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E4%B8%93%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">10.3.</span> <span class="toc-text">__printk_recursion_counter 返回指向调用方 CPU 上下文的专用计数器的指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#printk-enter-irqsave-%E5%B1%8F%E8%94%BD%E4%B8%AD%E6%96%AD%E5%B9%B6%E6%A3%80%E6%9F%A5%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8%E6%AC%A1%E6%95%B0%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E5%85%81%E8%AE%B8%E6%89%93%E5%8D%B0-%E5%A4%B1%E8%B4%A5%E4%B8%8D%E4%BC%9A%E7%A6%81%E7%94%A8"><span class="toc-number">10.4.</span> <span class="toc-text">printk_enter_irqsave 屏蔽中断并检查递归调用次数判断是否允许打印,失败不会禁用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#printk-parse-prefix-%E6%8F%90%E5%8F%96%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB%E6%88%96%E6%8E%A7%E5%88%B6%E6%A0%87%E5%BF%97%E3%80%82"><span class="toc-number">10.5.</span> <span class="toc-text">printk_parse_prefix 提取日志级别或控制标志。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#printk-ringbuffer-%E9%9D%99%E6%80%81-%E5%8A%A8%E6%80%81"><span class="toc-number">10.6.</span> <span class="toc-text">printk_ringbuffer 静态 动态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#truncate-msg-%E6%88%AA%E6%96%AD%E6%B6%88%E6%81%AF"><span class="toc-number">10.7.</span> <span class="toc-text">truncate_msg 截断消息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vprintk-store-%E6%89%93%E5%8D%B0%E6%B6%88%E6%81%AF%E5%88%B0%E7%8E%AF%E5%BD%A2%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">10.8.</span> <span class="toc-text">vprintk_store 打印消息到环形缓冲区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vprintk-emit-%E6%89%93%E5%8D%B0%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81"><span class="toc-number">10.9.</span> <span class="toc-text">vprintk_emit 打印消息发送</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#printk-%E5%86%85%E6%A0%B8%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0%E5%87%BD%E6%95%B0"><span class="toc-number">10.10.</span> <span class="toc-text">printk 内核日志打印函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ignore-loglevel"><span class="toc-number">10.11.</span> <span class="toc-text">ignore_loglevel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94-%E6%8E%A7%E5%88%B6%E5%8F%B0%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94"><span class="toc-number">10.12.</span> <span class="toc-text">—————-控制台——————————————-</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#suppress-message-printing-%E7%A6%81%E6%AD%A2%E6%89%93%E5%8D%B0%E6%B6%88%E6%81%AF"><span class="toc-number">10.13.</span> <span class="toc-text">suppress_message_printing 禁止打印消息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#console-list-lock-console-list-unlock-%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%88%97%E8%A1%A8%E9%94%81%E5%AE%9A%E5%92%8C%E8%A7%A3%E9%94%81"><span class="toc-number">10.14.</span> <span class="toc-text">console_list_lock console_list_unlock 控制台列表锁定和解锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#try-enable-default-console-%E5%B0%9D%E8%AF%95%E6%97%A0%E6%9D%A1%E4%BB%B6%E5%90%AF%E7%94%A8%E6%8E%A7%E5%88%B6%E5%8F%B0"><span class="toc-number">10.15.</span> <span class="toc-text">try_enable_default_console 尝试无条件启用控制台</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#try-enable-preferred-console-%E5%B0%9D%E8%AF%95%E5%90%AF%E7%94%A8%E9%A6%96%E9%80%89%E6%8E%A7%E5%88%B6%E5%8F%B0"><span class="toc-number">10.16.</span> <span class="toc-text">try_enable_preferred_console 尝试启用首选控制台</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#get-init-console-seq-%E8%BF%94%E5%9B%9E%E6%96%B0%E6%B3%A8%E5%86%8C%E7%9A%84%E6%8E%A7%E5%88%B6%E5%8F%B0%E7%9A%84%E8%B5%B7%E5%A7%8B%E5%BA%8F%E5%88%97%E5%8F%B7"><span class="toc-number">10.17.</span> <span class="toc-text">get_init_console_seq 返回新注册的控制台的起始序列号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#register-console-%E6%B3%A8%E5%86%8C%E6%8E%A7%E5%88%B6%E5%8F%B0-unregister-console-locked-%E6%B3%A8%E9%94%80%E6%8E%A7%E5%88%B6%E5%8F%B0"><span class="toc-number">10.18.</span> <span class="toc-text">register_console 注册控制台 unregister_console_locked 注销控制台</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#setup-log-buf"><span class="toc-number">10.19.</span> <span class="toc-text">setup_log_buf</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#console-init"><span class="toc-number">10.20.</span> <span class="toc-text">console_init</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#printk-set-kthreads-ready"><span class="toc-number">10.21.</span> <span class="toc-text">printk_set_kthreads_ready</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pr-flush-%E5%90%8C%E6%AD%A5%E5%B9%B6%E7%AD%89%E5%BE%85%E5%86%85%E6%A0%B8%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA"><span class="toc-number">10.22.</span> <span class="toc-text">pr_flush: 同步并等待内核日志输出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pr-flush-%E6%A0%B8%E5%BF%83%E5%AE%9E%E7%8E%B0"><span class="toc-number">10.22.1.</span> <span class="toc-text">__pr_flush: 核心实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pr-flush-%E4%BE%BF%E6%8D%B7%E7%9A%84API%E5%B0%81%E8%A3%85"><span class="toc-number">10.22.2.</span> <span class="toc-text">pr_flush: 便捷的API封装</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#console-prepend-message-%E5%9C%A8%E6%97%A5%E5%BF%97%E6%B6%88%E6%81%AF%E5%89%8D%E6%8F%92%E5%85%A5%E6%96%87%E6%9C%AC"><span class="toc-number">10.23.</span> <span class="toc-text">console_prepend_message: 在日志消息前插入文本</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#console-prepend-message-%E6%A0%B8%E5%BF%83%E5%AE%9E%E7%8E%B0"><span class="toc-number">10.23.1.</span> <span class="toc-text">console_prepend_message: 核心实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#console-prepend-dropped-%E4%BE%BF%E6%8D%B7%E7%9A%84API%E5%B0%81%E8%A3%85"><span class="toc-number">10.23.2.</span> <span class="toc-text">console_prepend_dropped: 便捷的API封装</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#printk-%E6%97%A5%E5%BF%97%E6%96%87%E6%9C%AC%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8E%E5%89%8D%E7%BC%80%E6%B3%A8%E5%85%A5"><span class="toc-number">10.24.</span> <span class="toc-text">printk 日志文本格式化与前缀注入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#info-print-prefix-%E7%94%9F%E6%88%90%E5%8D%95%E8%A1%8C%E5%89%8D%E7%BC%80"><span class="toc-number">10.24.1.</span> <span class="toc-text">info_print_prefix: 生成单行前缀</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#record-print-text-%E6%A0%B8%E5%BF%83%E7%9A%84%E2%80%9D%E5%8E%9F%E5%9C%B0%E2%80%9D%E6%96%87%E6%9C%AC%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%BC%95%E6%93%8E"><span class="toc-number">10.24.2.</span> <span class="toc-text">record_print_text: 核心的”原地”文本格式化引擎</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/1db9a982/" title="ext4"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/04.jpg" onerror="this.onerror=null;this.src='/images/404.jpg'" alt="ext4"/></a><div class="content"><a class="title" href="/posts/1db9a982/" title="ext4">ext4</a><time datetime="2025-10-07T03:18:15.310Z" title="更新于 2025-10-07 11:18:15">2025-10-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/b554c0f0/" title="mbcache"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/03.jpg" onerror="this.onerror=null;this.src='/images/404.jpg'" alt="mbcache"/></a><div class="content"><a class="title" href="/posts/b554c0f0/" title="mbcache">mbcache</a><time datetime="2025-10-07T03:16:04.099Z" title="更新于 2025-10-07 11:16:04">2025-10-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/88ab2b13/" title="fs-writeback"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/08.jpg" onerror="this.onerror=null;this.src='/images/404.jpg'" alt="fs-writeback"/></a><div class="content"><a class="title" href="/posts/88ab2b13/" title="fs-writeback">fs-writeback</a><time datetime="2025-10-07T03:08:29.811Z" title="更新于 2025-10-07 11:08:29">2025-10-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2089198e/" title="filesystems"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/03.jpg" onerror="this.onerror=null;this.src='/images/404.jpg'" alt="filesystems"/></a><div class="content"><a class="title" href="/posts/2089198e/" title="filesystems">filesystems</a><time datetime="2025-10-07T02:52:10.933Z" title="更新于 2025-10-07 10:52:10">2025-10-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/933a291e/" title="hweight"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/10.jpg" onerror="this.onerror=null;this.src='/images/404.jpg'" alt="hweight"/></a><div class="content"><a class="title" href="/posts/933a291e/" title="hweight">hweight</a><time datetime="2025-10-07T02:49:48.378Z" title="更新于 2025-10-07 10:49:48">2025-10-07</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/images/covers/10.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">文档</div><div class="footer-flex-content"><a href="/categories/linux/" target="_blank" title="🚀 linux">🚀 linux</a><a href="/categories/rt-thread/" target="_blank" title="📑 rt-thread">📑 rt-thread</a><a href="/categories/uboot/" target="_blank" title="📌 uboot">📌 uboot</a><a href="/categories/LoraWan/" target="_blank" title="⚔️ LoraWan">⚔️ LoraWan</a><a href="/categories/hpatch/" target="_blank" title="❓ hpatch">❓ hpatch</a><a href="/categories/git/" target="_blank" title="⚡️ git">⚡️ git</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/gallery/" target="_blank" title="图库">图库</a><a href="/messageboard/" target="_blank" title="留言板">留言板</a><a href="/shuoshuo/" target="_blank" title="说说">说说</a><a href="/link/" target="_blank" title="示例">示例</a><a href="/link/" target="_blank" title="友链">友链</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">框架</div><div class="footer-flex-content"><a href="https://hexo.io/zh-cn/" rel="external nofollow noreferrer" target="_blank" title="Hexo">Hexo</a><a href="https://butterfly.js.org/" rel="external nofollow noreferrer" target="_blank" title="Butterfly">Butterfly</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">贊助</div><div class="footer-flex-content"><div><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/alipay.png" alt='wdfk_prog' width='100px' height='100px'></div></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Liya Huang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo 8.0.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.1</a></span></div><div class="footer_custom_text">你好，欢迎来到我的 <a href="/about/">数字花园</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天" style="display:none"><i class="fas fa-message"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script><script>(() => {
  const abcjsInit = () => {
    const abcjsFn = () => {
      setTimeout(() => {
        const sheets = document.querySelectorAll(".abc-music-sheet")
        for (let i = 0; i < sheets.length; i++) {
          const ele = sheets[i]
          if (ele.children.length > 0) continue

          // Parse parameters from data-params attribute
          let params = {}
          const dp = ele.getAttribute("data-params")
          if (dp) {
            try {
              params = JSON.parse(dp)
            } catch (e) {
              console.error("Failed to parse data-params:", e)
            }
          }

          // Merge parsed parameters with the responsive option
          // Ensures params content appears before responsive
          const options = { ...params, responsive: "resize" }

          // Render the music score using ABCJS.renderAbc
          ABCJS.renderAbc(ele, ele.innerHTML, options)
        }
      }, 100)
    }

    if (typeof ABCJS === "object") {
      abcjsFn()
    } else {
      btf.getScript("https://cdn.jsdelivr.net/npm/abcjs/dist/abcjs-basic-min.min.js").then(abcjsFn)
    }
  }

  if (window.pjax) {
    abcjsInit()
  } else {
    window.addEventListener("load", abcjsInit)
  }

  btf.addGlobalFn("encrypt", abcjsInit, "abcjs")
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: 'Ov23livBmwx65h3XIdfT',
      clientSecret: '9f23bdaa2ea11322f9f405d77bcdc27166077a7d',
      repo: 'wdfk-prog.github.io',
      owner: 'wdfk-prog',
      admin: ['wdfk-prog'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || '51db94b73e1b05565df6366fcbabb99a'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script>window.newestComments = {
  changeContent: content => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<code>.*?<\/code>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g, "") // remove html tag

    if (content.length > 150) {
      content = content.substring(0, 150) + '...'
    }
    return content
  },

  generateHtml: (array, ele) => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class="aside-list-item">'

        if (true && array[i].avatar) {
          const imgAttr = 'data-lazy-src'
          const lazyloadNative = ''
          result += `<a href="${array[i].url}" class="thumbnail"><img ${imgAttr}="${array[i].avatar}" alt="${array[i].nick}" ${lazyloadNative}></a>`
        }

        result += `<div class="content">
        <a class="comment" href="${array[i].url}" title="${array[i].content}">${array[i].content}</a>
        <div class="name"><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '暂无评论'
    }

    ele.innerHTML = result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh(ele)
  },

  newestCommentInit: (name, getComment) => {
    const $dom = document.querySelector('#card-newest-comments .aside-list')
    if ($dom) {
      const data = btf.saveToLocal.get(name)
      if (data) {
        newestComments.generateHtml(JSON.parse(data), $dom)
      } else {
        getComment($dom)
      }
    }
  },

  run: (name, getComment) => {
    newestComments.newestCommentInit(name, getComment)
    btf.addGlobalFn('pjaxComplete', () => newestComments.newestCommentInit(name, getComment), name)
  }
}</script><script>window.addEventListener('load', () => {
  const keyName = 'github-newest-comments'
  const { changeContent, generateHtml, run } = window.newestComments

  const findTrueUrl = (array, ele) => {
    Promise.all(array.map(item =>
      fetch(item.url).then(resp => resp.json()).then(data => {
        let urlArray = data.body ? data.body.match(/(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?/ig) : []
        if (!Array.isArray(urlArray) || urlArray.length === 0) {
          urlArray = [`${data.html_url}`]
        }
        if (data.user.login === 'utterances-bot') {
          return urlArray.pop()
        } else {
          return urlArray.shift()
        }
      })
    )).then(res => {
        array = array.map((i,index)=> {
          return {
            ...i,
            url: res[index]
          }
        })

        btf.saveToLocal.set(keyName, JSON.stringify(array), 10/(60*24))
        generateHtml(array, ele)
    });
  }

  const getComment = ele => {
    fetch('https://api.github.com/repos/wdfk-prog/wdfk-prog.github.io/issues/comments?sort=updated&direction=desc&per_page=6&page=1',{
      "headers": {
        Accept: 'application/vnd.github.v3.html+json'
      }
    })
      .then(response => response.json())
      .then(data => {
        const githubArray = data.map(item => {
          return {
            'avatar': item.user.avatar_url,
            'content': changeContent(item.body_html || item.body),
            'nick': item.user.login,
            'url': item.issue_url,
            'date': item.updated_at
          }
        })
        findTrueUrl(githubArray, ele)
      }).catch(e => {
        console.error(e)
        ele.textContent= "无法获取评论，请确认相关配置是否正确"
      })
  }
  run(keyName, getComment)
})</script><div class="aplayer no-destroy" data-id="60198" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="false" data-volume="0.5"></div><script>
  var titleTime, OriginTitile = document.title;
  document.addEventListener("visibilitychange", function() {
    if (document.hidden) {
      titleTime = setTimeout(function() {
        document.title = "w(ﾟДﾟ)w 不要走！再看看嘛！";
      }, 300);
    } else {
      document.title = "♪(^∇^*)欢迎回来！" + OriginTitile;
      titleTime = setTimeout(function() {
        document.title = OriginTitile;
      }, 2000);
    }
  });
</script>
<script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script>(() => {
  window.ChatraID = '5cPWcnA8HKGzg5hoc'
  window.Chatra = window.Chatra || function() {
    (window.Chatra.q = window.Chatra.q || []).push(arguments)
  }

  btf.getScript('https://call.chatra.io/chatra.js').then(() => {
    const isChatBtn = true
    const isChatHideShow = true

    if (isChatBtn) {
      const close = () => {
        Chatra('minimizeWidget')
        Chatra('hide')
      }

      const open = () => {
        Chatra('openChat', true)
        Chatra('show')
      }

      window.ChatraSetup = { startHidden: true }
    
      window.chatBtnFn = () => document.getElementById('chatra').classList.contains('chatra--expanded') ? close() : open()

      document.getElementById('chat-btn').style.display = 'block'
    } else if (isChatHideShow) {
      window.chatBtn = {
        hide: () => Chatra('hide'),
        show: () => Chatra('show')
      }
    }
  })
})()</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: true,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      true
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-MF3J339H" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript></div><script src="https://cdn.jsdelivr.net/npm/echarts@5.5.1/dist/echarts.min.js"></script>
        
        <script>
            document.addEventListener("DOMContentLoaded", function() {
                const heatmapChartDom = document.getElementById('heatmapChart');
                if(heatmapChartDom){
                    const heatmapChart = echarts.init(heatmapChartDom, 'dark');
                    const cellSize = [18, 18];
                    
                    const groupByYear = (data) => {
                        const result = {};
                        data.forEach(([date, value]) => {
                            const [year] = date.split('-').map(Number);
                            if (!result[year]) {
                                result[year] = [];
                            }
                            result[year].push([date, value]);
                        });
                        return result;
                    };
                    
                    const groupedData = groupByYear([["2025-10-03",392],["2025-10-04",5],["2025-10-06",9],["2025-10-07",8]]);
                    const years = Object.keys(groupedData).reverse();
                    
                    var initYear = parseInt(heatmapChartDom.getAttribute('year')) || new Date().getFullYear();
                    const minYear = years[years.length - 1];
                    const maxYear = years[0];
                    if (initYear < minYear || initYear > maxYear) {
                        initYear = maxYear;
                    }
                    console.log('[hexo-graph]generateHeatmapChart|initYear:', initYear, 'minYear:', minYear, 'maxYear:', maxYear);
                    
                    heatmapChart.setOption({
                        grid: {},
                        tooltip: { 
                            position: 'top', 
                            formatter: params => `${params.value[0]}: ${params.value[1]} Articles` 
                        },
                        calendar: { 
                            top: '10%',
                            left: 'left', 
                            right: '8%',
                            range: initYear,
                            cellSize: cellSize, 
                            splitLine: { lineStyle: { color: '#E0E0E0', width: 1 } }, 
                            itemStyle: { borderWidth: 1, borderColor: '#E0E0E0' }, 
                            dayLabel: { show: false },
                            monthLabel: { show: true },
                            yearLabel: { show: false },
                        },
                        visualMap: { 
                            show: true,
                            right: '8%',
                            bottom: '5%',
                            type: 'piecewise',
                            orient: 'horizontal',
                            text: ['More', 'Less'],
                            min: 0,
                            max: Math.max(...groupedData[initYear].map(item => item[1])),
                            inRange: { color: ["#ACE7AE","#69C16D","#549F57"] }
                        },
                        legend: {
                            type: 'scroll',
                            icon: 'none',
                            data: years,
                            orient: 'vertical',
                            top: '5%',
                            right: 'right',
                            itemWidth: 20,
                            itemHeight: 20,
                            itemGap: 10,
                            pageIconSize: 10,
                            pageTextStyle: { fontSize: 14 },
                            selectedMode: 'single',
                        },
                        series: years.map(year => ({
                            type: 'heatmap',
                            coordinateSystem: 'calendar',
                            data: groupedData[year],
                            name: year,
                            emphasis: {
                                disabled: true,
                            },
                            silent: year !== initYear,
                        })),
                    });
                    
                    // init selected year
                    heatmapChart.dispatchAction({
                        type: 'legendSelect',
                        name: initYear,
                    });
                    
                    heatmapChart.on('legendselectchanged', function(params) {
                        console.log('[hexo-graph]generateHeatmapChart|legendselectchanged:', params);
                        const selectedYear = Object.keys(params.selected).find(key => params.selected[key]);
                        if (selectedYear && groupedData[selectedYear]) {
                            heatmapChart.setOption({
                                calendar: {
                                    range: selectedYear,
                                },
                                visualMap: {
                                    max: Math.max(...groupedData[selectedYear].map(item => item[1])),
                                },
                                series: years.map(year => ({
                                    type: 'heatmap',
                                    coordinateSystem: 'calendar',
                                    data: groupedData[year],
                                    name: year,
                                    emphasis: {
                                        disabled: true,
                                    },
                                    silent: year !== selectedYear,
                                })),
                            });
                        }
                    });
                    
                    heatmapChart.on('click', function (params) {
                        if (params.componentType === 'series') {
                            const [year, month] = params.value[0].split('-');
                            window.location.href = '/archives/' + year + '/' + month;
                        }
                    });
                }
            });
        </script>
    
        
        <script>
            document.addEventListener("DOMContentLoaded", function() {
                const monthlyChartDom = document.getElementById('monthlyChart');
                if(monthlyChartDom){
                    const monthlyChart = echarts.init(monthlyChartDom, 'dark');
                    monthlyChart.setOption({
                        xAxis: { 
                            type: 'category', 
                            data: ["2025-10"], 
                            axisLabel: { fontSize: 14, fontWeight: 'bold', fontFamily: 'Microsoft YaHei, SimSun, serif' }
                        },
                        yAxis: { type: 'value', splitLine: { lineStyle: { type: 'dashed', color: '#ccc' } } },
                        series: [{
                            name: 'Articles',
                            type: 'line',
                            data: [414],
                            smooth: true,
                            lineStyle: { color: '#5470C6', width: 2 },
                            itemStyle: { color: '#5470C6' },
                            areaStyle: { color: 'rgba(84, 112, 198, 0.4)' },
                            symbolSize: 10,
                            label: {
                                show: true,
                                position: 'top',
                                formatter: params => params.value,
                                fontSize: 14,
                                color: '#000',
                                fontWeight: 'bold',
                                fontFamily: 'Microsoft YaHei, SimSun, serif'
                            }
                        }]
                    });

                    monthlyChart.on('click', function (params) {
                        const [year, month] = params.name.split('-');
                        window.location.href = '/archives/' + year + '/' + month;
                    });
                }
            })
        </script>
    
        
        <script>
            document.addEventListener("DOMContentLoaded", function() {
                const tagsChartDom = document.getElementById('tagsChart');
                if(tagsChartDom){
                    const tagsChart = echarts.init(tagsChartDom, 'dark');
                    tagsChart.setOption({
                        tooltip: { trigger: 'item', formatter: '{b}: {c} ({d}%)' },
                        series: [{
                            type: 'pie',
                            radius: '60%',
                            data: [{"name":"linux","value":227},{"name":"uboot","value":68},{"name":"kernel","value":61},{"name":"rt-thread","value":44},{"name":"u-boot分类","value":44},{"name":"drivers","value":39},{"name":"fs","value":37},{"name":"other","value":28}],
                            label: {
                                position: 'outside',
                                formatter: '{b} {c} ({d}%)',
                                fontSize: 14,
                                fontWeight: 'bold',
                                fontFamily: 'Microsoft YaHei, SimSun, serif'
                            },
                            color: ["#5470C6","#91CC75","#FAC858","#EE6666","#73C0DE","#3BA272","#FC8452","#9A60B4"],
                            labelLine: { show: true }
                        }],
                        legend: {
                            bottom: '0',
                            left: 'center',
                            data: [{"name":"linux","value":227},{"name":"uboot","value":68},{"name":"kernel","value":61},{"name":"rt-thread","value":44},{"name":"u-boot分类","value":44},{"name":"drivers","value":39},{"name":"fs","value":37},{"name":"other","value":28}].map(tag => tag.name),
                            textStyle: { fontSize: 14, fontWeight: 'bold', fontFamily: 'Microsoft YaHei, SimSun, serif' }
                        }
                    });

                    tagsChart.on('click', function (params) {
                        window.location.href = '/tags/' + params.name;
                    });
                }
            })
        </script>
    
        
        <script>
            document.addEventListener("DOMContentLoaded", function() {
                const categoriesChartDom = document.getElementById('categoriesChart');
                if(categoriesChartDom){
                    const categoriesChart = echarts.init(categoriesChartDom, 'dark');
                    categoriesChart.setOption({
                        xAxis: { type: 'value', splitLine: { lineStyle: { type: 'dashed', color: '#ccc' } } },
                        yAxis: { 
                            type: 'category', 
                            data: [{"name":"linux","value":227},{"name":"uboot","value":68},{"name":"kernel","value":61},{"name":"rt-thread","value":44},{"name":"u-boot分类","value":44}].map(category => category.name).reverse(), 
                            axisLabel: { fontSize: 14, fontWeight: 'bold', fontFamily: 'Microsoft YaHei, SimSun, serif' }
                        },
                        series: [{
                            name: 'Category Count',
                            type: 'bar',
                            data: [{"name":"linux","value":227},{"name":"uboot","value":68},{"name":"kernel","value":61},{"name":"rt-thread","value":44},{"name":"u-boot分类","value":44}].map(category => category.value).reverse(),
                            label: {
                                show: true,
                                position: 'right',
                                formatter: params => params.value,
                                fontSize: 14,
                                color: '#000',
                                fontWeight: 'bold',
                                fontFamily: 'Microsoft YaHei, SimSun, serif'
                            },
                            itemStyle: {
                                color: new echarts.graphic.LinearGradient(0, 0, 1, 0, [
                                    { offset: 0, color: '#91CC75' },
                                    { offset: 1, color: '#73C0DE' }
                                ])
                            }
                        }]
                    });

                    categoriesChart.on('click', function (params) {
                        window.location.href = '/categories/' + params.name;
                    });
                }
            });
        </script>
    
        
        <script>
            document.addEventListener("DOMContentLoaded", function() {
                const categoriesTreeChartDom = document.getElementById('categoriesTreeChart');
                if(categoriesTreeChartDom){
                    const treeChart = echarts.init(categoriesTreeChartDom, 'dark');
                    treeChart.setOption({
                        title: {
                            text: '操作提示：单击展开分类，双击进入具体分类页面',
                            textStyle: {
                                fontSize: 12,
                                color: '#999',
                                fontWeight: 'normal'
                            },
                            bottom: 0,
                            left: 'center'
                        },
                        tooltip: {
                            trigger: 'item',
                            triggerOn: 'mousemove'
                        },
                        series: [{
                            type: 'tree',
                            data: [{"name":"Categories","children":[{"name":"uboot","children":[{"name":"other","children":[],"count":12,"path":"uboot/other"},{"name":"子目录","children":[],"count":10,"path":"uboot/子目录"},{"name":"u-boot分类","children":[{"name":"api","children":[],"count":1,"path":"uboot/u-boot分类/api"},{"name":"arch","children":[{"name":"arm","children":[],"count":2,"path":"uboot/u-boot分类/arch/arm"}],"count":3,"path":"uboot/u-boot分类/arch"},{"name":"boot","children":[],"count":4,"path":"uboot/u-boot分类/boot"},{"name":"common","children":[],"count":10,"path":"uboot/u-boot分类/common"},{"name":"cmd","children":[],"count":1,"path":"uboot/u-boot分类/cmd"},{"name":"dm","children":[],"count":15,"path":"uboot/u-boot分类/dm"},{"name":"env","children":[],"count":1,"path":"uboot/u-boot分类/env"},{"name":"fdt","children":[],"count":1,"path":"uboot/u-boot分类/fdt"},{"name":"lib","children":[],"count":4,"path":"uboot/u-boot分类/lib"},{"name":"include","children":[],"count":3,"path":"uboot/u-boot分类/include"},{"name":"test","children":[],"count":1,"path":"uboot/u-boot分类/test"}],"count":44,"path":"uboot/u-boot分类"}],"count":68,"path":"uboot"},{"name":"rt-thread","children":[{"name":"其他资料","children":[{"name":"fatfs","children":[],"count":1,"path":"rt-thread/其他资料/fatfs"}],"count":1,"path":"rt-thread/其他资料"}],"count":44,"path":"rt-thread"},{"name":"linux","children":[{"name":"fs","children":[],"count":37,"path":"linux/fs"},{"name":"lib","children":[],"count":19,"path":"linux/lib"},{"name":"mm","children":[],"count":19,"path":"linux/mm"},{"name":"kernel","children":[{"name":"time","children":[],"count":10,"path":"linux/kernel/time"},{"name":"irq","children":[],"count":5,"path":"linux/kernel/irq"},{"name":"rcu","children":[],"count":3,"path":"linux/kernel/rcu"},{"name":"lock","children":[],"count":7,"path":"linux/kernel/lock"},{"name":"sched","children":[],"count":7,"path":"linux/kernel/sched"}],"count":61,"path":"linux/kernel"},{"name":"other","children":[],"count":17,"path":"linux/other"},{"name":"scripts","children":[],"count":2,"path":"linux/scripts"},{"name":"security","children":[],"count":1,"path":"linux/security"},{"name":"include","children":[],"count":10,"path":"linux/include"},{"name":"block","children":[],"count":5,"path":"linux/block"},{"name":"drivers","children":[{"name":"clk","children":[],"count":2,"path":"linux/drivers/clk"},{"name":"base","children":[],"count":14,"path":"linux/drivers/base"},{"name":"tty","children":[],"count":2,"path":"linux/drivers/tty"}],"count":39,"path":"linux/drivers"},{"name":"arch","children":[{"name":"arm","children":[],"count":10,"path":"linux/arch/arm"}],"count":10,"path":"linux/arch"}],"count":227,"path":"linux"},{"name":"hpatch","children":[{"name":"SA-IS","children":[],"count":1,"path":"hpatch/SA-IS"},{"name":"libdivsufsort","children":[],"count":3,"path":"hpatch/libdivsufsort"}],"count":10,"path":"hpatch"},{"name":"杂谈","children":[],"count":8,"path":"杂谈"},{"name":"MCU","children":[],"count":23,"path":"MCU"},{"name":"git","children":[],"count":6,"path":"git"},{"name":"LoraWan","children":[{"name":"LoRaWAN标准","children":[{"name":"LoRaWAN-Specification_ZH_CN","children":[{"name":"LoRaWAN-Specification_ZH_CN-190102","children":[{"name":"chapter","children":[],"count":20,"path":"LoraWan/LoRaWAN标准/LoRaWAN-Specification_ZH_CN/LoRaWAN-Specification_ZH_CN-190102/chapter"}],"count":22,"path":"LoraWan/LoRaWAN标准/LoRaWAN-Specification_ZH_CN/LoRaWAN-Specification_ZH_CN-190102"}],"count":22,"path":"LoraWan/LoRaWAN标准/LoRaWAN-Specification_ZH_CN"}],"count":22,"path":"LoraWan/LoRaWAN标准"}],"count":23,"path":"LoraWan"},{"name":"freertos","children":[],"count":1,"path":"freertos"},{"name":"tmc5160","children":[],"count":1,"path":"tmc5160"}],"count":0,"path":""}],
                            initialTreeDepth: -1,
                            top: '5%',
                            bottom: '10%',
                            left: '0%',
                            right: '0%',
                            symbolSize: 15,
                            layout: 'orthogonal',
                            orient: 'TB',
                            itemStyle: {
                                color: '#91CC75',
                                borderColor: '#73C0DE'
                            },
                            label: {
                                position: 'bottom',
                                verticalAlign: 'middle',
                                align: 'center',
                                fontSize: 14,
                                distance: 28,
                                formatter: function(params) {
                                    return params.data.name + (params.data.count ? ' (' + params.data.count + ')' : '');
                                }
                            },
                            leaves: {
                                label: {
                                    position: 'top',
                                    verticalAlign: 'middle',
                                    align: 'center'
                                }
                            },
                            emphasis: {
                                focus: 'descendant'
                            },
                            expandAndCollapse: true
                        }]
                    });

                    treeChart.on('dblclick', function (params) {
                        if (params.data && params.data.path) {
                            window.location.href = '/categories/' + params.data.path;
                        }
                    });
                }
            });
        </script>
    
    <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"react":{"opacity":0.7},"log":false});</script></body></html>