<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>workqueue | wdfk-prog的个人博客</title><meta name="author" content="Liya Huang"><meta name="copyright" content="Liya Huang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[TOC] kernel&#x2F;workqueue.c 内核工作队列(Kernel Workqueues) 通用的内核后台任务处理框架历史与背景这项技术是为了解决什么特定 “问题而诞生的？kernel&#x2F;workqueue.c 实现了**工作队列（Workqueues）**机制，它的诞生是为了解决内核中一个极其普遍的需求：将一个函数的执行推迟（defer）到一个安全的进程上下文中去完成，特别是在">
<meta property="og:type" content="article">
<meta property="og:title" content="workqueue">
<meta property="og:url" content="https://wdfk-prog.space/posts/db1bbe40/index.html">
<meta property="og:site_name" content="wdfk-prog的个人博客">
<meta property="og:description" content="[TOC] kernel&#x2F;workqueue.c 内核工作队列(Kernel Workqueues) 通用的内核后台任务处理框架历史与背景这项技术是为了解决什么特定 “问题而诞生的？kernel&#x2F;workqueue.c 实现了**工作队列（Workqueues）**机制，它的诞生是为了解决内核中一个极其普遍的需求：将一个函数的执行推迟（defer）到一个安全的进程上下文中去完成，特别是在">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wdfk-prog.space/images/covers/02.jpg">
<meta property="article:published_time" content="2025-10-03T01:01:49.000Z">
<meta property="article:modified_time" content="2025-10-03T09:23:28.905Z">
<meta property="article:author" content="Liya Huang">
<meta property="article:tag" content="kernel">
<meta property="article:tag" content="linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wdfk-prog.space/images/covers/02.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "workqueue",
  "url": "https://wdfk-prog.space/posts/db1bbe40/",
  "image": "https://wdfk-prog.space/images/covers/02.jpg",
  "datePublished": "2025-10-03T01:01:49.000Z",
  "dateModified": "2025-10-03T09:23:28.905Z",
  "author": [
    {
      "@type": "Person",
      "name": "Liya Huang",
      "url": "https://github.com/wdfk-prog"
    }
  ]
}</script><link rel="shortcut icon" href="/images/favicon.png"><link rel="canonical" href="https://wdfk-prog.space/posts/db1bbe40/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//static.cloudflareinsights.com"/><link rel="preconnect" href="//www.clarity.ms"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxxxxx"/><meta name="baidu-site-verification" content="xxxxxxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-3978542742563797',
  enable_page_level_ads: 'true'
});</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?3c49dd4913ab43efb1bfc8d12b1cded9";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-PF2CVP2PL4"></script><script>window.dataLayer = window.dataLayer || []
function gtag(){dataLayer.push(arguments)}
gtag('js', new Date())
gtag('config', 'G-PF2CVP2PL4')
btf.addGlobalFn('pjaxComplete', () => {
  gtag('config', 'G-PF2CVP2PL4', {'page_path': window.location.pathname})
}, 'google_analytics')
</script><script defer="defer" data-pjax="data-pjax" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;17ff914b5e28493597b7dc19f3356022&quot;}"></script><script>(function(c,l,a,r,i,t,y){
    c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
    t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
    y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
})(window, document, "clarity", "script", "tkaenn1tjv");
</script><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
"https://www.googletagmanager.com/gtm.js?id="+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-MF3J339H');
btf.addGlobalFn('pjaxComplete', () => {
  dataLayer.push({'event': 'pjaxComplete', 'page_title': document.title, 'page_location': location.href, 'page_path': window.location.pathname})
}, 'google_tag_manager')</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":false,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'workqueue',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.0.0"><link rel="alternate" href="/atom.xml" title="wdfk-prog的个人博客" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (true) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(/images/subtle-texture.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/avatar.png" onerror="this.onerror=null;this.src='/images/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">417</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">49</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">53</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book-open"></i><span> 页面</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fas fa-quote-left"></i><span> 说说</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 示例</span></a></li></ul></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/songs/"><i class="fa-fw fas fa-music"></i><span> 歌曲</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/images/covers/02.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/my-logo.png" alt="Logo"><span class="site-name">wdfk-prog的个人博客</span></a><a class="nav-page-title" href="/"><span class="site-name">workqueue</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book-open"></i><span> 页面</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fas fa-quote-left"></i><span> 说说</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 示例</span></a></li></ul></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/songs/"><i class="fa-fw fas fa-music"></i><span> 歌曲</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">workqueue<a class="post-edit-link" href="null_posts/linux/kernel/workqueue.md" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-10-03T01:01:49.000Z" title="发表于 2025-10-03 09:01:49">2025-10-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-03T09:23:28.905Z" title="更新于 2025-10-03 17:23:28">2025-10-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/linux/">linux</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/linux/kernel/">kernel</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">30.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>116分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/db1bbe40/#post-comment"><span class="gitalk-comment-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;已经过了&quot;,&quot;messageNext&quot;:&quot;自上次更新以来，文章的内容可能已经过时&quot;,&quot;postUpdate&quot;:&quot;2025-10-03 17:23:28&quot;}" hidden></div><p>[TOC]</p>
<h1 id="kernel-workqueue-c-内核工作队列-Kernel-Workqueues-通用的内核后台任务处理框架"><a href="#kernel-workqueue-c-内核工作队列-Kernel-Workqueues-通用的内核后台任务处理框架" class="headerlink" title="kernel&#x2F;workqueue.c 内核工作队列(Kernel Workqueues) 通用的内核后台任务处理框架"></a>kernel&#x2F;workqueue.c 内核工作队列(Kernel Workqueues) 通用的内核后台任务处理框架</h1><h3 id="历史与背景"><a href="#历史与背景" class="headerlink" title="历史与背景"></a>历史与背景</h3><h4 id="这项技术是为了解决什么特定-“问题而诞生的？"><a href="#这项技术是为了解决什么特定-“问题而诞生的？" class="headerlink" title="这项技术是为了解决什么特定 “问题而诞生的？"></a>这项技术是为了解决什么特定 “问题而诞生的？</h4><p><code>kernel/workqueue.c</code> 实现了**工作队列（Workqueues）**机制，它的诞生是为了解决内核中一个极其普遍的需求：<strong>将一个函数的执行推迟（defer）到一个安全的进程上下文中去完成，特别是在中断处理程序中。</strong></p>
<p>在内核中，代码的执行上下文非常重要，主要分为两种：</p>
<ol>
<li><strong>进程上下文（Process Context）</strong>：代码代表一个特定的进程（或内核线程）在运行。在这种上下文中，代码可以做任何可能导致**睡眠（blocking&#x2F;sleep）**的操作，例如：获取互斥锁（<code>mutex</code>）、分配大块内存（<code>kmalloc(GFP_KERNEL)</code>）、与用户空间拷贝数据、执行磁盘I&#x2F;O等。</li>
<li><strong>中断上下文（Interrupt Context）</strong>：代码是作为对一个硬件中断的响应而运行的。中断处理程序必须<strong>尽快</strong>完成，并且<strong>绝对不能睡眠</strong>。如果它睡眠了，可能会导致整个系统死锁或错过其他重要的硬件中断。</li>
</ol>
<p>这就产生了一个经典问题：一个中断处理程序（例如，网卡驱动的中断处理函数在收到一个数据包后）可能需要执行一些复杂且耗时的操作，其中某些操作还可能会睡眠。它显然不能在中断上下文中直接完成这些工作。</p>
<p>工作队列就是为了解决这个问题而设计的<strong>通用“下半部”（bottom-half）处理机制</strong>。它允许中断处理程序（或其他任何不能睡眠的代码）将一个需要睡眠或耗时较长的工作任务，“排队”给一个在安全的进程上下文中运行的<strong>内核线程</strong>去执行。</p>
<h4 id="它的发展经历了哪些重要的里程碑或版本迭代？"><a href="#它的发展经历了哪些重要的里程碑或版本迭代？" class="headerlink" title="它的发展经历了哪些重要的里程碑或版本迭代？"></a>它的发展经历了哪些重要的里程碑或版本迭代？</h4><p>工作队列是内核中演进最复杂的子系统之一，其核心驱动力是<strong>性能、并发性和易用性</strong>。</p>
<ul>
<li><strong>早期实现 (基于<code>keventd</code>)</strong>：最初，内核有一个全局的事件守护进程<code>keventd</code>，所有模块都将工作排队给它。这非常简单，但也存在严重问题：所有工作都在一个单独的线程中串行执行，一个耗时的工作会阻塞所有其他工作；同时也无法很好地利用多核CPU的优势。</li>
<li><strong>引入Per-CPU工作线程</strong>：为了提高并发性，工作队列模型演变为为每个CPU核心都创建一组工作者线程（worker threads）。这使得工作可以在多个CPU上并行执行，是一个巨大的进步。</li>
<li><strong>并发管理工作队列 (Concurrency-Managed Workqueues, CMWQ)</strong>：这是由Tejun Heo主导的一次<strong>革命性的重构</strong>。CMWQ在Linux 3.x内核中被引入，它彻底改变了工作队列的实现。CMWQ的目标是<strong>动态地、按需地</strong>管理工作者线程的数量，而不是为每个工作队列都创建固定的线程。它通过一个复杂的池化和调度算法，在提供高并发性的同时，极大地减少了系统中不必要的内核线程数量，从而降低了内存消耗和调度开销。这是当前工作队列的实现基础。</li>
</ul>
<h4 id="目前该技术的社区活跃度和主流应用情况如何？"><a href="#目前该技术的社区活跃度和主流应用情况如何？" class="headerlink" title="目前该技术的社区活跃度和主流应用情况如何？"></a>目前该技术的社区活跃度和主流应用情况如何？</h4><p>工作队列是Linux内核中<strong>最基础、使用最广泛的异步执行机制</strong>，没有之一。</p>
<ul>
<li><strong>主流应用</strong>：几乎内核的每一个子系统都在使用工作队列。<ul>
<li><strong>设备驱动</strong>：绝大多数驱动的中断处理下半部。</li>
<li><strong>文件系统</strong>：执行延迟写入（writeback）、日志提交等。</li>
<li><strong>网络</strong>：处理一些复杂的协议栈任务。</li>
<li><strong>RCU</strong>：<code>call_rcu()</code>的回调函数通常就是通过一个工作队列来执行的。</li>
</ul>
</li>
</ul>
<h3 id="核心原理与设计"><a href="#核心原理与设计" class="headerlink" title="核心原理与设计"></a>核心原理与设计</h3><h4 id="它的核心工作原理是什么？"><a href="#它的核心工作原理是什么？" class="headerlink" title="它的核心工作原理是什么？"></a>它的核心工作原理是什么？</h4><p>现代工作队列（CMWQ）的核心是一个<strong>动态的、per-CPU的工作者线程池（worker pool）</strong>。</p>
<ol>
<li><p><strong>核心数据结构</strong>：</p>
<ul>
<li><strong><code>struct work_struct</code></strong>：这是开发者使用的基本单元。它只包含一个指向要执行的函数（<code>func</code>）的指针和一个用于链接的数据域。</li>
<li><strong><code>struct workqueue_struct</code></strong>：代表一个工作队列。开发者可以创建自己的工作队列，以获得特定的属性（如高优先级、非绑定等）。</li>
<li><strong><code>worker_pool</code></strong>：这是CMWQ的核心。它管理着一组工作者线程和排队等待执行的工作。</li>
</ul>
</li>
<li><p><strong>工作流程</strong>：</p>
<ul>
<li><strong>初始化工作 (INIT_WORK)</strong>：开发者在自己的数据结构中嵌入一个<code>work_struct</code>，并使用<code>INIT_WORK</code>宏将其与一个回调函数关联起来。</li>
<li><strong>排队工作 (queue_work)</strong>：<br>a. 当一个事件发生时（例如，在中断处理程序中），代码调用<code>queue_work(wq, work)</code>。<code>wq</code>是要使用的<code>workqueue_struct</code>，<code>work</code>是要排队的工作。<br>b. 内核会找到与该工作队列关联的<strong>工作者池（worker pool）</strong>。<br>c. 工作（<code>work</code>）会被添加到该池的<strong>待处理工作链表</strong>中。<br>d. 排队操作会确保池中至少有一个<strong>空闲的（idle）工作者线程</strong>被唤醒。</li>
<li><strong>执行工作 (由工作者线程完成)</strong>：<br>a. 被唤醒的工作者线程（是一个名为<code>kworker/uX:Y</code>的内核线程）开始运行。<br>b. 它会从自己所属的池的待处理链表中取出工作。<br>c. 然后，它直接调用该工作关联的回调函数（<code>work-&gt;func</code>）。<br>d. 因为工作者线程是在<strong>进程上下文</strong>中运行的，所以这个回调函数可以安全地执行任何可能睡眠的操作。<br>e. 执行完一个工作后，线程会再次检查链表中是否还有更多工作。如果有，就继续执行；如果没有，它就会把自己标记为空闲，并可能在一段时间后进入睡眠。</li>
</ul>
</li>
<li><p><strong>CMWQ的动态管理</strong>：</p>
<ul>
<li>CMWQ会持续监控每个池的负载情况。如果一个池中的工作大量堆积，而所有工作者线程都在忙碌（例如，都在睡眠等待I&#x2F;O），CMWQ会自动创建<strong>新的</strong>工作者线程加入到这个池中，以提高并发度。</li>
<li>反之，如果一个池中的工作者线程长时间处于空闲状态，CMWQ会自动销毁它们，以回收资源。</li>
</ul>
</li>
</ol>
<h4 id="它的主要优势体现在哪些方面？"><a href="#它的主要优势体现在哪些方面？" class="headerlink" title="它的主要优势体现在哪些方面？"></a>它的主要优势体现在哪些方面？</h4><ul>
<li><strong>上下文安全</strong>：完美地解决了在中断上下文中执行睡眠操作的问题。</li>
<li><strong>简单易用</strong>：为内核开发者提供了一个极其简单的API（<code>INIT_WORK</code>, <code>queue_work</code>）来利用复杂的后台处理能力。</li>
<li><strong>高效与并发</strong>：CMWQ的动态线程池管理提供了出色的性能和并发性，同时又避免了不必要的资源浪费。</li>
<li><strong>通用性</strong>：是一个高度通用的框架，可被任何需要后台处理的内核子系统使用。</li>
</ul>
<h4 id="它存在哪些已知的劣势、局限性或在特定场景下的不适用性？"><a href="#它存在哪些已知的劣势、局限性或在特定场景下的不适用性？" class="headerlink" title="它存在哪些已知的劣势、局限性或在特定场景下的不适用性？"></a>它存在哪些已知的劣势、局限性或在特定场景下的不适用性？</h4><ul>
<li><strong>延迟</strong>：从工作被排队到它真正开始执行，中间存在一定的调度延迟。因此，工作队列不适合用于有严格、低延迟时间要求的“硬实时”任务。</li>
<li>-<strong>非时间确定性</strong>：一个工作的执行可能会被其他更高优先级的进程或同一池中的其他工作所延迟，其执行时间点是不保证的。</li>
<li><strong>资源消耗</strong>：虽然CMWQ已经很高效，但内核线程本身仍然是内核中的一种资源，大量的后台工作仍然会消耗CPU时间和内存。</li>
</ul>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><h4 id="在哪些具体的业务或技术场景下，它是首选解决方案？"><a href="#在哪些具体的业务或技术场景下，它是首选解决方案？" class="headerlink" title="在哪些具体的业务或技术场景下，它是首选解决方案？"></a>在哪些具体的业务或技术场景下，它是首选解决方案？</h4><p>工作队列是<strong>从原子上下文（如中断、持有自旋锁）中推迟可能睡眠或耗时较长的工作</strong>的首选解决方案。</p>
<ul>
<li><strong>中断处理下半部</strong>：一个网卡驱动的中断处理程序（上半部）在收到数据包后，可能会快速地确认中断、从硬件DMA缓冲区中取出数据，然后调用<code>queue_work()</code>来安排一个工作，由该工作在进程上下文中去处理复杂的协议栈逻辑。</li>
<li><strong>延迟的I&#x2F;O操作</strong>：一个文件系统在需要将脏数据写回磁盘时，不会在系统调用路径上同步等待I&#x2F;O完成，而是创建一个工作来异步地执行写操作。</li>
<li><strong>驱动中的复杂状态机</strong>：一个USB驱动在处理设备枚举或状态变更时，涉及多个步骤，其中一些可能需要睡眠。这些通常都是通过工作队列来驱动的。</li>
</ul>
<h4 id="是否有不推荐使用该技术的场景？为什么？"><a href="#是否有不推荐使用该技术的场景？为什么？" class="headerlink" title="是否有不推荐使用该技术的场景？为什么？"></a>是否有不推荐使用该技术的场景？为什么？</h4><ul>
<li><strong>硬实时任务</strong>：如果一个任务必须在事件发生后的几百微秒内被处理，使用工作队列是不合适的，因为其调度延迟不可预测。这种场景可能需要使用线程化中断（threaded IRQs）。</li>
<li><strong>极简、高性能的下半部</strong>：如果下半部的工作非常简单，保证不会睡眠，且对延迟要求较高，那么使用开销更低的<strong>Tasklets</strong>或<strong>Softirqs</strong>可能会更合适。然而，由于工作队列的易用性和安全性，现在内核社区更倾向于优先使用工作队列。</li>
</ul>
<h3 id="对比分析"><a href="#对比分析" class="headerlink" title="对比分析"></a>对比分析</h3><h4 id="请将其-与-其他相似技术-进行详细对比。"><a href="#请将其-与-其他相似技术-进行详细对比。" class="headerlink" title="请将其 与 其他相似技术 进行详细对比。"></a>请将其 与 其他相似技术 进行详细对比。</h4><p>在Linux内核中，有多种“下半部”处理机制，它们在性能、复杂性和使用限制上各不相同。</p>
<p>| 特性 | 工作队列 (Workqueues) | Tasklets | Softirqs (软中断) |<br>| :— | :— | :— | :— | :— |<br>| <strong>执行上下文</strong> | <strong>进程上下文</strong> | <strong>软中断上下文</strong> | <strong>软中断上下文</strong> |<br>| <strong>是否可睡眠</strong> | <strong>是</strong> | <strong>否</strong> | <strong>否</strong> |<br>| <strong>并发模型</strong> | <strong>并发</strong>。工作可以在不同CPU上的不同内核线程中并行执行。 | <strong>串行</strong>。同一个tasklet在同一时间只能在一个CPU上运行。 | <strong>并发</strong>。同一个软中断的处理函数可以在多个CPU上同时运行（需要处理函数自身是可重入的）。 |<br>| <strong>性能&#x2F;延迟</strong> | <strong>较低&#x2F;延迟较高</strong>。涉及线程调度。 | <strong>较高&#x2F;延迟较低</strong>。 | <strong>最高&#x2F;延迟最低</strong>。是性能最高的机制。 |<br>| <strong>使用复杂度</strong> | <strong>简单</strong>。API直观，无需担心睡眠问题。 | <strong>中等</strong>。API简单，但不能睡眠。 | <strong>复杂</strong>。需要静态编译时定义，且处理函数必须是高度优化的可重入代码。 |<br>| <strong>适用场景</strong> | <strong>通用的、需要睡眠或耗时较长的</strong>下半部处理。 | 延迟敏感、不睡眠、相对简单的下半部。 | 性能极其敏感的核心子系统，如网络包接收和定时器处理。 |</p>
<h1 id="include-linux-workqueue-h"><a href="#include-linux-workqueue-h" class="headerlink" title="include&#x2F;linux&#x2F;workqueue.h"></a>include&#x2F;linux&#x2F;workqueue.h</h1><h2 id="INIT-WORK"><a href="#INIT-WORK" class="headerlink" title="INIT_WORK"></a>INIT_WORK</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * initialize all of a work item in one go</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * NOTE! No point in using &quot;atomic_long_set()&quot;: using a direct</span></span><br><span class="line"><span class="comment"> * assignment of the work data initializer allows the compiler</span></span><br><span class="line"><span class="comment"> * to generate better code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __INIT_WORK_KEY(_work, _func, _onstack, _key)			\</span></span><br><span class="line"><span class="meta">	do &#123;								\</span></span><br><span class="line"><span class="meta">		__init_work((_work), _onstack);				\</span></span><br><span class="line"><span class="meta">		(_work)-&gt;data = (atomic_long_t) WORK_DATA_INIT();	\</span></span><br><span class="line"><span class="meta">		INIT_LIST_HEAD(&amp;(_work)-&gt;entry);			\</span></span><br><span class="line"><span class="meta">		(_work)-&gt;func = (_func);				\</span></span><br><span class="line"><span class="meta">	&#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __INIT_WORK(_work, _func, _onstack)				\</span></span><br><span class="line"><span class="meta">	do &#123;								\</span></span><br><span class="line"><span class="meta">		static __maybe_unused struct lock_class_key __key;	\</span></span><br><span class="line"><span class="meta">									\</span></span><br><span class="line"><span class="meta">		__INIT_WORK_KEY(_work, _func, _onstack, &amp;__key);	\</span></span><br><span class="line"><span class="meta">	&#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_WORK(_work, _func)						\</span></span><br><span class="line"><span class="meta">	__INIT_WORK((_work), (_func), 0)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="queue-delayed-work-延迟后对-workqueue-上的工作进行排队"><a href="#queue-delayed-work-延迟后对-workqueue-上的工作进行排队" class="headerlink" title="queue_delayed_work 延迟后对 workqueue 上的工作进行排队"></a>queue_delayed_work 延迟后对 workqueue 上的工作进行排队</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * queue_delayed_work - 延迟后对 workqueue 上的工作进行排队</span></span><br><span class="line"><span class="comment"> * @wq：要使用的 workqueue</span></span><br><span class="line"><span class="comment"> * @dwork：可延迟排队的工作</span></span><br><span class="line"><span class="comment"> * @delay：排队前要等待的 jiffies 数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 等效于 queue_delayed_work_on（），但尝试使用本地 CPU。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">queue_delayed_work</span><span class="params">(<span class="keyword">struct</span> workqueue_struct *wq,</span></span><br><span class="line"><span class="params">				      <span class="keyword">struct</span> delayed_work *dwork,</span></span><br><span class="line"><span class="params">				      <span class="type">unsigned</span> <span class="type">long</span> delay)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> queue_delayed_work_on(WORK_CPU_UNBOUND, wq, dwork, delay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="kernel-workqueue-internal-h"><a href="#kernel-workqueue-internal-h" class="headerlink" title="kernel&#x2F;workqueue_internal.h"></a>kernel&#x2F;workqueue_internal.h</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * current_wq_worker - 如果 %current 是 workqueue worker，则返回 struct worker</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> worker *<span class="title function_">current_wq_worker</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 判断当前上下文是否属于任务线程 </span></span><br><span class="line"><span class="comment">	 *  检查当前线程的标志位是否包含 PF_WQ_WORKER。该标志位表示线程是工作队列的工作线程</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">if</span> (in_task() &amp;&amp; (current-&gt;flags &amp; PF_WQ_WORKER))</span><br><span class="line">		<span class="comment">/* 	通过 kthread_data(current) 获取该线程的私有数据。</span></span><br><span class="line"><span class="comment">			对于工作队列的工作线程，这个私有数据通常是一个 struct worker，</span></span><br><span class="line"><span class="comment">			它包含了工作线程的相关信息 */</span></span><br><span class="line">		<span class="keyword">return</span> kthread_data(current);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="kernel-workqueue-c"><a href="#kernel-workqueue-c" class="headerlink" title="kernel&#x2F;workqueue.c"></a>kernel&#x2F;workqueue.c</h1><h2 id="init-cpu-worker-pool-初始化-CPU-工作池"><a href="#init-cpu-worker-pool-初始化-CPU-工作池" class="headerlink" title="init_cpu_worker_pool 初始化 CPU 工作池"></a>init_cpu_worker_pool 初始化 CPU 工作池</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * init_worker_pool - 初始化一个新的 zalloc worker_pool</span></span><br><span class="line"><span class="comment"> * @pool：worker_pool初始化</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 初始化新 zalloc 的 @pool。 它还分配 @pool-&gt;attrs。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回：成功时为 0，失败时为 -errno。 即使在失败时，@pool 中的所有字段都会被初始化，并且可以安全地在 @pool 上调用 put_unbound_pool（） 来释放它。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">init_worker_pool</span><span class="params">(<span class="keyword">struct</span> worker_pool *pool)</span></span><br><span class="line">&#123;</span><br><span class="line">	raw_spin_lock_init(&amp;pool-&gt;lock);</span><br><span class="line">	pool-&gt;id = <span class="number">-1</span>;</span><br><span class="line">	pool-&gt;cpu = <span class="number">-1</span>;</span><br><span class="line">	pool-&gt;node = NUMA_NO_NODE;</span><br><span class="line">    <span class="comment">/* 设置工作池为非关联状态，通常用于非绑定工作队列。 */</span></span><br><span class="line">	pool-&gt;flags |= POOL_DISASSOCIATED;</span><br><span class="line">    <span class="comment">/* 初始化工作池的看门狗时间戳，用于监控工作池的状态 */</span></span><br><span class="line">	pool-&gt;watchdog_ts = jiffies;</span><br><span class="line">	INIT_LIST_HEAD(&amp;pool-&gt;worklist);</span><br><span class="line">	INIT_LIST_HEAD(&amp;pool-&gt;idle_list);</span><br><span class="line">	hash_init(pool-&gt;busy_hash);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置一个可延迟的定时器，用于处理空闲线程的超时。 */</span></span><br><span class="line">	timer_setup(&amp;pool-&gt;idle_timer, idle_worker_timeout, TIMER_DEFERRABLE);</span><br><span class="line">    <span class="comment">/* 初始化一个工作项，用于清理空闲线程 */</span></span><br><span class="line">	INIT_WORK(&amp;pool-&gt;idle_cull_work, idle_cull_fn);</span><br><span class="line">    <span class="comment">/* 设置一个定时器，用于在工作池需要帮助时发出 &quot;Mayday&quot; 信号 */</span></span><br><span class="line">	timer_setup(&amp;pool-&gt;mayday_timer, pool_mayday_timeout, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	INIT_LIST_HEAD(&amp;pool-&gt;workers);     <span class="comment">/* 初始化工作池的工作线程链表 */</span></span><br><span class="line"></span><br><span class="line">	ida_init(&amp;pool-&gt;worker_ida);        <span class="comment">/* 初始化 ID 分配器，用于分配工作线程的唯一 ID */</span></span><br><span class="line">	INIT_HLIST_NODE(&amp;pool-&gt;hash_node);  <span class="comment">/* 初始化工作池的哈希节点，用于将其插入全局哈希表 */</span></span><br><span class="line">	pool-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* shouldn&#x27;t fail above this point */</span></span><br><span class="line">	pool-&gt;attrs = alloc_workqueue_attrs();</span><br><span class="line">	<span class="keyword">if</span> (!pool-&gt;attrs)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	wqattrs_clear_for_pool(pool-&gt;attrs);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __init <span class="title function_">init_cpu_worker_pool</span><span class="params">(<span class="keyword">struct</span> worker_pool *pool, <span class="type">int</span> cpu, <span class="type">int</span> nice)</span></span><br><span class="line">&#123;</span><br><span class="line">	BUG_ON(init_worker_pool(pool));</span><br><span class="line">	pool-&gt;cpu = cpu;</span><br><span class="line">    <span class="comment">/* 将目标 CPU 的掩码复制到工作池的属性中，表示该工作池只能在指定的 CPU 上运行 */</span></span><br><span class="line">	cpumask_copy(pool-&gt;attrs-&gt;cpumask, cpumask_of(cpu));</span><br><span class="line">	cpumask_copy(pool-&gt;attrs-&gt;__pod_cpumask, cpumask_of(cpu));</span><br><span class="line">	pool-&gt;attrs-&gt;nice = nice;</span><br><span class="line">    <span class="comment">/* 设置工作池的严格亲和性（strict affinity），确保任务只能在绑定的 CPU 上运行 */</span></span><br><span class="line">	pool-&gt;attrs-&gt;affn_strict = <span class="literal">true</span>;</span><br><span class="line">	pool-&gt;node = cpu_to_node(cpu);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* alloc pool ID */</span></span><br><span class="line">	mutex_lock(&amp;wq_pool_mutex);</span><br><span class="line">	BUG_ON(worker_pool_assign_id(pool));</span><br><span class="line">	mutex_unlock(&amp;wq_pool_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="init-pwq-初始化-pwq"><a href="#init-pwq-初始化-pwq" class="headerlink" title="init_pwq 初始化 pwq"></a>init_pwq 初始化 pwq</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* initialize newly allocated @pwq which is associated with @wq and @pool */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">init_pwq</span><span class="params">(<span class="keyword">struct</span> pool_workqueue *pwq, <span class="keyword">struct</span> workqueue_struct *wq,</span></span><br><span class="line"><span class="params">		     <span class="keyword">struct</span> worker_pool *pool)</span></span><br><span class="line">&#123;</span><br><span class="line">	BUG_ON((<span class="type">unsigned</span> <span class="type">long</span>)pwq &amp; ~WORK_STRUCT_PWQ_MASK);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(pwq, <span class="number">0</span>, <span class="keyword">sizeof</span>(*pwq));</span><br><span class="line"></span><br><span class="line">	pwq-&gt;pool = pool;</span><br><span class="line">	pwq-&gt;wq = wq;</span><br><span class="line">	pwq-&gt;flush_color = <span class="number">-1</span>;</span><br><span class="line">	pwq-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line">	INIT_LIST_HEAD(&amp;pwq-&gt;inactive_works);</span><br><span class="line">	INIT_LIST_HEAD(&amp;pwq-&gt;pending_node);</span><br><span class="line">	INIT_LIST_HEAD(&amp;pwq-&gt;pwqs_node);</span><br><span class="line">	INIT_LIST_HEAD(&amp;pwq-&gt;mayday_node);</span><br><span class="line">	kthread_init_work(&amp;pwq-&gt;release_work, pwq_release_workfn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="wq-cpumask-show-显示CPU掩码的核心实现函数"><a href="#wq-cpumask-show-显示CPU掩码的核心实现函数" class="headerlink" title="__wq_cpumask_show: 显示CPU掩码的核心实现函数"></a><code>__wq_cpumask_show</code>: 显示CPU掩码的核心实现函数</h2><p>这个内部静态函数是所有只读 <code>_show</code> 函数的核心。它接收一个<code>cpumask</code>变量, 并将其格式化为人类可读的字符串, 然后放入用户的缓冲区。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这是一个内部静态函数, 负责将一个给定的CPU掩码格式化并写入到缓冲区 buf 中.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @dev:   指向 struct device 的指针. 在此上下文中, 它代表/sys/devices/virtual/workqueue设备.</span></span><br><span class="line"><span class="comment"> * @attr:  指向 struct device_attribute 的指针, 描述了被访问的 sysfs 属性 (文件).</span></span><br><span class="line"><span class="comment"> * @buf:   一个字符数组 (缓冲区), 用于存放格式化后的输出字符串, 这个字符串将展示给用户.</span></span><br><span class="line"><span class="comment"> * @mask:  一个 cpumask_var_t 类型的变量, 这就是要被显示的目标CPU掩码.</span></span><br><span class="line"><span class="comment"> * @return: 返回写入缓冲区的字节数, 或者一个负值的错误码.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> __wq_cpumask_show(<span class="keyword">struct</span> device *dev,</span><br><span class="line">		<span class="keyword">struct</span> device_attribute *attr, <span class="type">char</span> *buf, <span class="type">cpumask_var_t</span> mask)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 定义一个整型变量 written, 用于存储 scnprintf 函数的返回值 (即写入的字节数).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> written;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 对全局的工作队列池互斥锁 wq_pool_mutex 进行加锁.</span></span><br><span class="line"><span class="comment">	 * 即使在单核系统上, 这也是必要的, 以防止在读取 mask 变量时, 发生内核抢占, </span></span><br><span class="line"><span class="comment">	 * 而另一个任务可能会修改这个 mask, 从而导致读取到不一致的数据.</span></span><br><span class="line"><span class="comment">	 * 锁确保了对 mask 变量的访问是原子的.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	mutex_lock(&amp;wq_pool_mutex);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 调用 scnprintf 函数将 mask 的内容格式化成字符串, 并存入 buf.</span></span><br><span class="line"><span class="comment">	 * @ buf: 目标缓冲区.</span></span><br><span class="line"><span class="comment">	 * @ PAGE_SIZE: 缓冲区的最大长度, 防止溢出. PAGE_SIZE 是一个宏, 代表一个内存页的大小.</span></span><br><span class="line"><span class="comment">	 * @ &quot;%*pb\n&quot;: 这是格式化字符串.</span></span><br><span class="line"><span class="comment">	 *   - %pb 是一个内核专用的格式说明符, 用于打印位图(bitmap), 在这里特指CPU掩码.</span></span><br><span class="line"><span class="comment">	 *   - * 表示宽度由参数动态指定.</span></span><br><span class="line"><span class="comment">	 *   - \n 表示在末尾添加一个换行符.</span></span><br><span class="line"><span class="comment">	 * @ cpumask_pr_args(mask): 这是一个宏, 它为 %*pb 提供所需的参数 (掩码指针和长度).</span></span><br><span class="line"><span class="comment">	 * scnprintf 返回实际写入缓冲区的字符数.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	written = scnprintf(buf, PAGE_SIZE, <span class="string">&quot;%*pb\n&quot;</span>, cpumask_pr_args(mask));</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 解锁互斥锁, 允许其他任务访问工作队列池的数据.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	mutex_unlock(&amp;wq_pool_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 返回写入的字节数. 这是 sysfs _show 方法的标准返回值.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> written;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="cpumask-requested-show-DEVICE-ATTR-RO-cpumask-requested-显示-“requested”-CPU掩码"><a href="#cpumask-requested-show-DEVICE-ATTR-RO-cpumask-requested-显示-“requested”-CPU掩码" class="headerlink" title="cpumask_requested_show &amp; DEVICE_ATTR_RO(cpumask_requested): 显示 “requested” CPU掩码"></a><code>cpumask_requested_show</code> &amp; <code>DEVICE_ATTR_RO(cpumask_requested)</code>: 显示 “requested” CPU掩码</h2><p>这个函数和宏组合在一起, 创建了一个名为 <code>cpumask_requested</code> 的只读 <code>sysfs</code> 文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * cpumask_requested_show: sysfs 文件 &#x27;cpumask_requested&#x27; 的读操作处理函数.</span></span><br><span class="line"><span class="comment"> * 当用户执行 &#x27;cat /sys/devices/virtual/workqueue/cpumask_requested&#x27; 时, 此函数会被调用.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cpumask_requested_show</span><span class="params">(<span class="keyword">struct</span> device *dev,</span></span><br><span class="line"><span class="params">		<span class="keyword">struct</span> device_attribute *attr, <span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 此函数直接调用核心实现函数 __wq_cpumask_show,</span></span><br><span class="line"><span class="comment">	 * 并将全局变量 wq_requested_unbound_cpumask 作为要显示的掩码传递给它.</span></span><br><span class="line"><span class="comment">	 * 这个全局变量保存了在系统启动时所请求的非绑定工作队列CPU掩码.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> __wq_cpumask_show(dev, attr, buf, wq_requested_unbound_cpumask);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * DEVICE_ATTR_RO 是一个辅助宏, 用于快速定义一个只读 (Read-Only) 的设备属性.</span></span><br><span class="line"><span class="comment"> * 它会创建一个名为 &#x27;dev_attr_cpumask_requested&#x27; 的 static struct device_attribute 实例,</span></span><br><span class="line"><span class="comment"> * 并将其 .show 回调函数设置为 cpumask_requested_show.</span></span><br><span class="line"><span class="comment"> * 这最终会在 sysfs 中创建一个名为 &#x27;cpumask_requested&#x27; 的只读文件.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">DEVICE_ATTR_RO</span><span class="params">(cpumask_requested)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="cpumask-isolated-show-DEVICE-ATTR-RO-cpumask-isolated-显示-“isolated”-CPU掩码"><a href="#cpumask-isolated-show-DEVICE-ATTR-RO-cpumask-isolated-显示-“isolated”-CPU掩码" class="headerlink" title="cpumask_isolated_show &amp; DEVICE_ATTR_RO(cpumask_isolated): 显示 “isolated” CPU掩码"></a><code>cpumask_isolated_show</code> &amp; <code>DEVICE_ATTR_RO(cpumask_isolated)</code>: 显示 “isolated” CPU掩码</h2><p>这个函数和宏组合在一起, 创建了一个名为 <code>cpumask_isolated</code> 的只读 <code>sysfs</code> 文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * cpumask_isolated_show: sysfs 文件 &#x27;cpumask_isolated&#x27; 的读操作处理函数.</span></span><br><span class="line"><span class="comment"> * 当用户执行 &#x27;cat /sys/devices/virtual/workqueue/cpumask_isolated&#x27; 时, 此函数会被调用.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cpumask_isolated_show</span><span class="params">(<span class="keyword">struct</span> device *dev,</span></span><br><span class="line"><span class="params">		<span class="keyword">struct</span> device_attribute *attr, <span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 此函数直接调用核心实现函数 __wq_cpumask_show,</span></span><br><span class="line"><span class="comment">	 * 并将全局变量 wq_isolated_cpumask 作为要显示的掩码传递给它.</span></span><br><span class="line"><span class="comment">	 * 这个全局变量保存了通过 &#x27;isolcpus&#x27; 内核启动参数设置的被隔离的CPU掩码.</span></span><br><span class="line"><span class="comment">	 * 在单核系统上, 无法隔离CPU, 所以这个掩码通常是空的.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> __wq_cpumask_show(dev, attr, buf, wq_isolated_cpumask);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用 DEVICE_ATTR_RO 宏定义一个名为 &#x27;cpumask_isolated&#x27; 的只读 sysfs 文件.</span></span><br><span class="line"><span class="comment"> * 其 .show 回调函数为 cpumask_isolated_show.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">DEVICE_ATTR_RO</span><span class="params">(cpumask_isolated)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="cpumask-show-cpumask-store-DEVICE-ATTR-RW-cpumask-显示和修改当前的CPU掩码"><a href="#cpumask-show-cpumask-store-DEVICE-ATTR-RW-cpumask-显示和修改当前的CPU掩码" class="headerlink" title="cpumask_show, cpumask_store &amp; DEVICE_ATTR_RW(cpumask): 显示和修改当前的CPU掩码"></a><code>cpumask_show</code>, <code>cpumask_store</code> &amp; <code>DEVICE_ATTR_RW(cpumask)</code>: 显示和修改当前的CPU掩码</h2><p>这组函数和宏创建了一个名为 <code>cpumask</code> 的可读写 <code>sysfs</code> 文件, 这是用户最常交互的文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * cpumask_show: sysfs 文件 &#x27;cpumask&#x27; 的读操作处理函数.</span></span><br><span class="line"><span class="comment"> * 当用户执行 &#x27;cat /sys/devices/virtual/workqueue/cpumask&#x27; 时, 此函数会被调用.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cpumask_show</span><span class="params">(<span class="keyword">struct</span> device *dev,</span></span><br><span class="line"><span class="params">		<span class="keyword">struct</span> device_attribute *attr, <span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 此函数调用核心实现函数 __wq_cpumask_show,</span></span><br><span class="line"><span class="comment">	 * 并将全局变量 wq_unbound_cpumask作为要显示的掩码传递给它.</span></span><br><span class="line"><span class="comment">	 * 这个全局变量代表了当前非绑定工作队列实际生效的CPU掩码.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> __wq_cpumask_show(dev, attr, buf, wq_unbound_cpumask);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * cpumask_store: sysfs 文件 &#x27;cpumask&#x27; 的写操作处理函数.</span></span><br><span class="line"><span class="comment"> * 当用户执行 &#x27;echo &quot;1&quot; &gt; /sys/devices/virtual/workqueue/cpumask&#x27; 时, 此函数会被调用.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @dev:   指向 struct device 的指针.</span></span><br><span class="line"><span class="comment"> * @attr:  指向 struct device_attribute 的指针.</span></span><br><span class="line"><span class="comment"> * @buf:   指向用户写入内容的缓冲区的指针.</span></span><br><span class="line"><span class="comment"> * @count: 写入内容的字节数.</span></span><br><span class="line"><span class="comment"> * @return: 返回已处理的字节数表示成功, 或一个负值的错误码.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cpumask_store</span><span class="params">(<span class="keyword">struct</span> device *dev,</span></span><br><span class="line"><span class="params">		<span class="keyword">struct</span> device_attribute *attr, <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">size_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 定义一个 cpumask_var_t 类型的变量 cpumask. cpumask_var_t 是一种可以动态分配的cpumask.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">cpumask_var_t</span> cpumask;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 定义一个整型变量 ret, 用于存储函数调用的返回值 (错误码).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 尝试为 cpumask 变量分配内存.</span></span><br><span class="line"><span class="comment">	 * @ &amp;cpumask: 指向要被分配内存的变量的指针.</span></span><br><span class="line"><span class="comment">	 * @ GFP_KERNEL: 分配内存的标志, 表示此次分配可以在需要时睡眠(阻塞).</span></span><br><span class="line"><span class="comment">	 * 如果内存分配失败, zalloc_cpumask_var 返回 false.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!zalloc_cpumask_var(&amp;cpumask, GFP_KERNEL))</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 如果分配失败, 返回 -ENOMEM (内存不足) 错误码.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 调用 cpumask_parse 函数, 将用户写入的字符串(buf)解析成内核的cpumask格式.</span></span><br><span class="line"><span class="comment">	 * 例如, 用户写入 &quot;1&quot;, 该函数会设置 cpumask 的第0位.</span></span><br><span class="line"><span class="comment">	 * 如果解析成功, 返回0.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ret = cpumask_parse(buf, cpumask);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 如果前面的解析成功了 (ret == 0).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!ret)</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 调用 workqueue_set_unbound_cpumask 函数, 将新解析出的 cpumask 应用到系统中.</span></span><br><span class="line"><span class="comment">		 * 这个函数会更新全局的 wq_unbound_cpumask, 并调整工作队列线程的亲和性.</span></span><br><span class="line"><span class="comment">		 * 该函数的返回值会赋给 ret.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		ret = workqueue_set_unbound_cpumask(cpumask);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 释放之前为 cpumask 变量动态分配的内存, 防止内存泄漏.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	free_cpumask_var(cpumask);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 这是 sysfs _store 方法的标准返回逻辑.</span></span><br><span class="line"><span class="comment">	 * 如果 ret 不为0 (表示中间有错误发生), 则返回错误码 ret.</span></span><br><span class="line"><span class="comment">	 * 如果 ret 为0 (表示操作成功), 则返回已处理的字节数 count.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> ret ? ret : count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * DEVICE_ATTR_RW 是一个辅助宏, 用于快速定义一个可读写 (Read-Write) 的设备属性.</span></span><br><span class="line"><span class="comment"> * 它会创建一个名为 &#x27;dev_attr_cpumask&#x27; 的实例,</span></span><br><span class="line"><span class="comment"> * 并将其 .show 回调设置为 cpumask_show, .store 回调设置为 cpumask_store.</span></span><br><span class="line"><span class="comment"> * 这最终会在 sysfs 中创建一个名为 &#x27;cpumask&#x27; 的可读写文件.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">DEVICE_ATTR_RW</span><span class="params">(cpumask)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="wq-sysfs-cpumask-attrs-ATTRIBUTE-GROUPS-定义属性组"><a href="#wq-sysfs-cpumask-attrs-ATTRIBUTE-GROUPS-定义属性组" class="headerlink" title="wq_sysfs_cpumask_attrs &amp; ATTRIBUTE_GROUPS: 定义属性组"></a><code>wq_sysfs_cpumask_attrs</code> &amp; <code>ATTRIBUTE_GROUPS</code>: 定义属性组</h2><p>这部分代码将前面定义的所有属性文件打包成一个组, 以便一次性注册。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义一个静态的 struct attribute 指针数组.</span></span><br><span class="line"><span class="comment"> * 这个数组包含了所有我们希望在 sysfs 目录下创建的文件的属性定义.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> *<span class="title">wq_sysfs_cpumask_attrs</span>[] =</span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * &amp;dev_attr_cpumask.attr: &#x27;cpumask&#x27; 文件的属性结构体地址.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	&amp;dev_attr_cpumask.attr,</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * &amp;dev_attr_cpumask_requested.attr: &#x27;cpumask_requested&#x27; 文件的属性结构体地址.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	&amp;dev_attr_cpumask_requested.attr,</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * &amp;dev_attr_cpumask_isolated.attr: &#x27;cpumask_isolated&#x27; 文件的属性结构体地址.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	&amp;dev_attr_cpumask_isolated.attr,</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 数组必须以 NULL 结尾, 作为结束的标记.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="literal">NULL</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ATTRIBUTE_GROUPS 是一个宏, 用于将属性数组包装成一个或多个属性组.</span></span><br><span class="line"><span class="comment"> * 这里我们只定义了一个组, 名为 wq_sysfs_cpumask_groups.</span></span><br><span class="line"><span class="comment"> * 这个组包含了 wq_sysfs_cpumask_attrs 数组中定义的所有属性.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ATTRIBUTE_GROUPS(wq_sysfs_cpumask);</span><br></pre></td></tr></table></figure>

<h2 id="wq-sysfs-init-core-initcall-注册sysfs接口"><a href="#wq-sysfs-init-core-initcall-注册sysfs接口" class="headerlink" title="wq_sysfs_init &amp; core_initcall: 注册sysfs接口"></a><code>wq_sysfs_init</code> &amp; <code>core_initcall</code>: 注册<code>sysfs</code>接口</h2><p>这是最后的初始化函数, 它在内核启动时被调用, 用来完成 <code>sysfs</code> 目录和文件的创建。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * wq_sysfs_init: 工作队列 sysfs 接口的初始化函数.</span></span><br><span class="line"><span class="comment"> * 这是一个静态函数, 标记为 __init, 表示它仅在内核初始化期间使用,</span></span><br><span class="line"><span class="comment"> * 在初始化完成后, 其占用的内存可能会被释放.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">wq_sysfs_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 调用 subsys_virtual_register 函数来注册一个新的虚拟子系统.</span></span><br><span class="line"><span class="comment">	 * @ &amp;wq_subsys: 这是要注册的工作队列子系统.</span></span><br><span class="line"><span class="comment">	 * @ wq_sysfs_cpumask_groups: 这是要在这个子系统下创建的属性组 (即文件集合).</span></span><br><span class="line"><span class="comment">	 * 这个函数调用会在 /sys/devices/virtual/ 目录下创建一个名为 &#x27;workqueue&#x27; 的目录,</span></span><br><span class="line"><span class="comment">	 * 并在该目录中创建 &#x27;cpumask&#x27;, &#x27;cpumask_requested&#x27;, &#x27;cpumask_isolated&#x27; 这三个文件.</span></span><br><span class="line"><span class="comment">	 * 函数返回0表示成功, 负值表示错误.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> subsys_virtual_register(&amp;wq_subsys, wq_sysfs_cpumask_groups);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * core_initcall 是一个宏, 它将 wq_sysfs_init 函数注册为一个核心初始化函数.</span></span><br><span class="line"><span class="comment"> * 这意味着 wq_sysfs_init 会在内核启动过程中的一个较早阶段被调用,</span></span><br><span class="line"><span class="comment"> * 确保这些 sysfs 接口在系统完全启动前就已经可用.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">core_initcall(wq_sysfs_init);</span><br></pre></td></tr></table></figure>

<h2 id="format-worker-id-格式化工作线程-ID"><a href="#format-worker-id-格式化工作线程-ID" class="headerlink" title="format_worker_id 格式化工作线程 ID"></a>format_worker_id 格式化工作线程 ID</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">format_worker_id</span><span class="params">(<span class="type">char</span> *buf, <span class="type">size_t</span> size, <span class="keyword">struct</span> worker *worker,</span></span><br><span class="line"><span class="params">			    <span class="keyword">struct</span> worker_pool *pool)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (worker-&gt;rescue_wq)</span><br><span class="line">		<span class="keyword">return</span> scnprintf(buf, size, <span class="string">&quot;kworker/R-%s&quot;</span>,</span><br><span class="line">				 worker-&gt;rescue_wq-&gt;name);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pool) &#123;</span><br><span class="line">		<span class="keyword">if</span> (pool-&gt;cpu &gt;= <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> scnprintf(buf, size, <span class="string">&quot;kworker/%d:%d%s&quot;</span>,</span><br><span class="line">					 pool-&gt;cpu, worker-&gt;id,</span><br><span class="line">					 pool-&gt;attrs-&gt;nice &lt; <span class="number">0</span>  ? <span class="string">&quot;H&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> scnprintf(buf, size, <span class="string">&quot;kworker/u%d:%d&quot;</span>,</span><br><span class="line">					 pool-&gt;id, worker-&gt;id);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> scnprintf(buf, size, <span class="string">&quot;kworker/dying&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="worker-enter-idle-进入空闲状态"><a href="#worker-enter-idle-进入空闲状态" class="headerlink" title="worker_enter_idle 进入空闲状态"></a>worker_enter_idle 进入空闲状态</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* worker_enter_idle - 进入空闲状态 </span></span><br><span class="line"><span class="comment">* @worker: 正在进入空闲状态的工作者 * </span></span><br><span class="line"><span class="comment">* @worker 正在进入空闲状态。如果有必要，更新统计信息和空闲计时器。 * </span></span><br><span class="line"><span class="comment">* 锁定： * raw_spin_lock_irq(pool-&gt;lock).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">worker_enter_idle</span><span class="params">(<span class="keyword">struct</span> worker *worker)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span> =</span> worker-&gt;pool;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON_ONCE(worker-&gt;flags &amp; WORKER_IDLE) ||</span><br><span class="line">	    WARN_ON_ONCE(!list_empty(&amp;worker-&gt;entry) &amp;&amp;</span><br><span class="line">			 (worker-&gt;hentry.next || worker-&gt;hentry.pprev)))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* can&#x27;t use worker_set_flags(), also called from create_worker() */</span></span><br><span class="line">	worker-&gt;flags |= WORKER_IDLE;</span><br><span class="line">	pool-&gt;nr_idle++;</span><br><span class="line">	worker-&gt;last_active = jiffies;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 空闲列表采用后进先出（LIFO）的方式管理，以便优先复用最近进入空闲状态的线程*/</span></span><br><span class="line">	list_add(&amp;worker-&gt;entry, &amp;pool-&gt;idle_list);</span><br><span class="line">	<span class="comment">/* 检查线程池中的 worker 是否超过需求 	检查空闲计时器是否已激活*/</span></span><br><span class="line">	<span class="keyword">if</span> (too_many_workers(pool) &amp;&amp; !timer_pending(&amp;pool-&gt;idle_timer))</span><br><span class="line">		mod_timer(&amp;pool-&gt;idle_timer, jiffies + IDLE_WORKER_TIMEOUT);	<span class="comment">/* 通过 mod_timer 设置空闲计时器 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Sanity check nr_running. */</span></span><br><span class="line">	WARN_ON_ONCE(pool-&gt;nr_workers == pool-&gt;nr_idle &amp;&amp; pool-&gt;nr_running);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="set-pf-worker-设置当前线程为工作队列工作线程"><a href="#set-pf-worker-设置当前线程为工作队列工作线程" class="headerlink" title="set_pf_worker 设置当前线程为工作队列工作线程"></a>set_pf_worker 设置当前线程为工作队列工作线程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">set_pf_worker</span><span class="params">(<span class="type">bool</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">	mutex_lock(&amp;wq_pool_attach_mutex);</span><br><span class="line">	<span class="keyword">if</span> (val)</span><br><span class="line">		current-&gt;flags |= PF_WQ_WORKER;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		current-&gt;flags &amp;= ~PF_WQ_WORKER;</span><br><span class="line">	mutex_unlock(&amp;wq_pool_attach_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="worker-leave-idle-离开空闲状态"><a href="#worker-leave-idle-离开空闲状态" class="headerlink" title="worker_leave_idle - 离开空闲状态"></a>worker_leave_idle - 离开空闲状态</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * worker_leave_idle - 离开空闲状态</span></span><br><span class="line"><span class="comment"> * @worker: 处于空闲状态的工作者</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @worker 正在离开空闲状态。更新统计信息。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * LOCKING:</span></span><br><span class="line"><span class="comment"> * raw_spin_lock_irq(pool-&gt;lock).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">worker_leave_idle</span><span class="params">(<span class="keyword">struct</span> worker *worker)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span> =</span> worker-&gt;pool;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON_ONCE(!(worker-&gt;flags &amp; WORKER_IDLE)))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	worker_clr_flags(worker, WORKER_IDLE);</span><br><span class="line">	pool-&gt;nr_idle--;</span><br><span class="line">	list_del_init(&amp;worker-&gt;entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="need-more-worker-判断是否需要唤醒或创建更多的工作线程（worker）来处理工作队列中的任务"><a href="#need-more-worker-判断是否需要唤醒或创建更多的工作线程（worker）来处理工作队列中的任务" class="headerlink" title="need_more_worker 判断是否需要唤醒或创建更多的工作线程（worker）来处理工作队列中的任务"></a>need_more_worker 判断是否需要唤醒或创建更多的工作线程（worker）来处理工作队列中的任务</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 需要唤醒一个工作者吗？只能从当前未运行的工作者调用。</span></span><br><span class="line"><span class="comment"> * 请注意，由于无绑定工作者从不对 nr_running 贡献，因此只要工作列表不为空，此函数对于无绑定池将始终返回 %true。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">need_more_worker</span><span class="params">(<span class="keyword">struct</span> worker_pool *pool)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 如果任务队列为空，则不需要更多的工作线程， </span></span><br><span class="line"><span class="comment">	当前正在运行的工作线程数量。如果没有正在运行的线程（pool-&gt;nr_running == 0），</span></span><br><span class="line"><span class="comment">	则返回 true，表示需要唤醒或创建更多的工作线程。*/</span></span><br><span class="line">	<span class="keyword">return</span> !list_empty(&amp;pool-&gt;worklist) &amp;&amp; !pool-&gt;nr_running;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="may-start-working-判断是否可以开始工作"><a href="#may-start-working-判断是否可以开始工作" class="headerlink" title="may_start_working 判断是否可以开始工作"></a>may_start_working 判断是否可以开始工作</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 函数直接返回 pool-&gt;nr_idle 的值。nr_idle 是线程池中当前处于空闲状态的工作线程数量。</span></span><br><span class="line"><span class="comment">如果 nr_idle &gt; 0，表示线程池中有空闲线程，函数返回 true，允许线程开始工作。</span></span><br><span class="line"><span class="comment">如果 nr_idle == 0，表示线程池中没有空闲线程，函数返回 false，不允许线程开始工作。 */</span></span><br><span class="line"><span class="comment">/* Can I start working?  Called from busy but !running workers. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">may_start_working</span><span class="params">(<span class="keyword">struct</span> worker_pool *pool)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> pool-&gt;nr_idle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="wake-up-process-唤醒特定进程"><a href="#wake-up-process-唤醒特定进程" class="headerlink" title="wake_up_process 唤醒特定进程"></a>wake_up_process 唤醒特定进程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * wake_up_process - 唤醒特定进程</span></span><br><span class="line"><span class="comment"> * @p：要唤醒的过程。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 尝试唤醒指定的进程并将其移动到 runnable 的集合中</span></span><br><span class="line"><span class="comment"> *过程。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回：如果进程已唤醒，则为 1，如果进程已在运行，则为 0。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 此函数在访问 task 状态之前执行一个完整的内存屏障。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">wake_up_process</span><span class="params">(<span class="keyword">struct</span> task_struct *p)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> try_to_wake_up(p, TASK_NORMAL, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(wake_up_process);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="worker-thread-工作者线程函数"><a href="#worker-thread-工作者线程函数" class="headerlink" title="worker_thread - 工作者线程函数"></a>worker_thread - 工作者线程函数</h2><ul>
<li>worker_thread是所有工作队列的工作者内核线程（kworker）的主体函数。当一个kworker被创建时，它的入口点就被设置为这个函数。<br>它的核心作用是：在一个无限循环中，不断地从其所属的工作者池（worker_pool）的公共工作链表（pool-&gt;worklist）中取出待处理的工作项（work_struct），并执行它。当没有工作时，它会进入睡眠，直到被唤醒。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * worker_thread - 工作者线程函数</span></span><br><span class="line"><span class="comment"> * @__worker: 指向worker自身的指针</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 工作者线程函数。所有的工作者都属于一个工作者池(worker_pool) ——</span></span><br><span class="line"><span class="comment"> * 要么是一个per-cpu的池，要么是一个动态的非绑定池。这些工作者处理所有</span></span><br><span class="line"><span class="comment"> * 的工作项，无论它们具体的目标工作队列是什么。唯一的例外是那些属于</span></span><br><span class="line"><span class="comment"> * 带有救援线程(rescuer)的工作队列的工作项，这将在rescuer_thread()中解释。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值: 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">worker_thread</span><span class="params">(<span class="type">void</span> *__worker)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* worker: 指向当前工作者自身的worker结构体。*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">worker</span> =</span> __worker;</span><br><span class="line">	<span class="comment">/* pool: 指向该工作者所属的工作者池。*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span> =</span> worker-&gt;pool;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 告诉调度器，这是一个工作队列的工作者线程。*/</span></span><br><span class="line">	set_pf_worker(<span class="literal">true</span>);</span><br><span class="line">woke_up: <span class="comment">/* 这是线程被唤醒后的主循环入口点。*/</span></span><br><span class="line">	<span class="comment">/* 获取保护整个工作者池状态的自旋锁，并禁用中断。*/</span></span><br><span class="line">	raw_spin_lock_irq(&amp;pool-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 我应该死掉吗？*/</span></span><br><span class="line">	<span class="comment">/* 检查WORKER_DIE标志，如果被设置，则线程需要退出。*/</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(worker-&gt;flags &amp; WORKER_DIE)) &#123;</span><br><span class="line">		<span class="comment">/* 释放池锁。*/</span></span><br><span class="line">		raw_spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line">		<span class="comment">/* 清除工作者线程身份标志。*/</span></span><br><span class="line">		set_pf_worker(<span class="literal">false</span>);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 工作者已死，且PF_WQ_WORKER已被清除，不应再访问worker-&gt;pool，</span></span><br><span class="line"><span class="comment">		 * 为以防万一，将其重置为NULL。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		worker-&gt;pool = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="comment">/* 将工作者的ID归还给ID分配器。*/</span></span><br><span class="line">		ida_free(&amp;pool-&gt;worker_ida, worker-&gt;id);</span><br><span class="line">		<span class="comment">/* 线程函数返回，线程生命周期结束。*/</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 调用此函数，将工作者从池的空闲链表中移除，并更新空闲计数。*/</span></span><br><span class="line">	worker_leave_idle(worker);</span><br><span class="line">recheck: <span class="comment">/* 这是一个内部检查点，在状态改变后可能需要重新检查。*/</span></span><br><span class="line">	<span class="comment">/* 不再需要更多的工作者了吗？*/</span></span><br><span class="line">	<span class="keyword">if</span> (!need_more_worker(pool))</span><br><span class="line">		<span class="comment">/* 如果池中活跃的工作者已足够，则跳转到sleep准备睡眠。*/</span></span><br><span class="line">		<span class="keyword">goto</span> sleep;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 我们需要进行管理吗？*/</span></span><br><span class="line">	<span class="comment">/* 如果当前不允许开始工作，并且manage_workers()返回true（表示它进行了一些管理操作），</span></span><br><span class="line"><span class="comment">	 * 则需要重新检查所有条件。*/</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!may_start_working(pool)) &amp;&amp; manage_workers(worker))</span><br><span class="line">		<span class="keyword">goto</span> recheck;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * -&gt;scheduled链表只在一个工作者准备处理或正在处理工作时才能被填充。</span></span><br><span class="line"><span class="comment">	 * 确保在我睡觉的时候，没有人动过它。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/* 这是一个健壮性检查，确保工作者自己的“已调度”链表是空的。*/</span></span><br><span class="line">	WARN_ON_ONCE(!list_empty(&amp;worker-&gt;scheduled));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 完成准备(PREP)阶段。我们保证了至少有一个空闲工作者，或者</span></span><br><span class="line"><span class="comment">	 * 已经有别人承担了管理者的角色。从这里开始，@worker如果适用的话，</span></span><br><span class="line"><span class="comment">	 * 会开始参与并发管理，并且在被重新绑定后，并发管理会恢复。</span></span><br><span class="line"><span class="comment">	 * 详见rebind_workers()。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/* 清除WORKER_PREP和WORKER_REBOUND标志，表示准备工作完成。*/</span></span><br><span class="line">	worker_clr_flags(worker, WORKER_PREP | WORKER_REBOUND);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 进入工作处理循环。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="comment">/* 从池的公共工作链表(pool-&gt;worklist)的头部，获取第一个工作项。*/</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> *<span class="title">work</span> =</span></span><br><span class="line">			list_first_entry(&amp;pool-&gt;worklist,</span><br><span class="line">					 <span class="keyword">struct</span> work_struct, entry);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 调用assign_work将工作项分配给当前工作者，如果成功，</span></span><br><span class="line"><span class="comment">		 * 则调用process_scheduled_works来执行该工作项的回调函数。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (assign_work(work, worker, <span class="literal">NULL</span>))</span><br><span class="line">			process_scheduled_works(worker);</span><br><span class="line">	&#125; <span class="keyword">while</span> (keep_working(pool)); <span class="comment">/* keep_working检查池中是否还有工作且我们应该继续。*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 工作处理循环结束，重新将自己标记为准备状态。*/</span></span><br><span class="line">	worker_set_flags(worker, WORKER_PREP);</span><br><span class="line">sleep:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * pool-&gt;lock被持有，并且没有工作要处理，也不需要进行管理，就睡眠。</span></span><br><span class="line"><span class="comment">	 * 工作者只在持有pool-&gt;lock时或从本地CPU被唤醒，所以在释放pool-&gt;lock</span></span><br><span class="line"><span class="comment">	 * 之前设置当前状态，足以防止丢失任何事件。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/* 调用此函数，将工作者加入池的空闲链表，并更新空闲计数。*/</span></span><br><span class="line">	worker_enter_idle(worker);</span><br><span class="line">	<span class="comment">/* 将任务的调度器状态设置为一个特殊的、不可中断的睡眠状态。*/</span></span><br><span class="line">	__set_current_state(TASK_IDLE);</span><br><span class="line">	<span class="comment">/* 先释放池锁。*/</span></span><br><span class="line">	raw_spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line">	<span class="comment">/* 然后调用调度器，主动放弃CPU。*/</span></span><br><span class="line">	schedule();</span><br><span class="line">	<span class="comment">/* 当被唤醒后，直接跳转到主循环的入口点，开始新一轮的检查和工作。*/</span></span><br><span class="line">	<span class="keyword">goto</span> woke_up;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="create-worker-创建一个新的工作队列工作线程"><a href="#create-worker-创建一个新的工作队列工作线程" class="headerlink" title="create_worker  创建一个新的工作队列工作线程"></a>create_worker  创建一个新的工作队列工作线程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * create_worker - 创建一个新的工作队列工作线程 </span></span><br><span class="line"><span class="comment">* @pool: 新工作线程将属于的池 * </span></span><br><span class="line"><span class="comment">* 创建并启动一个新的工作线程，该线程附加到 @pool。 * </span></span><br><span class="line"><span class="comment">* 上下文: * 可能会休眠。执行 GFP_KERNEL 分配。 * </span></span><br><span class="line"><span class="comment">* 返回: * 指向新创建的工作线程的指针。 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> worker *<span class="title function_">create_worker</span><span class="params">(<span class="keyword">struct</span> worker_pool *pool)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">worker</span>;</span></span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 需要ID来确定kthread名称*/</span></span><br><span class="line">	id = ida_alloc(&amp;pool-&gt;worker_ida, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		pr_err_once(<span class="string">&quot;workqueue: Failed to allocate a worker ID: %pe\n&quot;</span>,</span><br><span class="line">			    ERR_PTR(id));</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	worker = alloc_worker(pool-&gt;node);</span><br><span class="line">	<span class="keyword">if</span> (!worker) &#123;</span><br><span class="line">		pr_err_once(<span class="string">&quot;workqueue: Failed to allocate a worker\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	worker-&gt;id = id;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(pool-&gt;flags &amp; POOL_BH)) &#123;</span><br><span class="line">		<span class="type">char</span> id_buf[WORKER_ID_LEN];</span><br><span class="line">		<span class="comment">/* 使用 format_worker_id 函数生成线程名，并存储到 id_buf 中 */</span></span><br><span class="line">		format_worker_id(id_buf, <span class="keyword">sizeof</span>(id_buf), worker, pool);</span><br><span class="line">		<span class="comment">/* 调用 kthread_create_on_node 创建一个内核线程，线程的入口函数为 worker_thread，参数为 worker */</span></span><br><span class="line">		worker-&gt;task = kthread_create_on_node(worker_thread, worker,</span><br><span class="line">						      pool-&gt;node, <span class="string">&quot;%s&quot;</span>, id_buf);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(worker-&gt;task)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (PTR_ERR(worker-&gt;task) == -EINTR) &#123;</span><br><span class="line">				pr_err(<span class="string">&quot;workqueue: Interrupted when creating a worker thread \&quot;%s\&quot;\n&quot;</span>,</span><br><span class="line">				       id_buf);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				pr_err_once(<span class="string">&quot;workqueue: Failed to create a worker thread: %pe&quot;</span>,</span><br><span class="line">					    worker-&gt;task);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">goto</span> fail;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		set_user_nice(worker-&gt;task, pool-&gt;attrs-&gt;nice);<span class="comment">/* 设置线程优先级 */</span></span><br><span class="line">		kthread_bind_mask(worker-&gt;task, pool_allowed_cpus(pool));	<span class="comment">/* 绑定 CPU */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* successful, attach the worker to the pool */</span></span><br><span class="line">	worker_attach_to_pool(worker, pool);	<span class="comment">/* 新创建的 worker 附加到指定的工作池中 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* start the newly created worker */</span></span><br><span class="line">	raw_spin_lock_irq(&amp;pool-&gt;lock);</span><br><span class="line"></span><br><span class="line">	worker-&gt;pool-&gt;nr_workers++;	<span class="comment">/* 更新 worker 数量 */</span></span><br><span class="line">	worker_enter_idle(worker);	<span class="comment">/* 设置 worker 状态为 idle */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *@worker 正在 kthread() 中等待完成，如果不尽快被唤醒，将触发挂起检查。由于如果 @pool 为空，kick_pool() 是无操作，因此需要显式唤醒它。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (worker-&gt;task)</span><br><span class="line">		wake_up_process(worker-&gt;task);	<span class="comment">/* 如果 worker-&gt;task 不为空，调用 wake_up_process 唤醒线程 */</span></span><br><span class="line"></span><br><span class="line">	raw_spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> worker;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">	ida_free(&amp;pool-&gt;worker_ida, id);</span><br><span class="line">	kfree(worker);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="maybe-create-worker-可能创建一个新的工作线程"><a href="#maybe-create-worker-可能创建一个新的工作线程" class="headerlink" title="maybe_create_worker 可能创建一个新的工作线程"></a>maybe_create_worker 可能创建一个新的工作线程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">- __releases(&amp;pool-&gt;lock)</span><br><span class="line">	这个标记表示函数在执行过程中会释放 pool-&gt;lock 锁。它告诉静态分析工具，在进入函数时，调用者必须已经持有 pool-&gt;lock，并且函数在某些操作中释放该锁。</span><br><span class="line"></span><br><span class="line">- __acquires(&amp;pool-&gt;lock)</span><br><span class="line">	这个标记表示函数在执行过程中会重新获取 pool-&gt;lock 锁。它告诉静态分析工具，函数在退出时会确保重新持有该锁。</span><br><span class="line"></span><br><span class="line">- 作用</span><br><span class="line">	这些标记的主要作用是帮助静态分析工具（如 sparse）验证锁的使用是否正确。例如：</span><br><span class="line"></span><br><span class="line">	确保在调用 maybe_create_worker 之前，调用者已经持有 pool-&gt;lock。</span><br><span class="line">	确保函数在退出时重新获取了 pool-&gt;lock，以避免锁的状态不一致。</span><br><span class="line">```c</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * maybe_create_worker - 如有必要，创建一个新工作者</span></span><br><span class="line"><span class="comment"> * @pool:池以创建一个新的工作者</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果需要，为@pool创建一个新工人。确保@pool在从此函数返回时至少有一个空闲工人。如果创建新工人所需的时间超过MAYDAY_INTERVAL，可能会向所有调度在@pool上的救援者发送求助信号，以解决可能的分配死锁问题。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在返回时，need_to_create_worker() 保证为假，而 may_start_working() 为真。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * LOCKING:</span></span><br><span class="line"><span class="comment"> * raw_spin_lock_irq(pool-&gt;lock) 可能会被多次释放和重新获取。执行 GFP_KERNEL 分配。仅从管理器调用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">maybe_create_worker</span><span class="params">(<span class="keyword">struct</span> worker_pool *pool)</span></span><br><span class="line">__<span class="title function_">releases</span><span class="params">(&amp;pool-&gt;lock)</span></span><br><span class="line">__<span class="title function_">acquires</span><span class="params">(&amp;pool-&gt;lock)</span></span><br><span class="line">&#123;</span><br><span class="line">restart:</span><br><span class="line">	raw_spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 在尝试创建 worker 的过程中，函数启动了一个定时器（mayday_timer），</span></span><br><span class="line"><span class="comment">	如果在 MAYDAY_INITIAL_TIMEOUT 时间内无法创建新的 worker，会触发 &quot;mayday&quot; 信号，</span></span><br><span class="line"><span class="comment">	通知其他救援线程以解决可能的分配死锁 */</span></span><br><span class="line">	<span class="comment">//修改池-&gt;mayday_timer的超时值</span></span><br><span class="line">	mod_timer(&amp;pool-&gt;mayday_timer, jiffies + MAYDAY_INITIAL_TIMEOUT);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (create_worker(pool) || !need_to_create_worker(pool))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">/* 如果线程创建失败，函数会进入一个循环，等待一段时间（CREATE_COOLDOWN），然后再次检查是否需要创建新的 worker。</span></span><br><span class="line"><span class="comment">		这种机制避免了频繁尝试创建线程导致的资源浪费。 */</span></span><br><span class="line">		schedule_timeout_interruptible(CREATE_COOLDOWN);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!need_to_create_worker(pool))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	timer_delete_sync(&amp;pool-&gt;mayday_timer);<span class="comment">//删除定时器</span></span><br><span class="line">	raw_spin_lock_irq(&amp;pool-&gt;lock);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 即使在新工作者刚刚成功创建后，这也是必要的，因为 @pool-&gt;lock 已经被释放，而新的工作者可能已经变得忙碌。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (need_to_create_worker(pool))</span><br><span class="line">		<span class="keyword">goto</span> restart;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="manage-workers-管理工作池"><a href="#manage-workers-管理工作池" class="headerlink" title="manage_workers 管理工作池"></a>manage_workers 管理工作池</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * manage_workers - 管理工作池</span></span><br><span class="line"><span class="comment"> * @worker: self</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 假设经理角色并管理属于@worker的工作人员池。在任何时候，每个池中只能有零个或一个经理。此排除由该功能自动处理。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 调用者可以安全地在假返回上开始处理工作。对于真返回，保证need_to_create_worker()为假，may_start_working()为真。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * CONTEXT:</span></span><br><span class="line"><span class="comment"> * raw_spin_lock_irq(pool-&gt;lock) 可能会被多次释放和重新获取。执行 GFP_KERNEL 分配。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return:</span></span><br><span class="line"><span class="comment"> * 如果池子不需要管理，并且调用者可以安全地开始处理工作，% 如果管理功能被执行，并且调用者在调用函数之前验证的条件可能不再成立，返回true。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">manage_workers</span><span class="params">(<span class="keyword">struct</span> worker *worker)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span> =</span> worker-&gt;pool;</span><br><span class="line">	<span class="comment">/* 如果线程池的标志位 POOL_MANAGER_ACTIVE 已经被设置，说明当前线程池已经有一个管理者在执行管理操作。此时函数直接返回 false，表示无需进一步管理，调用者可以安全地开始处理任务 */</span></span><br><span class="line">	<span class="keyword">if</span> (pool-&gt;flags &amp; POOL_MANAGER_ACTIVE)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">/*	如果没有其他管理者，当前线程将自身标记为管理者：</span></span><br><span class="line"><span class="comment">		设置 POOL_MANAGER_ACTIVE 标志位。</span></span><br><span class="line"><span class="comment">		将 pool-&gt;manager 指向当前线程 */</span></span><br><span class="line">	pool-&gt;flags |= POOL_MANAGER_ACTIVE;</span><br><span class="line">	pool-&gt;manager = worker;</span><br><span class="line">	<span class="comment">/*  调用 maybe_create_worker(pool)，根据线程池的状态决定是否需要创建新的工作线程。这是管理操作的核心部分，用于动态调整线程池的大小以适应任务负载*/</span></span><br><span class="line">	maybe_create_worker(pool);</span><br><span class="line">	<span class="comment">/* 在完成管理操作后，清除管理者标志位并将 pool-&gt;manager 设置为 NULL，表示当前线程不再是管理者 */</span></span><br><span class="line">	pool-&gt;manager = <span class="literal">NULL</span>;</span><br><span class="line">	pool-&gt;flags &amp;= ~POOL_MANAGER_ACTIVE;</span><br><span class="line">	<span class="comment">/* 唤醒可能等待管理者完成的其他线程 */</span></span><br><span class="line">	rcuwait_wake_up(&amp;manager_wait);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="find-worker-executing-work-查找正在执行工作项的工作线程"><a href="#find-worker-executing-work-查找正在执行工作项的工作线程" class="headerlink" title="find_worker_executing_work 查找正在执行工作项的工作线程"></a>find_worker_executing_work 查找正在执行工作项的工作线程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * find_worker_executing_work - 寻找正在执行工作的工人</span></span><br><span class="line"><span class="comment"> * @pool: 兴趣池</span></span><br><span class="line"><span class="comment"> * @work:努力寻找工人</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 通过搜索 @pool-&gt;busy_hash（该哈希表的键是 @work 的地址），找到正在 @pool 中执行 @work 的工作者。为了使工作者匹配，它的当前执行必须与 @work 的地址和它的工作函数相匹配。这是为了避免通过在仍被执行时回收的工作项，导致无关的工作执行之间产生不必要的依赖关系。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这有点棘手。一个工作项在执行开始后可能会被释放，并且没有任何东西阻止被释放的区域被回收用于另一个工作项。如果在原始执行完成之前，同一个工作项的地址被重复使用，工作队列将会将回收的工作项识别为当前正在执行，并使其等待直到当前执行完成，从而引入了一个不必要的依赖。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 此功能检查作业项地址和作业函数，以避免误报。 请注意，这并不完整，因为有人可能构造一个工作函数，通过重复使用的工作项引入对自身的依赖。 好吧，如果有人想要这样自毁，那么我们能做的也有限，如果确实发生这样的死锁，找出罪魁祸首的工作函数应该很容易。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * CONTEXT:</span></span><br><span class="line"><span class="comment"> * raw_spin_lock_irq(pool-&gt;lock).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return:</span></span><br><span class="line"><span class="comment"> *指向正在执行@work的工作者的指针，如果找到则返回，若未找到则返回%NULL.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> worker *<span class="title function_">find_worker_executing_work</span><span class="params">(<span class="keyword">struct</span> worker_pool *pool,</span></span><br><span class="line"><span class="params">						 <span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">worker</span>;</span></span><br><span class="line"></span><br><span class="line">	hash_for_each_possible(pool-&gt;busy_hash, worker, hentry,</span><br><span class="line">			       (<span class="type">unsigned</span> <span class="type">long</span>)work)</span><br><span class="line">		<span class="keyword">if</span> (worker-&gt;current_work == work &amp;&amp;</span><br><span class="line">		    worker-&gt;current_func == work-&gt;func)</span><br><span class="line">			<span class="keyword">return</span> worker;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="move-linked-works-移动关联的工作项"><a href="#move-linked-works-移动关联的工作项" class="headerlink" title="move_linked_works 移动关联的工作项"></a>move_linked_works 移动关联的工作项</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * move_linked_works - 将链接的作品移动到列表中</span></span><br><span class="line"><span class="comment"> * @work: start of series of works to be scheduled</span></span><br><span class="line"><span class="comment"> * @head: target list to append @work to</span></span><br><span class="line"><span class="comment"> * @nextp: out parameter for nested worklist walking</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 调度链接的工作从@work开始到@head。要调度的工作系列从@work开始，包括任何在其前导中设置了WORK_STRUCT_LINKED的连续工作。有关@nextp的详细信息，请参见assign_work()。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * CONTEXT:</span></span><br><span class="line"><span class="comment"> * raw_spin_lock_irq(pool-&gt;lock).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">move_linked_works</span><span class="params">(<span class="keyword">struct</span> work_struct *work, <span class="keyword">struct</span> list_head *head,</span></span><br><span class="line"><span class="params">			      <span class="keyword">struct</span> work_struct **nextp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> *<span class="title">n</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 链接工作列表将始终在列表末尾之前结束，使用 NULL 作为列表头部。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	list_for_each_entry_safe_from(work, n, <span class="literal">NULL</span>, entry) &#123;</span><br><span class="line">		list_move_tail(&amp;work-&gt;entry, head);</span><br><span class="line">		<span class="comment">/* 检查当前工作项的 WORK_STRUCT_LINKED 标志。如果标志未设置，说明当前工作项是链表的末尾，停止遍历 */</span></span><br><span class="line">		<span class="keyword">if</span> (!(*work_data_bits(work) &amp; WORK_STRUCT_LINKED))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 如果我们已经在安全列表遍历中，并且将多个作品移动到计划队列中，则需要更新下一个位置。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (nextp)</span><br><span class="line">		*nextp = n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="assign-work-分配工作项"><a href="#assign-work-分配工作项" class="headerlink" title="assign_work 分配工作项"></a>assign_work 分配工作项</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * assign_work - 将工作项及其关联的工作项分配给某个工作人员</span></span><br><span class="line"><span class="comment"> * @work: 工作分配</span></span><br><span class="line"><span class="comment"> * @worker: 分配给工人</span></span><br><span class="line"><span class="comment"> * @nextp: 用于嵌套工作列表遍历的输出参数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 将 @work 和其关联的工作项分配给 @worker。如果 @work 已经由同一个池中的其他工作者执行，则将其转交给他们。*</span></span><br><span class="line"><span class="comment"> * 如果 @nextp 为 NULL，它将更新为指向最后调度工作下一个工作的指针。这允许 assign_work() 嵌套在 list_for_each_entry_safe() 里面。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果 @work 成功分配给 @worker，则返回 %true。如果 @work 已被转交给另一个正在执行它的工作者，则返回 %false。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">assign_work</span><span class="params">(<span class="keyword">struct</span> work_struct *work, <span class="keyword">struct</span> worker *worker,</span></span><br><span class="line"><span class="params">			<span class="keyword">struct</span> work_struct **nextp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span> =</span> worker-&gt;pool;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">collision</span>;</span></span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(&amp;pool-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 并发执行检查: 函数首先调用 find_worker_executing_work 检查是否有其他 worker 正在执行该工作项。如果发现冲突（即 collision 不为 NULL），</span></span><br><span class="line"><span class="comment">	 * 说明该工作项已经在同一个线程池中被其他 worker 执行。此时，函数会将工作项及其关联的工作项移动到冲突 worker 的调度队列中，并返回 false，表示工作被推迟到当前正在执行它的 worker</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	collision = find_worker_executing_work(pool, work);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(collision)) &#123;</span><br><span class="line">		move_linked_works(work, &amp;collision-&gt;scheduled, nextp);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 将工作项及其关联的工作项移动到目标 worker 的调度队列 */</span></span><br><span class="line">	move_linked_works(work, &amp;worker-&gt;scheduled, nextp);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="keep-working-判断是否需要继续工作"><a href="#keep-working-判断是否需要继续工作" class="headerlink" title="keep_working 判断是否需要继续工作"></a>keep_working 判断是否需要继续工作</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Do I need to keep working?  Called from currently running workers. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">keep_working</span><span class="params">(<span class="keyword">struct</span> worker_pool *pool)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 如果没有正在运行的线程（pool-&gt;nr_running == 0） */</span></span><br><span class="line">	<span class="keyword">return</span> !list_empty(&amp;pool-&gt;worklist) &amp;&amp; (pool-&gt;nr_running &lt;= <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="get-pwq-获取指定pool-workqueue的额外引用"><a href="#get-pwq-获取指定pool-workqueue的额外引用" class="headerlink" title="get_pwq 获取指定pool_workqueue的额外引用"></a>get_pwq 获取指定pool_workqueue的额外引用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * get_pwq - 获取指定pool_workqueue的额外引用</span></span><br><span class="line"><span class="comment"> * @pwq：pool_workqueue获取</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在 @pwq 上获取额外的参考资料。 调用方应保证@pwq具有正 refcnt 并持有匹配的 pool-&gt;lock。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">get_pwq</span><span class="params">(<span class="keyword">struct</span> pool_workqueue *pwq)</span></span><br><span class="line">&#123;</span><br><span class="line">	lockdep_assert_held(&amp;pwq-&gt;pool-&gt;lock);</span><br><span class="line">	WARN_ON_ONCE(pwq-&gt;refcnt &lt;= <span class="number">0</span>);</span><br><span class="line">	pwq-&gt;refcnt++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="put-pwq-取消对-pwq-的引用。如果它的引用计数降为零，安排销毁它。调用者应该持有匹配的-pool-lock。"><a href="#put-pwq-取消对-pwq-的引用。如果它的引用计数降为零，安排销毁它。调用者应该持有匹配的-pool-lock。" class="headerlink" title="put_pwq 取消对 @pwq 的引用。如果它的引用计数降为零，安排销毁它。调用者应该持有匹配的 pool-&gt;lock。"></a>put_pwq 取消对 @pwq 的引用。如果它的引用计数降为零，安排销毁它。调用者应该持有匹配的 pool-&gt;lock。</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * put_pwq - 放一个 pool_workqueue 引用</span></span><br><span class="line"><span class="comment"> * @pwq: pool_workqueue to put</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 取消对 @pwq 的引用。如果它的引用计数降为零，安排销毁它。调用者应该持有匹配的 pool-&gt;lock。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">put_pwq</span><span class="params">(<span class="keyword">struct</span> pool_workqueue *pwq)</span></span><br><span class="line">&#123;</span><br><span class="line">	lockdep_assert_held(&amp;pwq-&gt;pool-&gt;lock);</span><br><span class="line">	<span class="keyword">if</span> (likely(--pwq-&gt;refcnt))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * @pwq不能在pool-&gt;lock下释放，应该跳转到专用的kthread_worker以避免A-A死锁。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	kthread_queue_work(pwq_release_worker, &amp;pwq-&gt;release_work);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="get-work-color-从-work-data-中提取工作项的颜色（color）"><a href="#get-work-color-从-work-data-中提取工作项的颜色（color）" class="headerlink" title="get_work_color 从 work_data 中提取工作项的颜色（color）"></a>get_work_color 从 work_data 中提取工作项的颜色（color）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_work_color</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> work_data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (work_data &gt;&gt; WORK_STRUCT_COLOR_SHIFT) &amp;</span><br><span class="line">		((<span class="number">1</span> &lt;&lt; WORK_STRUCT_COLOR_BITS) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pwq-dec-nr-in-flight-减少-pwq-的-nr-in-flight"><a href="#pwq-dec-nr-in-flight-减少-pwq-的-nr-in-flight" class="headerlink" title="pwq_dec_nr_in_flight 减少 pwq 的 nr_in_flight"></a>pwq_dec_nr_in_flight 减少 pwq 的 nr_in_flight</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * pwq_dec_nr_in_flight - decrement pwq&#x27;s nr_in_flight</span></span><br><span class="line"><span class="comment"> * @pwq: pwq of interest</span></span><br><span class="line"><span class="comment"> * @work_data: work_data of work which left the queue</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 	减少 pool_workqueue（简称 pwq）中某个颜色的正在执行的工作项计数（nr_in_flight），并在必要时触发与工作队列刷新（flush）相关的逻辑。</span></span><br><span class="line"><span class="comment">	管理工作项的执行状态： 每个 pwq 维护一个 nr_in_flight 数组，用于记录不同颜色的工作项的执行数量。pwq_dec_nr_in_flight 减少指定颜色的计数，表示某个工作项已经完成或被移除。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	支持工作队列的刷新机制： 在工作队列中，刷新（flush）操作需要确保所有正在执行的工作项都完成。pwq_dec_nr_in_flight 会检查当前颜色的工作项是否已经全部完成。如果完成，它会更新 pwq-&gt;flush_color 并通知等待的刷新操作。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	激活挂起的工作项： 如果 pwq 中有挂起的工作项（inactive works），pwq_dec_nr_in_flight 会尝试激活它们（即将它们从 inactive_works 移动到 worklist 中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * CONTEXT:</span></span><br><span class="line"><span class="comment"> * raw_spin_lock_irq(pool-&gt;lock).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pwq_dec_nr_in_flight</span><span class="params">(<span class="keyword">struct</span> pool_workqueue *pwq, <span class="type">unsigned</span> <span class="type">long</span> work_data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> color = get_work_color(work_data);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(work_data &amp; WORK_STRUCT_INACTIVE))</span><br><span class="line">		pwq_dec_nr_active(pwq);</span><br><span class="line">	<span class="comment">/* 减少指定颜色的工作项计数 */</span></span><br><span class="line">	pwq-&gt;nr_in_flight[color]--;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* is flush in progress and are we at the flushing tip? */</span></span><br><span class="line">	<span class="keyword">if</span> (likely(pwq-&gt;flush_color != color))</span><br><span class="line">		<span class="keyword">goto</span> out_put;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* are there still in-flight works? */</span></span><br><span class="line">	<span class="keyword">if</span> (pwq-&gt;nr_in_flight[color])</span><br><span class="line">		<span class="keyword">goto</span> out_put;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* this pwq is done, clear flush_color */</span></span><br><span class="line">	pwq-&gt;flush_color = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 如果这是最后一个pwq，请唤醒第一个冲水器。它会处理剩下的事情。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (atomic_dec_and_test(&amp;pwq-&gt;wq-&gt;nr_pwqs_to_flush))</span><br><span class="line">		complete(&amp;pwq-&gt;wq-&gt;first_flusher-&gt;done);</span><br><span class="line">out_put:</span><br><span class="line">	put_pwq(pwq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="first-idle-worker-返回第一个空闲的-worker"><a href="#first-idle-worker-返回第一个空闲的-worker" class="headerlink" title="first_idle_worker 返回第一个空闲的 worker"></a>first_idle_worker 返回第一个空闲的 worker</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 返回第一个空闲的 worker。 在持有 pool-&gt;lock 的情况下被调用. */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> worker *<span class="title function_">first_idle_worker</span><span class="params">(<span class="keyword">struct</span> worker_pool *pool)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(list_empty(&amp;pool-&gt;idle_list)))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> list_first_entry(&amp;pool-&gt;idle_list, <span class="keyword">struct</span> worker, entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="need-more-worker-判断工作池（worker-pool）是否需要唤醒更多的工作线程（worker）"><a href="#need-more-worker-判断工作池（worker-pool）是否需要唤醒更多的工作线程（worker）" class="headerlink" title="need_more_worker 判断工作池（worker_pool）是否需要唤醒更多的工作线程（worker）"></a>need_more_worker 判断工作池（worker_pool）是否需要唤醒更多的工作线程（worker）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 需要唤醒 worker？ 从除当前正在运行的 worker 之外的任何位置调用。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 请注意，由于 unbound worker 永远不会对 nr_running 做出贡献，因此只要 worklist 不为空，此函数将始终为未绑定的池返回 %true。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">need_more_worker</span><span class="params">(<span class="keyword">struct</span> worker_pool *pool)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 检查工作池中是否有挂起的工作项需要处理。</span></span><br><span class="line"><span class="comment">		pool-&gt;nr_running 表示当前正在运行的工作线程数量 */</span></span><br><span class="line">	<span class="keyword">return</span> !list_empty(&amp;pool-&gt;worklist) &amp;&amp; !pool-&gt;nr_running;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="kick-bh-pool-用于唤醒软中断（Bottom-Half，简称-BH）工作池中的工作线程"><a href="#kick-bh-pool-用于唤醒软中断（Bottom-Half，简称-BH）工作池中的工作线程" class="headerlink" title="kick_bh_pool 用于唤醒软中断（Bottom Half，简称 BH）工作池中的工作线程"></a>kick_bh_pool 用于唤醒软中断（Bottom Half，简称 BH）工作池中的工作线程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">kick_bh_pool</span><span class="params">(<span class="keyword">struct</span> worker_pool *pool)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 如果优先级为高（HIGHPRI_NICE_LEVEL），触发高优先级软中断（HI_SOFTIRQ） */</span></span><br><span class="line">	<span class="keyword">if</span> (pool-&gt;attrs-&gt;nice == HIGHPRI_NICE_LEVEL)</span><br><span class="line">		raise_softirq_irqoff(HI_SOFTIRQ);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="comment">/* 触发普通任务软中断 */</span></span><br><span class="line">		raise_softirq_irqoff(TASKLET_SOFTIRQ);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="kick-pool-如有必要，唤醒空闲的-worker"><a href="#kick-pool-如有必要，唤醒空闲的-worker" class="headerlink" title="kick_pool 如有必要，唤醒空闲的 worker"></a>kick_pool 如有必要，唤醒空闲的 worker</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kick_pool - 如有必要，唤醒空闲的 worker</span></span><br><span class="line"><span class="comment"> * @pool：台球踢球</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @pool 可能有待处理的工作项。如有必要，唤醒 worker。返回 worker 是否已唤醒。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">kick_pool</span><span class="params">(<span class="keyword">struct</span> worker_pool *pool)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 获取工作池中最近进入空闲状态的工作线程 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">worker</span> =</span> first_idle_worker(pool);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(&amp;pool-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 检查是否需要更多工作线程（need_more_worker）以及是否有空闲线程可用 */</span></span><br><span class="line">	<span class="keyword">if</span> (!need_more_worker(pool) || !worker)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果工作池是软中断类型（POOL_BH） */</span></span><br><span class="line">	<span class="keyword">if</span> (pool-&gt;flags &amp; POOL_BH) &#123;</span><br><span class="line">		kick_bh_pool(pool);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	p = worker-&gt;task;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*  唤醒工作线程，使其开始处理挂起的工作项 */</span></span><br><span class="line">	wake_up_process(p);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="process-one-work-处理单个工作项"><a href="#process-one-work-处理单个工作项" class="headerlink" title="process_one_work 处理单个工作项"></a>process_one_work 处理单个工作项</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * process_one_work - process single work</span></span><br><span class="line"><span class="comment"> * @worker: self</span></span><br><span class="line"><span class="comment"> * @work: work to process</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 处理@工作。此功能包含处理单个工作的所有逻辑，包括与同一CPU上的其他工作者的同步和交互、排队和刷新。只要满足上下文要求，任何工作者都可以调用此功能来处理工作。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * CONTEXT:</span></span><br><span class="line"><span class="comment"> * raw_spin_lock_irq(pool-&gt;lock) which is released and regrabbed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">process_one_work</span><span class="params">(<span class="keyword">struct</span> worker *worker, <span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">__<span class="title function_">releases</span><span class="params">(&amp;pool-&gt;lock)</span></span><br><span class="line">__<span class="title function_">acquires</span><span class="params">(&amp;pool-&gt;lock)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">pwq</span> =</span> get_work_pwq(work);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span> =</span> worker-&gt;pool;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> work_data;</span><br><span class="line">	<span class="type">int</span> lockdep_start_depth, rcu_start_depth;</span><br><span class="line">	<span class="type">bool</span> bh_draining = pool-&gt;flags &amp; POOL_BH_DRAINING;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 确保我们在正确的CPU上 */</span></span><br><span class="line">	WARN_ON_ONCE(!(pool-&gt;flags &amp; POOL_DISASSOCIATED) &amp;&amp;</span><br><span class="line">		     raw_smp_processor_id() != pool-&gt;cpu);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 声明和出队 */</span></span><br><span class="line">	debug_work_deactivate(work);</span><br><span class="line">	hash_add(pool-&gt;busy_hash, &amp;worker-&gt;hentry, (<span class="type">unsigned</span> <span class="type">long</span>)work);</span><br><span class="line">	worker-&gt;current_work = work;</span><br><span class="line">	worker-&gt;current_func = work-&gt;func;</span><br><span class="line">	worker-&gt;current_pwq = pwq;</span><br><span class="line">	<span class="keyword">if</span> (worker-&gt;task)</span><br><span class="line">		worker-&gt;current_at = worker-&gt;task-&gt;se.sum_exec_runtime;</span><br><span class="line">	work_data = *work_data_bits(work);</span><br><span class="line">	<span class="comment">/* 用于记录当前正在执行的工作项的颜色（color）。颜色是工作队列中用于区分不同批次工作项的标识。 */</span></span><br><span class="line">	worker-&gt;current_color = get_work_color(work_data);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Record wq name for cmdline and debug reporting, may get</span></span><br><span class="line"><span class="comment">	 * overridden through set_worker_desc().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	strscpy(worker-&gt;desc, pwq-&gt;wq-&gt;name, WORKER_DESC_LEN);</span><br><span class="line"></span><br><span class="line">	list_del_init(&amp;work-&gt;entry);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果工作队列标记为 CPU 密集型（WQ_CPU_INTENSIVE），将 worker 标记为 CPU 密集型，以便调度器优化其运行 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(pwq-&gt;wq-&gt;flags &amp; WQ_CPU_INTENSIVE))</span><br><span class="line">		worker_set_flags(worker, WORKER_CPU_INTENSIVE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *必要时在池中踢出。此时，对于每个 CPU 工作者池，由于 nr_running 始终大于或等于 1，因此始终为 noop。</span></span><br><span class="line"><span class="comment">	 这用于链接尚未执行的工作项，针对那些 WORKER_NOT_RUNNING 的工作者，例如 UNBOUND 和 CPU_INTENSIVE 的工作者。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	kick_pool(pool);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 记录最后一个池，并清除PENDING，这应该是对@work的最后更新。同时，在@pool-&gt;lock内部执行此操作，以便在禁用IRQ时PENDING和排队状态更改一起发生。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	set_work_pool_and_clear_pending(work, pool-&gt;id, pool_offq_flags(pool));</span><br><span class="line"></span><br><span class="line">	pwq-&gt;stats[PWQ_STAT_STARTED]++;</span><br><span class="line">	raw_spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line"></span><br><span class="line">	worker-&gt;current_func(work);</span><br><span class="line">	pwq-&gt;stats[PWQ_STAT_COMPLETED]++;</span><br><span class="line">	raw_spin_lock_irq(&amp;pool-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * In addition to %WQ_CPU_INTENSIVE, @worker may also have been marked</span></span><br><span class="line"><span class="comment">	 * CPU intensive by wq_worker_tick() if @work hogged CPU longer than</span></span><br><span class="line"><span class="comment">	 * wq_cpu_intensive_thresh_us. Clear it.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	worker_clr_flags(worker, WORKER_CPU_INTENSIVE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* tag the worker for identification in schedule() */</span></span><br><span class="line">	worker-&gt;last_func = worker-&gt;current_func;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* we&#x27;re done with it, release */</span></span><br><span class="line">	hash_del(&amp;worker-&gt;hentry);</span><br><span class="line">	worker-&gt;current_work = <span class="literal">NULL</span>;</span><br><span class="line">	worker-&gt;current_func = <span class="literal">NULL</span>;</span><br><span class="line">	worker-&gt;current_pwq = <span class="literal">NULL</span>;</span><br><span class="line">	worker-&gt;current_color = INT_MAX;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* must be the last step, see the function comment */</span></span><br><span class="line">	pwq_dec_nr_in_flight(pwq, work_data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="process-scheduled-works-处理调度的工作"><a href="#process-scheduled-works-处理调度的工作" class="headerlink" title="process_scheduled_works 处理调度的工作"></a>process_scheduled_works 处理调度的工作</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * process_scheduled_works - 处理所有计划的工作。</span></span><br><span class="line"><span class="comment"> * @worker: self</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 处理所有计划的工作。 请注意，在处理工作时，计划列表可能会发生变化，因此该功能会反复从顶部获取工作并执行。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * CONTEXT:</span></span><br><span class="line"><span class="comment"> * raw_spin_lock_irq(pool-&gt;lock)，可能会被多次释放和重新获取.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">process_scheduled_works</span><span class="params">(<span class="keyword">struct</span> worker *worker)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> *<span class="title">work</span>;</span></span><br><span class="line">	<span class="type">bool</span> first = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> ((work = list_first_entry_or_null(&amp;worker-&gt;scheduled,</span><br><span class="line">						<span class="keyword">struct</span> work_struct, entry))) &#123;</span><br><span class="line">		<span class="keyword">if</span> (first) &#123;</span><br><span class="line">			worker-&gt;pool-&gt;watchdog_ts = jiffies;</span><br><span class="line">			first = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		process_one_work(worker, work);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="set-pf-worker-标识一个任务是否为工作队列（workqueue）的工作者线程"><a href="#set-pf-worker-标识一个任务是否为工作队列（workqueue）的工作者线程" class="headerlink" title="set_pf_worker 标识一个任务是否为工作队列（workqueue）的工作者线程"></a>set_pf_worker 标识一个任务是否为工作队列（workqueue）的工作者线程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">set_pf_worker</span><span class="params">(<span class="type">bool</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">	mutex_lock(&amp;wq_pool_attach_mutex);</span><br><span class="line">	<span class="keyword">if</span> (val)</span><br><span class="line">		current-&gt;flags |= PF_WQ_WORKER;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		current-&gt;flags &amp;= ~PF_WQ_WORKER;</span><br><span class="line">	mutex_unlock(&amp;wq_pool_attach_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="worker-thread-工作线程函数"><a href="#worker-thread-工作线程函数" class="headerlink" title="worker_thread 工作线程函数"></a>worker_thread 工作线程函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * worker_thread - 工作线程函数</span></span><br><span class="line"><span class="comment"> * @__worker: self</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 工作线程功能。所有工作线程都归属于一个工作池——可以是每CPU一个的工作池，也可以是动态无绑定的工作池。</span></span><br><span class="line"><span class="comment"> * 这些工作线程处理所有工作项，而不考虑它们具体的目标工作队列。</span></span><br><span class="line"><span class="comment"> * 唯一的例外是属于具有救援者的工作队列的工作项，救援者的内容将在rescue_thread()中进行说明。.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">worker_thread</span><span class="params">(<span class="type">void</span> *__worker)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">worker</span> =</span> __worker;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span> =</span> worker-&gt;pool;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 告诉调度程序这是一个工作队列工作者 */</span></span><br><span class="line">	set_pf_worker(<span class="literal">true</span>);</span><br><span class="line">woke_up:</span><br><span class="line">	raw_spin_lock_irq(&amp;pool-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*我应该死吗？ */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(worker-&gt;flags &amp; WORKER_DIE)) &#123;</span><br><span class="line">		raw_spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line">		set_pf_worker(<span class="literal">false</span>);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * worker已死，PF_WQ_WORKER 被清除，worker-&gt;pool 不应被访问，如果未这样做，请将其重置为 NULL。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		worker-&gt;pool = <span class="literal">NULL</span>;</span><br><span class="line">		ida_free(&amp;pool-&gt;worker_ida, worker-&gt;id);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	worker_leave_idle(worker);</span><br><span class="line">recheck:</span><br><span class="line">	<span class="comment">/* 检查是否需要更多工作线程,不需要进入睡眠,需要执行任务 */</span></span><br><span class="line">	<span class="keyword">if</span> (!need_more_worker(pool))</span><br><span class="line">		<span class="keyword">goto</span> sleep;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 管理线程（may_start_working 返回 false），调用 manage_workers 进行管理后重新检查 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!may_start_working(pool)) &amp;&amp; manage_workers(worker))</span><br><span class="line">		<span class="keyword">goto</span> recheck;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 确保线程的 -&gt;scheduled 列表为空，避免在休眠期间被意外修改</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	WARN_ON_ONCE(!list_empty(&amp;worker-&gt;scheduled));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 清除线程的 WORKER_PREP 和 WORKER_REBOUND 标志，表示线程已准备好参与并发管理</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	worker_clr_flags(worker, WORKER_PREP | WORKER_REBOUND);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="comment">/* 提取第一个任务 */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> *<span class="title">work</span> =</span></span><br><span class="line">			list_first_entry(&amp;pool-&gt;worklist,</span><br><span class="line">					 <span class="keyword">struct</span> work_struct, entry);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (assign_work(work, worker, <span class="literal">NULL</span>))</span><br><span class="line">			<span class="comment">/* 处理已调度的任务 */</span></span><br><span class="line">			process_scheduled_works(worker);</span><br><span class="line">	&#125; <span class="keyword">while</span> (keep_working(pool));</span><br><span class="line"></span><br><span class="line">	worker_set_flags(worker, WORKER_PREP);</span><br><span class="line">sleep:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *池-&gt;锁被持有时没有工作需要处理，也没有管理的必要，休眠。</span></span><br><span class="line"><span class="comment">	 * 当持有池-&gt;锁或来自本地CPU时，工人会被唤醒，所以在释放池-&gt;锁之前设置当前状态就足以防止丢失任何事件。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	worker_enter_idle(worker);</span><br><span class="line">	__set_current_state(TASK_IDLE);</span><br><span class="line">	raw_spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line">	schedule();</span><br><span class="line">	<span class="keyword">goto</span> woke_up;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="wqattrs-hash-计算工作队列属性的哈希值"><a href="#wqattrs-hash-计算工作队列属性的哈希值" class="headerlink" title="wqattrs_hash 计算工作队列属性的哈希值"></a>wqattrs_hash 计算工作队列属性的哈希值</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* hash value of the content of @attr */</span></span><br><span class="line"><span class="type">static</span> u32 <span class="title function_">wqattrs_hash</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> workqueue_attrs *attrs)</span></span><br><span class="line">&#123;</span><br><span class="line">	u32 hash = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	hash = jhash_1word(attrs-&gt;nice, hash);</span><br><span class="line">	hash = jhash_1word(attrs-&gt;affn_strict, hash);</span><br><span class="line">	hash = jhash(cpumask_bits(attrs-&gt;__pod_cpumask),</span><br><span class="line">		     BITS_TO_LONGS(nr_cpumask_bits) * <span class="keyword">sizeof</span>(<span class="type">long</span>), hash);</span><br><span class="line">	<span class="keyword">if</span> (!attrs-&gt;affn_strict)</span><br><span class="line">		hash = jhash(cpumask_bits(attrs-&gt;cpumask),</span><br><span class="line">			     BITS_TO_LONGS(nr_cpumask_bits) * <span class="keyword">sizeof</span>(<span class="type">long</span>), hash);</span><br><span class="line">	<span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="set-worker-dying-设置工作线程为死亡状态"><a href="#set-worker-dying-设置工作线程为死亡状态" class="headerlink" title="set_worker_dying 设置工作线程为死亡状态"></a>set_worker_dying 设置工作线程为死亡状态</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * set_worker_dying - Tag a worker for destruction</span></span><br><span class="line"><span class="comment"> * @worker: worker to be destroyed</span></span><br><span class="line"><span class="comment"> * @list: transfer worker away from its pool-&gt;idle_list and into list</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Tag @worker for destruction and adjust @pool stats accordingly.  The worker</span></span><br><span class="line"><span class="comment"> * should be idle.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * CONTEXT:</span></span><br><span class="line"><span class="comment"> * raw_spin_lock_irq(pool-&gt;lock).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">set_worker_dying</span><span class="params">(<span class="keyword">struct</span> worker *worker, <span class="keyword">struct</span> list_head *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span> =</span> worker-&gt;pool;</span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(&amp;pool-&gt;lock);</span><br><span class="line">	lockdep_assert_held(&amp;wq_pool_attach_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* sanity check frenzy */</span></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON(worker-&gt;current_work) ||</span><br><span class="line">	    WARN_ON(!list_empty(&amp;worker-&gt;scheduled)) ||</span><br><span class="line">	    WARN_ON(!(worker-&gt;flags &amp; WORKER_IDLE)))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	pool-&gt;nr_workers--;</span><br><span class="line">	pool-&gt;nr_idle--;</span><br><span class="line"></span><br><span class="line">	worker-&gt;flags |= WORKER_DIE;</span><br><span class="line"></span><br><span class="line">	list_move(&amp;worker-&gt;entry, <span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* get an extra task struct reference for later kthread_stop_put() */</span></span><br><span class="line">	get_task_struct(worker-&gt;task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="detach-worker-分离工作线程"><a href="#detach-worker-分离工作线程" class="headerlink" title="detach_worker 分离工作线程"></a>detach_worker 分离工作线程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">unbind_worker</span><span class="params">(<span class="keyword">struct</span> worker *worker)</span></span><br><span class="line">&#123;</span><br><span class="line">	lockdep_assert_held(&amp;wq_pool_attach_mutex);</span><br><span class="line"></span><br><span class="line">	kthread_set_per_cpu(worker-&gt;task, <span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">if</span> (cpumask_intersects(wq_unbound_cpumask, cpu_active_mask))</span><br><span class="line">		WARN_ON_ONCE(set_cpus_allowed_ptr(worker-&gt;task, wq_unbound_cpumask) &lt; <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		WARN_ON_ONCE(set_cpus_allowed_ptr(worker-&gt;task, cpu_possible_mask) &lt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">detach_worker</span><span class="params">(<span class="keyword">struct</span> worker *worker)</span></span><br><span class="line">&#123;</span><br><span class="line">	lockdep_assert_held(&amp;wq_pool_attach_mutex);</span><br><span class="line"></span><br><span class="line">	unbind_worker(worker);</span><br><span class="line">	list_del(&amp;worker-&gt;node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="detach-dying-workers-分离死亡的工作线程"><a href="#detach-dying-workers-分离死亡的工作线程" class="headerlink" title="detach_dying_workers 分离死亡的工作线程"></a>detach_dying_workers 分离死亡的工作线程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">detach_dying_workers</span><span class="params">(<span class="keyword">struct</span> list_head *cull_list)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">worker</span>;</span></span><br><span class="line"></span><br><span class="line">	list_for_each_entry(worker, cull_list, entry)</span><br><span class="line">		detach_worker(worker);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="work-grab-pending-从-WorkList-中窃取工作项并禁用-IRQ"><a href="#work-grab-pending-从-WorkList-中窃取工作项并禁用-IRQ" class="headerlink" title="work_grab_pending 从 WorkList 中窃取工作项并禁用 IRQ"></a>work_grab_pending 从 WorkList 中窃取工作项并禁用 IRQ</h2><p>在 Linux 内核的 workqueue.c 文件中，<code>offqd</code> 是一个缩写，表示 <strong>off-queue data</strong>，它是与 <code>work_struct</code> 相关的一个状态信息，用于描述工作项（work item）在从队列中移除后的状态。</p>
<p>具体来说，<code>offqd</code> 是一个结构体 <code>work_offq_data</code> 的实例，该结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_offq_data</span> &#123;</span></span><br><span class="line">    u32 pool_id;   <span class="comment">// 表示工作项所属的 worker_pool 的 ID</span></span><br><span class="line">    u32 disable;   <span class="comment">// 表示工作项的禁用计数</span></span><br><span class="line">    u32 flags;     <span class="comment">// 表示工作项的状态标志</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="offqd-的作用"><a href="#offqd-的作用" class="headerlink" title="offqd 的作用"></a><code>offqd</code> 的作用</h3><p><code>offqd</code> 的主要作用是存储工作项在从队列中移除后的一些元数据，包括：</p>
<ol>
<li><strong><code>pool_id</code></strong>：工作项所属的 <code>worker_pool</code> 的 ID，用于标识工作项之前在哪个工作池中。</li>
<li><strong><code>disable</code></strong>：工作项的禁用计数，表示该工作项是否被禁用以及禁用的深度。禁用的工作项无法被重新排队。</li>
<li><strong><code>flags</code></strong>：工作项的状态标志，用于记录工作项的其他状态信息，例如是否是 BH（软中断）工作项。</li>
</ol>
<h3 id="offqd-的使用场景"><a href="#offqd-的使用场景" class="headerlink" title="offqd 的使用场景"></a><code>offqd</code> 的使用场景</h3><p><code>offqd</code> 主要在以下场景中使用：</p>
<ol>
<li><p><strong>工作项从队列中移除时</strong>：<br>当一个工作项从队列中移除时，其状态会被转换为 <code>off-queue</code> 状态，此时会使用 <code>offqd</code> 来存储相关的元数据。</p>
</li>
<li><p><strong>工作项禁用和启用</strong>：<br><code>offqd</code> 的 <code>disable</code> 字段用于记录工作项的禁用状态。通过 <code>disable_work()</code> 和 <code>enable_work()</code> 函数，可以增加或减少禁用计数，从而控制工作项是否可以被重新排队。</p>
</li>
<li><p><strong>工作项状态标志的管理</strong>：<br><code>offqd</code> 的 <code>flags</code> 字段用于存储工作项的额外状态信息，例如是否是 BH 类型的工作项（通过 <code>WORK_OFFQ_BH</code> 标志表示）。</p>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>offqd</code> 是 <code>workqueue</code> 子系统中用于管理工作项状态的一个辅助数据结构，主要用于记录工作项在从队列中移除后的元数据，包括所属的工作池 ID、禁用计数和状态标志。它在工作项的禁用、启用以及状态转换过程中起到了重要作用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * try_to_grab_pending - 从 WorkList 中窃取工作项并禁用 IRQ</span></span><br><span class="line"><span class="comment"> * @work: work item to steal</span></span><br><span class="line"><span class="comment"> * @cflags: %WORK_CANCEL_ flags</span></span><br><span class="line"><span class="comment"> * @irq_flags: place to store irq state</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment">try_to_grab_pending 的作用是尝试获取工作项的 PENDING 状态，并根据不同的情况返回以下结果：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">返回 1：表示工作项处于 PENDING 状态，并且成功获取了该状态。</span></span><br><span class="line"><span class="comment">返回 0：表示工作项处于空闲状态，并成功将其标记为 PENDING。</span></span><br><span class="line"><span class="comment">返回 -EAGAIN：表示暂时无法获取 PENDING 状态，调用方可以安全地重试。</span></span><br><span class="line"><span class="comment">该函数能够处理工作项的多种状态，包括空闲状态、延迟状态（由定时器管理）以及工作队列中的状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">try_to_grab_pending</span><span class="params">(<span class="keyword">struct</span> work_struct *work, u32 cflags,</span></span><br><span class="line"><span class="params">			       <span class="type">unsigned</span> <span class="type">long</span> *irq_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">pwq</span>;</span></span><br><span class="line"></span><br><span class="line">	local_irq_save(*irq_flags);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* try to steal the timer if it exists */</span></span><br><span class="line">	<span class="keyword">if</span> (cflags &amp; WORK_CANCEL_DELAYED) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">delayed_work</span> *<span class="title">dwork</span> =</span> to_delayed_work(work);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 尝试通过 timer_delete 删除延迟工作项的定时器。如果删除成功，说明工作项已不在定时器中，返回 1</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (likely(timer_delete(&amp;dwork-&gt;timer)))</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 表示工作项处于空闲状态 */</span></span><br><span class="line">	<span class="keyword">if</span> (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work)))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 如果工作项已经在队列中，则需要进一步尝试从队列中“偷取”它</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	pool = get_work_pool(work);</span><br><span class="line">	<span class="keyword">if</span> (!pool)</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock(&amp;pool-&gt;lock);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * work-&gt;data 保证在 work 项目排队在 pwq-&gt;wq 时仅指向 pwq，而在排队时将 work-&gt;data 更新为指向 pwq 和在出队时更新为指向池的操作都是在 pwq-&gt;pool-&gt;lock 下进行的。</span></span><br><span class="line"><span class="comment">	 * 这反过来保证了，如果 work-&gt;data 指向与被锁定的池相关联的 pwq，则工作项目目前在该池中排队。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	pwq = get_work_pwq(work);</span><br><span class="line">	<span class="keyword">if</span> (pwq &amp;&amp; pwq-&gt;pool == pool) &#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> work_data = *work_data_bits(work);</span><br><span class="line"></span><br><span class="line">		debug_work_deactivate(work);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * A cancelable inactive work item must be in the</span></span><br><span class="line"><span class="comment">		 * pwq-&gt;inactive_works since a queued barrier can&#x27;t be</span></span><br><span class="line"><span class="comment">		 * canceled (see the comments in insert_wq_barrier()).</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * An inactive work item cannot be deleted directly because</span></span><br><span class="line"><span class="comment">		 * it might have linked barrier work items which, if left</span></span><br><span class="line"><span class="comment">		 * on the inactive_works list, will confuse pwq-&gt;nr_active</span></span><br><span class="line"><span class="comment">		 * management later on and cause stall.  Move the linked</span></span><br><span class="line"><span class="comment">		 * barrier work items to the worklist when deleting the grabbed</span></span><br><span class="line"><span class="comment">		 * item. Also keep WORK_STRUCT_INACTIVE in work_data, so that</span></span><br><span class="line"><span class="comment">		 * it doesn&#x27;t participate in nr_active management in later</span></span><br><span class="line"><span class="comment">		 * pwq_dec_nr_in_flight().</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (work_data &amp; WORK_STRUCT_INACTIVE)</span><br><span class="line">			move_linked_works(work, &amp;pwq-&gt;pool-&gt;worklist, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">		list_del_init(&amp;work-&gt;entry);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * work-&gt;data points to pwq iff queued. Let&#x27;s point to pool. As</span></span><br><span class="line"><span class="comment">		 * this destroys work-&gt;data needed by the next step, stash it.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		set_work_pool_and_keep_pending(work, pool-&gt;id,</span><br><span class="line">					       pool_offq_flags(pool));</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* must be the last step, see the function comment */</span></span><br><span class="line">		pwq_dec_nr_in_flight(pwq, work_data);</span><br><span class="line"></span><br><span class="line">		raw_spin_unlock(&amp;pool-&gt;lock);</span><br><span class="line">		rcu_read_unlock();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	raw_spin_unlock(&amp;pool-&gt;lock);</span><br><span class="line">fail:</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	local_irq_restore(*irq_flags);</span><br><span class="line">	<span class="keyword">return</span> -EAGAIN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * work_grab_pending - 从工作列表中盗取工作项并禁用中断请求</span></span><br><span class="line"><span class="comment"> * @work: work item to steal</span></span><br><span class="line"><span class="comment"> * @cflags: %WORK_CANCEL_ flags</span></span><br><span class="line"><span class="comment"> * @irq_flags: place to store IRQ state</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 获取 @work 的 PENDING 位。@work 可以处于任何稳定状态 - 空闲、计时或在工作列表中。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 可以在任何上下文中调用。IRQ在返回时被禁用，IRQ状态存储在*@irq_flags中。调用者负责使用local_irq_restore()重新启用它。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果@work处于待处理状态，则返回%true。否则为闲置.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">work_grab_pending</span><span class="params">(<span class="keyword">struct</span> work_struct *work, u32 cflags,</span></span><br><span class="line"><span class="params">			      <span class="type">unsigned</span> <span class="type">long</span> *irq_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		ret = try_to_grab_pending(work, cflags, irq_flags);</span><br><span class="line">		<span class="keyword">if</span> (ret &gt;= <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">		cpu_relax();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">work_offqd_unpack</span><span class="params">(<span class="keyword">struct</span> work_offq_data *offqd, <span class="type">unsigned</span> <span class="type">long</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">	WARN_ON_ONCE(data &amp; WORK_STRUCT_PWQ);</span><br><span class="line"></span><br><span class="line">	offqd-&gt;pool_id = shift_and_mask(data, WORK_OFFQ_POOL_SHIFT,</span><br><span class="line">					WORK_OFFQ_POOL_BITS);</span><br><span class="line">	offqd-&gt;disable = shift_and_mask(data, WORK_OFFQ_DISABLE_SHIFT,</span><br><span class="line">					WORK_OFFQ_DISABLE_BITS);</span><br><span class="line">	offqd-&gt;flags = data &amp; WORK_OFFQ_FLAG_MASK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">work_offqd_disable</span><span class="params">(<span class="keyword">struct</span> work_offq_data *offqd)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> max = (<span class="number">1lu</span> &lt;&lt; WORK_OFFQ_DISABLE_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (likely(offqd-&gt;disable &lt; max))</span><br><span class="line">		offqd-&gt;disable++;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		WARN_ONCE(<span class="literal">true</span>, <span class="string">&quot;workqueue: work disable count overflowed\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="flush-work-等待一个工作项完成其最后的执行"><a href="#flush-work-等待一个工作项完成其最后的执行" class="headerlink" title="flush_work: 等待一个工作项完成其最后的执行"></a>flush_work: 等待一个工作项完成其最后的执行</h3><p>此函数是一个同步辅助函数. 它的作用是<strong>阻塞</strong>当前的执行流程, 直到指定的工作项(<code>work</code>)执行完毕. 当此函数返回时, 可以保证该工作项处于空闲状态 (除非在<code>flush_work</code>开始执行后, 有其他代码又重新将其加入了队列). 这在设备驱动中非常关键, 例如, 在卸载一个驱动模块或关闭一个设备之前, 必须确保所有由该驱动提交的后台任务(work items)都已处理完毕, <code>flush_work</code>就是用来实现这种同步等待的.</p>
<p>在STM32H750单核系统上, 虽然不存在多核并行执行, 但并发性依然存在. 一个<code>work</code>是由后台的<code>kworker</code>内核线程执行的, 而调用<code>flush_work</code>的可能是另一个内核线程或进程上下文. 调用<code>flush_work</code>会使当前任务进入睡眠状态, 内核调度器会切换到其他任务, 比如<code>kworker</code>线程, 让其有机会完成待处理的工作. 因此, 即使在单核上, 这个函数对于保证操作的正确顺序也是必不可少的.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * bool flush_work(struct work_struct *work) - 等待一个工作项完成其最后的排队实例</span></span><br><span class="line"><span class="comment"> * @work: 需要被冲刷(flush)的工作项.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 等待直到 @work 完成其执行. 如果从 flush 开始后 @work 没有被重新排队,</span></span><br><span class="line"><span class="comment"> * 那么可以保证在函数返回时 @work 是空闲的.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值:</span></span><br><span class="line"><span class="comment"> * 如果 flush_work() 等待了该工作项的完成, 则返回 %true.</span></span><br><span class="line"><span class="comment"> * 如果该工作项在调用时已经处于空闲状态, 则返回 %false.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">flush_work</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 调用 might_sleep() 宏. 这是一个调试辅助工具, 它会告知内核的锁验证器(lockdep),</span></span><br><span class="line"><span class="comment">	 * 当前函数可能会进入睡眠(阻塞)状态. 如果在不能睡眠的上下文(如持有自旋锁时)调用了此函数,</span></span><br><span class="line"><span class="comment">	 * 内核会打印警告信息. 它在运行时没有开销, 仅用于开发和调试阶段.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	might_sleep();</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 直接调用内部核心实现函数 __flush_work.</span></span><br><span class="line"><span class="comment">	 * 第二个参数 from_cancel 被设置为 false, 表示这是一个常规的冲刷(flush)操作,</span></span><br><span class="line"><span class="comment">	 * 而不是取消(cancel)操作的一部分.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> __flush_work(work, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将 flush_work 函数导出, 以便其他GPL许可的内核模块可以使用它.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">EXPORT_SYMBOL_GPL(flush_work);</span><br></pre></td></tr></table></figure>

<h2 id="insert-wq-barrier-向工作队列中插入一个屏障工作项"><a href="#insert-wq-barrier-向工作队列中插入一个屏障工作项" class="headerlink" title="insert_wq_barrier: 向工作队列中插入一个屏障工作项"></a>insert_wq_barrier: 向工作队列中插入一个屏障工作项</h2><p>此函数是工作项冲刷(flush)机制的核心实现, 它的作用是原子性地将一个作为同步点的”屏障”工作项 (<code>barr</code>) 插入到一个工作队列中, 紧跟在需要被等待的”目标”工作项 (<code>target</code>) 之后. 该函数通过两种不同的策略来实现这一目标, 具体取决于目标工作项是正在执行还是仍在队列中等待.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">wq_barrier_func</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wq_barrier</span> *<span class="title">barr</span> =</span> container_of(work, <span class="keyword">struct</span> wq_barrier, work);</span><br><span class="line">	complete(&amp;barr-&gt;done);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 静态函数声明: insert_wq_barrier</span></span><br><span class="line"><span class="comment"> * 向工作队列中插入一个屏障工作项.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @pwq:    需要插入屏障的目标 pool_workqueue (工作队列在池中的实例).</span></span><br><span class="line"><span class="comment"> * @barr:   需要被插入的 wq_barrier 结构体.</span></span><br><span class="line"><span class="comment"> * @target: 屏障需要等待的目标工作项.</span></span><br><span class="line"><span class="comment"> * @worker: 如果 target 正在被执行, 此参数指向执行它的 worker 线程; 否则为 NULL.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @barr 会被链接到 @target 之后, 这样 @barr 只有在 @target 执行完毕后才会被完成.</span></span><br><span class="line"><span class="comment"> * 请注意, 顺序保证仅相对于 @target 和本地CPU有效.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意: 当 @worker 不为 NULL 时, @target 的内容可能在底层被修改,</span></span><br><span class="line"><span class="comment"> *       因此我们不能可靠地从 @target 推断出 pwq.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * CONTEXT (调用上下文):</span></span><br><span class="line"><span class="comment"> * 必须在持有 pool-&gt;lock 的情况下调用此函数 (raw_spin_lock_irq).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">insert_wq_barrier</span><span class="params">(<span class="keyword">struct</span> pool_workqueue *pwq,</span></span><br><span class="line"><span class="params">			      <span class="keyword">struct</span> wq_barrier *barr,</span></span><br><span class="line"><span class="params">			      <span class="keyword">struct</span> work_struct *target, <span class="keyword">struct</span> worker *worker)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 为锁依赖检查器(lockdep)定义两个静态的锁类别密钥. __maybe_unused 表示如果内核未开启相关配置,</span></span><br><span class="line"><span class="comment">	 * 这些变量可能未使用, 以避免编译器警告.</span></span><br><span class="line"><span class="comment">	 * BH (Bottom Half) 和 线程化(threaded)工作队列需要不同的密钥,</span></span><br><span class="line"><span class="comment">	 * 以便 lockdep 能够正确区分它们的锁上下文, 避免误报死锁.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">static</span> __maybe_unused <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">bh_key</span>, <span class="title">thr_key</span>;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 定义一个无符号整型 work_flags, 用于累积要设置到屏障工作项中的标志位. 初始化为0.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> work_flags = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 定义一个无符号整型 work_color, 用于存储目标工作项的&quot;颜色&quot;.</span></span><br><span class="line"><span class="comment">	 * &quot;颜色&quot;是用于NUMA系统上进行优化的机制, 用于将工作项和worker线程保持在同一节点.</span></span><br><span class="line"><span class="comment">	 * 在非NUMA的STM32H750上, 只有一个颜色(通常是0).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> work_color;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 定义一个指向 list_head 的指针, 它将指向屏障工作项需要被插入的链表位置.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">head</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 初始化在栈上创建的屏障工作项 barr-&gt;work.</span></span><br><span class="line"><span class="comment">	 * INIT_WORK_ONSTACK_KEY 是一个宏, 用于初始化一个在栈上分配的 work_struct.</span></span><br><span class="line"><span class="comment">	 * wq_barrier_func 是这个屏障工作项被执行时会调用的函数.</span></span><br><span class="line"><span class="comment">	 * 根据工作队列的标志位判断它是BH型还是线程型, 并为其关联正确的lockdep密钥.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	INIT_WORK_ONSTACK_KEY(&amp;barr-&gt;work, wq_barrier_func,</span><br><span class="line">			      (pwq-&gt;wq-&gt;flags &amp; WQ_BH) ? &amp;bh_key : &amp;thr_key);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 使用 __set_bit 原子地设置屏障工作项的 PENDING 位.</span></span><br><span class="line"><span class="comment">	 * 这将其标记为&quot;待处理&quot;状态.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	__set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(&amp;barr-&gt;work));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 初始化屏障中的完成变量(completion) barr-&gt;done.</span></span><br><span class="line"><span class="comment">	 * 调用 flush_work 的任务将会睡眠在这个 completion 上, 等待被唤醒.</span></span><br><span class="line"><span class="comment">	 * 同时, 它会继承目标工作项的 lockdep 映射, 以便进行依赖性检查.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	init_completion_map(&amp;barr-&gt;done, &amp;target-&gt;lockdep_map);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 记录下发起此次冲刷操作的任务(进程), 用于调试.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	barr-&gt;task = current;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 将屏障工作项标记为 INACTIVE.</span></span><br><span class="line"><span class="comment">	 * 这意味着它不会计入工作队列的 &quot;nr_active&quot; (活动工作项数量)中.</span></span><br><span class="line"><span class="comment">	 * 因为屏障本身只是一个同步标记, 而不是一个真正需要消耗资源的&quot;工作&quot;.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	work_flags |= WORK_STRUCT_INACTIVE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 这是此函数的核心逻辑分歧点.</span></span><br><span class="line"><span class="comment">	 * 如果 worker 指针不为 NULL, 说明目标工作项 target 正在被这个 worker 执行.</span></span><br><span class="line"><span class="comment">	 * 否则, 说明 target 仍在队列中等待, 尚未开始执行.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (worker) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 目标正在执行: 屏障必须被插入到该 worker 的私有 scheduled 链表的头部,</span></span><br><span class="line"><span class="comment">		 * 这样在当前工作完成后, 它会是下一个被执行的项.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		head = worker-&gt;scheduled.next;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 屏障的颜色继承自正在执行它的 worker 的当前颜色.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		work_color = worker-&gt;current_color;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 目标正在排队:</span></span><br><span class="line"><span class="comment">		 * 获取指向 target 数据域的指针.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> *bits = work_data_bits(target);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 屏障必须被插入到队列中紧跟在 target 后面的位置.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		head = target-&gt;entry.next;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 如果 target 后面已经有其他链接的工作项, 屏障需要继承这个 LINKED 标志,</span></span><br><span class="line"><span class="comment">		 * 以维持这个执行链.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		work_flags |= *bits &amp; WORK_STRUCT_LINKED;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 屏障的颜色继承自仍在队列中的 target 工作项的颜色.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		work_color = get_work_color(*bits);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 在目标工作项 target 上设置 LINKED 标志位.</span></span><br><span class="line"><span class="comment">		 * 这个标志告诉工作队列处理器: &quot;在执行完这个工作项后, 不要去队列头取下一个,</span></span><br><span class="line"><span class="comment">		 * 而是直接执行紧跟在我后面的那个工作项&quot;. 这是实现屏障插入的关键.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		__set_bit(WORK_STRUCT_LINKED_BIT, bits);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 增加对应颜色的 &quot;in_flight&quot; (在途)工作项计数.</span></span><br><span class="line"><span class="comment">	 * 这个计数器帮助工作队列管理器决定是否需要创建或销毁 worker 线程.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	pwq-&gt;nr_in_flight[work_color]++;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 将颜色信息编码到屏障工作项的 flags 中.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	work_flags |= work_color_to_flags(work_color);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 调用 insert_work 函数, 将设置好所有标志的屏障工作项 barr-&gt;work,</span></span><br><span class="line"><span class="comment">	 * 插入到前面确定的链表位置 head 中.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	insert_work(pwq, &amp;barr-&gt;work, head, work_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="start-flush-work-启动一个工作项的冲刷操作"><a href="#start-flush-work-启动一个工作项的冲刷操作" class="headerlink" title="start_flush_work: 启动一个工作项的冲刷操作"></a>start_flush_work: 启动一个工作项的冲刷操作</h2><p>此函数是 <code>__flush_work</code> 的核心辅助函数, 它的主要职责是在一个原子性的上下文中, 检查一个给定的工作项 (<code>work</code>) 是否正处于活动状态 (即, 排队中或正在执行). 如果工作项是活动的, 此函数会将一个特殊的”屏障”工作项 (<code>barr</code>) 插入到与目标工作项相同的执行队列中, 并返回 <code>true</code>, 表示调用者需要等待. 如果目标工作项已经是空闲的, 则此函数直接返回 <code>false</code>, 表示无需等待.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 静态函数声明: start_flush_work</span></span><br><span class="line"><span class="comment"> * 尝试启动一个工作项的冲刷操作, 如果成功, 则返回 true.</span></span><br><span class="line"><span class="comment"> * @work:        目标工作项.</span></span><br><span class="line"><span class="comment"> * @barr:        将要被插入的屏障工作项.</span></span><br><span class="line"><span class="comment"> * @from_cancel: 布尔值, 指示此次调用是否源于取消操作.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">start_flush_work</span><span class="params">(<span class="keyword">struct</span> work_struct *work, <span class="keyword">struct</span> wq_barrier *barr,</span></span><br><span class="line"><span class="params">			     <span class="type">bool</span> from_cancel)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 定义一个指向 worker 结构体的指针, worker 代表一个执行工作项的内核线程. 初始化为NULL.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">worker</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 定义一个指向 worker_pool 结构体的指针, worker_pool 是 worker 线程的集合.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span>;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 定义一个指向 pool_workqueue 结构体的指针, 它代表了一个工作队列在一个工作池中的实例.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">pwq</span>;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 定义一个指向 workqueue_struct 结构体的指针, 它代表一个工作队列.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">wq</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 进入RCU读侧临界区. 这可以防止在读取 work-&gt;data (其中包含pool信息)时,</span></span><br><span class="line"><span class="comment">	 * work 被并发地从一个工作池迁移到另一个. 在单核可抢占内核上, 这会禁用内核抢占.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 调用 get_work_pool 获取 work 所在的 worker_pool.</span></span><br><span class="line"><span class="comment">	 * 这个信息编码在 work-&gt;data 中.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	pool = get_work_pool(work);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 如果 get_work_pool 返回 NULL, 说明这个 work 当前不属于任何工作池, 即它处于空闲状态.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!pool) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 既然 work 是空闲的, 就不需要等待. 退出RCU临界区.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		rcu_read_unlock();</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 返回 false, 告知调用者无需冲刷.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 获取工作池的自旋锁并禁用中断. 这是为了原子地检查 work 的状态并插入屏障.</span></span><br><span class="line"><span class="comment">	 * 在单核系统上, 这保证了在操作期间不会发生任务抢占或中断处理.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	raw_spin_lock_irq(&amp;pool-&gt;lock);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 首先, 假设 work 正在队列中等待执行, 尝试获取它的 pwq (pool workqueue) 实例.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	pwq = get_work_pwq(work);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 如果 pwq 不为 NULL, 说明 work 确实在某个队列里.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (pwq) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 一个罕见的竞态条件检查: 如果 pwq 所属的 pool 不是我们刚刚锁定的 pool,</span></span><br><span class="line"><span class="comment">		 * 说明 work 在我们获取锁的瞬间被迁移到了别的池并完成了执行.</span></span><br><span class="line"><span class="comment">		 * 这种情况下, 它已经 &quot;消失&quot; 了.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(pwq-&gt;pool != pool))</span><br><span class="line">			<span class="keyword">goto</span> already_gone;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 如果 pwq 为 NULL, 说明 work 不在任何等待队列中. 它可能正在被某个 worker 线程执行.</span></span><br><span class="line"><span class="comment">		 * 调用 find_worker_executing_work 在当前池中查找正在执行 work 的 worker 线程.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		worker = find_worker_executing_work(pool, work);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 如果没有找到 worker, 说明 work 既不在队列中也未在执行. 它已经 &quot;消失&quot; 了.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!worker)</span><br><span class="line">			<span class="keyword">goto</span> already_gone;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 如果找到了正在执行它的 worker, 那么从这个 worker 的状态中获取它当前的 pwq.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		pwq = worker-&gt;current_pwq;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 此时, 我们已经成功定位了 work 所在的 pwq. 从 pwq 中获取其所属的 workqueue (wq).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	wq = pwq-&gt;wq;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 调用锁依赖检查器, 检查是否存在循环依赖, 比如一个 work 冲刷它自己的工作队列, 这可能导致死锁.</span></span><br><span class="line"><span class="comment">	 * 这是一个调试功能, 在生产内核中通常没有开销.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	check_flush_dependency(wq, work, from_cancel);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 这是关键操作: 调用 insert_wq_barrier, 将屏障 barr 插入到 pwq 的工作队列中.</span></span><br><span class="line"><span class="comment">	 * 这个函数会把 barr 放置在合适的位置, 以确保它在 work 执行完毕后才会被执行.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	insert_wq_barrier(pwq, barr, work, worker);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 释放工作池的锁, 并恢复中断.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	raw_spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 接触(touch)工作项的锁映射, 通知锁依赖检查器.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	touch_work_lockdep_map(work, wq);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 这是一项针对死锁的预防性检查. 如果一个工作队列是单线程的(max_active == 1),</span></span><br><span class="line"><span class="comment">	 * 或者它配备了救援者线程(rescuer), 在其工作项内部调用 flush_work() 会导致死锁.</span></span><br><span class="line"><span class="comment">	 * 这行代码会模拟一次锁获取, 以便让锁依赖检查器(lockdep)能够捕获这种不当用法.</span></span><br><span class="line"><span class="comment">	 * 这个检查仅在常规冲刷(from_cancel 为 false)时进行.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!from_cancel &amp;&amp; (wq-&gt;saved_max_active == <span class="number">1</span> || wq-&gt;rescuer))</span><br><span class="line">		touch_wq_lockdep_map(wq);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 退出RCU读侧临界区. 在单核上, 重新启用内核抢占.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 返回 true, 表明屏障已成功插入, 调用者需要等待.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">already_gone:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 这是 &quot;work 已经消失&quot; 的统一出口.</span></span><br><span class="line"><span class="comment">	 * 释放池锁和RCU锁.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	raw_spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 返回 false, 告知调用者无需等待.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="flush-work-冲刷-flush-一个工作项的核心实现"><a href="#flush-work-冲刷-flush-一个工作项的核心实现" class="headerlink" title="__flush_work: 冲刷(flush)一个工作项的核心实现"></a>__flush_work: 冲刷(flush)一个工作项的核心实现</h2><p>这是<code>flush_work</code>和<code>cancel_work_sync</code>等函数的内部核心实现. 它的基本原理是在目标工作项<code>work</code>所在的CPU的工作队列上, 插入一个特殊的”屏障”(<code>barrier</code>)工作项. 因为同一个工作队列中的工作项是按顺序执行的, 所以当这个屏障工作项开始执行时, 就意味着它前面的所有工作项(包括我们关心的<code>work</code>)都已经完成了. 然后, 调用者只需等待这个屏障工作项完成即可.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 静态函数声明: __flush_work</span></span><br><span class="line"><span class="comment"> * 这是冲刷工作项的内部核心函数.</span></span><br><span class="line"><span class="comment"> * @work:         需要被冲刷的工作项.</span></span><br><span class="line"><span class="comment"> * @from_cancel:  一个布尔值, 如果为 true, 表示此次调用来自取消操作(cancel_work_sync),</span></span><br><span class="line"><span class="comment"> *                需要处理一些特殊的竞态条件.</span></span><br><span class="line"><span class="comment"> * @return:       如果函数实际等待了工作项, 返回 true, 否则返回 false.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> __flush_work(<span class="keyword">struct</span> work_struct *work, <span class="type">bool</span> from_cancel)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 在栈上定义一个 wq_barrier 结构体变量 barr.</span></span><br><span class="line"><span class="comment">	 * wq_barrier 是一种特殊的工作项, 用于在工作队列中设置一个同步点.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wq_barrier</span> <span class="title">barr</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 使用 WARN_ON 宏进行检查. 如果工作队列子系统尚未在线(wq_online 为 false),</span></span><br><span class="line"><span class="comment">	 * 说明系统处于早期启动或关闭阶段, 此时冲刷工作项是不安全或无意义的.</span></span><br><span class="line"><span class="comment">	 * 如果条件为真, 内核会打印一条警告信息, 并返回 false.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON(!wq_online))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 检查工作项的 func 成员是否为 NULL. 一个没有执行函数的工作项是无效的.</span></span><br><span class="line"><span class="comment">	 * 如果为 NULL, 打印警告并返回.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON(!work-&gt;func))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 调用 start_flush_work 函数. 这是实现冲刷的关键步骤.</span></span><br><span class="line"><span class="comment">	 * 这个函数会尝试将屏障 barr 插入到工作队列中.</span></span><br><span class="line"><span class="comment">	 * 如果目标工作项 work 当时并不在任何队列中也未在执行(即处于空闲),</span></span><br><span class="line"><span class="comment">	 * start_flush_work 会直接返回 false, 表示无需等待.</span></span><br><span class="line"><span class="comment">	 * 如果 work 正在排队或执行, 它会设置好屏障并返回 true, 表示我们需要等待.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!start_flush_work(work, &amp;barr, from_cancel))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 如果代码执行到这里, 说明 start_flush_work() 返回了 true, 我们需要等待.</span></span><br><span class="line"><span class="comment">	 * 下面是针对 from_cancel 标志的特殊处理逻辑.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (from_cancel) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 这段逻辑主要由 cancel_work_sync() 使用.</span></span><br><span class="line"><span class="comment">		 * 如果 from_cancel 为真, 我们知道 work 必须是在 start_flush_work() 执行期间正在被执行,</span></span><br><span class="line"><span class="comment">		 * 并且当前不可能被重新排队. 其 work_data_bits 中必须包含 OFFQ(已离队)标志位.</span></span><br><span class="line"><span class="comment">		 * 如果 work 是一个在 BH(Bottom Half)上下文中执行的工作队列项, 我们可以安全地对其进行忙等待.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> data = *work_data_bits(work);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 如果 work 不是一个 PENDING/INFLIGHT 工作项 (这是预期的, 但用WARN_ON_ONCE检查以防万一),</span></span><br><span class="line"><span class="comment">		 * 并且它是一个 BH 工作项 (由 WORK_OFFQ_BH 标志指示), 则进入忙等待循环.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!WARN_ON_ONCE(data &amp; WORK_STRUCT_PWQ) &amp;&amp;</span><br><span class="line">		    (data &amp; WORK_OFFQ_BH)) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * 这是一个忙等待循环, 不断尝试检查屏障是否已完成.</span></span><br><span class="line"><span class="comment">			 * try_wait_for_completion 不会使任务睡眠.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">while</span> (!try_wait_for_completion(&amp;barr.done)) &#123;</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * 在实时(PREEMPT_RT)内核中, 为了防止当前任务抢占了软中断处理,</span></span><br><span class="line"><span class="comment">				 * 从而导致死锁, 这里通过开关本地BH来给软中断执行的机会.</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				<span class="keyword">if</span> (IS_ENABLED(CONFIG_PREEMPT_RT)) &#123;</span><br><span class="line">					local_bh_disable();</span><br><span class="line">					local_bh_enable();</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">/*</span></span><br><span class="line"><span class="comment">					 * 在非实时内核中, 调用 cpu_relax() 是一个给处理器的提示,</span></span><br><span class="line"><span class="comment">					 * 表示当前处于一个自旋等待循环中, CPU可以进行一些优化, 比如降低功耗.</span></span><br><span class="line"><span class="comment">					 */</span></span><br><span class="line">					cpu_relax();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * 忙等待结束后, 跳转到清理步骤.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">goto</span> out_destroy;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 这是常规的等待路径 (from_cancel 为 false, 或不满足上述特殊条件).</span></span><br><span class="line"><span class="comment">	 * 调用 wait_for_completion(), 这将使当前任务进入不可中断的睡眠状态(TASK_UNINTERRUPTIBLE),</span></span><br><span class="line"><span class="comment">	 * 直到屏障工作项执行完毕并调用 complete(&amp;barr.done) 来唤醒我们. 这是高效的等待方式.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	wait_for_completion(&amp;barr.done);</span><br><span class="line"></span><br><span class="line">out_destroy:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 调用 destroy_work_on_stack 清理在栈上创建的屏障工作项.</span></span><br><span class="line"><span class="comment">	 * 这会确保工作项与工作队列完全解绑.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	destroy_work_on_stack(&amp;barr.work);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 返回 true, 表明我们的确执行了等待操作.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="cancel-work-取消工作项"><a href="#cancel-work-取消工作项" class="headerlink" title="cancel_work  取消工作项"></a>cancel_work  取消工作项</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> __cancel_work(<span class="keyword">struct</span> work_struct *work, u32 cflags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_offq_data</span> <span class="title">offqd</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> irq_flags;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	ret = work_grab_pending(work, cflags, &amp;irq_flags);</span><br><span class="line"></span><br><span class="line">	work_offqd_unpack(&amp;offqd, *work_data_bits(work));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cflags &amp; WORK_CANCEL_DISABLE)</span><br><span class="line">		work_offqd_disable(&amp;offqd);</span><br><span class="line"></span><br><span class="line">	set_work_pool_and_clear_pending(work, offqd.pool_id,</span><br><span class="line">					work_offqd_pack_flags(&amp;offqd));</span><br><span class="line">	local_irq_restore(irq_flags);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> __cancel_work_sync(<span class="keyword">struct</span> work_struct *work, u32 cflags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">bool</span> ret;</span><br><span class="line"></span><br><span class="line">	ret = __cancel_work(work, cflags | WORK_CANCEL_DISABLE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (*work_data_bits(work) &amp; WORK_OFFQ_BH)</span><br><span class="line">		WARN_ON_ONCE(in_hardirq());</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		might_sleep();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Skip __flush_work() during early boot when we know that @work isn&#x27;t</span></span><br><span class="line"><span class="comment">	 * executing. This allows canceling during early boot.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (wq_online)</span><br><span class="line">		__flush_work(work, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(cflags &amp; WORK_CANCEL_DISABLE))</span><br><span class="line">		enable_work(work);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * See cancel_delayed_work()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">cancel_work</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> __cancel_work(work, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(cancel_work);</span><br></pre></td></tr></table></figure>

<h2 id="put-unbound-pool-释放工作池"><a href="#put-unbound-pool-释放工作池" class="headerlink" title="put_unbound_pool 释放工作池"></a>put_unbound_pool 释放工作池</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * put_unbound_pool - put a worker_pool</span></span><br><span class="line"><span class="comment"> * @pool: worker_pool to put</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 放置到@pool。如果它的引用计数达到零，它将以RCU安全的方式被销毁。get_unbound_pool()在其失败路径上调用此函数，并且此函数应该能够释放那些成功或未成功经过init_worker_pool()的池。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 应该在持有 wq_pool_mutex 时调用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">put_unbound_pool</span><span class="params">(<span class="keyword">struct</span> worker_pool *pool)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">worker</span>;</span></span><br><span class="line">	LIST_HEAD(cull_list);</span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(&amp;wq_pool_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (--pool-&gt;refcnt)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* sanity checks */</span></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON(!(pool-&gt;cpu &lt; <span class="number">0</span>)) ||</span><br><span class="line">	    WARN_ON(!list_empty(&amp;pool-&gt;worklist)))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* release id and unhash */</span></span><br><span class="line">	<span class="keyword">if</span> (pool-&gt;id &gt;= <span class="number">0</span>)</span><br><span class="line">		idr_remove(&amp;worker_pool_idr, pool-&gt;id);</span><br><span class="line">	hash_del(&amp;pool-&gt;hash_node);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="comment">/* 通过循环等待，确保当前线程成为工作池的管理者 */</span></span><br><span class="line">		rcuwait_wait_event(&amp;manager_wait,</span><br><span class="line">				   !(pool-&gt;flags &amp; POOL_MANAGER_ACTIVE),</span><br><span class="line">				   TASK_UNINTERRUPTIBLE);</span><br><span class="line"></span><br><span class="line">		mutex_lock(&amp;wq_pool_attach_mutex);</span><br><span class="line">		raw_spin_lock_irq(&amp;pool-&gt;lock);</span><br><span class="line">		<span class="keyword">if</span> (!(pool-&gt;flags &amp; POOL_MANAGER_ACTIVE)) &#123;</span><br><span class="line">			pool-&gt;flags |= POOL_MANAGER_ACTIVE;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		raw_spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line">		mutex_unlock(&amp;wq_pool_attach_mutex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 清理工作线程 */</span></span><br><span class="line">	<span class="keyword">while</span> ((worker = first_idle_worker(pool)))</span><br><span class="line">		set_worker_dying(worker, &amp;cull_list);</span><br><span class="line">	WARN_ON(pool-&gt;nr_workers || pool-&gt;nr_idle);</span><br><span class="line">	raw_spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line"></span><br><span class="line">	detach_dying_workers(&amp;cull_list);</span><br><span class="line"></span><br><span class="line">	mutex_unlock(&amp;wq_pool_attach_mutex);</span><br><span class="line"></span><br><span class="line">	reap_dying_workers(&amp;cull_list);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 删除与工作池相关的定时器 */</span></span><br><span class="line">	timer_delete_sync(&amp;pool-&gt;idle_timer);</span><br><span class="line">	cancel_work_sync(&amp;pool-&gt;idle_cull_work);</span><br><span class="line">	timer_delete_sync(&amp;pool-&gt;mayday_timer);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 使用 call_rcu 延迟销毁工作池，以确保在其他线程可能仍然引用该工作池时不会立即释放 */</span></span><br><span class="line">	call_rcu(&amp;pool-&gt;rcu, rcu_free_pool);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="get-unbound-pool-获取具有指定属性的工作池"><a href="#get-unbound-pool-获取具有指定属性的工作池" class="headerlink" title="get_unbound_pool 获取具有指定属性的工作池"></a>get_unbound_pool 获取具有指定属性的工作池</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* PL: hash of all unbound pools keyed by pool-&gt;attrs */</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">DEFINE_HASHTABLE</span><span class="params">(unbound_pool_hash, UNBOUND_POOL_HASH_ORDER)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**get_unbound_pool - 获取具有指定属性的工作池 </span></span><br><span class="line"><span class="comment"> * @attrs: 要获取的工作池的属性 </span></span><br><span class="line"><span class="comment"> * 获取具有与@attrs相同属性的工作池，增加引用计数并返回它。</span></span><br><span class="line"><span class="comment"> * 如果已经存在匹配的工作池，则将使用它；否则，此函数将尝试创建一个新的。 </span></span><br><span class="line"><span class="comment"> * 应在持有wq_pool_mutex时调用。 </span></span><br><span class="line"><span class="comment"> * 返回：成功时，返回一个具有与@attrs相同属性的工作池；失败时，返回%NULL。 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> worker_pool *<span class="title function_">get_unbound_pool</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> workqueue_attrs *attrs)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wq_pod_type</span> *<span class="title">pt</span> =</span> &amp;wq_pod_types[WQ_AFFN_NUMA];</span><br><span class="line">	u32 hash = wqattrs_hash(attrs);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span>;</span></span><br><span class="line">	<span class="type">int</span> pod, node = NUMA_NO_NODE;</span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(&amp;wq_pool_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*我们已经有一个匹配的池子了吗？*/</span></span><br><span class="line">	<span class="comment">/* 通过哈希表 unbound_pool_hash 查找是否有属性匹配的 pool，若找到则增加引用计数并返回 */</span></span><br><span class="line">	hash_for_each_possible(unbound_pool_hash, pool, hash_node, hash) &#123;</span><br><span class="line">		<span class="keyword">if</span> (wqattrs_equal(pool-&gt;attrs, attrs)) &#123;</span><br><span class="line">			pool-&gt;refcnt++;</span><br><span class="line">			<span class="keyword">return</span> pool;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*根据属性中的 pod cpumask 判断应该分配到哪个 NUMA 节点，并在该节点上分配新的 worker_pool 结构体*/</span></span><br><span class="line">	<span class="keyword">for</span> (pod = <span class="number">0</span>; pod &lt; pt-&gt;nr_pods; pod++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (cpumask_subset(attrs-&gt;__pod_cpumask, pt-&gt;pod_cpus[pod])) &#123;</span><br><span class="line">			node = pt-&gt;pod_node[pod];</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*不，创建一个新的*/</span></span><br><span class="line">	pool = kzalloc_node(<span class="keyword">sizeof</span>(*pool), GFP_KERNEL, node);</span><br><span class="line">	<span class="keyword">if</span> (!pool || init_worker_pool(pool) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">	pool-&gt;node = node;</span><br><span class="line">	copy_workqueue_attrs(pool-&gt;attrs, attrs);</span><br><span class="line">	wqattrs_clear_for_pool(pool-&gt;attrs);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (worker_pool_assign_id(pool) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 创建并启动初始工作线程 */</span></span><br><span class="line">	<span class="keyword">if</span> (wq_online &amp;&amp; !create_worker(pool))</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* install */</span></span><br><span class="line">	hash_add(unbound_pool_hash, &amp;pool-&gt;hash_node, hash);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pool;</span><br><span class="line">fail:</span><br><span class="line">	<span class="keyword">if</span> (pool)</span><br><span class="line">		put_unbound_pool(pool);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="alloc-unbound-pwq-用于根据给定的属性-attrs-获取一个合适的-worker-pool"><a href="#alloc-unbound-pwq-用于根据给定的属性-attrs-获取一个合适的-worker-pool" class="headerlink" title="alloc_unbound_pwq 用于根据给定的属性 attrs 获取一个合适的 worker pool"></a>alloc_unbound_pwq 用于根据给定的属性 attrs 获取一个合适的 worker pool</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取一个与 @attr 匹配的池，并创建一个将该池与 @wq 关联的 pwq */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> pool_workqueue *<span class="title function_">alloc_unbound_pwq</span><span class="params">(<span class="keyword">struct</span> workqueue_struct *wq,</span></span><br><span class="line"><span class="params">					<span class="type">const</span> <span class="keyword">struct</span> workqueue_attrs *attrs)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">pwq</span>;</span></span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(&amp;wq_pool_mutex);</span><br><span class="line"></span><br><span class="line">	pool = get_unbound_pool(attrs);	<span class="comment">//根据属性查找或创建一个不绑定到特定 CPU 的 worker pool</span></span><br><span class="line">	<span class="keyword">if</span> (!pool)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//使用 kmem_cache_alloc_node 在 pool 所在的 NUMA 节点上分配一个 pool_workqueue 结构体</span></span><br><span class="line">	pwq = kmem_cache_alloc_node(pwq_cache, GFP_KERNEL, pool-&gt;node);</span><br><span class="line">	<span class="keyword">if</span> (!pwq) &#123;</span><br><span class="line">		put_unbound_pool(pool);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	init_pwq(pwq, wq, pool);	<span class="comment">//调用 init_pwq 对新分配的 pool_workqueue 进行初始化</span></span><br><span class="line">	<span class="keyword">return</span> pwq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="apply-wqattrs-prepare-应用工作队列属性"><a href="#apply-wqattrs-prepare-应用工作队列属性" class="headerlink" title="apply_wqattrs_prepare 应用工作队列属性"></a>apply_wqattrs_prepare 应用工作队列属性</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 为后续安装分配属性和pwqs*/</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> apply_wqattrs_ctx *</span><br><span class="line"><span class="title function_">apply_wqattrs_prepare</span><span class="params">(<span class="keyword">struct</span> workqueue_struct *wq,</span></span><br><span class="line"><span class="params">		      <span class="type">const</span> <span class="keyword">struct</span> workqueue_attrs *attrs,</span></span><br><span class="line"><span class="params">		      <span class="type">const</span> <span class="type">cpumask_var_t</span> unbound_cpumask)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">apply_wqattrs_ctx</span> *<span class="title">ctx</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">workqueue_attrs</span> *<span class="title">new_attrs</span>;</span></span><br><span class="line">	<span class="type">int</span> cpu;</span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(&amp;wq_pool_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON(attrs-&gt;affn_scope &lt; <span class="number">0</span> ||</span><br><span class="line">		    attrs-&gt;affn_scope &gt;= WQ_AFFN_NR_TYPES))</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">	ctx = kzalloc(struct_size(ctx, pwq_tbl, nr_cpu_ids), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">	new_attrs = alloc_workqueue_attrs();</span><br><span class="line">	<span class="keyword">if</span> (!ctx || !new_attrs)</span><br><span class="line">		<span class="keyword">goto</span> out_free;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If something goes wrong during CPU up/down, we&#x27;ll fall back to</span></span><br><span class="line"><span class="comment">	 * the default pwq covering whole @attrs-&gt;cpumask.  Always create</span></span><br><span class="line"><span class="comment">	 * it even if we don&#x27;t use it immediately.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	copy_workqueue_attrs(new_attrs, attrs);</span><br><span class="line">	wqattrs_actualize_cpumask(new_attrs, unbound_cpumask);</span><br><span class="line">	cpumask_copy(new_attrs-&gt;__pod_cpumask, new_attrs-&gt;cpumask);</span><br><span class="line">	ctx-&gt;dfl_pwq = alloc_unbound_pwq(wq, new_attrs);</span><br><span class="line">	<span class="keyword">if</span> (!ctx-&gt;dfl_pwq)</span><br><span class="line">		<span class="keyword">goto</span> out_free;</span><br><span class="line"></span><br><span class="line">	for_each_possible_cpu(cpu) &#123;</span><br><span class="line">		<span class="keyword">if</span> (new_attrs-&gt;ordered) &#123;</span><br><span class="line">			ctx-&gt;dfl_pwq-&gt;refcnt++;</span><br><span class="line">			ctx-&gt;pwq_tbl[cpu] = ctx-&gt;dfl_pwq;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			wq_calc_pod_cpumask(new_attrs, cpu);</span><br><span class="line">			ctx-&gt;pwq_tbl[cpu] = alloc_unbound_pwq(wq, new_attrs);</span><br><span class="line">			<span class="keyword">if</span> (!ctx-&gt;pwq_tbl[cpu])</span><br><span class="line">				<span class="keyword">goto</span> out_free;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* save the user configured attrs and sanitize it. */</span></span><br><span class="line">	copy_workqueue_attrs(new_attrs, attrs);</span><br><span class="line">	cpumask_and(new_attrs-&gt;cpumask, new_attrs-&gt;cpumask, cpu_possible_mask);</span><br><span class="line">	cpumask_copy(new_attrs-&gt;__pod_cpumask, new_attrs-&gt;cpumask);</span><br><span class="line">	ctx-&gt;attrs = new_attrs;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * For initialized ordered workqueues, there should only be one pwq</span></span><br><span class="line"><span class="comment">	 * (dfl_pwq). Set the plugged flag of ctx-&gt;dfl_pwq to suspend execution</span></span><br><span class="line"><span class="comment">	 * of newly queued work items until execution of older work items in</span></span><br><span class="line"><span class="comment">	 * the old pwq&#x27;s have completed.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((wq-&gt;flags &amp; __WQ_ORDERED) &amp;&amp; !list_empty(&amp;wq-&gt;pwqs))</span><br><span class="line">		ctx-&gt;dfl_pwq-&gt;plugged = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	ctx-&gt;wq = wq;</span><br><span class="line">	<span class="keyword">return</span> ctx;</span><br><span class="line"></span><br><span class="line">out_free:</span><br><span class="line">	free_workqueue_attrs(new_attrs);</span><br><span class="line">	apply_wqattrs_cleanup(ctx);</span><br><span class="line">	<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="apply-wqattrs-commit-应用新的工作队列属性（wqattrs），并将准备好的-pwqs（per-CPU-workqueues）安装到工作队列中"><a href="#apply-wqattrs-commit-应用新的工作队列属性（wqattrs），并将准备好的-pwqs（per-CPU-workqueues）安装到工作队列中" class="headerlink" title="apply_wqattrs_commit 应用新的工作队列属性（wqattrs），并将准备好的 pwqs（per-CPU workqueues）安装到工作队列中"></a>apply_wqattrs_commit 应用新的工作队列属性（wqattrs），并将准备好的 pwqs（per-CPU workqueues）安装到工作队列中</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* set attrs and install prepared pwqs, @ctx points to old pwqs on return */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">apply_wqattrs_commit</span><span class="params">(<span class="keyword">struct</span> apply_wqattrs_ctx *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> cpu;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* all pwqs have been created successfully, let&#x27;s install&#x27;em */</span></span><br><span class="line">	mutex_lock(&amp;ctx-&gt;wq-&gt;mutex);</span><br><span class="line"></span><br><span class="line">	copy_workqueue_attrs(ctx-&gt;wq-&gt;unbound_attrs, ctx-&gt;attrs);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* save the previous pwqs and install the new ones */</span></span><br><span class="line">	for_each_possible_cpu(cpu)</span><br><span class="line">		<span class="comment">/* 为每个 CPU 安装新的工作队列 */</span></span><br><span class="line">		ctx-&gt;pwq_tbl[cpu] = install_unbound_pwq(ctx-&gt;wq, cpu,</span><br><span class="line">							ctx-&gt;pwq_tbl[cpu]);</span><br><span class="line">	<span class="comment">/* 为默认工作队列（ctx-&gt;dfl_pwq）安装新的配置 */</span></span><br><span class="line">	ctx-&gt;dfl_pwq = install_unbound_pwq(ctx-&gt;wq, <span class="number">-1</span>, ctx-&gt;dfl_pwq);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 更新工作队列节点的最大活动工作项数 */</span></span><br><span class="line">	wq_update_node_max_active(ctx-&gt;wq, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 更新救援线程的 CPU 掩码，使其符合新的工作队列配置*/</span></span><br><span class="line">	<span class="keyword">if</span> (ctx-&gt;wq-&gt;rescuer)</span><br><span class="line">		set_cpus_allowed_ptr(ctx-&gt;wq-&gt;rescuer-&gt;task,</span><br><span class="line">				     unbound_effective_cpumask(ctx-&gt;wq));</span><br><span class="line"></span><br><span class="line">	mutex_unlock(&amp;ctx-&gt;wq-&gt;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="apply-workqueue-attrs-locked-在加锁状态下为-workqueue（工作队列）应用新的属性"><a href="#apply-workqueue-attrs-locked-在加锁状态下为-workqueue（工作队列）应用新的属性" class="headerlink" title="apply_workqueue_attrs_locked 在加锁状态下为 workqueue（工作队列）应用新的属性"></a>apply_workqueue_attrs_locked 在加锁状态下为 workqueue（工作队列）应用新的属性</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">apply_workqueue_attrs_locked</span><span class="params">(<span class="keyword">struct</span> workqueue_struct *wq,</span></span><br><span class="line"><span class="params">					<span class="type">const</span> <span class="keyword">struct</span> workqueue_attrs *attrs)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">apply_wqattrs_ctx</span> *<span class="title">ctx</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 只有未绑定的工作队列才能更改属性 */</span></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON(!(wq-&gt;flags &amp; WQ_UNBOUND)))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="comment">//为属性变更做准备工作</span></span><br><span class="line">	ctx = apply_wqattrs_prepare(wq, attrs, wq_unbound_cpumask);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(ctx))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(ctx);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 上下文已经成功准备，接下来我们来提交它 */</span></span><br><span class="line">	apply_wqattrs_commit(ctx);		<span class="comment">//提交属性变更</span></span><br><span class="line">	apply_wqattrs_cleanup(ctx);		<span class="comment">//清理相关资源</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="alloc-and-link-pwqs-分配并链接工作队列池（PWQ）"><a href="#alloc-and-link-pwqs-分配并链接工作队列池（PWQ）" class="headerlink" title="alloc_and_link_pwqs  分配并链接工作队列池（PWQ）"></a>alloc_and_link_pwqs  分配并链接工作队列池（PWQ）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">alloc_and_link_pwqs</span><span class="params">(<span class="keyword">struct</span> workqueue_struct *wq)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">bool</span> highpri = wq-&gt;flags &amp; WQ_HIGHPRI;</span><br><span class="line">	<span class="type">int</span> cpu, ret;</span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(&amp;wq_pool_mutex);</span><br><span class="line"></span><br><span class="line">	wq-&gt;cpu_pwq = alloc_percpu(<span class="keyword">struct</span> pool_workqueue *);</span><br><span class="line">	<span class="keyword">if</span> (!wq-&gt;cpu_pwq)</span><br><span class="line">		<span class="keyword">goto</span> enomem;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 表示这是一个绑定型工作队列，任务需要绑定到特定的 CPU 上执行。只有在这种情况下，代码才会继续执行后续逻辑。 */</span></span><br><span class="line">	<span class="keyword">if</span> (!(wq-&gt;flags &amp; WQ_UNBOUND)) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> __<span class="title">percpu</span> *<span class="title">pools</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (wq-&gt;flags &amp; WQ_BH)</span><br><span class="line">			pools = bh_worker_pools;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			pools = cpu_worker_pools;</span><br><span class="line"></span><br><span class="line">		for_each_possible_cpu(cpu) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> **<span class="title">pwq_p</span>;</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span>;</span></span><br><span class="line"></span><br><span class="line">			pool = &amp;(per_cpu_ptr(pools, cpu)[highpri]);</span><br><span class="line">			pwq_p = per_cpu_ptr(wq-&gt;cpu_pwq, cpu);</span><br><span class="line"></span><br><span class="line">			*pwq_p = kmem_cache_alloc_node(pwq_cache, GFP_KERNEL,</span><br><span class="line">						       pool-&gt;node);</span><br><span class="line">			<span class="keyword">if</span> (!*pwq_p)</span><br><span class="line">				<span class="keyword">goto</span> enomem;</span><br><span class="line"></span><br><span class="line">			init_pwq(*pwq_p, wq, pool);</span><br><span class="line"></span><br><span class="line">			mutex_lock(&amp;wq-&gt;mutex);</span><br><span class="line">			link_pwq(*pwq_p);</span><br><span class="line">			mutex_unlock(&amp;wq-&gt;mutex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (wq-&gt;flags &amp; __WQ_ORDERED) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">dfl_pwq</span>;</span></span><br><span class="line"></span><br><span class="line">		ret = apply_workqueue_attrs_locked(wq, ordered_wq_attrs[highpri]);</span><br><span class="line">		<span class="comment">/* there should only be single pwq for ordering guarantee */</span></span><br><span class="line">		dfl_pwq = rcu_access_pointer(wq-&gt;dfl_pwq);</span><br><span class="line">		WARN(!ret &amp;&amp; (wq-&gt;pwqs.next != &amp;dfl_pwq-&gt;pwqs_node ||</span><br><span class="line">			      wq-&gt;pwqs.prev != &amp;dfl_pwq-&gt;pwqs_node),</span><br><span class="line">		     <span class="string">&quot;ordering guarantee broken for workqueue %s\n&quot;</span>, wq-&gt;name);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ret = apply_workqueue_attrs_locked(wq, unbound_std_wq_attrs[highpri]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">enomem:</span><br><span class="line">	<span class="keyword">if</span> (wq-&gt;cpu_pwq) &#123;</span><br><span class="line">		for_each_possible_cpu(cpu) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">pwq</span> =</span> *per_cpu_ptr(wq-&gt;cpu_pwq, cpu);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (pwq)</span><br><span class="line">				kmem_cache_free(pwq_cache, pwq);</span><br><span class="line">		&#125;</span><br><span class="line">		free_percpu(wq-&gt;cpu_pwq);</span><br><span class="line">		wq-&gt;cpu_pwq = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="alloc-workqueue-分配工作队列"><a href="#alloc-workqueue-分配工作队列" class="headerlink" title="alloc_workqueue 分配工作队列"></a>alloc_workqueue 分配工作队列</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line">__printf(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *__<span class="title">alloc_workqueue</span>(<span class="title">const</span> <span class="title">char</span> *<span class="title">fmt</span>,</span></span><br><span class="line"><span class="class">						  <span class="title">unsigned</span> <span class="title">int</span> <span class="title">flags</span>,</span></span><br><span class="line"><span class="class">						  <span class="title">int</span> <span class="title">max_active</span>, <span class="title">va_list</span> <span class="title">args</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">wq</span>;</span></span><br><span class="line">	<span class="type">size_t</span> wq_size;</span><br><span class="line">	<span class="type">int</span> name_len;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; WQ_BH) &#123;</span><br><span class="line">		<span class="keyword">if</span> (WARN_ON_ONCE(flags &amp; ~__WQ_BH_ALLOWS))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">if</span> (WARN_ON_ONCE(max_active))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 请参阅上面的注释 WQ_POWER_EFFICIENT 的定义 */</span></span><br><span class="line">	<span class="keyword">if</span> ((flags &amp; WQ_POWER_EFFICIENT) &amp;&amp; wq_power_efficient)</span><br><span class="line">		flags |= WQ_UNBOUND;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 	 */</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; WQ_UNBOUND)</span><br><span class="line">		wq_size = struct_size(wq, node_nr_active, nr_node_ids + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		wq_size = <span class="keyword">sizeof</span>(*wq);</span><br><span class="line"></span><br><span class="line">	wq = kzalloc(wq_size, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!wq)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; WQ_UNBOUND) &#123;</span><br><span class="line">		wq-&gt;unbound_attrs = alloc_workqueue_attrs();</span><br><span class="line">		<span class="keyword">if</span> (!wq-&gt;unbound_attrs)</span><br><span class="line">			<span class="keyword">goto</span> err_free_wq;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	name_len = vsnprintf(wq-&gt;name, <span class="keyword">sizeof</span>(wq-&gt;name), fmt, args);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (name_len &gt;= WQ_NAME_LEN)</span><br><span class="line">		pr_warn_once(<span class="string">&quot;workqueue: name exceeds WQ_NAME_LEN. Truncating to: %s\n&quot;</span>,</span><br><span class="line">			     wq-&gt;name);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; WQ_BH) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * BH workqueues always share a single execution context per CPU</span></span><br><span class="line"><span class="comment">		 * and don&#x27;t impose any max_active limit.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		max_active = INT_MAX;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		max_active = max_active ?: WQ_DFL_ACTIVE;</span><br><span class="line">		max_active = wq_clamp_max_active(max_active, flags, wq-&gt;name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* init wq */</span></span><br><span class="line">	wq-&gt;flags = flags;</span><br><span class="line">	wq-&gt;max_active = max_active;</span><br><span class="line">	wq-&gt;min_active = min(max_active, WQ_DFL_MIN_ACTIVE);</span><br><span class="line">	wq-&gt;saved_max_active = wq-&gt;max_active;</span><br><span class="line">	wq-&gt;saved_min_active = wq-&gt;min_active;</span><br><span class="line">	mutex_init(&amp;wq-&gt;mutex);</span><br><span class="line">	<span class="type">atomic_set</span>(&amp;wq-&gt;nr_pwqs_to_flush, <span class="number">0</span>);	<span class="comment">//工作队列需要刷新多少个 pwq</span></span><br><span class="line">	INIT_LIST_HEAD(&amp;wq-&gt;pwqs);				<span class="comment">//工作队列池列表</span></span><br><span class="line">	INIT_LIST_HEAD(&amp;wq-&gt;flusher_queue);		<span class="comment">//刷新队列</span></span><br><span class="line">	INIT_LIST_HEAD(&amp;wq-&gt;flusher_overflow);	<span class="comment">//溢出刷新队列</span></span><br><span class="line">	INIT_LIST_HEAD(&amp;wq-&gt;maydays);			<span class="comment">//工作池的紧急任务列表</span></span><br><span class="line"></span><br><span class="line">	INIT_LIST_HEAD(&amp;wq-&gt;<span class="built_in">list</span>);</span><br><span class="line">	<span class="comment">/* 包含 WQ_UNBOUND 标志，表示这是一个无绑定的工作队列（可能不绑定到特定 CPU） */</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; WQ_UNBOUND) &#123;</span><br><span class="line">		<span class="keyword">if</span> (alloc_node_nr_active(wq-&gt;node_nr_active) &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> err_free_wq;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * wq_pool_mutex 保护工作队列列表、PWQ 分配和全局冻结状态。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	apply_wqattrs_lock();	<span class="comment">//mutex_lock(&amp;wq_pool_mutex);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*  分配并链接工作队列池（PWQ） */</span></span><br><span class="line">	<span class="keyword">if</span> (alloc_and_link_pwqs(wq) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> err_unlock_free_node_nr_active;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;wq-&gt;mutex);</span><br><span class="line">	<span class="comment">/*  调整工作队列的最大活动任务数，确保其符合当前的配置或状态 */</span></span><br><span class="line">	wq_adjust_max_active(wq);</span><br><span class="line">	mutex_unlock(&amp;wq-&gt;mutex);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 将新创建的工作队列（wq）添加到全局工作队列列表（workqueues）的尾部 */</span></span><br><span class="line">	list_add_tail_rcu(&amp;wq-&gt;<span class="built_in">list</span>, &amp;workqueues);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化救援线程（rescuer thread）。救</span></span><br><span class="line"><span class="comment">	援线程用于处理工作队列中可能被阻塞的任务，确保系统不会因为资源不足而陷入死锁。 */</span></span><br><span class="line">	<span class="keyword">if</span> (wq_online &amp;&amp; init_rescuer(wq) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> err_unlock_destroy;</span><br><span class="line"></span><br><span class="line">	apply_wqattrs_unlock();	<span class="comment">/* mutex_unlock(&amp;wq_pool_mutex); */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 调用 workqueue_sysfs_register(wq) 将工作队列注册到 sysfs（系统文件系统）。sysfs 是 Linux 内核提供的一种虚拟文件系统，用于向用户空间暴露内核对象。 */</span></span><br><span class="line">	<span class="keyword">if</span> ((wq-&gt;flags &amp; WQ_SYSFS) &amp;&amp; workqueue_sysfs_register(wq))</span><br><span class="line">		<span class="keyword">goto</span> err_destroy;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> wq;</span><br><span class="line"></span><br><span class="line">err_unlock_free_node_nr_active:</span><br><span class="line">	apply_wqattrs_unlock();</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Failed alloc_and_link_pwqs() may leave pending pwq-&gt;release_work,</span></span><br><span class="line"><span class="comment">	 * flushing the pwq_release_worker ensures that the pwq_release_workfn()</span></span><br><span class="line"><span class="comment">	 * completes before calling kfree(wq).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (wq-&gt;flags &amp; WQ_UNBOUND) &#123;</span><br><span class="line">		kthread_flush_worker(pwq_release_worker);</span><br><span class="line">		free_node_nr_active(wq-&gt;node_nr_active);</span><br><span class="line">	&#125;</span><br><span class="line">err_free_wq:</span><br><span class="line">	free_workqueue_attrs(wq-&gt;unbound_attrs);</span><br><span class="line">	kfree(wq);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">err_unlock_destroy:</span><br><span class="line">	apply_wqattrs_unlock();</span><br><span class="line">err_destroy:</span><br><span class="line">	destroy_workqueue(wq);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__printf(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">struct</span> workqueue_struct *<span class="title function_">alloc_workqueue</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt,</span></span><br><span class="line"><span class="params">					 <span class="type">unsigned</span> <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">					 <span class="type">int</span> max_active, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">wq</span>;</span></span><br><span class="line">	va_list args;</span><br><span class="line"></span><br><span class="line">	va_start(args, max_active);</span><br><span class="line">	wq = __alloc_workqueue(fmt, flags, max_active, args);</span><br><span class="line">	va_end(args);</span><br><span class="line">	<span class="keyword">if</span> (!wq)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	wq_init_lockdep(wq);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> wq;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(alloc_workqueue);</span><br></pre></td></tr></table></figure>

<h2 id="workqueue-init-early-工作队初始化"><a href="#workqueue-init-early-工作队初始化" class="headerlink" title="workqueue_init_early 工作队初始化"></a>workqueue_init_early 工作队初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> for_each_bh_worker_pool(pool, cpu)				\</span></span><br><span class="line"><span class="meta">	for ((pool) = &amp;per_cpu(bh_worker_pools, cpu)[0];		\</span></span><br><span class="line"><span class="meta">	     (pool) &lt; &amp;per_cpu(bh_worker_pools, cpu)[NR_STD_WORKER_POOLS]; \</span></span><br><span class="line"><span class="meta">	     (pool)++)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> for_each_cpu_worker_pool(pool, cpu)				\</span></span><br><span class="line"><span class="meta">	for ((pool) = &amp;per_cpu(cpu_worker_pools, cpu)[0];		\</span></span><br><span class="line"><span class="meta">	     (pool) &lt; &amp;per_cpu(cpu_worker_pools, cpu)[NR_STD_WORKER_POOLS]; \</span></span><br><span class="line"><span class="meta">	     (pool)++)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">1. 函数目的与调用时机</span></span><br><span class="line"><span class="comment">该函数在内核启动的早期阶段调用，当内存分配、CPU 掩码（cpumasks）和 IDR（ID 分配器）等基础设施已经准备就绪时执行。它的主要任务是：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">初始化工作队列的核心数据结构。</span></span><br><span class="line"><span class="comment">创建系统级工作队列。</span></span><br><span class="line"><span class="comment">允许早期引导代码创建工作队列并排队或取消工作项。</span></span><br><span class="line"><span class="comment">需要注意的是，实际的工作项执行要等到内核线程（kthreads）可以被创建和调度时才会开始。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">workqueue_init_early</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*  wq_pod_types 是一个全局数组，存储了不同类型的工作队列 Pods 的配置。</span></span><br><span class="line"><span class="comment">        WQ_AFFN_SYSTEM 表示系统级的工作队列 Pods。</span></span><br><span class="line"><span class="comment">        该变量的作用是为系统级工作队列 Pods 的初始化提供一个入口点。 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wq_pod_type</span> *<span class="title">pt</span> =</span> &amp;wq_pod_types[WQ_AFFN_SYSTEM];</span><br><span class="line">    <span class="comment">/* 定义了标准工作池（worker pool）的默认优先级（nice 值） </span></span><br><span class="line"><span class="comment">    数组的初始化值为 &#123; 0, HIGHPRI_NICE_LEVEL &#125;：</span></span><br><span class="line"><span class="comment">        0 表示普通优先级（默认优先级）。</span></span><br><span class="line"><span class="comment">        HIGHPRI_NICE_LEVEL 表示高优先级，用于高优先级工作队列。*/</span></span><br><span class="line">	<span class="type">int</span> std_nice[NR_STD_WORKER_POOLS] = &#123; <span class="number">0</span>, HIGHPRI_NICE_LEVEL &#125;;</span><br><span class="line">    <span class="comment">/* bh_pool_kick_normal 是用于普通优先级中断工作的处理函数。</span></span><br><span class="line"><span class="comment">        bh_pool_kick_highpri 是用于高优先级中断工作的处理函数。</span></span><br><span class="line"><span class="comment">        这些函数在初始化底半部（BH，Bottom Half）工作池时被调用，用于设置中断工作处理逻辑 */</span></span><br><span class="line">	<span class="type">void</span> (*irq_work_fns[<span class="number">2</span>])(<span class="keyword">struct</span> irq_work *) = &#123; bh_pool_kick_normal,</span><br><span class="line">						       bh_pool_kick_highpri &#125;;</span><br><span class="line">	<span class="type">int</span> i, cpu;</span><br><span class="line"></span><br><span class="line">	pwq_cache = KMEM_CACHE(pool_workqueue, SLAB_PANIC); <span class="comment">//分配工作队列缓存</span></span><br><span class="line"></span><br><span class="line">	unbound_wq_update_pwq_attrs_buf = alloc_workqueue_attrs();  <span class="comment">//attrs = kzalloc(sizeof(*attrs), GFP_KERNEL);</span></span><br><span class="line">	BUG_ON(!unbound_wq_update_pwq_attrs_buf);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* initialize WQ_AFFN_SYSTEM pods */</span></span><br><span class="line">	pt-&gt;pod_cpus = kcalloc(<span class="number">1</span>, <span class="keyword">sizeof</span>(pt-&gt;pod_cpus[<span class="number">0</span>]), GFP_KERNEL);         <span class="comment">//用于存储与 Pod 关联的 CPU 掩码</span></span><br><span class="line">	pt-&gt;pod_node = kcalloc(<span class="number">1</span>, <span class="keyword">sizeof</span>(pt-&gt;pod_node[<span class="number">0</span>]), GFP_KERNEL);         <span class="comment">//用于存储与 Pod 关联的 NUMA 节点。</span></span><br><span class="line">	pt-&gt;cpu_pod = kcalloc(nr_cpu_ids, <span class="keyword">sizeof</span>(pt-&gt;cpu_pod[<span class="number">0</span>]), GFP_KERNEL);  <span class="comment">//用于存储每个 CPU 所属的 Pod 索引。</span></span><br><span class="line">	BUG_ON(!pt-&gt;pod_cpus || !pt-&gt;pod_node || !pt-&gt;cpu_pod);</span><br><span class="line"></span><br><span class="line">	pt-&gt;nr_pods = <span class="number">1</span>;</span><br><span class="line">	cpumask_copy(pt-&gt;pod_cpus[<span class="number">0</span>], cpu_possible_mask);</span><br><span class="line">	pt-&gt;pod_node[<span class="number">0</span>] = NUMA_NO_NODE;</span><br><span class="line">	pt-&gt;cpu_pod[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* initialize BH and CPU pools */</span></span><br><span class="line">	for_each_possible_cpu(cpu) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span>;</span></span><br><span class="line"></span><br><span class="line">		i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/*  初始化底半部（BH）工作池 */</span></span><br><span class="line">		for_each_bh_worker_pool(pool, cpu) &#123;</span><br><span class="line">			init_cpu_worker_pool(pool, cpu, std_nice[i]);<span class="comment">/* 设置其优先级 */</span></span><br><span class="line">			pool-&gt;flags |= POOL_BH;<span class="comment">/* 设置工作池的标志位，表明这是一个底半部工作池 */</span></span><br><span class="line">			init_irq_work(bh_pool_irq_work(pool), irq_work_fns[i]);<span class="comment">/* 初始化与中断相关的工作机制，指定中断处理函数 */</span></span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* 初始化普通 CPU 工作池 */</span></span><br><span class="line">		for_each_cpu_worker_pool(pool, cpu)</span><br><span class="line">			init_cpu_worker_pool(pool, cpu, std_nice[i++]); <span class="comment">/* 设置其优先级 */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 创建默认的未绑定和有序 WQ attrs*/</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NR_STD_WORKER_POOLS; i++) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">workqueue_attrs</span> *<span class="title">attrs</span>;</span></span><br><span class="line"></span><br><span class="line">		BUG_ON(!(attrs = alloc_workqueue_attrs()));</span><br><span class="line">		attrs-&gt;nice = std_nice[i];</span><br><span class="line">		unbound_std_wq_attrs[i] = attrs;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 有序的 wq 应该只有一个 pwq，因为 ordered 由 max_active 保证，而 pwqs 强制执行。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		BUG_ON(!(attrs = alloc_workqueue_attrs()));</span><br><span class="line">		attrs-&gt;nice = std_nice[i];</span><br><span class="line">		attrs-&gt;ordered = <span class="literal">true</span>;</span><br><span class="line">		ordered_wq_attrs[i] = attrs;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* system_wq: 默认的工作队列，用于普通的异步任务。</span></span><br><span class="line"><span class="comment">	system_highpri_wq: 高优先级工作队列，用于需要更高调度优先级的任务。</span></span><br><span class="line"><span class="comment">	system_long_wq: 用于长时间运行的任务，避免阻塞其他短时任务。</span></span><br><span class="line"><span class="comment">	system_unbound_wq: 非绑定工作队列，任务可以在任意 CPU 上运行，适用于不需要 CPU 亲和性的任务。</span></span><br><span class="line"><span class="comment">	system_freezable_wq: 可冻结的工作队列，在系统挂起时可以被冻结。</span></span><br><span class="line"><span class="comment">	system_power_efficient_wq: 节能工作队列，任务调度时优先考虑能耗优化。</span></span><br><span class="line"><span class="comment">	system_freezable_power_efficient_wq: 结合了可冻结和节能特性的工作队列。</span></span><br><span class="line"><span class="comment">	system_bh_wq: 底半部（Bottom Half）工作队列，用于处理软中断相关任务。</span></span><br><span class="line"><span class="comment">	system_bh_highpri_wq: 高优先级的底半部工作队列，用于需要快速响应的软中断任务。 */</span></span><br><span class="line">	system_wq = alloc_workqueue(<span class="string">&quot;events&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	system_highpri_wq = alloc_workqueue(<span class="string">&quot;events_highpri&quot;</span>, WQ_HIGHPRI, <span class="number">0</span>);</span><br><span class="line">	system_long_wq = alloc_workqueue(<span class="string">&quot;events_long&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	system_unbound_wq = alloc_workqueue(<span class="string">&quot;events_unbound&quot;</span>, WQ_UNBOUND,</span><br><span class="line">					    WQ_MAX_ACTIVE);</span><br><span class="line">	system_freezable_wq = alloc_workqueue(<span class="string">&quot;events_freezable&quot;</span>,</span><br><span class="line">					      WQ_FREEZABLE, <span class="number">0</span>);</span><br><span class="line">	system_power_efficient_wq = alloc_workqueue(<span class="string">&quot;events_power_efficient&quot;</span>,</span><br><span class="line">					      WQ_POWER_EFFICIENT, <span class="number">0</span>);</span><br><span class="line">	system_freezable_power_efficient_wq = alloc_workqueue(<span class="string">&quot;events_freezable_pwr_efficient&quot;</span>,</span><br><span class="line">					      WQ_FREEZABLE | WQ_POWER_EFFICIENT,</span><br><span class="line">					      <span class="number">0</span>);</span><br><span class="line">	system_bh_wq = alloc_workqueue(<span class="string">&quot;events_bh&quot;</span>, WQ_BH, <span class="number">0</span>);</span><br><span class="line">	system_bh_highpri_wq = alloc_workqueue(<span class="string">&quot;events_bh_highpri&quot;</span>,</span><br><span class="line">					       WQ_BH | WQ_HIGHPRI, <span class="number">0</span>);</span><br><span class="line">	BUG_ON(!system_wq || !system_highpri_wq || !system_long_wq ||</span><br><span class="line">	       !system_unbound_wq || !system_freezable_wq ||</span><br><span class="line">	       !system_power_efficient_wq ||</span><br><span class="line">	       !system_freezable_power_efficient_wq ||</span><br><span class="line">	       !system_bh_wq || !system_bh_highpri_wq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="for-each-pool-遍历工作池"><a href="#for-each-pool-遍历工作池" class="headerlink" title="for_each_pool 遍历工作池"></a>for_each_pool 遍历工作池</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * for_each_pool - 遍历系统中的所有工作池 </span></span><br><span class="line"><span class="comment"> * @pool: 迭代游标 * @pi: 用于迭代的整数 * </span></span><br><span class="line"><span class="comment"> * 这必须在持有 wq_pool_mutex 或 RCU 读锁的情况下调用。如果池需要在生效的锁定之外使用，调用者有责任确保池保持在线。 * </span></span><br><span class="line"><span class="comment"> * if/else 条件仅用于 lockdep 断言，可以忽略。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> for_each_pool(pool, pi)						\</span></span><br><span class="line"><span class="meta">	idr_for_each_entry(&amp;worker_pool_idr, pool, pi)			\</span></span><br><span class="line"><span class="meta">		<span class="keyword">if</span> ((&#123; assert_rcu_or_pool_mutex(); false; &#125;)) &#123; &#125;	\</span></span><br><span class="line"><span class="meta">		<span class="keyword">else</span></span></span><br></pre></td></tr></table></figure>

<h2 id="is-chained-work-判断当前工作项是否是由同一工作队列执行的另一个工作项触发"><a href="#is-chained-work-判断当前工作项是否是由同一工作队列执行的另一个工作项触发" class="headerlink" title="is_chained_work 判断当前工作项是否是由同一工作队列执行的另一个工作项触发"></a>is_chained_work 判断当前工作项是否是由同一工作队列执行的另一个工作项触发</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 用于判断当前工作项是否是由同一工作队列（workqueue_struct）中的另一个工作项触发的。</span></span><br><span class="line"><span class="comment"> * 这种情况通常被称为“链式工作”（chained work），即一个工作项在执行过程中将另一个工作项添加到同一工作队列中。。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">is_chained_work</span><span class="params">(<span class="keyword">struct</span> workqueue_struct *wq)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">worker</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 获取当前正在执行工作的线程 */</span></span><br><span class="line">	worker = current_wq_worker();</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * worker 是否非空，确保当前线程是一个工作线程</span></span><br><span class="line"><span class="comment">	 * 当前线程是否正在执行属于该工作队列的工作项</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> worker &amp;&amp; worker-&gt;current_pwq-&gt;wq == wq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="work-struct-pwq-将工作项的-data-字段转换为-pool-workqueue"><a href="#work-struct-pwq-将工作项的-data-字段转换为-pool-workqueue" class="headerlink" title="work_struct_pwq 将工作项的 data 字段转换为 pool_workqueue"></a>work_struct_pwq 将工作项的 data 字段转换为 pool_workqueue</h2><ul>
<li>该函数用于从工作项的 data 字段中提取与之关联的工作池（pool_workqueue）。</li>
<li>该函数假设 data 字段包含了一个指向 pool_workqueue 的指针，并且使用 WORK_STRUCT_PWQ_MASK 进行掩码操作。</li>
<li>注意：此函数仅在工作项确实与一个 pool_workqueue 相关联时才有效。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> pool_workqueue *<span class="title function_">work_struct_pwq</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">struct</span> pool_workqueue *)(data &amp; WORK_STRUCT_PWQ_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="get-work-pool-返回与给定作品关联的worker-pool"><a href="#get-work-pool-返回与给定作品关联的worker-pool" class="headerlink" title="get_work_pool 返回与给定作品关联的worker_pool"></a>get_work_pool 返回与给定作品关联的worker_pool</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * get_work_pool - 返回与给定作品关联的worker_pool</span></span><br><span class="line"><span class="comment"> * @work：感兴趣的工作项</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 池在 wq_pool_mutex 下创建和销毁，并允许在 RCU 读取锁定下进行读取访问。 因此，应在 wq_pool_mutex 或 rcu_read_lock（） 区域内调用此函数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 只要上述锁定有效，就可以访问返回的池的所有字段。 如果需要在关键部分之外使用返回的池，则调用方负责确保返回的池处于联机状态并保持联机状态。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回：上次关联的worker_pool @work。 %NULL 如果无。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> worker_pool *<span class="title function_">get_work_pool</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 该字段包含了工作项的状态信息以及与工作池相关的标识 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> data = atomic_long_read(&amp;work-&gt;data);</span><br><span class="line">	<span class="type">int</span> pool_id;</span><br><span class="line"></span><br><span class="line">	assert_rcu_or_pool_mutex();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 包含 WORK_STRUCT_PWQ 标志，则表示工作项直接关联到一个 pool_workqueue */</span></span><br><span class="line">	<span class="keyword">if</span> (data &amp; WORK_STRUCT_PWQ)</span><br><span class="line">		<span class="keyword">return</span> work_struct_pwq(data)-&gt;pool;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 从 data 字段中提取工作池 ID */</span></span><br><span class="line">	pool_id = data &gt;&gt; WORK_OFFQ_POOL_SHIFT;</span><br><span class="line">	<span class="comment">/* 表示工作项未关联到任何工作池 */</span></span><br><span class="line">	<span class="keyword">if</span> (pool_id == WORK_OFFQ_POOL_NONE)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">/* worker_pool_idr 是一个 ID 映射表，用于管理工作池的生命周期 */</span></span><br><span class="line">	<span class="keyword">return</span> idr_find(&amp;worker_pool_idr, pool_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="find-worker-executing-work-查找正在执行工作的-worker"><a href="#find-worker-executing-work-查找正在执行工作的-worker" class="headerlink" title="find_worker_executing_work 查找正在执行工作的 worker"></a>find_worker_executing_work 查找正在执行工作的 worker</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * find_worker_executing_work - 查找正在执行工作的 worker</span></span><br><span class="line"><span class="comment"> * @pool：兴趣池</span></span><br><span class="line"><span class="comment"> * @work：寻找工人的工作</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 通过搜索 @pool-&gt;busy_hash（以 @work 地址为键），找到在 @pool 上执行@work的 worker。</span></span><br><span class="line"><span class="comment"> * 要使 worker 匹配，其当前执行应与 @work 的地址及其 work function 匹配。 </span></span><br><span class="line"><span class="comment"> * 这是为了避免不相关的工作执行之间不必要的依赖关系，因为在执行时回收工作项。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这有点棘手。 工作项的执行开始后，可以释放该工作项，并且没有什么可以阻止释放的区域被回收用于另一个工作项。 * 如果相同的工作项地址在原始执行完成之前被重复使用，workqueue 会将回收的工作项标识为当前正在执行，</span></span><br><span class="line"><span class="comment"> * 并使其等待当前执行完成，从而引入不需要的依赖关系。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 该函数会检查工作项地址和工作函数，避免误报。 </span></span><br><span class="line"><span class="comment"> * 请注意，这并不完整，因为可能会构造一个工作函数，该函数可以通过回收的工作项引入对自身的依赖。</span></span><br><span class="line"><span class="comment"> * 好吧，如果有人想那么狠地搬起石头砸自己的脚，我们能做的就只有这么多了，</span></span><br><span class="line"><span class="comment"> * 如果这样的僵局真的发生，应该很容易找到罪魁祸首。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *上下文：</span></span><br><span class="line"><span class="comment"> * raw_spin_lock_irq（pool-&gt;lock）.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *返回：</span></span><br><span class="line"><span class="comment"> * 指向正在执行的 worker 的指针 @work如果找到，否则为 %NULL。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> worker *<span class="title function_">find_worker_executing_work</span><span class="params">(<span class="keyword">struct</span> worker_pool *pool,</span></span><br><span class="line"><span class="params">						 <span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">worker</span>;</span></span><br><span class="line"></span><br><span class="line">	hash_for_each_possible(pool-&gt;busy_hash, worker, hentry,</span><br><span class="line">			       (<span class="type">unsigned</span> <span class="type">long</span>)work)</span><br><span class="line">		<span class="keyword">if</span> (worker-&gt;current_work == work &amp;&amp;</span><br><span class="line">		    worker-&gt;current_func == work-&gt;func)</span><br><span class="line">			<span class="keyword">return</span> worker;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="set-work-data-设置工作项的-data-字段"><a href="#set-work-data-设置工作项的-data-字段" class="headerlink" title="set_work_data 设置工作项的 data 字段"></a>set_work_data 设置工作项的 data 字段</h2><ol>
<li>队列状态：<ul>
<li>当工作项被排队时，WORK_STRUCT_PWQ 标志位被设置，表示工作项已关联到一个工作队列（pwq）。</li>
<li>此时，data 的非标志位部分存储指向队列的指针（pwq）。</li>
<li>一旦工作项开始执行，WORK_STRUCT_PWQ 标志位被清除，data 的高位部分存储脱队（OFFQ）标志和工作池 ID。</li>
</ul>
</li>
<li>状态设置函数：<ul>
<li>set_work_pwq()、set_work_pool_and_clear_pending() 和 mark_work_canceling() 是用于设置工作项状态的函数。这些函数可以设置工作队列（pwq）、工作池（pool）或清除 work-&gt;data。</li>
<li>这些函数只能在工作项被“拥有”（即 PENDING 位被设置）时调用，确保工作项的状态不会被其他线程竞争修改。</li>
</ul>
</li>
<li>状态获取函数：<ul>
<li>get_work_pool() 和 get_work_pwq() 用于获取工作项关联的工作池或工作队列。</li>
<li>工作池信息在工作项被排队后一直可用，直到工作项被同步取消。</li>
<li>工作队列信息仅在工作项处于队列中时可用。</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 排队时，%WORK_STRUCT_PWQ 被设置，并且作品数据的非标志位包含指向排队 pwq 的指针。 执行开始后，标志将被清除，高位包含 OFFQ 标志和池 ID。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * set_work_pwq（）、set_work_pool_and_clear_pending（） 和 mark_work_canceling（） 可用于设置 pwq、pool 或清除 work-&gt;数据。这些函数只能在作品被拥有时调用 - 即。当 PENDING 位被设置时。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * get_work_pool（） 和 get_work_pwq（） 可用于获取作品对应的 pool 或 pwq。 一旦工作在初始化后的任何位置排队，直到它被取消同步，Pool 就可用。 PWQ 仅在工作项排队时可用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">set_work_data</span><span class="params">(<span class="keyword">struct</span> work_struct *work, <span class="type">unsigned</span> <span class="type">long</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">	WARN_ON_ONCE(!work_pending(work));</span><br><span class="line">	atomic_long_set(&amp;work-&gt;data, data | work_static(work));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="set-work-pwq-设置工作项的工作池（pool-workqueue）"><a href="#set-work-pwq-设置工作项的工作池（pool-workqueue）" class="headerlink" title="set_work_pwq 设置工作项的工作池（pool_workqueue）"></a>set_work_pwq 设置工作项的工作池（pool_workqueue）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">set_work_pwq</span><span class="params">(<span class="keyword">struct</span> work_struct *work, <span class="keyword">struct</span> pool_workqueue *pwq,</span></span><br><span class="line"><span class="params">			 <span class="type">unsigned</span> <span class="type">long</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 	WORK_STRUCT_PENDING：标志位，表示工作项处于挂起状态，尚未执行。</span></span><br><span class="line"><span class="comment">		WORK_STRUCT_PWQ：标志位，表示工作项已关联到工作队列。</span></span><br><span class="line"><span class="comment">		flags：额外的标志位，用于设置工作项的其他属性 */</span></span><br><span class="line">	set_work_data(work, (<span class="type">unsigned</span> <span class="type">long</span>)pwq | WORK_STRUCT_PENDING |</span><br><span class="line">		      WORK_STRUCT_PWQ | flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="insert-work-将一个工作项（work-struct）插入到工作池（pool-workqueue）的指定位置"><a href="#insert-work-将一个工作项（work-struct）插入到工作池（pool-workqueue）的指定位置" class="headerlink" title="insert_work 将一个工作项（work_struct）插入到工作池（pool_workqueue）的指定位置"></a>insert_work 将一个工作项（work_struct）插入到工作池（pool_workqueue）的指定位置</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * insert_work - 将一个工作项（work_struct）插入到工作池（pool_workqueue）的指定位置</span></span><br><span class="line"><span class="comment"> * @pwq：PWQ @work 属于</span></span><br><span class="line"><span class="comment"> * @work：插入工件</span></span><br><span class="line"><span class="comment"> * @head：插入点</span></span><br><span class="line"><span class="comment"> * @extra_flags：要设置的额外 WORK_STRUCT_* 标志</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @head后插入属于 @pwq 的@work。 @extra_flags 是 OR&#x27;d 来work_struct标志。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *上下文：</span></span><br><span class="line"><span class="comment"> * raw_spin_lock_irq（pool-&gt;lock）.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">insert_work</span><span class="params">(<span class="keyword">struct</span> pool_workqueue *pwq, <span class="keyword">struct</span> work_struct *work,</span></span><br><span class="line"><span class="params">			<span class="keyword">struct</span> list_head *head, <span class="type">unsigned</span> <span class="type">int</span> extra_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	debug_work_activate(work);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* record the work call stack in order to print it in KASAN reports */</span></span><br><span class="line">	kasan_record_aux_stack(work);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 将工作项与工作池（pwq）关联，并设置额外的标志（extra_flags） */</span></span><br><span class="line">	set_work_pwq(work, pwq, extra_flags);</span><br><span class="line">	<span class="comment">/* 将工作项插入到链表的尾部（head 指定插入点） */</span></span><br><span class="line">	list_add_tail(&amp;work-&gt;entry, head);</span><br><span class="line">	<span class="comment">/* 调用 get_pwq 增加工作池的引用计数，确保工作池在工作项执行期间不会被释放 */</span></span><br><span class="line">	get_pwq(pwq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="wq-node-nr-active-用于确定工作队列（workqueue-struct）在指定-NUMA-节点上的-wq-node-nr-active-数据结构"><a href="#wq-node-nr-active-用于确定工作队列（workqueue-struct）在指定-NUMA-节点上的-wq-node-nr-active-数据结构" class="headerlink" title="wq_node_nr_active 用于确定工作队列（workqueue_struct）在指定 NUMA 节点上的 wq_node_nr_active 数据结构"></a>wq_node_nr_active 用于确定工作队列（workqueue_struct）在指定 NUMA 节点上的 wq_node_nr_active 数据结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * wq_node_nr_active - 确定要使用的wq_node_nr_active</span></span><br><span class="line"><span class="comment"> * @wq：感兴趣的 workqueue</span></span><br><span class="line"><span class="comment"> * @node：NUMA 节点，可以是 %NUMA_NO_NODE</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 确定用于 @node @wq 的wq_node_nr_active。返回：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - %NULL 用于每 CPU 工作队列，因为它们不需要使用共享nr_active。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - 如果 @node 为 %NUMA_NO_NODE，则node_nr_active[nr_node_ids]。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - 否则，node_nr_active[@node]。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> wq_node_nr_active *<span class="title function_">wq_node_nr_active</span><span class="params">(<span class="keyword">struct</span> workqueue_struct *wq,</span></span><br><span class="line"><span class="params">						   <span class="type">int</span> node)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 工作队列不是无绑定类型（WQ_UNBOUND），直接返回 NULL</span></span><br><span class="line"><span class="comment">	绑定工作队列不需要使用共享的活动计数 */</span></span><br><span class="line">	<span class="keyword">if</span> (!(wq-&gt;flags &amp; WQ_UNBOUND))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 传入的 NUMA 节点为 NUMA_NO_NODE，表示未指定具体节点。此时使用全局活动计数</span></span><br><span class="line"><span class="comment">	（node_nr_active[nr_node_ids]） */</span></span><br><span class="line">	<span class="keyword">if</span> (node == NUMA_NO_NODE)</span><br><span class="line">		node = nr_node_ids;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> wq-&gt;node_nr_active[node];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="tryinc-node-nr-active-尝试增加-wq-node-nr-active-结构体中的活动计数（nr）"><a href="#tryinc-node-nr-active-尝试增加-wq-node-nr-active-结构体中的活动计数（nr）" class="headerlink" title="tryinc_node_nr_active 尝试增加 wq_node_nr_active 结构体中的活动计数（nr）"></a>tryinc_node_nr_active 尝试增加 wq_node_nr_active 结构体中的活动计数（nr）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">tryinc_node_nr_active</span><span class="params">(<span class="keyword">struct</span> wq_node_nr_active *nna)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> max = READ_ONCE(nna-&gt;max);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="type">int</span> old, tmp;</span><br><span class="line"></span><br><span class="line">		old = <span class="type">atomic_read</span>(&amp;nna-&gt;nr);</span><br><span class="line">		<span class="keyword">if</span> (old &gt;= max)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="comment">/* 果活动计数未达到最大值，尝试以线程安全的方式增加活动计数 */</span></span><br><span class="line">		tmp = atomic_cmpxchg_relaxed(&amp;nna-&gt;nr, old, old + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (tmp == old)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pwq-tryinc-nr-active-尝试增加指定工作队列（pool-workqueue，简称-pwq）的活动工作项计数（nr-active）"><a href="#pwq-tryinc-nr-active-尝试增加指定工作队列（pool-workqueue，简称-pwq）的活动工作项计数（nr-active）" class="headerlink" title="pwq_tryinc_nr_active 尝试增加指定工作队列（pool_workqueue，简称 pwq）的活动工作项计数（nr_active）"></a>pwq_tryinc_nr_active 尝试增加指定工作队列（pool_workqueue，简称 pwq）的活动工作项计数（nr_active）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * pwq_tryinc_nr_active - 尝试增加 pwq 的 nr_active</span></span><br><span class="line"><span class="comment"> * @pwq：感兴趣的pool_workqueue</span></span><br><span class="line"><span class="comment"> * @fill：max_active可能已增加，请尝试提高并发级别</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 尝试增加 @pwq 的 nr_active。如果成功获取 nr_active 计数，则返回 %true。否则 LSE。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">pwq_tryinc_nr_active</span><span class="params">(<span class="keyword">struct</span> pool_workqueue *pwq, <span class="type">bool</span> fill)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">wq</span> =</span> pwq-&gt;wq;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span> =</span> pwq-&gt;pool;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wq_node_nr_active</span> *<span class="title">nna</span> =</span> wq_node_nr_active(wq, pool-&gt;node);</span><br><span class="line">	<span class="type">bool</span> obtained = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(&amp;pool-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 工作队列是绑定到特定 CPU 的（nna 为 NULL） */</span></span><br><span class="line">	<span class="keyword">if</span> (!nna) &#123;</span><br><span class="line">		<span class="comment">/* BH 或per-CPU 工作队列，pwq-&gt;nr_active 就足够了 */</span></span><br><span class="line">		obtained = pwq-&gt;nr_active &lt; READ_ONCE(wq-&gt;max_active);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 标记为“已插入”（plugged），表示当前不允许增加活动 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(pwq-&gt;plugged))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 未绑定的工作队列使用每个节点的共享nr_active $nna。</span></span><br><span class="line"><span class="comment">	 * 如果 @pwq 已在等待 $nna，则 pwq_dec_nr_active（） 将保持并发级别。不要插队。</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * max_active 增加后，我们需要忽略待处理的测试，因为 pwq_dec_nr_active（） 只能保持并发水平，不能提高并发水平。这由 @fill 表示。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/* 工作队列已经在等待增加活动计数（pending_node 非空），且未设置 fill 标志 */</span></span><br><span class="line">	<span class="keyword">if</span> (!list_empty(&amp;pwq-&gt;pending_node) &amp;&amp; likely(!fill))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 尝试无锁增加活动计数 */</span></span><br><span class="line">	obtained = tryinc_node_nr_active(nna);</span><br><span class="line">	<span class="keyword">if</span> (obtained)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 无锁采集失败。锁定，将自己添加到 $nna-&gt;pending_pwqs 并重试。smp_mb（） 与 pwq_dec_nr_active（） 中 atomic_dec_return（） 的隐含内存屏障配对，以确保我们看到递减的 $nna-&gt;nr，或者他们看到非空的 $nna-&gt;pending_pwqs。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	raw_spin_lock(&amp;nna-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (list_empty(&amp;pwq-&gt;pending_node))</span><br><span class="line">		list_add_tail(&amp;pwq-&gt;pending_node, &amp;nna-&gt;pending_pwqs);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (likely(!fill))</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">	smp_mb();</span><br><span class="line"></span><br><span class="line">	obtained = tryinc_node_nr_active(nna);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 如果成功增加活动计数且未设置 fill 标志，从等待列表中移除当前工作队列</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (obtained &amp;&amp; likely(!fill))</span><br><span class="line">		list_del_init(&amp;pwq-&gt;pending_node);</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">	raw_spin_unlock(&amp;nna-&gt;lock);</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> (obtained)</span><br><span class="line">		pwq-&gt;nr_active++;</span><br><span class="line">	<span class="keyword">return</span> obtained;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="queue-work-工作队列添加工作"><a href="#queue-work-工作队列添加工作" class="headerlink" title="__queue_work 工作队列添加工作"></a>__queue_work 工作队列添加工作</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __queue_work(<span class="type">int</span> cpu, <span class="keyword">struct</span> workqueue_struct *wq,</span><br><span class="line">			 <span class="keyword">struct</span> work_struct *work)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">pwq</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">last_pool</span>, *<span class="title">pool</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> work_flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> req_cpu = cpu;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *确保在调用此函数时中断被禁用。这是为了避免竞争条件，因为工作队列的操作可能涉及多个 CPU</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	lockdep_assert_irqs_disabled();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 如果工作队列正在销毁（__WQ_DESTROYING）或排空（__WQ_DRAINING），则不允许添加新的工作项</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(wq-&gt;flags &amp; (__WQ_DESTROYING | __WQ_DRAINING) &amp;&amp;</span><br><span class="line">		     WARN_ONCE(!is_chained_work(wq), <span class="string">&quot;workqueue: cannot queue %ps on wq %s\n&quot;</span>,</span><br><span class="line">			       work-&gt;func, wq-&gt;name))) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	rcu_read_lock();</span><br><span class="line">retry:</span><br><span class="line">	<span class="comment">/* 如果工作队列是“无绑定”（WORK_CPU_UNBOUND），则选择一个合适的 CPU */</span></span><br><span class="line">	<span class="keyword">if</span> (req_cpu == WORK_CPU_UNBOUND) &#123;</span><br><span class="line">		<span class="keyword">if</span> (wq-&gt;flags &amp; WQ_UNBOUND)</span><br><span class="line">			cpu = wq_select_unbound_cpu(raw_smp_processor_id());</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			cpu = raw_smp_processor_id();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 读取工作池队列指针 */</span></span><br><span class="line">	pwq = rcu_dereference(*per_cpu_ptr(wq-&gt;cpu_pwq, cpu));</span><br><span class="line">	pool = pwq-&gt;pool;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 如果 @work 以前位于其他存储池中，它可能仍在该存储池中运行，在这种情况下，需要在该存储池中对工作进行排队，以保证不可重入。</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 对于有序工作队列，工作项必须在最新的 pwq 上排队，以便准确地管理订单。 保证订单还保证不可重入。 请参阅上面的注释 unplug_oldest_pwq（）。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	last_pool = get_work_pool(work);</span><br><span class="line">	<span class="comment">/* 	检查工作项是否已经在另一个工作池中执行 </span></span><br><span class="line"><span class="comment">		并且工作队列不是有序的（__WQ_ORDERED）*/</span></span><br><span class="line">	<span class="keyword">if</span> (last_pool &amp;&amp; last_pool != pool &amp;&amp; !(wq-&gt;flags &amp; __WQ_ORDERED)) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">worker</span>;</span></span><br><span class="line">		<span class="comment">/* 通过锁定上一个工作池（last_pool */</span></span><br><span class="line">		raw_spin_lock(&amp;last_pool-&gt;lock);</span><br><span class="line">		<span class="comment">/* 找到正在执行该工作项的工作线程（worker） */</span></span><br><span class="line">		worker = find_worker_executing_work(last_pool, work);</span><br><span class="line">		<span class="comment">/* 找到的工作线程确实属于当前工作队列（wq） */</span></span><br><span class="line">		<span class="keyword">if</span> (worker &amp;&amp; worker-&gt;current_pwq-&gt;wq == wq) &#123;</span><br><span class="line">			<span class="comment">/* 更新目标工作池为该线程的当前工作池（current_pwq） */</span></span><br><span class="line">			pwq = worker-&gt;current_pwq;</span><br><span class="line">			pool = pwq-&gt;pool;</span><br><span class="line">			WARN_ON_ONCE(pool != last_pool);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* 释放上一个工作池的锁，并锁定当前目标工作池，准备将工作项队列到当前池中 */</span></span><br><span class="line">			raw_spin_unlock(&amp;last_pool-&gt;lock);</span><br><span class="line">			raw_spin_lock(&amp;pool-&gt;lock);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		raw_spin_lock(&amp;pool-&gt;lock);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 如果工作池的引用计数为零（可能由于竞争条件导致），对于无绑定队列，会重试选择工作池</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!pwq-&gt;refcnt)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (wq-&gt;flags &amp; WQ_UNBOUND) &#123;</span><br><span class="line">			raw_spin_unlock(&amp;pool-&gt;lock);</span><br><span class="line">			cpu_relax();</span><br><span class="line">			<span class="keyword">goto</span> retry;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* oops */</span></span><br><span class="line">		<span class="comment">/* &quot;oops&quot;，它通常用于表示某种错误、意外或问题。</span></span><br><span class="line"><span class="comment">		在技术文档或代码注释中，&quot;oops&quot; 可能是开发者用来标记某个需要注意的地方 */</span></span><br><span class="line">		WARN_ONCE(<span class="literal">true</span>, <span class="string">&quot;workqueue: per-cpu pwq for %s on cpu%d has 0 refcnt&quot;</span>,</span><br><span class="line">			  wq-&gt;name, cpu);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* pwq determined, queue */</span></span><br><span class="line">	trace_workqueue_queue_work(req_cpu, pwq, work);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON(!list_empty(&amp;work-&gt;entry)))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	pwq-&gt;nr_in_flight[pwq-&gt;work_color]++;</span><br><span class="line">	work_flags = work_color_to_flags(pwq-&gt;work_color);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 如果工作项可以立即激活（pwq_tryinc_nr_active 返回 true），则将其插入到活动工作列表中</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (list_empty(&amp;pwq-&gt;inactive_works) &amp;&amp; pwq_tryinc_nr_active(pwq, <span class="literal">false</span>)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (list_empty(&amp;pool-&gt;worklist))</span><br><span class="line">			pool-&gt;watchdog_ts = jiffies;</span><br><span class="line"></span><br><span class="line">		trace_workqueue_activate_work(work);</span><br><span class="line">		insert_work(pwq, work, &amp;pool-&gt;worklist, work_flags);</span><br><span class="line">		kick_pool(pool);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* 将其标记为非活动（WORK_STRUCT_INACTIVE），并插入到非活动工作列表中 */</span></span><br><span class="line">		work_flags |= WORK_STRUCT_INACTIVE;</span><br><span class="line">		insert_work(pwq, work, &amp;pwq-&gt;inactive_works, work_flags);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	raw_spin_unlock(&amp;pool-&gt;lock);</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="queue-delayed-work-工作队列添加延时工作"><a href="#queue-delayed-work-工作队列添加延时工作" class="headerlink" title="__queue_delayed_work 工作队列添加延时工作"></a>__queue_delayed_work 工作队列添加延时工作</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __queue_delayed_work(<span class="type">int</span> cpu, <span class="keyword">struct</span> workqueue_struct *wq,</span><br><span class="line">				<span class="keyword">struct</span> delayed_work *dwork, <span class="type">unsigned</span> <span class="type">long</span> delay)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> *<span class="title">timer</span> =</span> &amp;dwork-&gt;timer;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> *<span class="title">work</span> =</span> &amp;dwork-&gt;work;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 例如工作队列是否为空、定时器函数是否正确、定时器是否已经挂起，以及工作项是否已经在队列中 */</span></span><br><span class="line">	WARN_ON_ONCE(!wq);</span><br><span class="line">	WARN_ON_ONCE(timer-&gt;function != delayed_work_timer_fn);</span><br><span class="line">	WARN_ON_ONCE(timer_pending(timer));</span><br><span class="line">	WARN_ON_ONCE(!list_empty(&amp;work-&gt;entry));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 如果 @delay 为 0，则立即排队 @dwork-&gt;work。 </span></span><br><span class="line"><span class="comment">	 * 这既是为了优化，也是为了正确性。 </span></span><br><span class="line"><span class="comment">	 * @timer最早可以在最近的下一个时钟周期到期，delayed_work用户依赖于当 @delay 为 0 时没有这样的延迟。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!delay) &#123;</span><br><span class="line">		__queue_work(cpu, wq, &amp;dwork-&gt;work);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	WARN_ON_ONCE(cpu != WORK_CPU_UNBOUND &amp;&amp; !cpu_online(cpu));</span><br><span class="line">	dwork-&gt;wq = wq;</span><br><span class="line">	dwork-&gt;cpu = cpu;</span><br><span class="line">	<span class="comment">/* ，设置定时器的到期时间为 jiffies + delay */</span></span><br><span class="line">	timer-&gt;expires = jiffies + delay;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果启用，表示某些 CPU 专门用于处理定时器等后台任务。 */</span></span><br><span class="line">	<span class="keyword">if</span> (housekeeping_enabled(HK_TYPE_TIMER)) &#123;</span><br><span class="line">		<span class="comment">/*如果当前 cpu 是 housekeeping cpu，请使用它。 */</span></span><br><span class="line">		cpu = smp_processor_id();</span><br><span class="line">		<span class="keyword">if</span> (!housekeeping_test_cpu(cpu, HK_TYPE_TIMER))</span><br><span class="line">			<span class="comment">/* 获取一个合适的 housekeeping CPU */</span></span><br><span class="line">			cpu = housekeeping_any_cpu(HK_TYPE_TIMER);</span><br><span class="line">		<span class="comment">/* 将定时器添加到选定的 CPU */</span></span><br><span class="line">		add_timer_on(timer, cpu);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (likely(cpu == WORK_CPU_UNBOUND))</span><br><span class="line">			<span class="comment">/* 使用全局计时器 */</span></span><br><span class="line">			add_timer_global(timer);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			add_timer_on(timer, cpu);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="queue-delayed-work-on-延迟后对特定-CPU-上的工作进行排队"><a href="#queue-delayed-work-on-延迟后对特定-CPU-上的工作进行排队" class="headerlink" title="queue_delayed_work_on 延迟后对特定 CPU 上的工作进行排队"></a>queue_delayed_work_on 延迟后对特定 CPU 上的工作进行排队</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * queue_delayed_work_on - 延迟后对特定 CPU 上的工作进行排队</span></span><br><span class="line"><span class="comment"> * @cpu：要执行工作的 CPU 编号</span></span><br><span class="line"><span class="comment"> * @wq：要使用的 workqueue</span></span><br><span class="line"><span class="comment"> * @dwork：要排队的工作</span></span><br><span class="line"><span class="comment"> * @delay：排队前要等待的 jiffies 数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 我们将delayed_work排队到特定的 CPU，对于非零延迟，调用者必须确保它在线且无法消失。</span></span><br><span class="line"><span class="comment"> * 无法确保这一点的调用方可能会得到 @dwork-&gt;timer 排队到离线的 CPU，这将阻止 @dwork-&gt; 的排队，除非离线的 CPU 再次联机。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回：如果 @work 已在队列中，则返回 lse，否则为 %true。 如果 @delay 为零且 @dwork 处于空闲状态，则将安排立即执行。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">queue_delayed_work_on</span><span class="params">(<span class="type">int</span> cpu, <span class="keyword">struct</span> workqueue_struct *wq,</span></span><br><span class="line"><span class="params">			   <span class="keyword">struct</span> delayed_work *dwork, <span class="type">unsigned</span> <span class="type">long</span> delay)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> *<span class="title">work</span> =</span> &amp;dwork-&gt;work;</span><br><span class="line">	<span class="type">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> irq_flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* read the comment in __queue_work() */</span></span><br><span class="line">	local_irq_save(irq_flags);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 检查工作项是否已经在队列中。如果工作项已经排队，则返回 false */</span></span><br><span class="line">	<span class="keyword">if</span> (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work)) &amp;&amp;</span><br><span class="line">		<span class="comment">/* 调用 clear_pending_if_disabled(work) 检查工作项是否被禁用。如果工作项被禁用，则不会继续排队 */</span></span><br><span class="line">	    !clear_pending_if_disabled(work)) &#123;</span><br><span class="line">		<span class="comment">/* 将工作项添加到指定的 CPU 和工作队列中，并设置延迟时间 */</span></span><br><span class="line">		__queue_delayed_work(cpu, wq, dwork, delay);</span><br><span class="line">		ret = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	local_irq_restore(irq_flags);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(queue_delayed_work_on);</span><br></pre></td></tr></table></figure>

<h2 id="wq-worker-sleeping-处理一个工作线程（worker）进入睡眠状态时的相关逻辑"><a href="#wq-worker-sleeping-处理一个工作线程（worker）进入睡眠状态时的相关逻辑" class="headerlink" title="wq_worker_sleeping 处理一个工作线程（worker）进入睡眠状态时的相关逻辑"></a>wq_worker_sleeping 处理一个工作线程（worker）进入睡眠状态时的相关逻辑</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * wq_worker_sleeping - worker 将要进入睡眠状态</span></span><br><span class="line"><span class="comment"> * @task：任务进入休眠状态</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 当繁忙的 worker 为</span></span><br><span class="line"><span class="comment"> * 要睡觉。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">wq_worker_sleeping</span><span class="params">(<span class="keyword">struct</span> task_struct *task)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">worker</span> =</span> kthread_data(task);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 救援人员，可能没有像平常那样设置所有字段</span></span><br><span class="line"><span class="comment">	 * 工人，也到这里，我们之前什么都不要访问</span></span><br><span class="line"><span class="comment">	 * 检查 NOT_RUNNING。</span></span><br><span class="line"><span class="comment">	 * 这是一个保护机制，避免对未运行的线程执行后续操作</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (worker-&gt;flags &amp; WORKER_NOT_RUNNING)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	pool = worker-&gt;pool;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果在到达 wq_worker_running（） 之前被抢占，则返回*/</span></span><br><span class="line">	<span class="keyword">if</span> (READ_ONCE(worker-&gt;sleeping))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	WRITE_ONCE(worker-&gt;sleeping, <span class="number">1</span>);</span><br><span class="line">	raw_spin_lock_irq(&amp;pool-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 如果 unbind_workers（） 抢占了我们，请重新检查。我们没有</span></span><br><span class="line"><span class="comment">	 * 希望在 worker 解绑后递减 nr_running</span></span><br><span class="line"><span class="comment">	 * 和 nr_running 已被重置。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (worker-&gt;flags &amp; WORKER_NOT_RUNNING) &#123;</span><br><span class="line">		raw_spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pool-&gt;nr_running--;</span><br><span class="line">	<span class="comment">/* 调用 kick_pool 检查是否需要唤醒其他线程以维持工作池的并发性 */</span></span><br><span class="line">	<span class="keyword">if</span> (kick_pool(pool))</span><br><span class="line">		worker-&gt;current_pwq-&gt;stats[PWQ_STAT_CM_WAKEUP]++;</span><br><span class="line"></span><br><span class="line">	raw_spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="wq-cpu-intensive-thresh-init-初始化并动态调整wq-cpu-intensive-thresh-us"><a href="#wq-cpu-intensive-thresh-init-初始化并动态调整wq-cpu-intensive-thresh-us" class="headerlink" title="wq_cpu_intensive_thresh_init 初始化并动态调整wq_cpu_intensive_thresh_us"></a>wq_cpu_intensive_thresh_init 初始化并动态调整wq_cpu_intensive_thresh_us</h2><ul>
<li>wq_cpu_intensive_thresh_us:该阈值定义了工作队列（workqueue）子系统判定一个工作项（work item）为“CPU密集型”的时间上限。</li>
<li>其工作原理基于一个自适应的启发式算法：<ul>
<li>CPU密集型判定: 在工作队列的执行逻辑中，若一个工作项在持有工作者池（worker pool）内部锁的情况下，其执行时间超过 wq_cpu_intensive_thresh_us 微秒，该工作项将被分类为CPU密集型，并可能触发调度器对其进行特殊处理，以避免抢占其他重要工作。</li>
<li>动态调整的必要性: 一个固定的时间阈值无法适应性能差异巨大的各种硬件平台。对于高性能处理器，10毫秒可能已是相当长的时间；而对于低性能微控制器，这可能是一个常规操作所需的时间。因此，必须根据当前系统的计算能力来动态设定此阈值。</li>
<li>基于BogoMIPS的性能估算: 该函数利用内核在早期启动阶段通过calibrate_delay()计算出的loops_per_jiffy全局变量，来估算一个非精确但具备参考价值的性能指标——BogoMIPS。BogoMIPS粗略地反映了CPU执行简单指令循环的速度。</li>
<li>阈值缩放（Scaling）算法: 函数设定一个10毫秒的基准阈值。若计算出的BogoMIPS值低于4000，则判定系统为低性能平台，并启动缩放算法。该算法将阈值与BogoMIPS值成反比进行放大（thresh * 4000 &#x2F; bogo），但上限不超过1秒。此算法确保了在计算能力较低的硬件上，该阈值会被放宽，以避免错误的密集型任务判定。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这是一个静态的、仅在初始化阶段调用的函数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __init <span class="title function_">wq_cpu_intensive_thresh_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> thresh;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> bogo;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 创建一个专用的内核线程工作者，命名为&quot;pool_workqueue_release&quot;，</span></span><br><span class="line"><span class="comment">	 * 用于异步处理pool_workqueue的释放操作。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	pwq_release_worker = kthread_run_worker(<span class="number">0</span>, <span class="string">&quot;pool_workqueue_release&quot;</span>);</span><br><span class="line">	<span class="comment">/* 若创建失败（IS_ERR返回true），则触发内核致命错误（BUG_ON）。*/</span></span><br><span class="line">	BUG_ON(IS_ERR(pwq_release_worker));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 注释：如果用户已将其设置为特定值，则保留该值。*/</span></span><br><span class="line">	<span class="comment">/* 检查全局变量是否不等于其默认的未设置值（ULONG_MAX）。*/</span></span><br><span class="line">	<span class="keyword">if</span> (wq_cpu_intensive_thresh_us != ULONG_MAX)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 注释：默认的10ms阈值源于这样一个事实：大多数现代处理器（截至2023年）</span></span><br><span class="line"><span class="comment">	 *       在10ms内可以完成大量工作，并且这个时间刚好低于大多数人能感知到的延迟。</span></span><br><span class="line"><span class="comment">	 *       然而，内核也运行在包括微控制器在内的许多慢速CPU上，</span></span><br><span class="line"><span class="comment">	 *       对它们来说这个阈值太低了。</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 注释：如果BogoMips低于4000，我们就将阈值最高放大到1秒。</span></span><br><span class="line"><span class="comment">	 *       这绝非精确，但也不必要求精确。即使阈值被完全放大，</span></span><br><span class="line"><span class="comment">	 *       这个机制仍然是有用的。而且，由于报告通常适用于所有人，</span></span><br><span class="line"><span class="comment">	 *       少数机器在较长的阈值下运行，并不会显著降低其有用性。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/* 设定基准阈值为10毫秒。*/</span></span><br><span class="line">	thresh = <span class="number">10</span> * USEC_PER_MSEC;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 注释：参见init/calibrate.c中的lpj -&gt; BogoMIPS计算方法。*/</span></span><br><span class="line">	<span class="comment">/* 基于loops_per_jiffy变量估算BogoMIPS值。max_t确保结果最小为1。*/</span></span><br><span class="line">	bogo = <span class="type">max_t</span>(<span class="type">unsigned</span> <span class="type">long</span>, loops_per_jiffy / <span class="number">500000</span> * HZ, <span class="number">1</span>);</span><br><span class="line">	<span class="comment">/* 若估算的BogoMIPS值低于4000，则执行阈值缩放。*/</span></span><br><span class="line">	<span class="keyword">if</span> (bogo &lt; <span class="number">4000</span>)</span><br><span class="line">		<span class="comment">/* 根据公式按BogoMIPS值反比放大阈值，并确保结果不超过1秒。*/</span></span><br><span class="line">		thresh = <span class="type">min_t</span>(<span class="type">unsigned</span> <span class="type">long</span>, thresh * <span class="number">4000</span> / bogo, USEC_PER_SEC);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 输出包含计算过程关键变量的调试信息。*/</span></span><br><span class="line">	pr_debug(<span class="string">&quot;wq_cpu_intensive_thresh: lpj=%lu BogoMIPS=%lu thresh_us=%lu\n&quot;</span>,</span><br><span class="line">		 loops_per_jiffy, bogo, thresh);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 将最终计算出的阈值赋给全局变量。*/</span></span><br><span class="line">	wq_cpu_intensive_thresh_us = thresh;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="workqueue-init-使工作队列子系统完全上线"><a href="#workqueue-init-使工作队列子系统完全上线" class="headerlink" title="workqueue_init 使工作队列子系统完全上线"></a>workqueue_init 使工作队列子系统完全上线</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * workqueue_init - 使工作队列子系统完全上线</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这是工作队列子系统三阶段初始化中的第二步，在内核线程可以被创建和调度后</span></span><br><span class="line"><span class="comment"> * 立即被调用。此时，工作队列可能已经被创建，工作项也已排队，但还没有</span></span><br><span class="line"><span class="comment"> * 任何工作者线程（kworkers）来执行它们。本函数为工作者池填充初始的</span></span><br><span class="line"><span class="comment"> * 工作者，并使能未来的工作者创建。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">workqueue_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">wq</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span>;</span></span><br><span class="line">	<span class="type">int</span> cpu, bkt;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化用于CPU密集型工作队列的调度阈值。*/</span></span><br><span class="line">	wq_cpu_intensive_thresh_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 获取wq_pool_mutex锁，以保护对全局工作者池数据结构的并发访问。*/</span></span><br><span class="line">	mutex_lock(&amp;wq_pool_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 注释：早期创建的per-cpu池可能缺少NUMA节点提示，这里进行修复。</span></span><br><span class="line"><span class="comment">	 *       同时，为已请求的工作队列创建救援线程。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/* 遍历系统中所有可能的CPU核心。*/</span></span><br><span class="line">	for_each_possible_cpu(cpu) &#123;</span><br><span class="line">		<span class="comment">/* 为每个CPU的BH池和普通per-cpu池，根据CPU拓扑设置其NUMA节点(node)属性。*/</span></span><br><span class="line">		for_each_bh_worker_pool(pool, cpu)</span><br><span class="line">			pool-&gt;node = cpu_to_node(cpu);</span><br><span class="line">		for_each_cpu_worker_pool(pool, cpu)</span><br><span class="line">			pool-&gt;node = cpu_to_node(cpu);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 遍历全局的workqueues链表，检查所有已创建的工作队列。*/</span></span><br><span class="line">	list_for_each_entry(wq, &amp;workqueues, <span class="built_in">list</span>) &#123;</span><br><span class="line">		<span class="comment">/* 为需要救援服务的早期工作队列创建救援线程。若创建失败，则发出内核警告。*/</span></span><br><span class="line">		WARN(init_rescuer(wq),</span><br><span class="line">		     <span class="string">&quot;workqueue: failed to create early rescuer for %s&quot;</span>,</span><br><span class="line">		     wq-&gt;name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 释放wq_pool_mutex锁。*/</span></span><br><span class="line">	mutex_unlock(&amp;wq_pool_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 注释：创建初始的工作者。BH池有一个伪工作者，它代表了共享的BH执行</span></span><br><span class="line"><span class="comment">	 *       上下文，因此不受CPU热插拔事件影响。在这里为所有可能的CPU</span></span><br><span class="line"><span class="comment">	 *       创建BH伪工作者。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/* 为系统中所有可能CPU的BH工作者池创建第一个工作者线程。*/</span></span><br><span class="line">	for_each_possible_cpu(cpu)</span><br><span class="line">		for_each_bh_worker_pool(pool, cpu)</span><br><span class="line">			BUG_ON(!create_worker(pool)); <span class="comment">/* 若create_worker返回false，则触发内核致命错误。*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 仅为当前在线的CPU的普通per-cpu工作者池创建第一个工作者线程。*/</span></span><br><span class="line">	for_each_online_cpu(cpu) &#123;</span><br><span class="line">		for_each_cpu_worker_pool(pool, cpu) &#123;</span><br><span class="line">			<span class="comment">/* 清除该池的POOL_DISASSOCIATED标志位，表示其已与CPU关联。*/</span></span><br><span class="line">			pool-&gt;flags &amp;= ~POOL_DISASSOCIATED;</span><br><span class="line">			<span class="comment">/* 创建工作者线程，若失败则触发内核致命错误。*/</span></span><br><span class="line">			BUG_ON(!create_worker(pool));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 遍历存储unbound池的哈希表，为每个非绑定的工作者池创建第一个工作者线程。*/</span></span><br><span class="line">	hash_for_each(unbound_pool_hash, bkt, pool, hash_node)</span><br><span class="line">		BUG_ON(!create_worker(pool));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 设置全局标志位wq_online为true，表明工作队列子系统已功能完备。*/</span></span><br><span class="line">	wq_online = <span class="literal">true</span>;</span><br><span class="line">	<span class="comment">/* 初始化工作队列的看门狗（watchdog）监控机制。*/</span></span><br><span class="line">	<span class="comment">// wq_watchdog_init();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="init-pod-type-根据特定的物理拓扑关系对系统中的所有CPU进行分组"><a href="#init-pod-type-根据特定的物理拓扑关系对系统中的所有CPU进行分组" class="headerlink" title="init_pod_type 根据特定的物理拓扑关系对系统中的所有CPU进行分组"></a>init_pod_type 根据特定的物理拓扑关系对系统中的所有CPU进行分组</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 通过根据 cpus_share_pod() 函数首先初始化 pt-&gt;cpu_pod[] 来初始化 @pt。</span></span><br><span class="line"><span class="comment"> * 每个共享一个 pod 的 CPU 子集都被分配一个唯一且连续的 pod ID。</span></span><br><span class="line"><span class="comment"> * @pt 的其余部分也相应地进行初始化。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* 这是一个静态的、仅在初始化阶段运行的函数。</span></span><br><span class="line"><span class="comment"> * @pt: 指向 wq_pod_type 结构的指针，此函数将填充该结构。</span></span><br><span class="line"><span class="comment"> * @cpus_share_pod: 一个函数指针，接收两个CPU ID作为参数，</span></span><br><span class="line"><span class="comment"> *                  如果它们共享一个pod，则返回true，否则返回false。</span></span><br><span class="line"><span class="comment"> *                  这使得本函数可以根据不同标准（如共享SMT、缓存、NUMA）进行分组。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __init <span class="title function_">init_pod_type</span><span class="params">(<span class="keyword">struct</span> wq_pod_type *pt,</span></span><br><span class="line"><span class="params">				 <span class="type">bool</span> (*cpus_share_pod)(<span class="type">int</span>, <span class="type">int</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* cur: 当前正在处理的CPU ID。</span></span><br><span class="line"><span class="comment">	 * pre: 在cur之前、已经被处理过的CPU ID。</span></span><br><span class="line"><span class="comment">	 * cpu: 用于通用CPU遍历的变量。</span></span><br><span class="line"><span class="comment">	 * pod: 用于pod ID遍历的变量。*/</span></span><br><span class="line">	<span class="type">int</span> cur, pre, cpu, pod;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化pod的数量为0。*/</span></span><br><span class="line">	pt-&gt;nr_pods = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 根据 cpus_share_pod() 函数来初始化 pt-&gt;cpu_pod[] 数组 */</span></span><br><span class="line">	<span class="comment">/* 为 cpu_pod 数组分配内存。该数组的索引是CPU ID，值是该CPU所属的pod ID。</span></span><br><span class="line"><span class="comment">	 * nr_cpu_ids 是系统中可能存在的最大CPU数量。</span></span><br><span class="line"><span class="comment">	 * GFP_KERNEL 是内核内存分配的标志，表示在正常的内核上下文中进行分配。*/</span></span><br><span class="line">	pt-&gt;cpu_pod = kcalloc(nr_cpu_ids, <span class="keyword">sizeof</span>(pt-&gt;cpu_pod[<span class="number">0</span>]), GFP_KERNEL);</span><br><span class="line">	<span class="comment">/* BUG_ON 是一个内核断言。如果内存分配失败（返回NULL），则系统会立即崩溃。</span></span><br><span class="line"><span class="comment">	 * 在初始化代码中这是合理的，因为如果基本结构无法分配，系统也无法正常运行。*/</span></span><br><span class="line">	BUG_ON(!pt-&gt;cpu_pod);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 遍历系统上所有可能的CPU ID，作为当前要分组的CPU。*/</span></span><br><span class="line">	<span class="comment">/* 对于单核来说,这里直接break,不会走到外部传入函数 */</span></span><br><span class="line">	for_each_possible_cpu(cur) &#123;</span><br><span class="line">		<span class="comment">/* 再次遍历所有可能的CPU ID，作为已经处理过的CPU，用于比较。*/</span></span><br><span class="line">		for_each_possible_cpu(pre) &#123;</span><br><span class="line">			<span class="comment">/* 如果 pre 大于等于 cur，说明对于当前的 cur，所有在它之前的 pre 都已经</span></span><br><span class="line"><span class="comment">			 * 检查完毕，且没有找到可以共享的pod。因此，cur 属于一个新的pod。*/</span></span><br><span class="line">			<span class="keyword">if</span> (pre &gt;= cur) &#123;</span><br><span class="line">				<span class="comment">/* 将新的pod ID赋给当前CPU，这个ID就是当前的pod总数。*/</span></span><br><span class="line">				pt-&gt;cpu_pod[cur] = pt-&gt;nr_pods++;</span><br><span class="line">				<span class="comment">/* 已经为 cur 分配了pod，跳出内层循环。*/</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/* 调用外部传入的函数，判断 cur 和 pre 是否共享同一个pod。*/</span></span><br><span class="line">			<span class="keyword">if</span> (cpus_share_pod(cur, pre)) &#123;</span><br><span class="line">				<span class="comment">/* 如果共享，则将 pre 的pod ID赋给 cur。*/</span></span><br><span class="line">				pt-&gt;cpu_pod[cur] = pt-&gt;cpu_pod[pre];</span><br><span class="line">				<span class="comment">/* 已经为 cur 分配了pod，跳出内层循环。*/</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化结构的其余部分，以匹配 pt-&gt;cpu_pod[] 的内容 */</span></span><br><span class="line">	<span class="comment">/* 分配 pod_cpus 数组，该数组的索引是pod ID，值是一个指向cpumask的指针。</span></span><br><span class="line"><span class="comment">	 * cpumask是一个位图，用于表示该pod包含哪些CPU。*/</span></span><br><span class="line">	pt-&gt;pod_cpus = kcalloc(pt-&gt;nr_pods, <span class="keyword">sizeof</span>(pt-&gt;pod_cpus[<span class="number">0</span>]), GFP_KERNEL);</span><br><span class="line">	<span class="comment">/* 分配 pod_node 数组，该数组的索引是pod ID，值是该pod所属的NUMA节点ID。*/</span></span><br><span class="line">	pt-&gt;pod_node = kcalloc(pt-&gt;nr_pods, <span class="keyword">sizeof</span>(pt-&gt;pod_node[<span class="number">0</span>]), GFP_KERNEL);</span><br><span class="line">	<span class="comment">/* 检查内存分配是否成功。*/</span></span><br><span class="line">	BUG_ON(!pt-&gt;pod_cpus || !pt-&gt;pod_node);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 遍历所有已发现的pod。*/</span></span><br><span class="line">	<span class="keyword">for</span> (pod = <span class="number">0</span>; pod &lt; pt-&gt;nr_pods; pod++)</span><br><span class="line">		<span class="comment">/* 为每个pod动态分配一个cpumask变量并清零。zalloc_cpumask_var确保位图初始为空。*/</span></span><br><span class="line">		BUG_ON(!zalloc_cpumask_var(&amp;pt-&gt;pod_cpus[pod], GFP_KERNEL));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 再次遍历所有可能的CPU，以填充反向映射。*/</span></span><br><span class="line">	for_each_possible_cpu(cpu) &#123;</span><br><span class="line">		<span class="comment">/* 在对应pod的cpumask中，设置代表当前cpu的位。</span></span><br><span class="line"><span class="comment">		 * pt-&gt;cpu_pod[cpu] 获取cpu的pod ID，</span></span><br><span class="line"><span class="comment">		 * pt-&gt;pod_cpus[...] 获取该pod的cpumask指针，</span></span><br><span class="line"><span class="comment">		 * cpumask_set_cpu 将该cpu添加到该cpumask中。*/</span></span><br><span class="line">		cpumask_set_cpu(cpu, pt-&gt;pod_cpus[pt-&gt;cpu_pod[cpu]]);</span><br><span class="line">		<span class="comment">/* 获取当前CPU所属的NUMA节点，并将其存入pod的节点信息中。</span></span><br><span class="line"><span class="comment">		 * 这里假设一个pod内的所有CPU都属于同一个NUMA节点。*/</span></span><br><span class="line">		pt-&gt;pod_node[pt-&gt;cpu_pod[cpu]] = cpu_to_node(cpu);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="unbound-wq-update-pwq-专门用于处理非绑定（unbound）工作队列在CPU热插拔（hotplug）事件发生时的状态更新"><a href="#unbound-wq-update-pwq-专门用于处理非绑定（unbound）工作队列在CPU热插拔（hotplug）事件发生时的状态更新" class="headerlink" title="unbound_wq_update_pwq 专门用于处理非绑定（unbound）工作队列在CPU热插拔（hotplug）事件发生时的状态更新"></a>unbound_wq_update_pwq 专门用于处理非绑定（unbound）工作队列在CPU热插拔（hotplug）事件发生时的状态更新</h2><ul>
<li>当一个CPU被添加或移除时，系统中CPU的拓扑结构会发生变化。对于非绑定工作队列，其工作项（work item）可以在一组允许的CPU上执行。此函数的作用就是，在CPU变化后，重新计算和调整该工作队列在特定CPU上关联的 pool_workqueue (pwq) 结构，确保工作项能够被调度到符合最新CPU亲和性掩码（cpumask）的处理器池中，从而维持系统的高效运行。在像STM32H7这样通常不支持CPU热插拔的嵌入式系统上，这个函数在运行时可能永远不会被调用，但它是通用内核所必需的一部分。<br>带注释的代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * unbound_wq_update_pwq - 为CPU热插拔事件更新一个pwq槽位</span></span><br><span class="line"><span class="comment"> * @wq: 目标工作队列</span></span><br><span class="line"><span class="comment"> * @cpu: 需要为其更新pwq槽位的CPU</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这个函数应该从 %CPU_DOWN_PREPARE, %CPU_ONLINE 和</span></span><br><span class="line"><span class="comment"> * %CPU_DOWN_FAILED 这些CPU热插拔状态通知中被调用。@cpu 与</span></span><br><span class="line"><span class="comment"> * 正在被热插拔的CPU位于同一个pod中。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果因为内存分配失败导致pod亲和性无法调整，</span></span><br><span class="line"><span class="comment"> * 它会回退到使用 @wq-&gt;dfl_pwq，这可能不是最优的，但总是正确的。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意，当一个跨越多个pod的cpumask的工作队列，其某个pod中</span></span><br><span class="line"><span class="comment"> * 最后一个允许的CPU下线时，那些已经在为该工作队列执行工作项的</span></span><br><span class="line"><span class="comment"> * worker线程将会失去它们的CPU亲和性，并可能在任何CPU上执行。</span></span><br><span class="line"><span class="comment"> * 这与per-cpu工作队列在CPU_DOWN时的行为类似。如果一个工作队列的</span></span><br><span class="line"><span class="comment"> * 用户需要严格的亲和性，用户有责任在CPU_DOWN_PREPARE阶段刷新其</span></span><br><span class="line"><span class="comment"> * 工作项。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">unbound_wq_update_pwq</span><span class="params">(<span class="keyword">struct</span> workqueue_struct *wq, <span class="type">int</span> cpu)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">old_pwq</span> =</span> <span class="literal">NULL</span>, *pwq;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">workqueue_attrs</span> *<span class="title">target_attrs</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 断言，确保调用此函数时已经持有了 wq_pool_mutex 锁，防止竞争。</span></span><br><span class="line">	lockdep_assert_held(&amp;wq_pool_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果工作队列不是非绑定的（WQ_UNBOUND），或者是“有序的”非绑定队列，则直接返回。</span></span><br><span class="line">	<span class="comment">// 因为有序队列有特殊的处理方式，不适用此逻辑。</span></span><br><span class="line">	<span class="keyword">if</span> (!(wq-&gt;flags &amp; WQ_UNBOUND) || wq-&gt;unbound_attrs-&gt;ordered)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 我们不希望为每个工作队列在每个CPU上都分配/释放wq_attrs。</span></span><br><span class="line"><span class="comment">	 * 让我们使用一个预先分配好的。下面的缓冲区受到CPU热插拔排他锁的保护。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">// 使用一个静态的预分配缓冲区来存放目标属性，避免在热插拔路径中进行内存分配。</span></span><br><span class="line">	target_attrs = unbound_wq_update_pwq_attrs_buf;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将工作队列当前的非绑定属性复制到目标属性结构中。</span></span><br><span class="line">	copy_workqueue_attrs(target_attrs, wq-&gt;unbound_attrs);</span><br><span class="line">	<span class="comment">// 根据系统当前在线的CPU掩码，将属性中的cpumask实体化。</span></span><br><span class="line">	wqattrs_actualize_cpumask(target_attrs, wq_unbound_cpumask);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果目标cpumask与当前的pwq匹配，则无需任何操作 */</span></span><br><span class="line">	<span class="comment">// 计算与给定cpu关联的pod（处理器组）的cpumask。</span></span><br><span class="line">	wq_calc_pod_cpumask(target_attrs, cpu);</span><br><span class="line">	<span class="comment">// 比较计算出的目标属性与当前该cpu上pwq所关联的池的属性是否相同。</span></span><br><span class="line">	<span class="keyword">if</span> (wqattrs_equal(target_attrs, unbound_pwq(wq, cpu)-&gt;pool-&gt;attrs))</span><br><span class="line">		<span class="keyword">return</span>; <span class="comment">// 如果相同，则无需更新，直接返回。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 创建一个新的 pwq */</span></span><br><span class="line">	<span class="comment">// 根据新的目标属性，为工作队列分配一个新的 pool_workqueue 结构。</span></span><br><span class="line">	pwq = alloc_unbound_pwq(wq, target_attrs);</span><br><span class="line">	<span class="comment">// 如果分配失败。</span></span><br><span class="line">	<span class="keyword">if</span> (!pwq) &#123;</span><br><span class="line">		<span class="comment">// 打印警告信息。</span></span><br><span class="line">		pr_warn(<span class="string">&quot;workqueue: allocation failed while updating CPU pod affinity of \&quot;%s\&quot;\n&quot;</span>,</span><br><span class="line">			wq-&gt;name);</span><br><span class="line">		<span class="comment">// 跳转到使用默认pwq的备用逻辑。</span></span><br><span class="line">		<span class="keyword">goto</span> use_dfl_pwq;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 安装新的 pwq. */</span></span><br><span class="line">	<span class="comment">// 锁定工作队列的互斥锁，以安全地修改其内部结构。</span></span><br><span class="line">	mutex_lock(&amp;wq-&gt;mutex);</span><br><span class="line">	<span class="comment">// 将新创建的pwq安装到指定cpu的槽位上，并返回旧的pwq。</span></span><br><span class="line">	old_pwq = install_unbound_pwq(wq, cpu, pwq);</span><br><span class="line">	<span class="comment">// 跳转到解锁和清理步骤。</span></span><br><span class="line">	<span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">use_dfl_pwq:</span><br><span class="line">	<span class="comment">// 这是分配失败时的回退路径。</span></span><br><span class="line">	<span class="comment">// 锁定工作队列互斥锁。</span></span><br><span class="line">	mutex_lock(&amp;wq-&gt;mutex);</span><br><span class="line">	<span class="comment">// 获取工作队列的默认pwq（unbound_pwq的cpu参数为-1）。</span></span><br><span class="line">	pwq = unbound_pwq(wq, <span class="number">-1</span>);</span><br><span class="line">	<span class="comment">// 锁定pwq所在池的自旋锁，并增加pwq的引用计数。</span></span><br><span class="line">	raw_spin_lock_irq(&amp;pwq-&gt;pool-&gt;lock);</span><br><span class="line">	get_pwq(pwq);</span><br><span class="line">	raw_spin_unlock_irq(&amp;pwq-&gt;pool-&gt;lock);</span><br><span class="line">	<span class="comment">// 将这个默认的pwq安装到指定cpu的槽位上，并返回旧的pwq。</span></span><br><span class="line">	old_pwq = install_unbound_pwq(wq, cpu, pwq);</span><br><span class="line">out_unlock:</span><br><span class="line">	<span class="comment">// 解锁工作队列的互斥锁。</span></span><br><span class="line">	mutex_unlock(&amp;wq-&gt;mutex);</span><br><span class="line">	<span class="comment">// 减少旧pwq的引用计数，如果引用计数归零，则释放它。</span></span><br><span class="line">	put_pwq_unlocked(old_pwq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="workqueue-init-topology-为非绑定工作队列初始化CPU-“pod”（荚-分组）"><a href="#workqueue-init-topology-为非绑定工作队列初始化CPU-“pod”（荚-分组）" class="headerlink" title="workqueue_init_topology 为非绑定工作队列初始化CPU “pod”（荚&#x2F;分组）"></a>workqueue_init_topology 为非绑定工作队列初始化CPU “pod”（荚&#x2F;分组）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * workqueue_init_topology - 为非绑定工作队列初始化CPU &quot;pod&quot;（荚/分组）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这是工作队列子系统三阶段初始化中的第三步，在SMP（对称多处理）和</span></span><br><span class="line"><span class="comment"> * 拓扑信息完全初始化之后被调用。它相应地初始化非绑定的CPU pod。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">workqueue_init_topology</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 声明一个指向 workqueue_struct 的指针 wq，用于遍历工作队列列表。*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">wq</span>;</span></span><br><span class="line">	<span class="comment">/* 声明一个整型变量 cpu，用于遍历在线的CPU。*/</span></span><br><span class="line">	<span class="type">int</span> cpu;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化 &#x27;WQ_AFFN_CPU&#x27; 类型的 pod。&#x27;cpus_dont_share&#x27; 表示每个CPU自成一组。</span></span><br><span class="line"><span class="comment">	 * 这是最细粒度的分组。*/</span></span><br><span class="line">	init_pod_type(&amp;wq_pod_types[WQ_AFFN_CPU], cpus_dont_share);</span><br><span class="line">	<span class="comment">/* 初始化 &#x27;WQ_AFFN_SMT&#x27; 类型的 pod。&#x27;cpus_share_smt&#x27; 表示共享SMT（如超线程）的</span></span><br><span class="line"><span class="comment">	 * 逻辑CPU被分为一组。*/</span></span><br><span class="line">	init_pod_type(&amp;wq_pod_types[WQ_AFFN_SMT], cpus_share_smt);</span><br><span class="line">	<span class="comment">/* 初始化 &#x27;WQ_AFFN_CACHE&#x27; 类型的 pod。&#x27;cpus_share_cache&#x27; 表示共享缓存</span></span><br><span class="line"><span class="comment">	 * (通常是L2或L3)的CPU被分为一组。*/</span></span><br><span class="line">	init_pod_type(&amp;wq_pod_types[WQ_AFFN_CACHE], cpus_share_cache);</span><br><span class="line">	<span class="comment">/* 初始化 &#x27;WQ_AFFN_NUMA&#x27; 类型的 pod。&#x27;cpus_share_numa&#x27; 表示属于同一个NUMA节点</span></span><br><span class="line"><span class="comment">	 * 的CPU被分为一组。*/</span></span><br><span class="line">	init_pod_type(&amp;wq_pod_types[WQ_AFFN_NUMA], cpus_share_numa);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 设置全局标志，表示工作队列的拓扑结构已经初始化完成。*/</span></span><br><span class="line">	wq_topo_initialized = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 锁住 wq_pool_mutex 互斥锁，以保护对全局工作队列池的并发访问。*/</span></span><br><span class="line">	mutex_lock(&amp;wq_pool_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 在此函数执行前就分配的工作队列，会把所有CPU都关联到默认的 worker pool。</span></span><br><span class="line"><span class="comment">	 * 现在需要显式地对所有已存在的工作队列和CPU的组合调用 unbound_wq_update_pwq()，</span></span><br><span class="line"><span class="comment">	 * 来应用基于 pod 的共享策略。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/* 遍历全局的 &#x27;workqueues&#x27; 链表，该链表包含了系统中所有已创建的工作队列。*/</span></span><br><span class="line">	list_for_each_entry(wq, &amp;workqueues, <span class="built_in">list</span>) &#123;</span><br><span class="line">		<span class="comment">/* 对于每一个工作队列，遍历系统里每一个在线的CPU。*/</span></span><br><span class="line">		for_each_online_cpu(cpu)</span><br><span class="line">			<span class="comment">/* 更新这个工作队列(wq)在指定CPU(cpu)上的 per-queue-worker-pool (pwq)</span></span><br><span class="line"><span class="comment">			 * 信息，使其与新的拓扑分组对齐。*/</span></span><br><span class="line">			unbound_wq_update_pwq(wq, cpu);</span><br><span class="line">		<span class="comment">/* 如果该工作队列是一个非绑定（UNBOUND）工作队列。*/</span></span><br><span class="line">		<span class="keyword">if</span> (wq-&gt;flags &amp; WQ_UNBOUND) &#123;</span><br><span class="line">			<span class="comment">/* 锁住该工作队列自身的互斥锁，以保护其内部数据。*/</span></span><br><span class="line">			mutex_lock(&amp;wq-&gt;mutex);</span><br><span class="line">			<span class="comment">/* 根据新的拓扑信息，更新该工作队列在NUMA节点上的最大并发工作数量。</span></span><br><span class="line"><span class="comment">			 * -1 表示让系统自动计算。*/</span></span><br><span class="line">			wq_update_node_max_active(wq, <span class="number">-1</span>);</span><br><span class="line">			<span class="comment">/* 解锁该工作队列的互斥锁。*/</span></span><br><span class="line">			mutex_unlock(&amp;wq-&gt;mutex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 解锁全局的工作队列池互斥锁。*/</span></span><br><span class="line">	mutex_unlock(&amp;wq_pool_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/wdfk-prog">Liya Huang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://wdfk-prog.space/posts/db1bbe40/">https://wdfk-prog.space/posts/db1bbe40/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://wdfk-prog.space" target="_blank">wdfk-prog的个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/linux/">linux</a><a class="post-meta__tags" href="/tags/kernel/">kernel</a></div><div class="post-share"><div class="social-share" data-image="/images/covers/02.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/images/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/images/alipay.png" target="_blank"><img class="post-qr-code-img" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/alipay.png" alt="支付寶"/></a><div class="post-qr-code-desc">支付寶</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/44c8f818/" title="list"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/10.jpg" onerror="onerror=null;src='/images/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">list</div></div><div class="info-2"><div class="info-item-1">  [TOC]  include&#x2F;linux&#x2F;list.h 内核双向循环链表(Kernel Doubly-Linked List) 内核数据结构的基础构建块历史与背景这项技术是为了解决什么特定问题而诞生的？include/linux/list.h 提供了一套宏和内联函数，用于实现侵入式（Intrusive）的双向循环链表（Doubly-Linked Circular List）。它的诞生是为了解决在C语言编写的操作系统内核中一个极其普遍和基础的问题：如何以一种高效、类型安全且代码复用度高的方式，将任意类型的数据结构组织成一个链表。 在没有这样一个通用实现的情况下，每个需要使用链表的子系统都可能会：  重复造轮子：自己定义一套链表节点和操作函数，导致代码冗余和不一致。 使用非侵入式链表：创建一个通用的链表节点结构，其中包含一个void *指针来指向实际数据。这种方式的缺点是： 额外的内存开销：每次向链表中添加一个元素，都需要额外分配一个链表节点。 性能开销：访问实际数据需要两次指针解引用（list_node-&gt;data），这会降低缓存效率。 类型不安全：从...</div></div></div></a><a class="pagination-related" href="/posts/aca6454c/" title="printk"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/04.jpg" onerror="onerror=null;src='/images/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">printk</div></div><div class="info-2"><div class="info-item-1">[TOC] kernel&#x2F;printk.c 内核打印(Kernel Printing) 内核信息输出的基础设施历史与背景这项技术是为了解决什么特定问题而诞生的？kernel/printk.c 及其核心功能 printk() 的诞生，是为了解决一个对于操作系统内核来说最根本的问题：如何从一个没有标准输出（stdout）、没有文件系统、甚至可能没有正常运行环境的受限上下文中，可靠地输出诊断信息。 用户空间的程序可以简单地使用 printf() 将信息打印到终端，但内核无法这样做。内核是所有用户空间程序运行的基础，它需要一个独立于任何用户进程的日志记录机制，以应对以下场景：  系统启动早期：在 init 进程启动之前，甚至在控制台驱动初始化之前，就需要有方法来报告硬件探测、内存初始化等关键步骤的状态。 中断和异常上下文：当内核正在处理一个硬件中断或CPU异常时，它处于一个不能睡眠、不能调用大部分内核函数的受限上下文中。此时需要一个足够安全、不会导致死锁的打印函数。 系统崩溃（Kernel Panic）：当系统遭遇无法恢复的致命错误时，printk 通常是内核在“死亡”前留下最...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/d32d8ac9/" title="clocksource"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/02.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-03</div><div class="info-item-2">clocksource</div></div><div class="info-2"><div class="info-item-1">[TOC] clocksource 内核时钟源(Kernel Clocksource) 为内核提供统一的时间基准历史与背景这项技术是为了解决什么特定问题而诞生的？clocksource框架的诞生是为了解决Linux内核中一个根本性的问题：如何以一种统一、可移植的方式来处理多样化的硬件计时器。  硬件的多样性：不同的CPU架构和平台提供了五花八门的硬件计时器，例如x86上的TSC（时间戳计数器）、HPET（高精度事件定时器）、ACPI PM Timer，以及ARM平台上的Architected Timer等。这些计时器的精度、速度、稳定性和编程接口各不相同。 缺乏统一抽象：在clocksource框架出现之前，内核中的时间管理代码与特定的硬件架构和计时器紧密耦合。这使得将内核移植到新平台变得困难，也难以在运行时动态选择最优的计时器硬件。 对高精度的需求：随着系统应用（如实时系统、高频交易、性能剖析）对时间精度要求的提高，内核需要一个能够充分利用现代高精度计时器硬件的框架。  clocksource框架通过创建一个通用的抽象层，将这些底层硬件计时器的差异性隐藏起来，为内核的上层时间子...</div></div></div></a><a class="pagination-related" href="/posts/5a79feca/" title="dma"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/02.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-03</div><div class="info-item-2">dma</div></div><div class="info-2"><div class="info-item-1">[TOC] drivers&#x2F;dma DMA引擎与映射(DMA Engine &amp; Mapping) 内核统一的直接内存访问框架历史与背景这项技术是为了解决什么特定问题而诞生的？DMA（Direct Memory Access，直接内存访问）框架的诞生是为了解决一个根本性的性能瓶颈问题，并为内核提供一个统一、可移植的解决方案。  解决CPU性能瓶颈：在没有DMA的系统中，当外设（如网卡、磁盘）需要与内存交换大量数据时，CPU必须亲自担当“搬运工”的角色。这种方式被称为PIO（Programmed I&#x2F;O），CPU需要逐字节或逐字地从设备读取数据再写入内存，或者反之。对于高速设备，这会消耗大量的CPU周期，导致CPU无暇处理其他计算任务，严重影响系统整体性能。DMA技术通过引入一个专门的硬件控制器（DMAC），允许外设在没有CPU干预的情况下直接与内存进行数据传输，从而将CPU解放出来。 抽象硬件差异：不同的CPU架构和SoC平台，其DMA控制器的设计和编程接口千差万别。如果没有一个统一的软件框架，设备驱动程序的开发者将不得不为每一种不同的DMAC编写特定的...</div></div></div></a><a class="pagination-related" href="/posts/ba80502e/" title="cpu"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/03.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-03</div><div class="info-item-2">cpu</div></div><div class="info-2"><div class="info-item-1">[TOC] include&#x2F;linux&#x2F;cpumask.hcpumask_check 验证当前cpu数量是否超过了配置的最大cpu数量,并返回cpu1234567891011121314151617// 验证当前cpu数量是否超过了配置的最大cpu数量static __always_inline void cpu_max_bits_warn(unsigned int cpu, unsigned int bits)&#123;#ifdef CONFIG_DEBUG_PER_CPU_MAPS	WARN_ON_ONCE(cpu &gt;= bits);#endif /* CONFIG_DEBUG_PER_CPU_MAPS */&#125;/* verify cpu argument to cpumask_* operators *///验证当前cpu数量是否超过了配置的最大cpu数量static __always_inline unsigned int cpumask_check(unsigned int cpu)&#123;    //small_cpumask_...</div></div></div></a><a class="pagination-related" href="/posts/dd631879/" title="kallsyms"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/08.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-06</div><div class="info-item-2">kallsyms</div></div><div class="info-2"><div class="info-item-1">  [TOC] kernel&#x2F;kallsyms.c 内核符号表(Kernel Symbols) 运行时内核符号解析 历史与背景这项技术是为了解决什么特定问题而诞生的？kallsyms（Kernel All Symbols）机制的诞生是为了解决在内核运行时动态解析符号地址的核心需求。一个符号（Symbol）是程序中的一个构建块，通常指代一个函数名或变量名。内核在运行时，更倾向于直接使用内存地址（如 0xffffffff81c33580）而不是符号名（如 schedule）。 然而，在很多场景下，将地址转换回人类可读的符号名是至关重要的：  内核调试与错误分析：当内核发生严重错误（Kernel Panic）或“oops”时，它会打印出当时的寄存器状态和函数调用栈（Call Trace）。 如果调用栈仅仅是一串十六进制地址，那么对于开发者来说几乎是无用的。kallsyms 机制使得内核能够在崩溃时，当场将这些地址解析成具体的函数名和偏移量，极大地简化了调试过程。 动态模块加载：内核模块（Loadable Kernel Modules, LKM）在加载时需要链接到内核主镜像中的...</div></div></div></a><a class="pagination-related" href="/posts/c674e474/" title="init"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/06.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-03</div><div class="info-item-2">init</div></div><div class="info-2"><div class="info-item-1"> [TOC] init&#x2F;init_task.c 内核线程的一个核心特征是：它们没有自己独立的用户地址空间。它们只在内核空间运行，而内核地址空间是所有进程共享的。因此，内核线程不需要一个属于自己的内存描述符 struct mm_struct，所以它们的 task-&gt;mm 指针通常是 NULL  init_task 就是大名鼎鼎的 PID 0 进程，也常被称为 swapper 进程。从它的标志位 .flags &#x3D; PF_KTHREAD 可以看出，它是一个内核线程。  init_task 的调度策略(policy)是 SCHED_NORMAL，这意味着它是一个普通的分时调度任务，而不是实时任务。但是初始化阶段调用了init_idle()，使得它的sched_class 是 SCHED_IDLE，这样它就可以作为 CPU 的空闲任务运行。但是fork出来的其他进程继承的还是 SCHED_NORMAL 策略。  进程的“始祖”：init_task 是系统中所有进程的祖先。在系统启动后，它会创建第一个内核线程 kernel_init（它最终会成为 PID 1 的 i...</div></div></div></a><a class="pagination-related" href="/posts/6ce74947/" title="regmap"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/08.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-03</div><div class="info-item-2">regmap</div></div><div class="info-2"><div class="info-item-1">[TOC] regmapRegmap 简介Regmap 是 Linux 内核中的一个子系统，用于抽象和管理设备寄存器的访问。它为驱动程序提供了统一的接口，支持多种总线（如 I2C、SPI、MMIO 等）上的寄存器操作，同时提供了缓存、锁机制和调试功能。Regmap 的设计目标是简化驱动开发，减少重复代码，并提高寄存器访问的效率和安全性。  工作原理1. 核心概念 寄存器映射 (Register Map):Regmap 将设备的寄存器抽象为一个统一的映射，屏蔽了底层总线的差异。  寄存器缓存:Regmap 提供了可选的寄存器缓存机制，用于减少总线访问次数，提高性能。  寄存器访问控制:通过配置文件（struct regmap_config），可以定义哪些寄存器是可读、可写或易失的。  总线适配器:Regmap 支持多种总线（如 I2C、SPI、MMIO 等），通过总线适配器实现具体的读写操作。   2. 数据结构 struct regmap:表示寄存器映射的核心数据结构，包含寄存器的地址、值、缓存等信息。  struct regmap_config:配置寄存器映射的结构体，用于定义...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/avatar.png" onerror="this.onerror=null;this.src='/images/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Liya Huang</div><div class="author-info-description">WORK-LIFE BALANCE</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">417</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">49</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">53</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/wdfk-prog"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/wdfk-prog" rel="external nofollow noreferrer" target="_blank" title="GitHub"><i class="fab fa-github" style="color: #181717;"></i></a><a class="social-icon" href="https://wdfk-prog.blog.csdn.net/" rel="external nofollow noreferrer" target="_blank" title="CSDN"><i class="fas fa-blog" style="color: #FC5531;"></i></a><a class="social-icon" href="mailto:1425075683@qq.com" rel="external nofollow noreferrer" target="_blank" title="E-mail"><i class="fas fa-envelope" style="color: #4A4A4A;"></i></a><a class="social-icon" href="/images/wechat-qrcode.jpg" target="_blank" title="微信公众号"><i class="fab fa-weixin" style="color: #07C160;"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss" style="color: #EE802F;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎光临！有任何问题或想法，欢迎在文章下留言交流，或者通过 <a href='/about/'>关于页面</a> 联系我。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#kernel-workqueue-c-%E5%86%85%E6%A0%B8%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97-Kernel-Workqueues-%E9%80%9A%E7%94%A8%E7%9A%84%E5%86%85%E6%A0%B8%E5%90%8E%E5%8F%B0%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86%E6%A1%86%E6%9E%B6"><span class="toc-number">1.</span> <span class="toc-text">kernel&#x2F;workqueue.c 内核工作队列(Kernel Workqueues) 通用的内核后台任务处理框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%86%E5%8F%B2%E4%B8%8E%E8%83%8C%E6%99%AF"><span class="toc-number">1.0.1.</span> <span class="toc-text">历史与背景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%99%E9%A1%B9%E6%8A%80%E6%9C%AF%E6%98%AF%E4%B8%BA%E4%BA%86%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E7%89%B9%E5%AE%9A-%E2%80%9C%E9%97%AE%E9%A2%98%E8%80%8C%E8%AF%9E%E7%94%9F%E7%9A%84%EF%BC%9F"><span class="toc-number">1.0.1.1.</span> <span class="toc-text">这项技术是为了解决什么特定 “问题而诞生的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%83%E7%9A%84%E5%8F%91%E5%B1%95%E7%BB%8F%E5%8E%86%E4%BA%86%E5%93%AA%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9A%84%E9%87%8C%E7%A8%8B%E7%A2%91%E6%88%96%E7%89%88%E6%9C%AC%E8%BF%AD%E4%BB%A3%EF%BC%9F"><span class="toc-number">1.0.1.2.</span> <span class="toc-text">它的发展经历了哪些重要的里程碑或版本迭代？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E5%89%8D%E8%AF%A5%E6%8A%80%E6%9C%AF%E7%9A%84%E7%A4%BE%E5%8C%BA%E6%B4%BB%E8%B7%83%E5%BA%A6%E5%92%8C%E4%B8%BB%E6%B5%81%E5%BA%94%E7%94%A8%E6%83%85%E5%86%B5%E5%A6%82%E4%BD%95%EF%BC%9F"><span class="toc-number">1.0.1.3.</span> <span class="toc-text">目前该技术的社区活跃度和主流应用情况如何？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.0.2.</span> <span class="toc-text">核心原理与设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%83%E7%9A%84%E6%A0%B8%E5%BF%83%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.0.2.1.</span> <span class="toc-text">它的核心工作原理是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%83%E7%9A%84%E4%B8%BB%E8%A6%81%E4%BC%98%E5%8A%BF%E4%BD%93%E7%8E%B0%E5%9C%A8%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2%EF%BC%9F"><span class="toc-number">1.0.2.2.</span> <span class="toc-text">它的主要优势体现在哪些方面？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%83%E5%AD%98%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%B7%B2%E7%9F%A5%E7%9A%84%E5%8A%A3%E5%8A%BF%E3%80%81%E5%B1%80%E9%99%90%E6%80%A7%E6%88%96%E5%9C%A8%E7%89%B9%E5%AE%9A%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E4%B8%8D%E9%80%82%E7%94%A8%E6%80%A7%EF%BC%9F"><span class="toc-number">1.0.2.3.</span> <span class="toc-text">它存在哪些已知的劣势、局限性或在特定场景下的不适用性？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.0.3.</span> <span class="toc-text">使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%85%B7%E4%BD%93%E7%9A%84%E4%B8%9A%E5%8A%A1%E6%88%96%E6%8A%80%E6%9C%AF%E5%9C%BA%E6%99%AF%E4%B8%8B%EF%BC%8C%E5%AE%83%E6%98%AF%E9%A6%96%E9%80%89%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="toc-number">1.0.3.1.</span> <span class="toc-text">在哪些具体的业务或技术场景下，它是首选解决方案？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E5%90%A6%E6%9C%89%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E8%AF%A5%E6%8A%80%E6%9C%AF%E7%9A%84%E5%9C%BA%E6%99%AF%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.0.3.2.</span> <span class="toc-text">是否有不推荐使用该技术的场景？为什么？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90"><span class="toc-number">1.0.4.</span> <span class="toc-text">对比分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E5%B0%86%E5%85%B6-%E4%B8%8E-%E5%85%B6%E4%BB%96%E7%9B%B8%E4%BC%BC%E6%8A%80%E6%9C%AF-%E8%BF%9B%E8%A1%8C%E8%AF%A6%E7%BB%86%E5%AF%B9%E6%AF%94%E3%80%82"><span class="toc-number">1.0.4.1.</span> <span class="toc-text">请将其 与 其他相似技术 进行详细对比。</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#include-linux-workqueue-h"><span class="toc-number">2.</span> <span class="toc-text">include&#x2F;linux&#x2F;workqueue.h</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#INIT-WORK"><span class="toc-number">2.1.</span> <span class="toc-text">INIT_WORK</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#queue-delayed-work-%E5%BB%B6%E8%BF%9F%E5%90%8E%E5%AF%B9-workqueue-%E4%B8%8A%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%9B%E8%A1%8C%E6%8E%92%E9%98%9F"><span class="toc-number">2.2.</span> <span class="toc-text">queue_delayed_work 延迟后对 workqueue 上的工作进行排队</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#kernel-workqueue-internal-h"><span class="toc-number">3.</span> <span class="toc-text">kernel&#x2F;workqueue_internal.h</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#kernel-workqueue-c"><span class="toc-number">4.</span> <span class="toc-text">kernel&#x2F;workqueue.c</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#init-cpu-worker-pool-%E5%88%9D%E5%A7%8B%E5%8C%96-CPU-%E5%B7%A5%E4%BD%9C%E6%B1%A0"><span class="toc-number">4.1.</span> <span class="toc-text">init_cpu_worker_pool 初始化 CPU 工作池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#init-pwq-%E5%88%9D%E5%A7%8B%E5%8C%96-pwq"><span class="toc-number">4.2.</span> <span class="toc-text">init_pwq 初始化 pwq</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#wq-cpumask-show-%E6%98%BE%E7%A4%BACPU%E6%8E%A9%E7%A0%81%E7%9A%84%E6%A0%B8%E5%BF%83%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0"><span class="toc-number">4.3.</span> <span class="toc-text">__wq_cpumask_show: 显示CPU掩码的核心实现函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cpumask-requested-show-DEVICE-ATTR-RO-cpumask-requested-%E6%98%BE%E7%A4%BA-%E2%80%9Crequested%E2%80%9D-CPU%E6%8E%A9%E7%A0%81"><span class="toc-number">4.4.</span> <span class="toc-text">cpumask_requested_show &amp; DEVICE_ATTR_RO(cpumask_requested): 显示 “requested” CPU掩码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cpumask-isolated-show-DEVICE-ATTR-RO-cpumask-isolated-%E6%98%BE%E7%A4%BA-%E2%80%9Cisolated%E2%80%9D-CPU%E6%8E%A9%E7%A0%81"><span class="toc-number">4.5.</span> <span class="toc-text">cpumask_isolated_show &amp; DEVICE_ATTR_RO(cpumask_isolated): 显示 “isolated” CPU掩码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cpumask-show-cpumask-store-DEVICE-ATTR-RW-cpumask-%E6%98%BE%E7%A4%BA%E5%92%8C%E4%BF%AE%E6%94%B9%E5%BD%93%E5%89%8D%E7%9A%84CPU%E6%8E%A9%E7%A0%81"><span class="toc-number">4.6.</span> <span class="toc-text">cpumask_show, cpumask_store &amp; DEVICE_ATTR_RW(cpumask): 显示和修改当前的CPU掩码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#wq-sysfs-cpumask-attrs-ATTRIBUTE-GROUPS-%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E7%BB%84"><span class="toc-number">4.7.</span> <span class="toc-text">wq_sysfs_cpumask_attrs &amp; ATTRIBUTE_GROUPS: 定义属性组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#wq-sysfs-init-core-initcall-%E6%B3%A8%E5%86%8Csysfs%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.8.</span> <span class="toc-text">wq_sysfs_init &amp; core_initcall: 注册sysfs接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#format-worker-id-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B-ID"><span class="toc-number">4.9.</span> <span class="toc-text">format_worker_id 格式化工作线程 ID</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#worker-enter-idle-%E8%BF%9B%E5%85%A5%E7%A9%BA%E9%97%B2%E7%8A%B6%E6%80%81"><span class="toc-number">4.10.</span> <span class="toc-text">worker_enter_idle 进入空闲状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#set-pf-worker-%E8%AE%BE%E7%BD%AE%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E4%B8%BA%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.11.</span> <span class="toc-text">set_pf_worker 设置当前线程为工作队列工作线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#worker-leave-idle-%E7%A6%BB%E5%BC%80%E7%A9%BA%E9%97%B2%E7%8A%B6%E6%80%81"><span class="toc-number">4.12.</span> <span class="toc-text">worker_leave_idle - 离开空闲状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#need-more-worker-%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E5%94%A4%E9%86%92%E6%88%96%E5%88%9B%E5%BB%BA%E6%9B%B4%E5%A4%9A%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%EF%BC%88worker%EF%BC%89%E6%9D%A5%E5%A4%84%E7%90%86%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E4%B8%AD%E7%9A%84%E4%BB%BB%E5%8A%A1"><span class="toc-number">4.13.</span> <span class="toc-text">need_more_worker 判断是否需要唤醒或创建更多的工作线程（worker）来处理工作队列中的任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#may-start-working-%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%BC%80%E5%A7%8B%E5%B7%A5%E4%BD%9C"><span class="toc-number">4.14.</span> <span class="toc-text">may_start_working 判断是否可以开始工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#wake-up-process-%E5%94%A4%E9%86%92%E7%89%B9%E5%AE%9A%E8%BF%9B%E7%A8%8B"><span class="toc-number">4.15.</span> <span class="toc-text">wake_up_process 唤醒特定进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#worker-thread-%E5%B7%A5%E4%BD%9C%E8%80%85%E7%BA%BF%E7%A8%8B%E5%87%BD%E6%95%B0"><span class="toc-number">4.16.</span> <span class="toc-text">worker_thread - 工作者线程函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#create-worker-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.17.</span> <span class="toc-text">create_worker  创建一个新的工作队列工作线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#maybe-create-worker-%E5%8F%AF%E8%83%BD%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.18.</span> <span class="toc-text">maybe_create_worker 可能创建一个新的工作线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#manage-workers-%E7%AE%A1%E7%90%86%E5%B7%A5%E4%BD%9C%E6%B1%A0"><span class="toc-number">4.19.</span> <span class="toc-text">manage_workers 管理工作池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#find-worker-executing-work-%E6%9F%A5%E6%89%BE%E6%AD%A3%E5%9C%A8%E6%89%A7%E8%A1%8C%E5%B7%A5%E4%BD%9C%E9%A1%B9%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.20.</span> <span class="toc-text">find_worker_executing_work 查找正在执行工作项的工作线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#move-linked-works-%E7%A7%BB%E5%8A%A8%E5%85%B3%E8%81%94%E7%9A%84%E5%B7%A5%E4%BD%9C%E9%A1%B9"><span class="toc-number">4.21.</span> <span class="toc-text">move_linked_works 移动关联的工作项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#assign-work-%E5%88%86%E9%85%8D%E5%B7%A5%E4%BD%9C%E9%A1%B9"><span class="toc-number">4.22.</span> <span class="toc-text">assign_work 分配工作项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#keep-working-%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E7%BB%A7%E7%BB%AD%E5%B7%A5%E4%BD%9C"><span class="toc-number">4.23.</span> <span class="toc-text">keep_working 判断是否需要继续工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#get-pwq-%E8%8E%B7%E5%8F%96%E6%8C%87%E5%AE%9Apool-workqueue%E7%9A%84%E9%A2%9D%E5%A4%96%E5%BC%95%E7%94%A8"><span class="toc-number">4.24.</span> <span class="toc-text">get_pwq 获取指定pool_workqueue的额外引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#put-pwq-%E5%8F%96%E6%B6%88%E5%AF%B9-pwq-%E7%9A%84%E5%BC%95%E7%94%A8%E3%80%82%E5%A6%82%E6%9E%9C%E5%AE%83%E7%9A%84%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E9%99%8D%E4%B8%BA%E9%9B%B6%EF%BC%8C%E5%AE%89%E6%8E%92%E9%94%80%E6%AF%81%E5%AE%83%E3%80%82%E8%B0%83%E7%94%A8%E8%80%85%E5%BA%94%E8%AF%A5%E6%8C%81%E6%9C%89%E5%8C%B9%E9%85%8D%E7%9A%84-pool-lock%E3%80%82"><span class="toc-number">4.25.</span> <span class="toc-text">put_pwq 取消对 @pwq 的引用。如果它的引用计数降为零，安排销毁它。调用者应该持有匹配的 pool-&gt;lock。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#get-work-color-%E4%BB%8E-work-data-%E4%B8%AD%E6%8F%90%E5%8F%96%E5%B7%A5%E4%BD%9C%E9%A1%B9%E7%9A%84%E9%A2%9C%E8%89%B2%EF%BC%88color%EF%BC%89"><span class="toc-number">4.26.</span> <span class="toc-text">get_work_color 从 work_data 中提取工作项的颜色（color）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwq-dec-nr-in-flight-%E5%87%8F%E5%B0%91-pwq-%E7%9A%84-nr-in-flight"><span class="toc-number">4.27.</span> <span class="toc-text">pwq_dec_nr_in_flight 减少 pwq 的 nr_in_flight</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#first-idle-worker-%E8%BF%94%E5%9B%9E%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A9%BA%E9%97%B2%E7%9A%84-worker"><span class="toc-number">4.28.</span> <span class="toc-text">first_idle_worker 返回第一个空闲的 worker</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#need-more-worker-%E5%88%A4%E6%96%AD%E5%B7%A5%E4%BD%9C%E6%B1%A0%EF%BC%88worker-pool%EF%BC%89%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E5%94%A4%E9%86%92%E6%9B%B4%E5%A4%9A%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%EF%BC%88worker%EF%BC%89"><span class="toc-number">4.29.</span> <span class="toc-text">need_more_worker 判断工作池（worker_pool）是否需要唤醒更多的工作线程（worker）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kick-bh-pool-%E7%94%A8%E4%BA%8E%E5%94%A4%E9%86%92%E8%BD%AF%E4%B8%AD%E6%96%AD%EF%BC%88Bottom-Half%EF%BC%8C%E7%AE%80%E7%A7%B0-BH%EF%BC%89%E5%B7%A5%E4%BD%9C%E6%B1%A0%E4%B8%AD%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.30.</span> <span class="toc-text">kick_bh_pool 用于唤醒软中断（Bottom Half，简称 BH）工作池中的工作线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kick-pool-%E5%A6%82%E6%9C%89%E5%BF%85%E8%A6%81%EF%BC%8C%E5%94%A4%E9%86%92%E7%A9%BA%E9%97%B2%E7%9A%84-worker"><span class="toc-number">4.31.</span> <span class="toc-text">kick_pool 如有必要，唤醒空闲的 worker</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#process-one-work-%E5%A4%84%E7%90%86%E5%8D%95%E4%B8%AA%E5%B7%A5%E4%BD%9C%E9%A1%B9"><span class="toc-number">4.32.</span> <span class="toc-text">process_one_work 处理单个工作项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#process-scheduled-works-%E5%A4%84%E7%90%86%E8%B0%83%E5%BA%A6%E7%9A%84%E5%B7%A5%E4%BD%9C"><span class="toc-number">4.33.</span> <span class="toc-text">process_scheduled_works 处理调度的工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#set-pf-worker-%E6%A0%87%E8%AF%86%E4%B8%80%E4%B8%AA%E4%BB%BB%E5%8A%A1%E6%98%AF%E5%90%A6%E4%B8%BA%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%EF%BC%88workqueue%EF%BC%89%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%80%85%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.34.</span> <span class="toc-text">set_pf_worker 标识一个任务是否为工作队列（workqueue）的工作者线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#worker-thread-%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E5%87%BD%E6%95%B0"><span class="toc-number">4.35.</span> <span class="toc-text">worker_thread 工作线程函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#wqattrs-hash-%E8%AE%A1%E7%AE%97%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E5%B1%9E%E6%80%A7%E7%9A%84%E5%93%88%E5%B8%8C%E5%80%BC"><span class="toc-number">4.36.</span> <span class="toc-text">wqattrs_hash 计算工作队列属性的哈希值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#set-worker-dying-%E8%AE%BE%E7%BD%AE%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E4%B8%BA%E6%AD%BB%E4%BA%A1%E7%8A%B6%E6%80%81"><span class="toc-number">4.37.</span> <span class="toc-text">set_worker_dying 设置工作线程为死亡状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#detach-worker-%E5%88%86%E7%A6%BB%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.38.</span> <span class="toc-text">detach_worker 分离工作线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#detach-dying-workers-%E5%88%86%E7%A6%BB%E6%AD%BB%E4%BA%A1%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.39.</span> <span class="toc-text">detach_dying_workers 分离死亡的工作线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#work-grab-pending-%E4%BB%8E-WorkList-%E4%B8%AD%E7%AA%83%E5%8F%96%E5%B7%A5%E4%BD%9C%E9%A1%B9%E5%B9%B6%E7%A6%81%E7%94%A8-IRQ"><span class="toc-number">4.40.</span> <span class="toc-text">work_grab_pending 从 WorkList 中窃取工作项并禁用 IRQ</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#offqd-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">4.40.1.</span> <span class="toc-text">offqd 的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#offqd-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.40.2.</span> <span class="toc-text">offqd 的使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.40.3.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#flush-work-%E7%AD%89%E5%BE%85%E4%B8%80%E4%B8%AA%E5%B7%A5%E4%BD%9C%E9%A1%B9%E5%AE%8C%E6%88%90%E5%85%B6%E6%9C%80%E5%90%8E%E7%9A%84%E6%89%A7%E8%A1%8C"><span class="toc-number">4.40.4.</span> <span class="toc-text">flush_work: 等待一个工作项完成其最后的执行</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#insert-wq-barrier-%E5%90%91%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E4%B8%AD%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%AA%E5%B1%8F%E9%9A%9C%E5%B7%A5%E4%BD%9C%E9%A1%B9"><span class="toc-number">4.41.</span> <span class="toc-text">insert_wq_barrier: 向工作队列中插入一个屏障工作项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#start-flush-work-%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E5%B7%A5%E4%BD%9C%E9%A1%B9%E7%9A%84%E5%86%B2%E5%88%B7%E6%93%8D%E4%BD%9C"><span class="toc-number">4.42.</span> <span class="toc-text">start_flush_work: 启动一个工作项的冲刷操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#flush-work-%E5%86%B2%E5%88%B7-flush-%E4%B8%80%E4%B8%AA%E5%B7%A5%E4%BD%9C%E9%A1%B9%E7%9A%84%E6%A0%B8%E5%BF%83%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.43.</span> <span class="toc-text">__flush_work: 冲刷(flush)一个工作项的核心实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cancel-work-%E5%8F%96%E6%B6%88%E5%B7%A5%E4%BD%9C%E9%A1%B9"><span class="toc-number">4.44.</span> <span class="toc-text">cancel_work  取消工作项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#put-unbound-pool-%E9%87%8A%E6%94%BE%E5%B7%A5%E4%BD%9C%E6%B1%A0"><span class="toc-number">4.45.</span> <span class="toc-text">put_unbound_pool 释放工作池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#get-unbound-pool-%E8%8E%B7%E5%8F%96%E5%85%B7%E6%9C%89%E6%8C%87%E5%AE%9A%E5%B1%9E%E6%80%A7%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B1%A0"><span class="toc-number">4.46.</span> <span class="toc-text">get_unbound_pool 获取具有指定属性的工作池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#alloc-unbound-pwq-%E7%94%A8%E4%BA%8E%E6%A0%B9%E6%8D%AE%E7%BB%99%E5%AE%9A%E7%9A%84%E5%B1%9E%E6%80%A7-attrs-%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AA%E5%90%88%E9%80%82%E7%9A%84-worker-pool"><span class="toc-number">4.47.</span> <span class="toc-text">alloc_unbound_pwq 用于根据给定的属性 attrs 获取一个合适的 worker pool</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#apply-wqattrs-prepare-%E5%BA%94%E7%94%A8%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E5%B1%9E%E6%80%A7"><span class="toc-number">4.48.</span> <span class="toc-text">apply_wqattrs_prepare 应用工作队列属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#apply-wqattrs-commit-%E5%BA%94%E7%94%A8%E6%96%B0%E7%9A%84%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E5%B1%9E%E6%80%A7%EF%BC%88wqattrs%EF%BC%89%EF%BC%8C%E5%B9%B6%E5%B0%86%E5%87%86%E5%A4%87%E5%A5%BD%E7%9A%84-pwqs%EF%BC%88per-CPU-workqueues%EF%BC%89%E5%AE%89%E8%A3%85%E5%88%B0%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E4%B8%AD"><span class="toc-number">4.49.</span> <span class="toc-text">apply_wqattrs_commit 应用新的工作队列属性（wqattrs），并将准备好的 pwqs（per-CPU workqueues）安装到工作队列中</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#apply-workqueue-attrs-locked-%E5%9C%A8%E5%8A%A0%E9%94%81%E7%8A%B6%E6%80%81%E4%B8%8B%E4%B8%BA-workqueue%EF%BC%88%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%EF%BC%89%E5%BA%94%E7%94%A8%E6%96%B0%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">4.50.</span> <span class="toc-text">apply_workqueue_attrs_locked 在加锁状态下为 workqueue（工作队列）应用新的属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#alloc-and-link-pwqs-%E5%88%86%E9%85%8D%E5%B9%B6%E9%93%BE%E6%8E%A5%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E6%B1%A0%EF%BC%88PWQ%EF%BC%89"><span class="toc-number">4.51.</span> <span class="toc-text">alloc_and_link_pwqs  分配并链接工作队列池（PWQ）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#alloc-workqueue-%E5%88%86%E9%85%8D%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97"><span class="toc-number">4.52.</span> <span class="toc-text">alloc_workqueue 分配工作队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#workqueue-init-early-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">4.53.</span> <span class="toc-text">workqueue_init_early 工作队初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for-each-pool-%E9%81%8D%E5%8E%86%E5%B7%A5%E4%BD%9C%E6%B1%A0"><span class="toc-number">4.54.</span> <span class="toc-text">for_each_pool 遍历工作池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#is-chained-work-%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E5%B7%A5%E4%BD%9C%E9%A1%B9%E6%98%AF%E5%90%A6%E6%98%AF%E7%94%B1%E5%90%8C%E4%B8%80%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E6%89%A7%E8%A1%8C%E7%9A%84%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%B7%A5%E4%BD%9C%E9%A1%B9%E8%A7%A6%E5%8F%91"><span class="toc-number">4.55.</span> <span class="toc-text">is_chained_work 判断当前工作项是否是由同一工作队列执行的另一个工作项触发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#work-struct-pwq-%E5%B0%86%E5%B7%A5%E4%BD%9C%E9%A1%B9%E7%9A%84-data-%E5%AD%97%E6%AE%B5%E8%BD%AC%E6%8D%A2%E4%B8%BA-pool-workqueue"><span class="toc-number">4.56.</span> <span class="toc-text">work_struct_pwq 将工作项的 data 字段转换为 pool_workqueue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#get-work-pool-%E8%BF%94%E5%9B%9E%E4%B8%8E%E7%BB%99%E5%AE%9A%E4%BD%9C%E5%93%81%E5%85%B3%E8%81%94%E7%9A%84worker-pool"><span class="toc-number">4.57.</span> <span class="toc-text">get_work_pool 返回与给定作品关联的worker_pool</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#find-worker-executing-work-%E6%9F%A5%E6%89%BE%E6%AD%A3%E5%9C%A8%E6%89%A7%E8%A1%8C%E5%B7%A5%E4%BD%9C%E7%9A%84-worker"><span class="toc-number">4.58.</span> <span class="toc-text">find_worker_executing_work 查找正在执行工作的 worker</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#set-work-data-%E8%AE%BE%E7%BD%AE%E5%B7%A5%E4%BD%9C%E9%A1%B9%E7%9A%84-data-%E5%AD%97%E6%AE%B5"><span class="toc-number">4.59.</span> <span class="toc-text">set_work_data 设置工作项的 data 字段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#set-work-pwq-%E8%AE%BE%E7%BD%AE%E5%B7%A5%E4%BD%9C%E9%A1%B9%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B1%A0%EF%BC%88pool-workqueue%EF%BC%89"><span class="toc-number">4.60.</span> <span class="toc-text">set_work_pwq 设置工作项的工作池（pool_workqueue）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#insert-work-%E5%B0%86%E4%B8%80%E4%B8%AA%E5%B7%A5%E4%BD%9C%E9%A1%B9%EF%BC%88work-struct%EF%BC%89%E6%8F%92%E5%85%A5%E5%88%B0%E5%B7%A5%E4%BD%9C%E6%B1%A0%EF%BC%88pool-workqueue%EF%BC%89%E7%9A%84%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE"><span class="toc-number">4.61.</span> <span class="toc-text">insert_work 将一个工作项（work_struct）插入到工作池（pool_workqueue）的指定位置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#wq-node-nr-active-%E7%94%A8%E4%BA%8E%E7%A1%AE%E5%AE%9A%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%EF%BC%88workqueue-struct%EF%BC%89%E5%9C%A8%E6%8C%87%E5%AE%9A-NUMA-%E8%8A%82%E7%82%B9%E4%B8%8A%E7%9A%84-wq-node-nr-active-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">4.62.</span> <span class="toc-text">wq_node_nr_active 用于确定工作队列（workqueue_struct）在指定 NUMA 节点上的 wq_node_nr_active 数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tryinc-node-nr-active-%E5%B0%9D%E8%AF%95%E5%A2%9E%E5%8A%A0-wq-node-nr-active-%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E7%9A%84%E6%B4%BB%E5%8A%A8%E8%AE%A1%E6%95%B0%EF%BC%88nr%EF%BC%89"><span class="toc-number">4.63.</span> <span class="toc-text">tryinc_node_nr_active 尝试增加 wq_node_nr_active 结构体中的活动计数（nr）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwq-tryinc-nr-active-%E5%B0%9D%E8%AF%95%E5%A2%9E%E5%8A%A0%E6%8C%87%E5%AE%9A%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%EF%BC%88pool-workqueue%EF%BC%8C%E7%AE%80%E7%A7%B0-pwq%EF%BC%89%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%B7%A5%E4%BD%9C%E9%A1%B9%E8%AE%A1%E6%95%B0%EF%BC%88nr-active%EF%BC%89"><span class="toc-number">4.64.</span> <span class="toc-text">pwq_tryinc_nr_active 尝试增加指定工作队列（pool_workqueue，简称 pwq）的活动工作项计数（nr_active）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#queue-work-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E6%B7%BB%E5%8A%A0%E5%B7%A5%E4%BD%9C"><span class="toc-number">4.65.</span> <span class="toc-text">__queue_work 工作队列添加工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#queue-delayed-work-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E6%B7%BB%E5%8A%A0%E5%BB%B6%E6%97%B6%E5%B7%A5%E4%BD%9C"><span class="toc-number">4.66.</span> <span class="toc-text">__queue_delayed_work 工作队列添加延时工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#queue-delayed-work-on-%E5%BB%B6%E8%BF%9F%E5%90%8E%E5%AF%B9%E7%89%B9%E5%AE%9A-CPU-%E4%B8%8A%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%9B%E8%A1%8C%E6%8E%92%E9%98%9F"><span class="toc-number">4.67.</span> <span class="toc-text">queue_delayed_work_on 延迟后对特定 CPU 上的工作进行排队</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#wq-worker-sleeping-%E5%A4%84%E7%90%86%E4%B8%80%E4%B8%AA%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%EF%BC%88worker%EF%BC%89%E8%BF%9B%E5%85%A5%E7%9D%A1%E7%9C%A0%E7%8A%B6%E6%80%81%E6%97%B6%E7%9A%84%E7%9B%B8%E5%85%B3%E9%80%BB%E8%BE%91"><span class="toc-number">4.68.</span> <span class="toc-text">wq_worker_sleeping 处理一个工作线程（worker）进入睡眠状态时的相关逻辑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#wq-cpu-intensive-thresh-init-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B9%B6%E5%8A%A8%E6%80%81%E8%B0%83%E6%95%B4wq-cpu-intensive-thresh-us"><span class="toc-number">4.69.</span> <span class="toc-text">wq_cpu_intensive_thresh_init 初始化并动态调整wq_cpu_intensive_thresh_us</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#workqueue-init-%E4%BD%BF%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%AE%8C%E5%85%A8%E4%B8%8A%E7%BA%BF"><span class="toc-number">4.70.</span> <span class="toc-text">workqueue_init 使工作队列子系统完全上线</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#init-pod-type-%E6%A0%B9%E6%8D%AE%E7%89%B9%E5%AE%9A%E7%9A%84%E7%89%A9%E7%90%86%E6%8B%93%E6%89%91%E5%85%B3%E7%B3%BB%E5%AF%B9%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89CPU%E8%BF%9B%E8%A1%8C%E5%88%86%E7%BB%84"><span class="toc-number">4.71.</span> <span class="toc-text">init_pod_type 根据特定的物理拓扑关系对系统中的所有CPU进行分组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unbound-wq-update-pwq-%E4%B8%93%E9%97%A8%E7%94%A8%E4%BA%8E%E5%A4%84%E7%90%86%E9%9D%9E%E7%BB%91%E5%AE%9A%EF%BC%88unbound%EF%BC%89%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E5%9C%A8CPU%E7%83%AD%E6%8F%92%E6%8B%94%EF%BC%88hotplug%EF%BC%89%E4%BA%8B%E4%BB%B6%E5%8F%91%E7%94%9F%E6%97%B6%E7%9A%84%E7%8A%B6%E6%80%81%E6%9B%B4%E6%96%B0"><span class="toc-number">4.72.</span> <span class="toc-text">unbound_wq_update_pwq 专门用于处理非绑定（unbound）工作队列在CPU热插拔（hotplug）事件发生时的状态更新</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#workqueue-init-topology-%E4%B8%BA%E9%9D%9E%E7%BB%91%E5%AE%9A%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E5%88%9D%E5%A7%8B%E5%8C%96CPU-%E2%80%9Cpod%E2%80%9D%EF%BC%88%E8%8D%9A-%E5%88%86%E7%BB%84%EF%BC%89"><span class="toc-number">4.73.</span> <span class="toc-text">workqueue_init_topology 为非绑定工作队列初始化CPU “pod”（荚&#x2F;分组）</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/48974a1a/" title="mq-deadline"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/08.jpg" onerror="this.onerror=null;this.src='/images/404.jpg'" alt="mq-deadline"/></a><div class="content"><a class="title" href="/posts/48974a1a/" title="mq-deadline">mq-deadline</a><time datetime="2025-10-10T09:35:34.893Z" title="更新于 2025-10-10 17:35:34">2025-10-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/44c8f818/" title="list"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/10.jpg" onerror="this.onerror=null;this.src='/images/404.jpg'" alt="list"/></a><div class="content"><a class="title" href="/posts/44c8f818/" title="list">list</a><time datetime="2025-10-10T08:51:23.325Z" title="更新于 2025-10-10 16:51:23">2025-10-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/447af9b5/" title="genhd"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/09.jpg" onerror="this.onerror=null;this.src='/images/404.jpg'" alt="genhd"/></a><div class="content"><a class="title" href="/posts/447af9b5/" title="genhd">genhd</a><time datetime="2025-10-10T08:50:59.612Z" title="更新于 2025-10-10 16:50:59">2025-10-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/ed4b199f/" title="class"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/01.jpg" onerror="this.onerror=null;this.src='/images/404.jpg'" alt="class"/></a><div class="content"><a class="title" href="/posts/ed4b199f/" title="class">class</a><time datetime="2025-10-10T08:38:03.324Z" title="更新于 2025-10-10 16:38:03">2025-10-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/aa511041/" title="blk-core"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/07.jpg" onerror="this.onerror=null;this.src='/images/404.jpg'" alt="blk-core"/></a><div class="content"><a class="title" href="/posts/aa511041/" title="blk-core">blk-core</a><time datetime="2025-10-10T08:15:30.737Z" title="更新于 2025-10-10 16:15:30">2025-10-10</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/images/covers/02.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">文档</div><div class="footer-flex-content"><a href="/categories/linux/" target="_blank" title="🚀 linux">🚀 linux</a><a href="/categories/rt-thread/" target="_blank" title="📑 rt-thread">📑 rt-thread</a><a href="/categories/uboot/" target="_blank" title="📌 uboot">📌 uboot</a><a href="/categories/LoraWan/" target="_blank" title="⚔️ LoraWan">⚔️ LoraWan</a><a href="/categories/hpatch/" target="_blank" title="❓ hpatch">❓ hpatch</a><a href="/categories/git/" target="_blank" title="⚡️ git">⚡️ git</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/gallery/" target="_blank" title="图库">图库</a><a href="/messageboard/" target="_blank" title="留言板">留言板</a><a href="/shuoshuo/" target="_blank" title="说说">说说</a><a href="/link/" target="_blank" title="示例">示例</a><a href="/link/" target="_blank" title="友链">友链</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">框架</div><div class="footer-flex-content"><a href="https://hexo.io/zh-cn/" rel="external nofollow noreferrer" target="_blank" title="Hexo">Hexo</a><a href="https://butterfly.js.org/" rel="external nofollow noreferrer" target="_blank" title="Butterfly">Butterfly</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">贊助</div><div class="footer-flex-content"><div><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/alipay.png" alt='wdfk_prog' width='100px' height='100px'></div></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Liya Huang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo 8.0.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.1</a></span></div><div class="footer_custom_text">你好，欢迎来到我的 <a href="/about/">数字花园</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天" style="display:none"><i class="fas fa-message"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script><script>(() => {
  const abcjsInit = () => {
    const abcjsFn = () => {
      setTimeout(() => {
        const sheets = document.querySelectorAll(".abc-music-sheet")
        for (let i = 0; i < sheets.length; i++) {
          const ele = sheets[i]
          if (ele.children.length > 0) continue

          // Parse parameters from data-params attribute
          let params = {}
          const dp = ele.getAttribute("data-params")
          if (dp) {
            try {
              params = JSON.parse(dp)
            } catch (e) {
              console.error("Failed to parse data-params:", e)
            }
          }

          // Merge parsed parameters with the responsive option
          // Ensures params content appears before responsive
          const options = { ...params, responsive: "resize" }

          // Render the music score using ABCJS.renderAbc
          ABCJS.renderAbc(ele, ele.innerHTML, options)
        }
      }, 100)
    }

    if (typeof ABCJS === "object") {
      abcjsFn()
    } else {
      btf.getScript("https://cdn.jsdelivr.net/npm/abcjs/dist/abcjs-basic-min.min.js").then(abcjsFn)
    }
  }

  if (window.pjax) {
    abcjsInit()
  } else {
    window.addEventListener("load", abcjsInit)
  }

  btf.addGlobalFn("encrypt", abcjsInit, "abcjs")
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: 'Ov23livBmwx65h3XIdfT',
      clientSecret: '9f23bdaa2ea11322f9f405d77bcdc27166077a7d',
      repo: 'wdfk-prog.github.io',
      owner: 'wdfk-prog',
      admin: ['wdfk-prog'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || '31e3b0bbfb0b7bf26fb83855fc470916'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script>window.newestComments = {
  changeContent: content => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<code>.*?<\/code>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g, "") // remove html tag

    if (content.length > 150) {
      content = content.substring(0, 150) + '...'
    }
    return content
  },

  generateHtml: (array, ele) => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class="aside-list-item">'

        if (true && array[i].avatar) {
          const imgAttr = 'data-lazy-src'
          const lazyloadNative = ''
          result += `<a href="${array[i].url}" class="thumbnail"><img ${imgAttr}="${array[i].avatar}" alt="${array[i].nick}" ${lazyloadNative}></a>`
        }

        result += `<div class="content">
        <a class="comment" href="${array[i].url}" title="${array[i].content}">${array[i].content}</a>
        <div class="name"><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '暂无评论'
    }

    ele.innerHTML = result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh(ele)
  },

  newestCommentInit: (name, getComment) => {
    const $dom = document.querySelector('#card-newest-comments .aside-list')
    if ($dom) {
      const data = btf.saveToLocal.get(name)
      if (data) {
        newestComments.generateHtml(JSON.parse(data), $dom)
      } else {
        getComment($dom)
      }
    }
  },

  run: (name, getComment) => {
    newestComments.newestCommentInit(name, getComment)
    btf.addGlobalFn('pjaxComplete', () => newestComments.newestCommentInit(name, getComment), name)
  }
}</script><script>window.addEventListener('load', () => {
  const keyName = 'github-newest-comments'
  const { changeContent, generateHtml, run } = window.newestComments

  const findTrueUrl = (array, ele) => {
    Promise.all(array.map(item =>
      fetch(item.url).then(resp => resp.json()).then(data => {
        let urlArray = data.body ? data.body.match(/(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?/ig) : []
        if (!Array.isArray(urlArray) || urlArray.length === 0) {
          urlArray = [`${data.html_url}`]
        }
        if (data.user.login === 'utterances-bot') {
          return urlArray.pop()
        } else {
          return urlArray.shift()
        }
      })
    )).then(res => {
        array = array.map((i,index)=> {
          return {
            ...i,
            url: res[index]
          }
        })

        btf.saveToLocal.set(keyName, JSON.stringify(array), 10/(60*24))
        generateHtml(array, ele)
    });
  }

  const getComment = ele => {
    fetch('https://api.github.com/repos/wdfk-prog/wdfk-prog.github.io/issues/comments?sort=updated&direction=desc&per_page=6&page=1',{
      "headers": {
        Accept: 'application/vnd.github.v3.html+json'
      }
    })
      .then(response => response.json())
      .then(data => {
        const githubArray = data.map(item => {
          return {
            'avatar': item.user.avatar_url,
            'content': changeContent(item.body_html || item.body),
            'nick': item.user.login,
            'url': item.issue_url,
            'date': item.updated_at
          }
        })
        findTrueUrl(githubArray, ele)
      }).catch(e => {
        console.error(e)
        ele.textContent= "无法获取评论，请确认相关配置是否正确"
      })
  }
  run(keyName, getComment)
})</script><div class="aplayer no-destroy" data-id="60198" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="false" data-volume="0.5"></div><script>
  var titleTime, OriginTitile = document.title;
  document.addEventListener("visibilitychange", function() {
    if (document.hidden) {
      titleTime = setTimeout(function() {
        document.title = "w(ﾟДﾟ)w 不要走！再看看嘛！";
      }, 300);
    } else {
      document.title = "♪(^∇^*)欢迎回来！" + OriginTitile;
      titleTime = setTimeout(function() {
        document.title = OriginTitile;
      }, 2000);
    }
  });
</script>
<script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script>(() => {
  window.ChatraID = '5cPWcnA8HKGzg5hoc'
  window.Chatra = window.Chatra || function() {
    (window.Chatra.q = window.Chatra.q || []).push(arguments)
  }

  btf.getScript('https://call.chatra.io/chatra.js').then(() => {
    const isChatBtn = true
    const isChatHideShow = true

    if (isChatBtn) {
      const close = () => {
        Chatra('minimizeWidget')
        Chatra('hide')
      }

      const open = () => {
        Chatra('openChat', true)
        Chatra('show')
      }

      window.ChatraSetup = { startHidden: true }
    
      window.chatBtnFn = () => document.getElementById('chatra').classList.contains('chatra--expanded') ? close() : open()

      document.getElementById('chat-btn').style.display = 'block'
    } else if (isChatHideShow) {
      window.chatBtn = {
        hide: () => Chatra('hide'),
        show: () => Chatra('show')
      }
    }
  })
})()</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: true,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      true
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-MF3J339H" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript></div><script src="https://cdn.jsdelivr.net/npm/echarts@5.5.1/dist/echarts.min.js"></script>
        
        <script>
            document.addEventListener("DOMContentLoaded", function() {
                const heatmapChartDom = document.getElementById('heatmapChart');
                if(heatmapChartDom){
                    const heatmapChart = echarts.init(heatmapChartDom, 'dark');
                    const cellSize = [18, 18];
                    
                    const groupByYear = (data) => {
                        const result = {};
                        data.forEach(([date, value]) => {
                            const [year] = date.split('-').map(Number);
                            if (!result[year]) {
                                result[year] = [];
                            }
                            result[year].push([date, value]);
                        });
                        return result;
                    };
                    
                    const groupedData = groupByYear([["2025-10-03",392],["2025-10-04",5],["2025-10-06",9],["2025-10-07",8],["2025-10-10",3]]);
                    const years = Object.keys(groupedData).reverse();
                    
                    var initYear = parseInt(heatmapChartDom.getAttribute('year')) || new Date().getFullYear();
                    const minYear = years[years.length - 1];
                    const maxYear = years[0];
                    if (initYear < minYear || initYear > maxYear) {
                        initYear = maxYear;
                    }
                    console.log('[hexo-graph]generateHeatmapChart|initYear:', initYear, 'minYear:', minYear, 'maxYear:', maxYear);
                    
                    heatmapChart.setOption({
                        grid: {},
                        tooltip: { 
                            position: 'top', 
                            formatter: params => `${params.value[0]}: ${params.value[1]} Articles` 
                        },
                        calendar: { 
                            top: '10%',
                            left: 'left', 
                            right: '8%',
                            range: initYear,
                            cellSize: cellSize, 
                            splitLine: { lineStyle: { color: '#E0E0E0', width: 1 } }, 
                            itemStyle: { borderWidth: 1, borderColor: '#E0E0E0' }, 
                            dayLabel: { show: false },
                            monthLabel: { show: true },
                            yearLabel: { show: false },
                        },
                        visualMap: { 
                            show: true,
                            right: '8%',
                            bottom: '5%',
                            type: 'piecewise',
                            orient: 'horizontal',
                            text: ['More', 'Less'],
                            min: 0,
                            max: Math.max(...groupedData[initYear].map(item => item[1])),
                            inRange: { color: ["#ACE7AE","#69C16D","#549F57"] }
                        },
                        legend: {
                            type: 'scroll',
                            icon: 'none',
                            data: years,
                            orient: 'vertical',
                            top: '5%',
                            right: 'right',
                            itemWidth: 20,
                            itemHeight: 20,
                            itemGap: 10,
                            pageIconSize: 10,
                            pageTextStyle: { fontSize: 14 },
                            selectedMode: 'single',
                        },
                        series: years.map(year => ({
                            type: 'heatmap',
                            coordinateSystem: 'calendar',
                            data: groupedData[year],
                            name: year,
                            emphasis: {
                                disabled: true,
                            },
                            silent: year !== initYear,
                        })),
                    });
                    
                    // init selected year
                    heatmapChart.dispatchAction({
                        type: 'legendSelect',
                        name: initYear,
                    });
                    
                    heatmapChart.on('legendselectchanged', function(params) {
                        console.log('[hexo-graph]generateHeatmapChart|legendselectchanged:', params);
                        const selectedYear = Object.keys(params.selected).find(key => params.selected[key]);
                        if (selectedYear && groupedData[selectedYear]) {
                            heatmapChart.setOption({
                                calendar: {
                                    range: selectedYear,
                                },
                                visualMap: {
                                    max: Math.max(...groupedData[selectedYear].map(item => item[1])),
                                },
                                series: years.map(year => ({
                                    type: 'heatmap',
                                    coordinateSystem: 'calendar',
                                    data: groupedData[year],
                                    name: year,
                                    emphasis: {
                                        disabled: true,
                                    },
                                    silent: year !== selectedYear,
                                })),
                            });
                        }
                    });
                    
                    heatmapChart.on('click', function (params) {
                        if (params.componentType === 'series') {
                            const [year, month] = params.value[0].split('-');
                            window.location.href = '/archives/' + year + '/' + month;
                        }
                    });
                }
            });
        </script>
    
        
        <script>
            document.addEventListener("DOMContentLoaded", function() {
                const monthlyChartDom = document.getElementById('monthlyChart');
                if(monthlyChartDom){
                    const monthlyChart = echarts.init(monthlyChartDom, 'dark');
                    monthlyChart.setOption({
                        xAxis: { 
                            type: 'category', 
                            data: ["2025-10"], 
                            axisLabel: { fontSize: 14, fontWeight: 'bold', fontFamily: 'Microsoft YaHei, SimSun, serif' }
                        },
                        yAxis: { type: 'value', splitLine: { lineStyle: { type: 'dashed', color: '#ccc' } } },
                        series: [{
                            name: 'Articles',
                            type: 'line',
                            data: [417],
                            smooth: true,
                            lineStyle: { color: '#5470C6', width: 2 },
                            itemStyle: { color: '#5470C6' },
                            areaStyle: { color: 'rgba(84, 112, 198, 0.4)' },
                            symbolSize: 10,
                            label: {
                                show: true,
                                position: 'top',
                                formatter: params => params.value,
                                fontSize: 14,
                                color: '#000',
                                fontWeight: 'bold',
                                fontFamily: 'Microsoft YaHei, SimSun, serif'
                            }
                        }]
                    });

                    monthlyChart.on('click', function (params) {
                        const [year, month] = params.name.split('-');
                        window.location.href = '/archives/' + year + '/' + month;
                    });
                }
            })
        </script>
    
        
        <script>
            document.addEventListener("DOMContentLoaded", function() {
                const tagsChartDom = document.getElementById('tagsChart');
                if(tagsChartDom){
                    const tagsChart = echarts.init(tagsChartDom, 'dark');
                    tagsChart.setOption({
                        tooltip: { trigger: 'item', formatter: '{b}: {c} ({d}%)' },
                        series: [{
                            type: 'pie',
                            radius: '60%',
                            data: [{"name":"linux","value":230},{"name":"uboot","value":68},{"name":"kernel","value":61},{"name":"rt-thread","value":44},{"name":"u-boot分类","value":44},{"name":"drivers","value":39},{"name":"fs","value":37},{"name":"other","value":28}],
                            label: {
                                position: 'outside',
                                formatter: '{b} {c} ({d}%)',
                                fontSize: 14,
                                fontWeight: 'bold',
                                fontFamily: 'Microsoft YaHei, SimSun, serif'
                            },
                            color: ["#5470C6","#91CC75","#FAC858","#EE6666","#73C0DE","#3BA272","#FC8452","#9A60B4"],
                            labelLine: { show: true }
                        }],
                        legend: {
                            bottom: '0',
                            left: 'center',
                            data: [{"name":"linux","value":230},{"name":"uboot","value":68},{"name":"kernel","value":61},{"name":"rt-thread","value":44},{"name":"u-boot分类","value":44},{"name":"drivers","value":39},{"name":"fs","value":37},{"name":"other","value":28}].map(tag => tag.name),
                            textStyle: { fontSize: 14, fontWeight: 'bold', fontFamily: 'Microsoft YaHei, SimSun, serif' }
                        }
                    });

                    tagsChart.on('click', function (params) {
                        window.location.href = '/tags/' + params.name;
                    });
                }
            })
        </script>
    
        
        <script>
            document.addEventListener("DOMContentLoaded", function() {
                const categoriesChartDom = document.getElementById('categoriesChart');
                if(categoriesChartDom){
                    const categoriesChart = echarts.init(categoriesChartDom, 'dark');
                    categoriesChart.setOption({
                        xAxis: { type: 'value', splitLine: { lineStyle: { type: 'dashed', color: '#ccc' } } },
                        yAxis: { 
                            type: 'category', 
                            data: [{"name":"linux","value":230},{"name":"uboot","value":68},{"name":"kernel","value":61},{"name":"rt-thread","value":44},{"name":"u-boot分类","value":44}].map(category => category.name).reverse(), 
                            axisLabel: { fontSize: 14, fontWeight: 'bold', fontFamily: 'Microsoft YaHei, SimSun, serif' }
                        },
                        series: [{
                            name: 'Category Count',
                            type: 'bar',
                            data: [{"name":"linux","value":230},{"name":"uboot","value":68},{"name":"kernel","value":61},{"name":"rt-thread","value":44},{"name":"u-boot分类","value":44}].map(category => category.value).reverse(),
                            label: {
                                show: true,
                                position: 'right',
                                formatter: params => params.value,
                                fontSize: 14,
                                color: '#000',
                                fontWeight: 'bold',
                                fontFamily: 'Microsoft YaHei, SimSun, serif'
                            },
                            itemStyle: {
                                color: new echarts.graphic.LinearGradient(0, 0, 1, 0, [
                                    { offset: 0, color: '#91CC75' },
                                    { offset: 1, color: '#73C0DE' }
                                ])
                            }
                        }]
                    });

                    categoriesChart.on('click', function (params) {
                        window.location.href = '/categories/' + params.name;
                    });
                }
            });
        </script>
    
        
        <script>
            document.addEventListener("DOMContentLoaded", function() {
                const categoriesTreeChartDom = document.getElementById('categoriesTreeChart');
                if(categoriesTreeChartDom){
                    const treeChart = echarts.init(categoriesTreeChartDom, 'dark');
                    treeChart.setOption({
                        title: {
                            text: '操作提示：单击展开分类，双击进入具体分类页面',
                            textStyle: {
                                fontSize: 12,
                                color: '#999',
                                fontWeight: 'normal'
                            },
                            bottom: 0,
                            left: 'center'
                        },
                        tooltip: {
                            trigger: 'item',
                            triggerOn: 'mousemove'
                        },
                        series: [{
                            type: 'tree',
                            data: [{"name":"Categories","children":[{"name":"git","children":[],"count":6,"path":"git"},{"name":"hpatch","children":[{"name":"libdivsufsort","children":[],"count":3,"path":"hpatch/libdivsufsort"},{"name":"SA-IS","children":[],"count":1,"path":"hpatch/SA-IS"}],"count":10,"path":"hpatch"},{"name":"LoraWan","children":[{"name":"LoRaWAN标准","children":[{"name":"LoRaWAN-Specification_ZH_CN","children":[{"name":"LoRaWAN-Specification_ZH_CN-190102","children":[{"name":"chapter","children":[],"count":20,"path":"LoraWan/LoRaWAN标准/LoRaWAN-Specification_ZH_CN/LoRaWAN-Specification_ZH_CN-190102/chapter"}],"count":22,"path":"LoraWan/LoRaWAN标准/LoRaWAN-Specification_ZH_CN/LoRaWAN-Specification_ZH_CN-190102"}],"count":22,"path":"LoraWan/LoRaWAN标准/LoRaWAN-Specification_ZH_CN"}],"count":22,"path":"LoraWan/LoRaWAN标准"}],"count":23,"path":"LoraWan"},{"name":"MCU","children":[],"count":23,"path":"MCU"},{"name":"linux","children":[{"name":"block","children":[],"count":8,"path":"linux/block"},{"name":"include","children":[],"count":10,"path":"linux/include"},{"name":"fs","children":[],"count":37,"path":"linux/fs"},{"name":"drivers","children":[{"name":"base","children":[],"count":14,"path":"linux/drivers/base"},{"name":"tty","children":[],"count":2,"path":"linux/drivers/tty"},{"name":"clk","children":[],"count":2,"path":"linux/drivers/clk"}],"count":39,"path":"linux/drivers"},{"name":"kernel","children":[{"name":"rcu","children":[],"count":3,"path":"linux/kernel/rcu"},{"name":"lock","children":[],"count":7,"path":"linux/kernel/lock"},{"name":"irq","children":[],"count":5,"path":"linux/kernel/irq"},{"name":"sched","children":[],"count":7,"path":"linux/kernel/sched"},{"name":"time","children":[],"count":10,"path":"linux/kernel/time"}],"count":61,"path":"linux/kernel"},{"name":"lib","children":[],"count":19,"path":"linux/lib"},{"name":"security","children":[],"count":1,"path":"linux/security"},{"name":"scripts","children":[],"count":2,"path":"linux/scripts"},{"name":"other","children":[],"count":17,"path":"linux/other"},{"name":"mm","children":[],"count":19,"path":"linux/mm"},{"name":"arch","children":[{"name":"arm","children":[],"count":10,"path":"linux/arch/arm"}],"count":10,"path":"linux/arch"}],"count":230,"path":"linux"},{"name":"tmc5160","children":[],"count":1,"path":"tmc5160"},{"name":"rt-thread","children":[{"name":"其他资料","children":[{"name":"fatfs","children":[],"count":1,"path":"rt-thread/其他资料/fatfs"}],"count":1,"path":"rt-thread/其他资料"}],"count":44,"path":"rt-thread"},{"name":"uboot","children":[{"name":"other","children":[],"count":12,"path":"uboot/other"},{"name":"子目录","children":[],"count":10,"path":"uboot/子目录"},{"name":"u-boot分类","children":[{"name":"arch","children":[{"name":"arm","children":[],"count":2,"path":"uboot/u-boot分类/arch/arm"}],"count":3,"path":"uboot/u-boot分类/arch"},{"name":"boot","children":[],"count":4,"path":"uboot/u-boot分类/boot"},{"name":"api","children":[],"count":1,"path":"uboot/u-boot分类/api"},{"name":"common","children":[],"count":10,"path":"uboot/u-boot分类/common"},{"name":"cmd","children":[],"count":1,"path":"uboot/u-boot分类/cmd"},{"name":"dm","children":[],"count":15,"path":"uboot/u-boot分类/dm"},{"name":"env","children":[],"count":1,"path":"uboot/u-boot分类/env"},{"name":"lib","children":[],"count":4,"path":"uboot/u-boot分类/lib"},{"name":"include","children":[],"count":3,"path":"uboot/u-boot分类/include"},{"name":"fdt","children":[],"count":1,"path":"uboot/u-boot分类/fdt"},{"name":"test","children":[],"count":1,"path":"uboot/u-boot分类/test"}],"count":44,"path":"uboot/u-boot分类"}],"count":68,"path":"uboot"},{"name":"杂谈","children":[],"count":8,"path":"杂谈"},{"name":"freertos","children":[],"count":1,"path":"freertos"}],"count":0,"path":""}],
                            initialTreeDepth: -1,
                            top: '5%',
                            bottom: '10%',
                            left: '0%',
                            right: '0%',
                            symbolSize: 15,
                            layout: 'orthogonal',
                            orient: 'TB',
                            itemStyle: {
                                color: '#91CC75',
                                borderColor: '#73C0DE'
                            },
                            label: {
                                position: 'bottom',
                                verticalAlign: 'middle',
                                align: 'center',
                                fontSize: 14,
                                distance: 28,
                                formatter: function(params) {
                                    return params.data.name + (params.data.count ? ' (' + params.data.count + ')' : '');
                                }
                            },
                            leaves: {
                                label: {
                                    position: 'top',
                                    verticalAlign: 'middle',
                                    align: 'center'
                                }
                            },
                            emphasis: {
                                focus: 'descendant'
                            },
                            expandAndCollapse: true
                        }]
                    });

                    treeChart.on('dblclick', function (params) {
                        if (params.data && params.data.path) {
                            window.location.href = '/categories/' + params.data.path;
                        }
                    });
                }
            });
        </script>
    
    <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"react":{"opacity":0.7},"log":false});</script></body></html>