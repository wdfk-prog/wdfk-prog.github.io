<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>slub | wdfk-prog的个人博客</title><meta name="author" content="Liya Huang"><meta name="copyright" content="Liya Huang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[TOC] mm&#x2F;slub.c SLUB内存分配器(The SLUB Allocator) 现代内核对象缓存的核心历史与背景这项技术是为了解决什么特定问题而诞生的？这项技术以及它所实现的SLUB分配器，是为了解决内核中一个基础且关键的性能问题：如何高效地分配和释放大量小的、固定大小的内存对象。  对抗内部碎片（Internal Fragmentation）：内核需要频繁创建大量的小对象（">
<meta property="og:type" content="article">
<meta property="og:title" content="slub">
<meta property="og:url" content="https://wdfk-prog.space/posts/e8f76fed/index.html">
<meta property="og:site_name" content="wdfk-prog的个人博客">
<meta property="og:description" content="[TOC] mm&#x2F;slub.c SLUB内存分配器(The SLUB Allocator) 现代内核对象缓存的核心历史与背景这项技术是为了解决什么特定问题而诞生的？这项技术以及它所实现的SLUB分配器，是为了解决内核中一个基础且关键的性能问题：如何高效地分配和释放大量小的、固定大小的内存对象。  对抗内部碎片（Internal Fragmentation）：内核需要频繁创建大量的小对象（">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wdfk-prog.space/images/covers/07.jpg">
<meta property="article:published_time" content="2025-10-03T01:01:49.000Z">
<meta property="article:modified_time" content="2025-10-03T09:23:28.754Z">
<meta property="article:author" content="Liya Huang">
<meta property="article:tag" content="linux">
<meta property="article:tag" content="mm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wdfk-prog.space/images/covers/07.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "slub",
  "url": "https://wdfk-prog.space/posts/e8f76fed/",
  "image": "https://wdfk-prog.space/images/covers/07.jpg",
  "datePublished": "2025-10-03T01:01:49.000Z",
  "dateModified": "2025-10-03T09:23:28.754Z",
  "author": [
    {
      "@type": "Person",
      "name": "Liya Huang",
      "url": "https://github.com/wdfk-prog"
    }
  ]
}</script><link rel="shortcut icon" href="/images/favicon.png"><link rel="canonical" href="https://wdfk-prog.space/posts/e8f76fed/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//static.cloudflareinsights.com"/><link rel="preconnect" href="//www.clarity.ms"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxxxxx"/><meta name="baidu-site-verification" content="xxxxxxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-3978542742563797',
  enable_page_level_ads: 'true'
});</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?3c49dd4913ab43efb1bfc8d12b1cded9";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-PF2CVP2PL4"></script><script>window.dataLayer = window.dataLayer || []
function gtag(){dataLayer.push(arguments)}
gtag('js', new Date())
gtag('config', 'G-PF2CVP2PL4')
btf.addGlobalFn('pjaxComplete', () => {
  gtag('config', 'G-PF2CVP2PL4', {'page_path': window.location.pathname})
}, 'google_analytics')
</script><script defer="defer" data-pjax="data-pjax" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;17ff914b5e28493597b7dc19f3356022&quot;}"></script><script>(function(c,l,a,r,i,t,y){
    c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
    t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
    y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
})(window, document, "clarity", "script", "tkaenn1tjv");
</script><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
"https://www.googletagmanager.com/gtm.js?id="+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-MF3J339H');
btf.addGlobalFn('pjaxComplete', () => {
  dataLayer.push({'event': 'pjaxComplete', 'page_title': document.title, 'page_location': location.href, 'page_path': window.location.pathname})
}, 'google_tag_manager')</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":false,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'slub',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.0.0"><link rel="alternate" href="/atom.xml" title="wdfk-prog的个人博客" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (true) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(/images/subtle-texture.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/avatar.png" onerror="this.onerror=null;this.src='/images/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">417</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">49</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">53</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book-open"></i><span> 页面</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fas fa-quote-left"></i><span> 说说</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 示例</span></a></li></ul></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/songs/"><i class="fa-fw fas fa-music"></i><span> 歌曲</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/images/covers/07.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/my-logo.png" alt="Logo"><span class="site-name">wdfk-prog的个人博客</span></a><a class="nav-page-title" href="/"><span class="site-name">slub</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book-open"></i><span> 页面</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fas fa-quote-left"></i><span> 说说</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 示例</span></a></li></ul></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/songs/"><i class="fa-fw fas fa-music"></i><span> 歌曲</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">slub<a class="post-edit-link" href="null_posts/linux/mm/slub.md" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-10-03T01:01:49.000Z" title="发表于 2025-10-03 09:01:49">2025-10-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-03T09:23:28.754Z" title="更新于 2025-10-03 17:23:28">2025-10-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/linux/">linux</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/linux/mm/">mm</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">20k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>82分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/e8f76fed/#post-comment"><span class="gitalk-comment-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;已经过了&quot;,&quot;messageNext&quot;:&quot;自上次更新以来，文章的内容可能已经过时&quot;,&quot;postUpdate&quot;:&quot;2025-10-03 17:23:28&quot;}" hidden></div><p>[TOC]</p>
<h1 id="mm-slub-c-SLUB内存分配器-The-SLUB-Allocator-现代内核对象缓存的核心"><a href="#mm-slub-c-SLUB内存分配器-The-SLUB-Allocator-现代内核对象缓存的核心" class="headerlink" title="mm&#x2F;slub.c SLUB内存分配器(The SLUB Allocator) 现代内核对象缓存的核心"></a>mm&#x2F;slub.c SLUB内存分配器(The SLUB Allocator) 现代内核对象缓存的核心</h1><h3 id="历史与背景"><a href="#历史与背景" class="headerlink" title="历史与背景"></a>历史与背景</h3><h4 id="这项技术是为了解决什么特定问题而诞生的？"><a href="#这项技术是为了解决什么特定问题而诞生的？" class="headerlink" title="这项技术是为了解决什么特定问题而诞生的？"></a>这项技术是为了解决什么特定问题而诞生的？</h4><p>这项技术以及它所实现的SLUB分配器，是为了解决内核中一个基础且关键的性能问题：<strong>如何高效地分配和释放大量小的、固定大小的内存对象</strong>。</p>
<ul>
<li><strong>对抗内部碎片（Internal Fragmentation）</strong>：内核需要频繁创建大量的小对象（如inode, dentry, task_struct等），它们的大小通常远小于一个物理内存页（通常是4KB）。如果直接使用页分配器（Buddy System）来为这些小对象分配整个页，会造成巨大的内存浪费。例如，为一个128字节的对象分配一个4096字节的页，97%的内存就被浪费了。</li>
<li><strong>提升分配性能</strong>：通用的内存分配器需要处理任意大小的请求，其算法相对复杂。而对于特定类型的对象，我们可以创建一个专用的“对象缓存池”。SLUB分配器就是这种缓存池的实现者。</li>
<li><strong>利用对象构造&#x2F;析构</strong>：很多内核对象在首次使用时需要进行初始化。SLUB框架允许在创建缓存时指定一个“构造函数”（constructor）。当从缓存中分配一个新对象时，这个构造函数会被自动调用，避免了在每次分配后都重复编写初始化代码。</li>
<li><strong>提升硬件缓存利用率</strong>：通过将相同类型的对象紧凑地存放在一起，可以提高CPU缓存的命中率，从而提升性能。</li>
</ul>
<h4 id="它的发展经历了哪些重要的里程碑或版本迭代？"><a href="#它的发展经历了哪些重要的里程碑或版本迭代？" class="headerlink" title="它的发展经历了哪些重要的里程碑或版本迭代？"></a>它的发展经历了哪些重要的里程碑或版本迭代？</h4><p>Linux内核的Slab分配器经历了三个主要实现：SLAB, SLOB, 和 SLUB。</p>
<ol>
<li><strong>SLAB</strong>：这是最初的、经典的Slab分配器实现。它的设计非常精巧，为每个NUMA节点和每个CPU维护了三类Slab链表：完全满的（full）、部分满的（partial）和完全空的（empty）。这种设计能很好地回收部分使用的slab，但其内部逻辑非常复杂，管理这些链表本身也带来了不可忽略的性能和内存开销。</li>
<li><strong>SLOB (Simple List Of Blocks)</strong>：这是一个极其简单的分配器，专为内存占用是首要考虑因素的嵌入式系统设计。它使用首次适应算法（first-fit）在页面中分配内存，内存开销极小，但性能和扩展性较差，且容易产生碎片。</li>
<li><strong>SLUB (The Unqueued Allocator)</strong>：SLUB是作为SLAB的现代替代品而被设计的。它的核心设计目标是<strong>简化</strong>和<strong>提升性能</strong>，特别是在大型多核（SMP）系统上。它<strong>废除</strong>了SLAB中复杂的队列管理，其核心思想是：一个slab页要么完全属于一个CPU，要么位于一个全局的、按NUMA节点组织的链表中。这种简化的设计减少了锁争用，降低了元数据开销，并最终在大多数工作负载下提供了比SLAB更好的性能。由于其优越性，<strong>SLUB现在是绝大多数Linux发行版的默认Slab分配器</strong>。</li>
</ol>
<h4 id="目前该技术的社区活跃度和主流应用情况如何？"><a href="#目前该技术的社区活跃度和主流应用情况如何？" class="headerlink" title="目前该技术的社区活跃度和主流应用情况如何？"></a>目前该技术的社区活跃度和主流应用情况如何？</h4><p>SLUB是Linux内存管理子系统的核心和默认组件，其地位稳固。</p>
<ul>
<li><strong>社区活跃度</strong>：作为性能关键路径，SLUB的代码非常稳定，但仍在持续优化。社区的关注点包括进一步提升NUMA系统的性能、改进调试特性、以及微调其与页分配器和内存回收机制的交互。</li>
<li><strong>主流应用</strong>：SLUB是整个内核的基础设施。<ul>
<li><strong>对象缓存</strong>：内核中几乎所有的数据结构（进程、文件、网络套接字等）都是通过<code>kmem_cache_alloc</code>从SLUB缓存中分配的。</li>
<li><strong><code>kmalloc</code>的后端</strong>：通用的内核内存分配接口<code>kmalloc()</code>和<code>kfree()</code>，其后端就是一系列预设好大小（8, 16, 32, … , 8192字节等）的SLUB缓存。可以说，内核中绝大部分的动态内存分配都最终由SLUB处理。</li>
</ul>
</li>
</ul>
<h3 id="核心原理与设计"><a href="#核心原理与设计" class="headerlink" title="核心原理与设计"></a>核心原理与设计</h3><h4 id="它的核心工作原理是什么？"><a href="#它的核心工作原理是什么？" class="headerlink" title="它的核心工作原理是什么？"></a>它的核心工作原理是什么？</h4><p>SLUB的核心是将一个或多个连续的物理内存页（称为一个<strong>slab</strong>）分割成多个固定大小的<strong>对象</strong>，并高效地管理这些对象的分配与释放。</p>
<ol>
<li><strong><code>kmem_cache</code></strong>：代表一类特定对象的缓存。通过<code>kmem_cache_create()</code>创建，它定义了对象的大小、对齐方式、构造函数等属性。</li>
<li><strong>Slab</strong>：从伙伴系统（Buddy System）分配的一个或多个连续的物理页。一个slab被格式化后，专门用于存放一种<code>kmem_cache</code>的对象。</li>
<li><strong>Per-CPU缓存</strong>：这是SLUB高性能的关键。每个CPU核心都有一个<strong>私有的、当前活动的slab</strong>。当一个CPU上的代码需要分配对象时，它会首先尝试从这个私有slab中获取。因为访问的是CPU私有数据，所以这个过程<strong>完全无锁</strong>，速度极快。</li>
<li><strong>简单的Freelist管理</strong>：当一个对象被释放时，它会被放回当前CPU的活动slab的freelist中。SLUB的freelist设计非常巧妙和简单：它将指向下一个空闲对象的指针<strong>直接存储在前一个空闲对象的内存空间中</strong>。这几乎消除了所有额外的元数据开销。</li>
<li><strong>Slab的流转</strong>：<ul>
<li><strong>分配路径</strong>：当一个CPU的活动slab用完时，它会去一个per-NUMA节点的<strong>部分空闲slab链表</strong>中获取一个新的slab。如果这个链表也为空，它才会向伙伴系统申请新的页来创建一个全新的slab。</li>
<li><strong>释放路径</strong>：当一个CPU释放对象，导致其活动slab变满（所有对象都空闲）时，这个slab可能会被放回到per-NUMA节点的链表中，供其他CPU使用。</li>
</ul>
</li>
<li><strong>调试特性</strong>：SLUB集成了强大的调试功能，如Red Zoning（在对象前后放置“红区”以检测溢出）、Poisoning（用特定值填充已释放的对象以检测use-after-free）、以及所有权跟踪。</li>
</ol>
<h4 id="它的主要优势体现在哪些方面？"><a href="#它的主要优势体现在哪些方面？" class="headerlink" title="它的主要优势体现在哪些方面？"></a>它的主要优势体现在哪些方面？</h4><ul>
<li><strong>高性能与高扩展性</strong>：基于Per-CPU的无锁快速路径，极大地减少了多核系统中的锁争用。</li>
<li><strong>设计简洁</strong>：相比SLAB，其内部逻辑大大简化，代码更易于理解和维护。</li>
<li><strong>低内存开销</strong>：元数据极少，大部分slab页面几乎完全用于存储对象本身。</li>
<li><strong>优秀的NUMA亲和性</strong>：Slab和对象都优先在当前CPU所在的NUMA节点上分配，减少了跨节点内存访问的延迟。</li>
</ul>
<h4 id="它存在哪些已知的劣势、局-限性或在特定场景下的不适用性？"><a href="#它存在哪些已知的劣势、局-限性或在特定场景下的不适用性？" class="headerlink" title="它存在哪些已知的劣势、局-限性或在特定场景下的不适用性？"></a>它存在哪些已知的劣势、局-限性或在特定场景下的不适用性？</h4><ul>
<li><strong>部分slab回收可能延迟</strong>：由于其简化的设计，相比SLAB，SLUB在回收那些仅有少量对象被使用的“部分空闲”slab时，可能没有那么积极。但这通常被认为是一个合理的权衡。</li>
<li><strong>内部碎片仍然存在</strong>：虽然解决了页分配器的内部碎片问题，但如果对象的大小不能很好地适配slab页的大小，slab内部仍然会存在一些无法利用的“边角料”内存。</li>
</ul>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><h4 id="在哪些具体的业务或技术场景下，它是首选解决方案？请举例说明。"><a href="#在哪些具体的业务或技术场景下，它是首选解决方案？请举例说明。" class="headerlink" title="在哪些具体的业务或技术场景下，它是首选解决方案？请举例说明。"></a>在哪些具体的业务或技术场景下，它是首选解决方案？请举例说明。</h4><p>SLUB是内核中进行<strong>小对象和通用内存分配</strong>的<strong>默认和首选</strong>方案。</p>
<ul>
<li><strong>创建内核数据结构</strong>：当一个新进程被创建时，内核需要分配一个<code>struct task_struct</code>。它会调用<code>kmem_cache_alloc(task_struct_cache, ...)</code>，这会从专门为<code>task_struct</code>优化的SLUB缓存中快速获取一个对象。</li>
<li><strong>通用<code>kmalloc</code>分配</strong>：当一个设备驱动需要一个中等大小的缓冲区（例如200字节）来处理DMA描述符时，它会调用<code>kmalloc(200, GFP_KERNEL)</code>。<code>kmalloc</code>的实现会找到最适合200字节的SLUB缓存（可能是<code>kmalloc-256</code>缓存），并从中分配一个对象。</li>
<li><strong>任何性能敏感的对象池</strong>：网络栈为每个网络包分配的<code>sk_buff</code>结构，VFS为每个打开的文件分配的<code>struct file</code>，都是通过各自的SLUB缓存进行高效管理的。</li>
</ul>
<h4 id="是否有不推荐使用该技术的场景？为什么？"><a href="#是否有不推荐使用该技术的场景？为什么？" class="headerlink" title="是否有不推荐使用该技术的场景？为什么？"></a>是否有不推荐使用该技术的场景？为什么？</h4><ul>
<li><strong>大块内存分配</strong>：SLUB不适合用于分配大的、跨越多个页面的内存块。这是页分配器（Buddy System）的工作，应直接使用<code>alloc_pages()</code>或<code>vmalloc()</code>。<code>kmalloc</code>的上限通常是几兆字节，超过这个大小的请求会失败或转向其他分配器。</li>
<li><strong>用户空间内存分配</strong>：SLUB是纯粹的内核机制。用户空间的应用程序使用<code>malloc()</code>（由glibc等C库提供），它有自己的、在用户态实现的内存分配器（如ptmalloc, jemalloc, tcmalloc）。</li>
</ul>
<h3 id="对比分析"><a href="#对比分析" class="headerlink" title="对比分析"></a>对比分析</h3><h4 id="请将其-与-其他相似技术-进行详细对比。"><a href="#请将其-与-其他相似技术-进行详细对比。" class="headerlink" title="请将其 与 其他相似技术 进行详细对比。"></a>请将其 与 其他相似技术 进行详细对比。</h4><p><strong>对比一：SLUB vs. SLAB</strong></p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">SLUB (The Unqueued Allocator)</th>
<th align="left">SLAB (The Original Slab Allocator)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>设计复杂度</strong></td>
<td align="left"><strong>简单</strong>。</td>
<td align="left"><strong>复杂</strong>。</td>
</tr>
<tr>
<td align="left"><strong>Slab管理</strong></td>
<td align="left">无复杂的队列。Slab要么在CPU本地，要么在一个简单的per-node链表中。</td>
<td align="left">每个CPU和每个node都有三个队列：full, partial, empty。</td>
</tr>
<tr>
<td align="left"><strong>Freelist管理</strong></td>
<td align="left">将freelist指针存储在对象内部。</td>
<td align="left">需要额外的元数据来管理freelist。</td>
</tr>
<tr>
<td align="left"><strong>内存开销</strong></td>
<td align="left"><strong>低</strong>。元数据极少。</td>
<td align="left"><strong>较高</strong>。管理队列和freelist需要额外的内存。</td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left"><strong>通常更高</strong>，尤其是在大型SMP系统上，得益于简单的无锁路径。</td>
<td align="left">在某些特定的、碎片化严重的负载下，其更积极的部分slab回收策略可能有优势。</td>
</tr>
<tr>
<td align="left"><strong>默认状态</strong></td>
<td align="left"><strong>现代内核的默认选择</strong>。</td>
<td align="left">仍然保留在内核中，可通过启动选项启用，但已不常用。</td>
</tr>
</tbody></table>
<p><strong>对比二：SLUB vs. 伙伴系统 (Buddy System &#x2F; Page Allocator)</strong></p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">SLUB 分配器</th>
<th align="left">伙伴系统 (Buddy System)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>分配单位</strong></td>
<td align="left"><strong>对象（Object）</strong>，大小通常远小于一个页。</td>
<td align="left"><strong>物理页（Page）</strong>，以2的幂次方（1, 2, 4, 8…页）为单位。</td>
</tr>
<tr>
<td align="left"><strong>主要目标</strong></td>
<td align="left">解决<strong>内部碎片</strong>问题，高效管理小对象的生命周期。</td>
<td align="left">管理整个系统的<strong>物理内存页</strong>，解决<strong>外部碎片</strong>问题。</td>
</tr>
<tr>
<td align="left"><strong>碎片类型</strong></td>
<td align="left">内部碎片（slab内的边角料）。</td>
<td align="left">外部碎片（小的空闲页块无法合并成大的块）。</td>
</tr>
<tr>
<td align="left"><strong>关系</strong></td>
<td align="left"><strong>客户端&#x2F;上层</strong>。SLUB自身需要的大块内存（用于创建slab）是从伙伴系统申请的。</td>
<td align="left"><strong>基础&#x2F;底层</strong>。是内核内存管理的最底层，为SLUB和其他所有需要物理页的地方提供服务。</td>
</tr>
</tbody></table>
<h1 id="mm-folio-c-内存页束-Memory-Folios-简化大页和页面缓存管理"><a href="#mm-folio-c-内存页束-Memory-Folios-简化大页和页面缓存管理" class="headerlink" title="mm&#x2F;folio.c 内存页束(Memory Folios) 简化大页和页面缓存管理"></a>mm&#x2F;folio.c 内存页束(Memory Folios) 简化大页和页面缓存管理</h1><h3 id="历史与背景-1"><a href="#历史与背景-1" class="headerlink" title="历史与背景"></a>历史与背景</h3><h4 id="这项技术是为了解决什么特定问题而诞生的？-1"><a href="#这项技术是为了解决什么特定问题而诞生的？-1" class="headerlink" title="这项技术是为了解决什么特定问题而诞生的？"></a>这项技术是为了解决什么特定问题而诞生的？</h4><p>这项技术以及其核心数据结构<code>struct folio</code>，是为了解决Linux内存管理中一个长期存在的、导致代码复杂且极易出错的根本性问题：<strong>如何清晰、安全地处理大于单个页面（4KB）的连续物理内存块</strong>。</p>
<ul>
<li><strong><code>struct page</code>的歧义性</strong>：在Linux中，<code>struct page</code>是管理单个物理页面的基本单元。然而，为了性能，内核在很多地方（如透明大页THP、页面缓存、网络缓冲区）会分配连续的多个页面，这被称为“复合页”（Compound Page）或“高阶页”（High-order Page）。</li>
<li><strong>复合页的笨拙处理</strong>：在Folio出现之前，一个复合页由一个<code>struct page</code>数组表示。其中第一个页面<code>page[0]</code>是“头页”（head page），包含了整个内存块的信息，而后续的<code>page[1]</code>, <code>page[2]</code>…都是“尾页”（tail pages）。这种设计的缺陷是灾难性的：<ol>
<li><strong>API混乱</strong>：函数需要传递多个参数，如<code>(struct page *page, unsigned int order)</code>，增加了复杂性。</li>
<li><strong>逻辑脆弱且易错</strong>：代码中到处都需要检查一个给定的<code>struct page</code>指针是否是尾页。如果是，就必须调用<code>compound_head(page)</code>来找到真正的头页才能获取正确信息。忘记这个检查是内核bug的一个常见来源。</li>
<li><strong>概念不清</strong>：一个<code>struct page*</code>指针的含义变得模糊不清，它可能指向一个4KB的页，也可能指向一个2MB大页的中间某个4KB部分。</li>
</ol>
</li>
</ul>
<p><strong>Folio的诞生就是为了终结这种混乱</strong>。它提供了一个新的、清晰的抽象：<code>struct folio</code>，它<strong>明确地代表一个完整的、大小可能不一的内存块</strong>，无论它是一个4KB的普通页还是一个2MB的大页。</p>
<h4 id="它的发展经历了哪些重要的里程碑或版本迭代？-1"><a href="#它的发展经历了哪些重要的里程碑或版本迭代？-1" class="headerlink" title="它的发展经历了哪些重要的里程碑或版本迭代？"></a>它的发展经历了哪些重要的里程碑或版本迭代？</h4><p>Folio是由内核资深开发者Matthew Wilcox主导的一项重大重构工作，它不是一次性完成的，而是一个持续的、遍及整个内核的演进过程。</p>
<ul>
<li><strong>引入</strong>：Folio的概念和初步实现大约在Linux内核5.16版本中被正式引入。</li>
<li><strong>页面缓存的转换</strong>：最重要的里程碑之一是将内核中最核心的缓存——页面缓存（Page Cache）——完全从使用<code>struct page</code>转换为使用<code>struct folio</code>。这极大地简化了文件I&#x2F;O和内存管理之间的交互代码。</li>
<li><strong>持续的内核转换</strong>：自引入以来，内核社区一直在进行一项庞大的工作，即逐步将内核的其他子系统（如驱动程序、网络栈、各种文件系统）的API从接收<code>struct page</code>改为接收<code>struct folio</code>。这是一个仍在进行中的过程。</li>
</ul>
<h4 id="目前该技术的社区活跃度和主流应用情况如何？-1"><a href="#目前该技术的社区活跃度和主流应用情况如何？-1" class="headerlink" title="目前该技术的社区活跃度和主流应用情况如何？"></a>目前该技术的社区活跃度和主流应用情况如何？</h4><p>Folio是当前Linux内存管理子系统<strong>最活跃的开发领域之一</strong>，它代表了未来内核内存管理的方向。</p>
<ul>
<li><strong>社区活跃度</strong>：极高。大量的补丁集仍在不断地提交，以将内核的各个角落转换为使用Folio。</li>
<li><strong>主流应用</strong>：它已经成为内核MM子系统的核心组件。所有新的内存管理相关的开发都鼓励或强制使用Folio。它不是一个可选功能，而是对内核底层架构的根本性改进。</li>
</ul>
<h3 id="核心原理与设计-1"><a href="#核心原理与设计-1" class="headerlink" title="核心原理与设计"></a>核心原理与设计</h3><h4 id="它的核心工作原理是什么？-1"><a href="#它的核心工作原理是什么？-1" class="headerlink" title="它的核心工作原理是什么？"></a>它的核心工作原理是什么？</h4><p>Folio的核心原理是<strong>提供一个更高级的、无歧义的内存管理单元</strong>，并巧妙地将其与现有的<code>struct page</code>基础设施集成，以实现平滑过渡。</p>
<ol>
<li><strong>数据结构</strong>：<code>struct folio</code>并非一个全新的、独立分配的结构。为了节省内存，它被巧妙地嵌入（通过<code>union</code>）到复合页的<strong>头页</strong>的<code>struct page</code>结构中。因此，一个Folio本质上是头页的一个“更结构化的视图”，它没有带来额外的内存开销。</li>
<li><strong>明确的大小</strong>：一个<code>struct folio</code>内部直接包含了它所代表的内存块的大小（或阶数<code>order</code>）。因此，一个<code>struct folio*</code>指针就足以描述整个内存块，不再需要额外的<code>size</code>或<code>order</code>参数。</li>
<li><strong>API的演进</strong>：<ul>
<li>旧API：<code>void function(struct page *page, unsigned int order);</code></li>
<li>新API：<code>void function(struct folio *folio);</code><br>新API更简洁，并且类型安全。</li>
</ul>
</li>
<li><strong>关系与转换</strong>：内核提供了一套完整的函数来在<code>folio</code>和<code>page</code>之间转换：<ul>
<li><code>page_folio(page)</code>：从任意一个（头或尾）<code>struct page</code>指针找到其所属的<code>struct folio</code>。</li>
<li><code>&amp;folio-&gt;page</code>：从一个<code>struct folio</code>获取其头页的<code>struct page</code>指针。</li>
</ul>
</li>
</ol>
<h4 id="它的主要优势体现在哪些方面？-1"><a href="#它的主要优势体现在哪些方面？-1" class="headerlink" title="它的主要优势体现在哪些方面？"></a>它的主要优势体现在哪些方面？</h4><ul>
<li><strong>代码简化与可读性</strong>：这是最直接、最重要的优势。它消除了大量的<code>compound_head()</code>调用和相关的条件判断，使得代码更短、更清晰、更易于理解和维护。</li>
<li><strong>减少Bug</strong>：通过消除处理尾页的复杂逻辑，从根本上杜绝了一整类常见的内核bug。</li>
<li><strong>性能</strong>：虽然主要目标是简化代码，但更清晰的逻辑和更少的函数参数有时也能带来微小的性能提升。例如，编译器可以更好地优化代码，同时减少了函数调用时的栈操作。</li>
</ul>
<h4 id="它存在哪些已知的劣势、局限性或在特定场景下的不适用性？"><a href="#它存在哪些已知的劣势、局限性或在特定场景下的不适用性？" class="headerlink" title="它存在哪些已知的劣势、局限性或在特定场景下的不适用性？"></a>它存在哪些已知的劣势、局限性或在特定场景下的不适用性？</h4><ul>
<li><strong>庞大的转换工作</strong>：最大的“劣势”是将其应用到整个内核所需的工作量是巨大的。这是一个持续数年的重构项目。</li>
<li><strong>过渡期的复杂性</strong>：在所有代码都被转换之前，开发者需要在新旧API之间进行转换，这在过渡期间会引入一些额外的复杂性。</li>
<li><strong>学习成本</strong>：对于习惯了旧的<code>struct page</code>模型的内核开发者来说，需要一个适应和学习新API和新概念的过程。</li>
</ul>
<h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><h4 id="在哪些具体的业务或技术场景下，它是首选解决方案？请举例说明。-1"><a href="#在哪些具体的业务或技术场景下，它是首选解决方案？请举例说明。-1" class="headerlink" title="在哪些具体的业务或技术场景下，它是首选解决方案？请举例说明。"></a>在哪些具体的业务或技术场景下，它是首选解决方案？请举例说明。</h4><p>Folio是处理<strong>任何可能大于4KB的内存块</strong>的<strong>现代、首选</strong>的内核编程方式。</p>
<ul>
<li><strong>页面缓存（Page Cache）</strong>：这是Folio最典型的应用场景。当读写一个文件时，内核可能会为它分配一个2MB的透明大页（THP）来作为缓存。使用Folio，整个2MB的块可以被一个<code>struct folio</code>对象管理。文件系统代码在处理这个缓存时，只需传递这一个对象，而无需关心它是由512个4KB的页面组成的。</li>
<li><strong>透明大页（THP）和HugeTLB</strong>：管理大页的内核代码（分配、分裂、合并）是Folio的直接受益者，其内部逻辑得到了极大的简化。</li>
<li><strong>I&#x2F;O操作</strong>：在进行块设备I&#x2F;O或网络数据包处理时，经常会处理跨越多个页面的大数据块。将这些数据块表示为Folio，可以简化驱动程序和协议栈的代码。</li>
</ul>
<h4 id="是否有不推荐使用该技术的场景？为什么？-1"><a href="#是否有不推荐使用该技术的场景？为什么？-1" class="headerlink" title="是否有不推荐使用该技术的场景？为什么？"></a>是否有不推荐使用该技术的场景？为什么？</h4><ul>
<li><strong>底层页分配器</strong>：内核最底层的物理页分配器——伙伴系统（Buddy System）——仍然直接操作<code>struct page</code>和<code>order</code>。这是因为它就是构建所有上层抽象（包括Folio）的基础。Folio是更高层次的抽象。</li>
<li><strong>必须操作单个物理页的场景</strong>：在极少数的、需要直接与硬件交互并精确控制单个4KB物理页的底层代码中，可能仍然需要直接使用<code>struct page</code>。但即使在这种情况下，通常也可以从Folio中获取其包含的第一个或第N个<code>struct page</code>来进行操作。</li>
</ul>
<h3 id="对比分析-1"><a href="#对比分析-1" class="headerlink" title="对比分析"></a>对比分析</h3><h4 id="请将其-与-其他相似技术-进行详细对比。-1"><a href="#请将其-与-其他相似技术-进行详细对比。-1" class="headerlink" title="请将其 与 其他相似技术 进行详细对比。"></a>请将其 与 其他相似技术 进行详细对比。</h4><p>Folio最直接的对比对象就是它所要取代的——传统的复合页（Compound Page）机制。</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">内存页束 (Memory Folios)</th>
<th align="left">复合页 (Compound Pages)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>核心抽象</strong></td>
<td align="left"><code>struct folio</code>，一个明确代表完整内存块的对象。</td>
<td align="left"><code>struct page</code>，一个有歧义的指针，可能是头页或尾页。</td>
</tr>
<tr>
<td align="left"><strong>API签名</strong></td>
<td align="left">简洁：<code>function(struct folio *folio)</code></td>
<td align="left">繁琐：<code>function(struct page *page, int order)</code></td>
</tr>
<tr>
<td align="left"><strong>查找元信息</strong></td>
<td align="left">直接从folio对象获取。</td>
<td align="left">必须先检查是否为尾页，若是，则需调用<code>compound_head()</code>找到头页。</td>
</tr>
<tr>
<td align="left"><strong>大小&#x2F;阶数信息</strong></td>
<td align="left">内置于<code>struct folio</code>中。</td>
<td align="left">存储在头页的<code>struct page</code>中，需要间接获取。</td>
</tr>
<tr>
<td align="left"><strong>代码复杂度</strong></td>
<td align="left"><strong>低</strong>。逻辑清晰，线性。</td>
<td align="left"><strong>高</strong>。充满了条件判断和<code>compound_head()</code>调用。</td>
</tr>
<tr>
<td align="left"><strong>出错可能性</strong></td>
<td align="left"><strong>低</strong>。类型系统提供了更强的保护，消除了尾页问题。</td>
<td align="left"><strong>高</strong></td>
</tr>
</tbody></table>
<h1 id="include-asm-generic-getorder-h"><a href="#include-asm-generic-getorder-h" class="headerlink" title="include&#x2F;asm-generic&#x2F;getorder.h"></a>include&#x2F;asm-generic&#x2F;getorder.h</h1><h2 id="get-order-计算给定大小的内存块所需的页数"><a href="#get-order-计算给定大小的内存块所需的页数" class="headerlink" title="get_order 计算给定大小的内存块所需的页数"></a>get_order 计算给定大小的内存块所需的页数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * get_order - 确定内存大小的分配顺序</span></span><br><span class="line"><span class="comment"> * @size：要获取订单的大小</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 确定特定大小的内存块的分配顺序。 这是对数刻度，其中：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * order = 0：表示内存块大小小于等于一个页面。</span></span><br><span class="line"><span class="comment"> * order = 1：表示内存块大小在 1 * PAGE_SIZE 到 2 * PAGE_SIZE 之间。</span></span><br><span class="line"><span class="comment"> * order = 2：表示内存块大小在 2 * PAGE_SIZE 到 4 * PAGE_SIZE 之间</span></span><br><span class="line"><span class="comment"> *	...</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回的订单用于查找保存指定大小的对象所需的最小分配颗粒。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果大小为 0，则结果为 undefined。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> __always_inline __attribute_const__ <span class="type">int</span> <span class="title function_">get_order</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (__builtin_constant_p(size)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!size)	<span class="comment">//如果 size 为 0，返回 BITS_PER_LONG - PAGE_SHIFT（通常是一个较大的值，用于表示错误或未定义行为）</span></span><br><span class="line">			<span class="keyword">return</span> BITS_PER_LONG - PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (size &lt; (<span class="number">1UL</span> &lt;&lt; PAGE_SHIFT))	<span class="comment">//size 小于一个页面大小（PAGE_SIZE），返回 0，表示只需要一个页面即可满足分配需求</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> ilog2((size) - <span class="number">1</span>) - PAGE_SHIFT + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	size--;</span><br><span class="line">	size &gt;&gt;= PAGE_SHIFT;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> BITS_PER_LONG == 32</span></span><br><span class="line">	<span class="keyword">return</span> fls(size);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="keyword">return</span> fls64(size);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="mm-slab-h"><a href="#mm-slab-h" class="headerlink" title="mm&#x2F;slab.h"></a>mm&#x2F;slab.h</h1><h2 id="folio-slab-将-folio-转换为-slab-结构体"><a href="#folio-slab-将-folio-转换为-slab-结构体" class="headerlink" title="folio_slab 将 folio 转换为 slab 结构体"></a>folio_slab 将 folio 转换为 slab 结构体</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * folio_slab - 从作品集转换为板。</span></span><br><span class="line"><span class="comment"> * @folio：对开页。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 目前，struct slab 是作品集的不同表示形式，其中 folio_test_slab（） 为 true。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回：包含此作品集的板。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> folio_slab(folio)	(_Generic((folio),			\</span></span><br><span class="line"><span class="meta">	const struct folio *:	(const struct slab *)(folio),		\</span></span><br><span class="line"><span class="meta">	struct folio *:		(struct slab *)(folio)))</span></span><br></pre></td></tr></table></figure>

<h2 id="slab-folio-结构体"><a href="#slab-folio-结构体" class="headerlink" title="slab folio 结构体"></a>slab folio 结构体</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* struct folio 是 Linux 内核中用于表示一组连续内存页面的抽象。</span></span><br><span class="line"><span class="comment"> * 它是对 struct page 的扩展，旨在提高内存管理的效率，特别是在处理大页面（huge pages）和文件缓存时。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> __page_flags;	<span class="comment">//页面的标志位</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab_cache</span>;</span>	<span class="comment">//表示该 slab 所属的缓存</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slab_list</span>;</span></span><br><span class="line">			<span class="comment">/* Double-word boundary */</span></span><br><span class="line">			<span class="type">void</span> *freelist;		<span class="comment">/* first free object */</span></span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span>	<span class="comment">//用于 RCU 回收的头部</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> __page_type;		<span class="comment">//页面的类型</span></span><br><span class="line">	<span class="type">atomic_t</span> __page_refcount;		<span class="comment">//页面的引用计数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * folio是一组在物理上、虚拟上和逻辑上连续的字节。 </span></span><br><span class="line"><span class="comment">  * 它的大小是 2 的幂，并且与相同的 2 的幂对齐。 它至少与 %PAGE_SIZE 一样大。 </span></span><br><span class="line"><span class="comment">  * 如果它在页面缓存中，则它位于文件偏移量是 2 的幂数的倍数。 </span></span><br><span class="line"><span class="comment">  * 它可能被映射到位于任意页面偏移量的地址的用户空间，但其内核虚拟地址与其大小对齐。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">folio</span> &#123;</span></span><br><span class="line">	<span class="comment">/* private: don&#x27;t document the anon union */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> <span class="title">page</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> __<span class="title">page_1</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> __<span class="title">page_2</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> __<span class="title">page_3</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="kmem-cache-args-结构体"><a href="#kmem-cache-args-结构体" class="headerlink" title="kmem_cache_args 结构体"></a>kmem_cache_args 结构体</h2><ul>
<li>在 Linux 内核中，kmem_cache_create 提供了一个构造函数（ctor），用于在分配内存时对对象进行自定义初始化。然而，内核并没有直接提供析构函数的机制。这是因为内核的内存管理模型与用户态的对象生命周期管理不同，析构操作通常是由调用者显式完成的。<br>原因分析</li>
</ul>
<ol>
<li><p>内存管理的简单性:<br>内核的内存管理尽量保持简单高效，避免增加额外的复杂性。构造函数的主要作用是确保分配的内存对象在被使用之前处于已知的初始状态，而析构函数则需要在释放内存时执行清理逻辑，这会增加额外的开销。</p>
</li>
<li><p>释放内存的不可预测性:<br>在内核中，内存释放操作通常是由调用者决定的，内核并不知道对象的具体用途或释放时需要进行什么操作。因此，析构逻辑更适合由调用者在释放前手动完成。</p>
</li>
<li><p>RCU 和延迟释放机制的影响:<br>在某些情况下，内核使用 RCU（Read-Copy-Update）或其他延迟释放机制来管理内存。对象在被释放之前可能会经历一段延迟期，在这期间执行析构函数可能会导致不一致性或额外的复杂性。</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_args</span> &#123;</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * @align：对象所需的对齐方式。</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * %0 表示未请求特定对齐。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> align;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * @useroffset：Usercopy 区域偏移量。</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * %0 是有效的偏移量，当 @usersize 为非 %0 时</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> useroffset;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * @usersize：Usercopy 区域大小。</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * %0 表示未指定 usercopy 区域。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> usersize;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * @freeptr_offset：自由指针的自定义偏移量</span></span><br><span class="line"><span class="comment">	 * 在 &amp;SLAB_TYPESAFE_BY_RCU 缓存中</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 默认情况下 &amp;SLAB_TYPESAFE_BY_RCU 缓存将空闲指针放在对象外部。这可能会导致对象变大。有理由避免这种情况的缓存创建者可以在其结构体中指定自定义自由指针偏移量，自由指针将放置在其中。</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 请注意，将空闲指针放在对象内需要调用方确保没有防止对象回收所需的字段无效（有关详细信息，请参阅 &amp;SLAB_TYPESAFE_BY_RCU）。</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 使用 %0 作为 @freeptr_offset 的值是有效的。如果指定了 @freeptr_offset，则必须将 %use_freeptr_offset 设置为 %true。</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 请注意，自定义自由指针目前不支持 @ctor，因为@ctor需要外部自由指针。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> freeptr_offset;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * @use_freeptr_offset: Whether a @freeptr_offset is used.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">bool</span> use_freeptr_offset;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * @ctor：对象的构造函数。</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 为新分配的 slab 页面中的每个对象调用构造函数。缓存用户有责任释放与调用构造函数后相同状态的对象，或者适当处理新构造的对象和重新分配的对象之间的任何差异。</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * %NULL 表示没有构造函数。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">void</span> (*ctor)(<span class="type">void</span> *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="kmalloc-index-计算-kmalloc-的索引"><a href="#kmalloc-index-计算-kmalloc-的索引" class="headerlink" title="kmalloc_index 计算 kmalloc 的索引"></a>kmalloc_index 计算 kmalloc 的索引</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 确定分配特定大小的 kmalloc 板</span></span><br><span class="line"><span class="comment"> * 属于。</span></span><br><span class="line"><span class="comment"> * 0 = 零分配</span></span><br><span class="line"><span class="comment"> * 1 = 65 ..96 字节</span></span><br><span class="line"><span class="comment"> * 2 = 129 ..192 字节</span></span><br><span class="line"><span class="comment"> * n = 2^（n-1） 1 ..2^n</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：__kmalloc_index（） 是编译时优化的，而不是运行时优化的;典型用法是通过 kmalloc_index（） 进行的，因此在编译时进行评估。其中 ！size_is_constant 应该只应该是测试模块，可以容忍 __kmalloc_index（） 的运行时开销。 另请参阅 kmalloc_slab（）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">unsigned</span> <span class="type">int</span> __kmalloc_index(<span class="type">size_t</span> size,</span><br><span class="line">						    <span class="type">bool</span> size_is_constant)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!size)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (size &lt;= KMALLOC_MIN_SIZE)</span><br><span class="line">		<span class="keyword">return</span> KMALLOC_SHIFT_LOW;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (KMALLOC_MIN_SIZE &lt;= <span class="number">32</span> &amp;&amp; size &gt; <span class="number">64</span> &amp;&amp; size &lt;= <span class="number">96</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (KMALLOC_MIN_SIZE &lt;= <span class="number">64</span> &amp;&amp; size &gt; <span class="number">128</span> &amp;&amp; size &lt;= <span class="number">192</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;=          <span class="number">8</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;=         <span class="number">16</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;=         <span class="number">32</span>) <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;=         <span class="number">64</span>) <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;=        <span class="number">128</span>) <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;=        <span class="number">256</span>) <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;=        <span class="number">512</span>) <span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;=       <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;=   <span class="number">2</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;=   <span class="number">4</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;=   <span class="number">8</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">13</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;=  <span class="number">16</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">14</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;=  <span class="number">32</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">15</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;=  <span class="number">64</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">16</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;= <span class="number">128</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">17</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;= <span class="number">256</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">18</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;= <span class="number">512</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">19</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;= <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;=  <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!IS_ENABLED(CONFIG_PROFILE_ALL_BRANCHES) &amp;&amp; size_is_constant)</span><br><span class="line">		BUILD_BUG_ON_MSG(<span class="number">1</span>, <span class="string">&quot;unexpected size in kmalloc_index()&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		BUG();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Will never be reached. Needed because the compiler may complain */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static_assert</span>(PAGE_SHIFT &lt;= <span class="number">20</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kmalloc_index(s) __kmalloc_index(s, true)</span></span><br></pre></td></tr></table></figure>

<h2 id="kmalloc-type-计算-kmalloc-的类型"><a href="#kmalloc-type-计算-kmalloc-的类型" class="headerlink" title="kmalloc_type 计算 kmalloc 的类型"></a>kmalloc_type 计算 kmalloc 的类型</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="keyword">enum</span> kmalloc_cache_type <span class="title function_">kmalloc_type</span><span class="params">(<span class="type">gfp_t</span> flags, <span class="type">unsigned</span> <span class="type">long</span> caller)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 最常见的情况是 KMALLOC_NORMAL，因此请使用所有相关标志的单个分支进行测试。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (likely((flags &amp; KMALLOC_NOT_NORMAL_BITS) == <span class="number">0</span>))</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_RANDOM_KMALLOC_CACHES</span></span><br><span class="line">		<span class="comment">/* RANDOM_KMALLOC_CACHES_NR (=15) copies + the KMALLOC_NORMAL */</span></span><br><span class="line">		<span class="keyword">return</span> KMALLOC_RANDOM_START + hash_64(caller ^ random_kmalloc_seed,</span><br><span class="line">						      ilog2(RANDOM_KMALLOC_CACHES_NR + <span class="number">1</span>));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		<span class="keyword">return</span> KMALLOC_NORMAL;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * At least one of the flags has to be set. Their priorities in</span></span><br><span class="line"><span class="comment">	 * decreasing order are:</span></span><br><span class="line"><span class="comment">	 *  1) __GFP_DMA</span></span><br><span class="line"><span class="comment">	 *  2) __GFP_RECLAIMABLE</span></span><br><span class="line"><span class="comment">	 *  3) __GFP_ACCOUNT</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_ZONE_DMA) &amp;&amp; (flags &amp; __GFP_DMA))</span><br><span class="line">		<span class="keyword">return</span> KMALLOC_DMA;</span><br><span class="line">	<span class="keyword">if</span> (!IS_ENABLED(CONFIG_MEMCG) || (flags &amp; __GFP_RECLAIMABLE))</span><br><span class="line">		<span class="keyword">return</span> KMALLOC_RECLAIM;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> KMALLOC_CGROUP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="kmalloc-分配内核内存"><a href="#kmalloc-分配内核内存" class="headerlink" title="kmalloc 分配内核内存"></a>kmalloc 分配内核内存</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kmalloc - allocate kernel memory</span></span><br><span class="line"><span class="comment"> * @size: how many bytes of memory are required.</span></span><br><span class="line"><span class="comment"> * @flags: describe the allocation context</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment">1. kmalloc 的用途</span></span><br><span class="line"><span class="comment">kmalloc 用于分配内核内存，主要针对小于页面大小的对象。分配的内存地址至少对齐到 ARCH_KMALLOC_MINALIGN 字节，并根据分配大小提供额外的对齐保证：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如果分配大小是 2 的幂，则对齐到该大小。</span></span><br><span class="line"><span class="comment">对于其他大小，对齐到分配大小的最大 2 的幂因子。</span></span><br><span class="line"><span class="comment">这种对齐方式确保了内存分配的高效性和兼容性，特别是在需要特定对齐的硬件或数据结构中。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. GFP 标志</span></span><br><span class="line"><span class="comment">kmalloc 的第二个参数 flags 是 GFP（Get Free Pages）标志，用于描述分配的上下文和行为。常用的 GFP 标志包括：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">GFP_KERNEL：分配普通内核内存，可能会导致睡眠。</span></span><br><span class="line"><span class="comment">GFP_NOWAIT：分配不会导致睡眠。</span></span><br><span class="line"><span class="comment">GFP_ATOMIC：分配不会导致睡眠，并可能使用紧急内存池。</span></span><br><span class="line"><span class="comment">__GFP_ZERO：分配的内存会被初始化为零。</span></span><br><span class="line"><span class="comment">__GFP_NOFAIL：分配不能失败（需谨慎使用）。</span></span><br><span class="line"><span class="comment">__GFP_NORETRY：如果内存不足，立即放弃分配。</span></span><br><span class="line"><span class="comment">__GFP_NOWARN：分配失败时不打印警告。</span></span><br><span class="line"><span class="comment">__GFP_RETRY_MAYFAIL：尽力分配，但允许最终失败。</span></span><br><span class="line"><span class="comment">这些标志通过按位或（|）组合，可以灵活地指定分配行为。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> __always_inline __alloc_size(<span class="number">1</span>) <span class="type">void</span> *<span class="title function_">kmalloc_noprof</span><span class="params">(<span class="type">size_t</span> size, <span class="type">gfp_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (__builtin_constant_p(size) &amp;&amp; size) &#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (size &gt; KMALLOC_MAX_CACHE_SIZE)</span><br><span class="line">			<span class="keyword">return</span> __kmalloc_large_noprof(size, flags);</span><br><span class="line"></span><br><span class="line">		index = kmalloc_index(size);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> __kmalloc_cache_noprof(</span><br><span class="line">				kmalloc_caches[kmalloc_type(flags, _RET_IP_)][index],</span><br><span class="line">				flags, size);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> __kmalloc_noprof(size, flags);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kmalloc(...)				alloc_hooks(kmalloc_noprof(__VA_ARGS__))</span></span><br></pre></td></tr></table></figure>

<h2 id="kzalloc-分配并清零内核内存"><a href="#kzalloc-分配并清零内核内存" class="headerlink" title="kzalloc 分配并清零内核内存"></a>kzalloc 分配并清零内核内存</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kzalloc - 分配内存。内存设置为零。</span></span><br><span class="line"><span class="comment"> * @size：需要多少字节的内存。</span></span><br><span class="line"><span class="comment"> * @flags：要分配的内存类型（参见 kmalloc）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> __alloc_size(<span class="number">1</span>) <span class="type">void</span> *<span class="title function_">kzalloc_noprof</span><span class="params">(<span class="type">size_t</span> size, <span class="type">gfp_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> kmalloc_noprof(size, flags | __GFP_ZERO);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kzalloc(...)				alloc_hooks(kzalloc_noprof(__VA_ARGS__))</span></span><br></pre></td></tr></table></figure>

<h2 id="kcalloc-分配数组并清零"><a href="#kcalloc-分配数组并清零" class="headerlink" title="kcalloc 分配数组并清零"></a>kcalloc 分配数组并清零</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kmalloc_array - allocate memory for an array.</span></span><br><span class="line"><span class="comment"> * @n: number of elements.</span></span><br><span class="line"><span class="comment"> * @size: element size.</span></span><br><span class="line"><span class="comment"> * @flags: the type of memory to allocate (see kmalloc).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> __alloc_size(<span class="number">1</span>, <span class="number">2</span>) <span class="type">void</span> *<span class="title function_">kmalloc_array_noprof</span><span class="params">(<span class="type">size_t</span> n, <span class="type">size_t</span> size, <span class="type">gfp_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">size_t</span> bytes;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(check_mul_overflow(n, size, &amp;bytes)))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> kmalloc_noprof(bytes, flags);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kmalloc_array(...)			alloc_hooks(kmalloc_array_noprof(__VA_ARGS__))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kcalloc - 为数组分配内存。内存设置为零。</span></span><br><span class="line"><span class="comment"> * @n：元素数量。</span></span><br><span class="line"><span class="comment"> * @size：元素大小。</span></span><br><span class="line"><span class="comment"> * @flags：要分配的内存类型（参见 kmalloc）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kcalloc(n, size, flags)		kmalloc_array(n, size, (flags) | __GFP_ZERO)</span></span><br></pre></td></tr></table></figure>

<h2 id="kmem-cache-zalloc-分配-slab-缓存中的内存"><a href="#kmem-cache-zalloc-分配-slab-缓存中的内存" class="headerlink" title="kmem_cache_zalloc 分配 slab 缓存中的内存"></a>kmem_cache_zalloc 分配 slab 缓存中的内存</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">kmem_cache_alloc_noprof</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">gfp_t</span> gfpflags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> *ret = slab_alloc_node(s, <span class="literal">NULL</span>, gfpflags, NUMA_NO_NODE, _RET_IP_,</span><br><span class="line">				    s-&gt;object_size);</span><br><span class="line"></span><br><span class="line">	trace_kmem_cache_alloc(_RET_IP_, ret, s, gfpflags, NUMA_NO_NODE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kmem_cache_alloc - 分配对象</span></span><br><span class="line"><span class="comment"> * @cachep：要从中分配的缓存。</span></span><br><span class="line"><span class="comment"> * @flags：请参阅 kmalloc（）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 从此缓存中分配对象。</span></span><br><span class="line"><span class="comment"> * 请参阅 kmem_cache_zalloc（） 以获取向标志添加__GFP_ZERO的快捷方式。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回：指向新对象的指针或 %NULL（如果出现错误）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">kmem_cache_alloc_noprof</span><span class="params">(<span class="keyword">struct</span> kmem_cache *cachep,</span></span><br><span class="line"><span class="params">			      <span class="type">gfp_t</span> flags)</span> __assume_slab_alignment __malloc;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kmem_cache_alloc(...)			alloc_hooks(kmem_cache_alloc_noprof(__VA_ARGS__))</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Shortcuts</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kmem_cache_zalloc(_k, _flags)		kmem_cache_alloc(_k, (_flags)|__GFP_ZERO)</span></span><br></pre></td></tr></table></figure>

<h2 id="kmem-cache-create-usercopy-创建用户拷贝缓存"><a href="#kmem-cache-create-usercopy-创建用户拷贝缓存" class="headerlink" title="kmem_cache_create_usercopy 创建用户拷贝缓存"></a>kmem_cache_create_usercopy 创建用户拷贝缓存</h2><ul>
<li>useroffset（用户复制区域偏移量）：<br>  useroffset 表示用户可复制区域相对于内存块起始地址的偏移量。<br>  通过指定偏移量，可以确保用户只能访问内存块中的特定区域，而不会影响其他敏感数据。</li>
<li>usersize（用户复制区域大小）：<br>  usersize 定义了用户可复制区域的大小。<br>  这确保用户只能操作指定大小的内存数据，从而避免越界访问或数据损坏。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kmem_cache_create_usercopy - 创建具有适合复制到用户空间的区域的 kmem 缓存。</span></span><br><span class="line"><span class="comment"> * @name：在 /proc/slabinfo 中用于标识此缓存的字符串。</span></span><br><span class="line"><span class="comment"> * @size：要在此缓存中创建的对象的大小。</span></span><br><span class="line"><span class="comment"> * @align：对象所需的对齐方式。</span></span><br><span class="line"><span class="comment"> * @flags：SLAB 标志</span></span><br><span class="line"><span class="comment"> * @useroffset：Usercopy 区域偏移</span></span><br><span class="line"><span class="comment"> * @usersize：Usercopy 区域大小</span></span><br><span class="line"><span class="comment"> * @ctor：对象的构造函数，或 %NULL。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这是一个遗留的包装器，如果将单个字段列入白名单就足够了，新代码应该使用 KMEM_CACHE_USERCOPY（） ，或者使用 kmem_cache_create（） 并通过 args 参数传递必要的参数（参见 &amp;struct kmem_cache_args）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回：成功时指向缓存的指针，失败时返回 NULL。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> kmem_cache *</span><br><span class="line"><span class="title function_">kmem_cache_create_usercopy</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">unsigned</span> <span class="type">int</span> size,</span></span><br><span class="line"><span class="params">			   <span class="type">unsigned</span> <span class="type">int</span> align, <span class="type">slab_flags_t</span> flags,</span></span><br><span class="line"><span class="params">			   <span class="type">unsigned</span> <span class="type">int</span> useroffset, <span class="type">unsigned</span> <span class="type">int</span> usersize,</span></span><br><span class="line"><span class="params">			   <span class="type">void</span> (*ctor)(<span class="type">void</span> *))</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_args</span> <span class="title">kmem_args</span> =</span> &#123;</span><br><span class="line">		.align		= align,</span><br><span class="line">		.ctor		= ctor,</span><br><span class="line">		.useroffset	= useroffset,</span><br><span class="line">		.usersize	= usersize,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> __kmem_cache_create_args(name, size, &amp;kmem_args, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="kmem-cache-default-args-创建默认参数的-slab-缓存"><a href="#kmem-cache-default-args-创建默认参数的-slab-缓存" class="headerlink" title="__kmem_cache_default_args 创建默认参数的 slab 缓存"></a>__kmem_cache_default_args 创建默认参数的 slab 缓存</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* If NULL is passed for @args, use this variant with default arguments. */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *</span></span><br><span class="line"><span class="class">__<span class="title">kmem_cache_default_args</span>(<span class="title">const</span> <span class="title">char</span> *<span class="title">name</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">size</span>,</span></span><br><span class="line"><span class="class">			  <span class="keyword">struct</span> <span class="title">kmem_cache_args</span> *<span class="title">args</span>,</span></span><br><span class="line"><span class="class">			  <span class="title">slab_flags_t</span> <span class="title">flags</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_args</span> <span class="title">kmem_default_args</span> =</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Make sure we don&#x27;t get passed garbage. */</span></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON_ONCE(args))</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> __kmem_cache_create_args(name, size, &amp;kmem_default_args, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="kmem-cache-create-创建-slab-缓存-传入构造函数与对齐值"><a href="#kmem-cache-create-创建-slab-缓存-传入构造函数与对齐值" class="headerlink" title="__kmem_cache_create 创建 slab 缓存 传入构造函数与对齐值"></a>__kmem_cache_create 创建 slab 缓存 传入构造函数与对齐值</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *__<span class="title">kmem_cache_create_args</span>(<span class="title">const</span> <span class="title">char</span> *<span class="title">name</span>,</span></span><br><span class="line"><span class="class">					    <span class="title">unsigned</span> <span class="title">int</span> <span class="title">object_size</span>,</span></span><br><span class="line"><span class="class">					    <span class="keyword">struct</span> <span class="title">kmem_cache_args</span> *<span class="title">args</span>,</span></span><br><span class="line"><span class="class">					    <span class="title">slab_flags_t</span> <span class="title">flags</span>);</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *</span></span><br><span class="line"><span class="class">__<span class="title">kmem_cache_create</span>(<span class="title">const</span> <span class="title">char</span> *<span class="title">name</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">size</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">align</span>,</span></span><br><span class="line"><span class="class">		    <span class="title">slab_flags_t</span> <span class="title">flags</span>, <span class="title">void</span> (*<span class="title">ctor</span>)(<span class="title">void</span> *))</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_args</span> <span class="title">kmem_args</span> =</span> &#123;</span><br><span class="line">		.align	= align,</span><br><span class="line">		.ctor	= ctor,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> __kmem_cache_create_args(name, size, &amp;kmem_args, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="kmem-cache-create-创建-slab-缓存"><a href="#kmem-cache-create-创建-slab-缓存" class="headerlink" title="kmem_cache_create 创建 slab 缓存"></a>kmem_cache_create 创建 slab 缓存</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* kmem_cache_create - 创建 kmem 缓存。</span></span><br><span class="line"><span class="comment"> * @__name：在 /proc/slabinfo 中用于标识此缓存的字符串。</span></span><br><span class="line"><span class="comment"> * @__object_size：要在此缓存中创建的对象的大小。</span></span><br><span class="line"><span class="comment"> * @__args：可选参数，请参阅 &amp;struct kmem_cache_args。传递 %NULL 意味着默认值将用于所有参数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 目前，这是作为宏实现的，使用 &#x27;&#x27;_Generic（）&#x27;&#x27; 调用</span></span><br><span class="line"><span class="comment"> * 函数的新变体或旧变体。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 新变体有 4 个参数：</span></span><br><span class="line"><span class="comment"> * &#x27;&#x27;kmem_cache_create（名称、object_size、参数、标志）&#x27;&#x27;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参见 __kmem_cache_create_args（） 实现此功能。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 旧版变体有 5 个参数：</span></span><br><span class="line"><span class="comment"> * &#x27;&#x27;kmem_cache_create（名称、object_size、对齐、标志、ctor）&#x27;&#x27;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * align 和 ctor 参数映射到 &amp;struct 的相应字段kmem_cache_args</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 上下文：不能在中断中调用，但可以中断。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回：成功时指向缓存的指针，失败时返回 NULL。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kmem_cache_create(__name, __object_size, __args, ...)           \</span></span><br><span class="line"><span class="meta">	_Generic((__args),                                              \</span></span><br><span class="line"><span class="meta">		struct kmem_cache_args *: __kmem_cache_create_args,	\</span></span><br><span class="line"><span class="meta">		void *: __kmem_cache_default_args,			\</span></span><br><span class="line"><span class="meta">		default: __kmem_cache_create)(__name, __object_size, __args, __VA_ARGS__)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="KMEM-CACHE-创建-slab-缓存"><a href="#KMEM-CACHE-创建-slab-缓存" class="headerlink" title="KMEM_CACHE 创建 slab 缓存"></a>KMEM_CACHE 创建 slab 缓存</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 请使用此宏创建 slab 缓存。只需指定结构的名称，也许还可以指定上面列出的一些标志。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 结构体的对齐方式决定了对象的对齐方式。如果你在 struct 声明中添加 ____cacheline_aligned_in_smp，那么对象将在 SMP 配置中正确对齐。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMEM_CACHE(__struct, __flags)                                   \</span></span><br><span class="line"><span class="meta">	__kmem_cache_create_args(#__struct, sizeof(struct __struct),    \</span></span><br><span class="line"><span class="meta">			&amp;(struct kmem_cache_args) &#123;			\</span></span><br><span class="line"><span class="meta">				.align	= __alignof__(struct __struct), \</span></span><br><span class="line"><span class="meta">			&#125;, (__flags))</span></span><br></pre></td></tr></table></figure>

<h2 id="kmem-cache-alloc-lru-noprof-分配-LRU-缓存中的对象"><a href="#kmem-cache-alloc-lru-noprof-分配-LRU-缓存中的对象" class="headerlink" title="kmem_cache_alloc_lru_noprof 分配 LRU 缓存中的对象"></a>kmem_cache_alloc_lru_noprof 分配 LRU 缓存中的对象</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> kmem_cache_alloc_lru(...)	alloc_hooks(kmem_cache_alloc_lru_noprof(__VA_ARGS__))</span></span><br></pre></td></tr></table></figure>

<h2 id="kvmalloc-array-分配大数组"><a href="#kvmalloc-array-分配大数组" class="headerlink" title="kvmalloc_array 分配大数组"></a>kvmalloc_array 分配大数组</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> kvmalloc_node_noprof(size, flags, node)	\</span></span><br><span class="line"><span class="meta">	__kvmalloc_node_noprof(PASS_BUCKET_PARAMS(size, NULL), flags, node)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> __alloc_size(<span class="number">1</span>, <span class="number">2</span>) <span class="type">void</span> *</span><br><span class="line"><span class="title function_">kvmalloc_array_node_noprof</span><span class="params">(<span class="type">size_t</span> n, <span class="type">size_t</span> size, <span class="type">gfp_t</span> flags, <span class="type">int</span> node)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">size_t</span> bytes;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(check_mul_overflow(n, size, &amp;bytes)))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> kvmalloc_node_noprof(bytes, flags, node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kvmalloc_array_noprof(...)		kvmalloc_array_node_noprof(__VA_ARGS__, NUMA_NO_NODE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kvmalloc_array(...)			alloc_hooks(kvmalloc_array_noprof(__VA_ARGS__))</span></span><br></pre></td></tr></table></figure>

<h2 id="kmalloc-slab-查找-kmalloc-缓存"><a href="#kmalloc-slab-查找-kmalloc-缓存" class="headerlink" title="kmalloc_slab 查找 kmalloc 缓存"></a>kmalloc_slab 查找 kmalloc 缓存</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 找到用于给定分配大小的 kmem_cache 结构  </span></span><br><span class="line"><span class="comment">*  </span></span><br><span class="line"><span class="comment">* 假设 size 大于零且不超过 KMALLOC_MAX_CACHE_SIZE，  </span></span><br><span class="line"><span class="comment">* 调用者必须检查这一点。  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> kmem_cache *</span><br><span class="line"><span class="title function_">kmalloc_slab</span><span class="params">(<span class="type">size_t</span> size, kmem_buckets *b, <span class="type">gfp_t</span> flags, <span class="type">unsigned</span> <span class="type">long</span> caller)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!b)</span><br><span class="line">		b = &amp;kmalloc_caches[kmalloc_type(flags, caller)];</span><br><span class="line">	<span class="keyword">if</span> (size &lt;= <span class="number">192</span>)</span><br><span class="line">		index = kmalloc_size_index[size_index_elem(size)];</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		index = fls(size - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (*b)[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="include-linux-slab-h"><a href="#include-linux-slab-h" class="headerlink" title="include&#x2F;linux&#x2F;slab.h"></a>include&#x2F;linux&#x2F;slab.h</h1><h2 id="kmem-cache-alloc-node-在指定节点上分配对象"><a href="#kmem-cache-alloc-node-在指定节点上分配对象" class="headerlink" title="kmem_cache_alloc_node 在指定节点上分配对象"></a>kmem_cache_alloc_node 在指定节点上分配对象</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> kmem_cache_alloc_node(...)	alloc_hooks(kmem_cache_alloc_node_noprof(__VA_ARGS__))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kmem_cache_alloc_node - 在指定节点上分配对象</span></span><br><span class="line"><span class="comment"> * @s：要从中分配的缓存。</span></span><br><span class="line"><span class="comment"> * @gfpflags：请参见 kmalloc（）。</span></span><br><span class="line"><span class="comment"> * @node：目标节点的节点号。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 与 kmem_cache_alloc 相同，但它将在给定节点上分配内存，这可以提高 cpu 绑定结构的性能。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果未设置__GFP_THISNODE，则可以回退到其他节点。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回：指向新对象的指针或 %NULL（如果出现错误）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">kmem_cache_alloc_node_noprof</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">gfp_t</span> gfpflags, <span class="type">int</span> node)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> *ret = slab_alloc_node(s, <span class="literal">NULL</span>, gfpflags, node, _RET_IP_, s-&gt;object_size);</span><br><span class="line"></span><br><span class="line">	trace_kmem_cache_alloc(_RET_IP_, ret, s, gfpflags, node);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(kmem_cache_alloc_node_noprof);</span><br></pre></td></tr></table></figure>

<h1 id="include-linux-vmalloc-h"><a href="#include-linux-vmalloc-h" class="headerlink" title="include&#x2F;linux&#x2F;vmalloc.h"></a>include&#x2F;linux&#x2F;vmalloc.h</h1><h2 id="vmalloc-分配虚拟内存"><a href="#vmalloc-分配虚拟内存" class="headerlink" title="__vmalloc 分配虚拟内存"></a>__vmalloc 分配虚拟内存</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> *__vmalloc_noprof(<span class="type">unsigned</span> <span class="type">long</span> size, <span class="type">gfp_t</span> gfp_mask) __alloc_size(<span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __vmalloc(...)		alloc_hooks(__vmalloc_noprof(__VA_ARGS__))</span></span><br></pre></td></tr></table></figure>

<h1 id="mm-slab-common-c"><a href="#mm-slab-common-c" class="headerlink" title="mm&#x2F;slab_common.c"></a>mm&#x2F;slab_common.c</h1><h2 id="calculate-alignment-计算对齐要求"><a href="#calculate-alignment-计算对齐要求" class="headerlink" title="calculate_alignment 计算对齐要求"></a>calculate_alignment 计算对齐要求</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 确定对象的对齐方式，给定一组标志、用户指定的对齐方式和对象的大小。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">calculate_alignment</span><span class="params">(<span class="type">slab_flags_t</span> flags,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">int</span> align, <span class="type">unsigned</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 如果用户想要硬件缓存对齐的对象，则在对象足够大的情况下遵循该建议。</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 但是，硬件缓存对齐方式无法覆盖指定的对齐方式。如果这更大，那就使用它。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; SLAB_HWCACHE_ALIGN) &#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> ralign;</span><br><span class="line"></span><br><span class="line">		ralign = cache_line_size();</span><br><span class="line">		<span class="keyword">while</span> (size &lt;= ralign / <span class="number">2</span>)</span><br><span class="line">			ralign /= <span class="number">2</span>;</span><br><span class="line">		align = max(align, ralign);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	align = max(align, arch_slab_minalign());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ALIGN(align, <span class="keyword">sizeof</span>(<span class="type">void</span> *));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="create-boot-cache-在系统启动阶段创建一个-slab-缓存"><a href="#create-boot-cache-在系统启动阶段创建一个-slab-缓存" class="headerlink" title="create_boot_cache 在系统启动阶段创建一个 slab 缓存"></a>create_boot_cache 在系统启动阶段创建一个 slab 缓存</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在引导期间，当尚无可用的 slab 服务时创建缓存 */</span></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">create_boot_cache</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">int</span> size, <span class="type">slab_flags_t</span> flags,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">int</span> useroffset, <span class="type">unsigned</span> <span class="type">int</span> usersize)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> align = ARCH_KMALLOC_MINALIGN;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_args</span> <span class="title">kmem_args</span> =</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * kmalloc 高速缓存保证至少对齐该大小的最大 2 次方除数。对于 2 的幂次方大小，它是大小本身。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; SLAB_KMALLOC)	<span class="comment">//包含 SLAB_KMALLOC 标志，则根据对象大小计算对齐值</span></span><br><span class="line">		align = max(align, <span class="number">1U</span> &lt;&lt; (ffs(size) - <span class="number">1</span>));</span><br><span class="line">	kmem_args.align = calculate_alignment(flags, align, size);	<span class="comment">//计算最终的对齐要求</span></span><br><span class="line"></span><br><span class="line">	err = do_kmem_cache_create(s, name, size, &amp;kmem_args, flags);	<span class="comment">//实际创建 slab 缓存</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		panic(<span class="string">&quot;Creation of kmalloc slab %s size=%u failed. Reason %d\n&quot;</span>,</span><br><span class="line">					name, size, err);</span><br><span class="line"></span><br><span class="line">	s-&gt;refcount = <span class="number">-1</span>;	<span class="comment">/* 暂时免于合并 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="slab-unmergeable-检查-slab-是否不可合并"><a href="#slab-unmergeable-检查-slab-是否不可合并" class="headerlink" title="slab_unmergeable 检查 slab 是否不可合并"></a>slab_unmergeable 检查 slab 是否不可合并</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Find a mergeable slab cache</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">slab_unmergeable</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (slab_nomerge || (s-&gt;flags &amp; SLAB_NEVER_MERGE))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (s-&gt;ctor)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HARDENED_USERCOPY</span></span><br><span class="line">	<span class="keyword">if</span> (s-&gt;usersize)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We may have set a slab to be unmergeable during bootstrap.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (s-&gt;refcount &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="setup-kmalloc-cache-index-table-设置-kmalloc-缓存索引表"><a href="#setup-kmalloc-cache-index-table-设置-kmalloc-缓存索引表" class="headerlink" title="setup_kmalloc_cache_index_table 设置 kmalloc 缓存索引表"></a>setup_kmalloc_cache_index_table 设置 kmalloc 缓存索引表</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 小板大小的转换表 / 8 到 kmalloc 数组中的索引。这对于 192 &lt;的 slab 是必需的，因为我们那里没有 2 个缓存大小的幂。较大板的尺寸可以使用 fls 确定。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">u8 kmalloc_size_index[<span class="number">24</span>] __ro_after_init = &#123;</span><br><span class="line">	<span class="number">3</span>,	<span class="comment">/* 8 */</span></span><br><span class="line">	<span class="number">4</span>,	<span class="comment">/* 16 */</span></span><br><span class="line">	<span class="number">5</span>,	<span class="comment">/* 24 */</span></span><br><span class="line">	<span class="number">5</span>,	<span class="comment">/* 32 */</span></span><br><span class="line">	<span class="number">6</span>,	<span class="comment">/* 40 */</span></span><br><span class="line">	<span class="number">6</span>,	<span class="comment">/* 48 */</span></span><br><span class="line">	<span class="number">6</span>,	<span class="comment">/* 56 */</span></span><br><span class="line">	<span class="number">6</span>,	<span class="comment">/* 64 */</span></span><br><span class="line">	<span class="number">1</span>,	<span class="comment">/* 72 */</span></span><br><span class="line">	<span class="number">1</span>,	<span class="comment">/* 80 */</span></span><br><span class="line">	<span class="number">1</span>,	<span class="comment">/* 88 */</span></span><br><span class="line">	<span class="number">1</span>,	<span class="comment">/* 96 */</span></span><br><span class="line">	<span class="number">7</span>,	<span class="comment">/* 104 */</span></span><br><span class="line">	<span class="number">7</span>,	<span class="comment">/* 112 */</span></span><br><span class="line">	<span class="number">7</span>,	<span class="comment">/* 120 */</span></span><br><span class="line">	<span class="number">7</span>,	<span class="comment">/* 128 */</span></span><br><span class="line">	<span class="number">2</span>,	<span class="comment">/* 136 */</span></span><br><span class="line">	<span class="number">2</span>,	<span class="comment">/* 144 */</span></span><br><span class="line">	<span class="number">2</span>,	<span class="comment">/* 152 */</span></span><br><span class="line">	<span class="number">2</span>,	<span class="comment">/* 160 */</span></span><br><span class="line">	<span class="number">2</span>,	<span class="comment">/* 168 */</span></span><br><span class="line">	<span class="number">2</span>,	<span class="comment">/* 176 */</span></span><br><span class="line">	<span class="number">2</span>,	<span class="comment">/* 184 */</span></span><br><span class="line">	<span class="number">2</span>	<span class="comment">/* 192 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如果我们对 kmalloc 数组有奇怪的大对齐要求，请修补 size_index 表。这似乎只是 MIPS 的情况。标准拱门不会在此处生成任何代码。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 允许的最大对齐方式为 256 字节，因为我们处理较小缓存的索引确定的方式。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 确保如果有人开始摆弄 ARCH_KMALLOC_MINALIGN 不会发生任何疯狂的事情</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">setup_kmalloc_cache_index_table</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">	<span class="comment">//KMALLOC_MIN_SIZE = 32</span></span><br><span class="line">	BUILD_BUG_ON(KMALLOC_MIN_SIZE &gt; <span class="number">256</span> ||</span><br><span class="line">		!is_power_of_2(KMALLOC_MIN_SIZE));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">8</span>; i &lt; KMALLOC_MIN_SIZE; i += <span class="number">8</span>) &#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> elem = size_index_elem(i);	<span class="comment">//(bytes - 1) / 8;</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (elem &gt;= ARRAY_SIZE(kmalloc_size_index))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		kmalloc_size_index[elem] = KMALLOC_SHIFT_LOW;	<span class="comment">//ilog2(KMALLOC_MIN_SIZE)</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (KMALLOC_MIN_SIZE &gt;= <span class="number">64</span>) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 如果对齐方式为 64 字节，则不使用 96 字节大小的高速缓存。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">64</span> + <span class="number">8</span>; i &lt;= <span class="number">96</span>; i += <span class="number">8</span>)</span><br><span class="line">			kmalloc_size_index[size_index_elem(i)] = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (KMALLOC_MIN_SIZE &gt;= <span class="number">128</span>) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 如果对齐方式为 128 字节，则不使用 192 字节大小的高速缓存。重定向 kmalloc 以改用 256 字节缓存。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">128</span> + <span class="number">8</span>; i &lt;= <span class="number">192</span>; i += <span class="number">8</span>)</span><br><span class="line">			kmalloc_size_index[size_index_elem(i)] = <span class="number">8</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="new-kmalloc-cache-创建新的-kmalloc-缓存"><a href="#new-kmalloc-cache-创建新的-kmalloc-缓存" class="headerlink" title="new_kmalloc_cache 创建新的 kmalloc 缓存"></a>new_kmalloc_cache 创建新的 kmalloc 缓存</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> kmem_cache *__init <span class="title function_">create_kmalloc_cache</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">						      <span class="type">unsigned</span> <span class="type">int</span> size,</span></span><br><span class="line"><span class="params">						      <span class="type">slab_flags_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">s</span> =</span> kmem_cache_zalloc(kmem_cache, GFP_NOWAIT);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!s)</span><br><span class="line">		panic(<span class="string">&quot;Out of memory when creating slab %s\n&quot;</span>, name);</span><br><span class="line"></span><br><span class="line">	create_boot_cache(s, name, size, flags | SLAB_KMALLOC, <span class="number">0</span>, size);</span><br><span class="line">	list_add(&amp;s-&gt;<span class="built_in">list</span>, &amp;slab_caches);</span><br><span class="line">	s-&gt;refcount = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __init</span><br><span class="line"><span class="title function_">new_kmalloc_cache</span><span class="params">(<span class="type">int</span> idx, <span class="keyword">enum</span> kmalloc_cache_type type)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">slab_flags_t</span> flags = <span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> minalign = __kmalloc_minalign();</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> aligned_size = kmalloc_info[idx].size;</span><br><span class="line">	<span class="type">int</span> aligned_idx = idx;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((KMALLOC_RECLAIM != KMALLOC_NORMAL) &amp;&amp; (type == KMALLOC_RECLAIM)) &#123;</span><br><span class="line">		flags |= SLAB_RECLAIM_ACCOUNT;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_ENABLED(CONFIG_MEMCG) &amp;&amp; (type == KMALLOC_CGROUP)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (mem_cgroup_kmem_disabled()) &#123;</span><br><span class="line">			kmalloc_caches[type][idx] = kmalloc_caches[KMALLOC_NORMAL][idx];</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		flags |= SLAB_ACCOUNT;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_ENABLED(CONFIG_ZONE_DMA) &amp;&amp; (type == KMALLOC_DMA)) &#123;</span><br><span class="line">		flags |= SLAB_CACHE_DMA;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_RANDOM_KMALLOC_CACHES</span></span><br><span class="line">	<span class="keyword">if</span> (type &gt;= KMALLOC_RANDOM_START &amp;&amp; type &lt;= KMALLOC_RANDOM_END)</span><br><span class="line">		flags |= SLAB_NO_MERGE;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If CONFIG_MEMCG is enabled, disable cache merging for</span></span><br><span class="line"><span class="comment">	 * KMALLOC_NORMAL caches.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_MEMCG) &amp;&amp; (type == KMALLOC_NORMAL))</span><br><span class="line">		flags |= SLAB_NO_MERGE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (minalign &gt; ARCH_KMALLOC_MINALIGN) &#123;</span><br><span class="line">		aligned_size = ALIGN(aligned_size, minalign);</span><br><span class="line">		aligned_idx = __kmalloc_index(aligned_size, <span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!kmalloc_caches[type][aligned_idx])</span><br><span class="line">		kmalloc_caches[type][aligned_idx] = create_kmalloc_cache(</span><br><span class="line">					kmalloc_info[aligned_idx].name[type],</span><br><span class="line">					aligned_size, flags);</span><br><span class="line">	<span class="keyword">if</span> (idx != aligned_idx)</span><br><span class="line">		kmalloc_caches[type][idx] = kmalloc_caches[type][aligned_idx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="create-kmalloc-caches-创建-kmalloc-缓存"><a href="#create-kmalloc-caches-创建-kmalloc-缓存" class="headerlink" title="create_kmalloc_caches 创建 kmalloc 缓存"></a>create_kmalloc_caches 创建 kmalloc 缓存</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 创建 kmalloc 数组。一些常规的 kmalloc 数组可能已经创建，</span></span><br><span class="line"><span class="comment">* 因为需要它们来启用用于创建 slab 的分配。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">create_kmalloc_caches</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">kmalloc_cache_type</span> <span class="title">type</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 包括 KMALLOC_CGROUP （如果已定义CONFIG_MEMCG</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (type = KMALLOC_NORMAL; type &lt; NR_KMALLOC_TYPES; type++) &#123;</span><br><span class="line">		<span class="comment">/* 大小不是 2 次方的缓存。 */</span></span><br><span class="line">		<span class="keyword">if</span> (KMALLOC_MIN_SIZE &lt;= <span class="number">32</span>)</span><br><span class="line">			new_kmalloc_cache(<span class="number">1</span>, type);</span><br><span class="line">		<span class="keyword">if</span> (KMALLOC_MIN_SIZE &lt;= <span class="number">64</span>)</span><br><span class="line">			new_kmalloc_cache(<span class="number">2</span>, type);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*大小为 2 次方的缓存。*/</span></span><br><span class="line">		<span class="keyword">for</span> (i = KMALLOC_SHIFT_LOW; i &lt;= KMALLOC_SHIFT_HIGH; i++)</span><br><span class="line">			new_kmalloc_cache(i, type);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_RANDOM_KMALLOC_CACHES</span></span><br><span class="line">	random_kmalloc_seed = get_random_u64();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*Kmalloc 数组现在可用 */</span></span><br><span class="line">	slab_state = UP;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_SLAB_BUCKETS))</span><br><span class="line">		kmem_buckets_cache = kmem_cache_create(<span class="string">&quot;kmalloc_buckets&quot;</span>,</span><br><span class="line">						       <span class="keyword">sizeof</span>(kmem_buckets),</span><br><span class="line">						       <span class="number">0</span>, SLAB_NO_MERGE, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="create-cache-创建-slab-缓存"><a href="#create-cache-创建-slab-缓存" class="headerlink" title="create_cache 创建 slab 缓存"></a>create_cache 创建 slab 缓存</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> kmem_cache *<span class="title function_">create_cache</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">				       <span class="type">unsigned</span> <span class="type">int</span> object_size,</span></span><br><span class="line"><span class="params">				       <span class="keyword">struct</span> kmem_cache_args *args,</span></span><br><span class="line"><span class="params">				       <span class="type">slab_flags_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">s</span>;</span></span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If a custom freelist pointer is requested make sure it&#x27;s sane. */</span></span><br><span class="line">	err = -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (args-&gt;use_freeptr_offset &amp;&amp;</span><br><span class="line">	    (args-&gt;freeptr_offset &gt;= object_size ||</span><br><span class="line">	     !(flags &amp; SLAB_TYPESAFE_BY_RCU) ||</span><br><span class="line">	     !IS_ALIGNED(args-&gt;freeptr_offset, __alignof__(<span class="type">freeptr_t</span>))))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	err = -ENOMEM;</span><br><span class="line">	s = kmem_cache_zalloc(kmem_cache, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!s)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	err = do_kmem_cache_create(s, name, object_size, args, flags);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> out_free_cache;</span><br><span class="line"></span><br><span class="line">	s-&gt;refcount = <span class="number">1</span>;</span><br><span class="line">	list_add(&amp;s-&gt;<span class="built_in">list</span>, &amp;slab_caches);</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">out_free_cache:</span><br><span class="line">	kmem_cache_free(kmem_cache, s);</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> ERR_PTR(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="kmem-cache-create-args-创建-kmem-cache"><a href="#kmem-cache-create-args-创建-kmem-cache" class="headerlink" title="__kmem_cache_create_args 创建 kmem_cache"></a>__kmem_cache_create_args 创建 kmem_cache</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * __kmem_cache_create_args - 创建 kmem 缓存。</span></span><br><span class="line"><span class="comment"> * @name：在 /proc/slabinfo 中用于标识此缓存的字符串。</span></span><br><span class="line"><span class="comment"> * @object_size：要在此缓存中创建的对象的大小。</span></span><br><span class="line"><span class="comment"> * @args：用于创建缓存的附加参数（参见 &amp;struct kmem_cache_args）。</span></span><br><span class="line"><span class="comment"> * @flags：请参阅单个标志的描述。常见的在下面的描述中列出。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 不要直接调用，请使用具有相同参数的 kmem_cache_create（） 包装器。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 常用@flags：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &amp;SLAB_ACCOUNT - memcg 的账户分配。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &amp;SLAB_HWCACHE_ALIGN - 在缓存行边界上对齐对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &amp;SLAB_RECLAIM_ACCOUNT - 对象是可回收的。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &amp;SLAB_TYPESAFE_BY_RCU - Slab 页面（不是单个对象）的释放因宽限期而延迟 - 使用前请参阅完整说明。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 上下文：不能在中断中调用，但可以中断。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回：成功时指向缓存的指针，失败时返回 NULL。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *__<span class="title">kmem_cache_create_args</span>(<span class="title">const</span> <span class="title">char</span> *<span class="title">name</span>,</span></span><br><span class="line"><span class="class">					    <span class="title">unsigned</span> <span class="title">int</span> <span class="title">object_size</span>,</span></span><br><span class="line"><span class="class">					    <span class="keyword">struct</span> <span class="title">kmem_cache_args</span> *<span class="title">args</span>,</span></span><br><span class="line"><span class="class">					    <span class="title">slab_flags_t</span> <span class="title">flags</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">s</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *cache_name;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_DEBUG</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If no slab_debug was enabled globally, the static key is not yet</span></span><br><span class="line"><span class="comment">	 * enabled by setup_slub_debug(). Enable it if the cache is being</span></span><br><span class="line"><span class="comment">	 * created with any of the debugging flags passed explicitly.</span></span><br><span class="line"><span class="comment">	 * It&#x27;s also possible that this is the first cache created with</span></span><br><span class="line"><span class="comment">	 * SLAB_STORE_USER and we should init stack_depot for it.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; SLAB_DEBUG_FLAGS)</span><br><span class="line">		static_branch_enable(&amp;slub_debug_enabled);</span><br><span class="line">	<span class="keyword">if</span> (flags &amp; SLAB_STORE_USER)</span><br><span class="line">		stack_depot_init();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	flags &amp;= ~SLAB_DEBUG_FLAGS;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;slab_mutex);</span><br><span class="line"></span><br><span class="line">	err = kmem_cache_sanity_check(name, object_size);</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; ~SLAB_FLAGS_PERMITTED) &#123;</span><br><span class="line">		err = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 在 useroffset 值的 usersize 错误时失败关闭。 */</span></span><br><span class="line">	<span class="keyword">if</span> (!IS_ENABLED(CONFIG_HARDENED_USERCOPY) ||</span><br><span class="line">	    WARN_ON(!args-&gt;usersize &amp;&amp; args-&gt;useroffset) ||</span><br><span class="line">	    WARN_ON(object_size &lt; args-&gt;usersize ||</span><br><span class="line">		    object_size - args-&gt;usersize &lt; args-&gt;useroffset))</span><br><span class="line">		args-&gt;usersize = args-&gt;useroffset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!args-&gt;usersize)</span><br><span class="line">		s = __kmem_cache_alias(name, object_size, args-&gt;align, flags,</span><br><span class="line">				       args-&gt;ctor);</span><br><span class="line">	<span class="keyword">if</span> (s)</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">	cache_name = kstrdup_const(name, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!cache_name) &#123;</span><br><span class="line">		err = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	args-&gt;align = calculate_alignment(flags, args-&gt;align, object_size);</span><br><span class="line">	s = create_cache(cache_name, object_size, args, flags);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(s)) &#123;</span><br><span class="line">		err = PTR_ERR(s);</span><br><span class="line">		kfree_const(cache_name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">	mutex_unlock(&amp;slab_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		<span class="keyword">if</span> (flags &amp; SLAB_PANIC)</span><br><span class="line">			panic(<span class="string">&quot;%s: Failed to create slab &#x27;%s&#x27;. Error %d\n&quot;</span>,</span><br><span class="line">				__func__, name, err);</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			pr_warn(<span class="string">&quot;%s(%s) failed with error %d\n&quot;</span>,</span><br><span class="line">				__func__, name, err);</span><br><span class="line">			dump_stack();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="mm-slub-c"><a href="#mm-slub-c" class="headerlink" title="mm&#x2F;slub.c"></a>mm&#x2F;slub.c</h1><h2 id="order-objects-计算在给定阶数（order）下，一个-slab-中可以容纳的对象数量"><a href="#order-objects-计算在给定阶数（order）下，一个-slab-中可以容纳的对象数量" class="headerlink" title="order_objects 计算在给定阶数（order）下，一个 slab 中可以容纳的对象数量"></a>order_objects 计算在给定阶数（order）下，一个 slab 中可以容纳的对象数量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">order_objects</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> order, <span class="type">unsigned</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> ((<span class="type">unsigned</span> <span class="type">int</span>)PAGE_SIZE &lt;&lt; order) / size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="calc-slab-order-根据-slab-对象的大小（size）计算分配的阶数（order）"><a href="#calc-slab-order-根据-slab-对象的大小（size）计算分配的阶数（order）" class="headerlink" title="calc_slab_order 根据 slab 对象的大小（size）计算分配的阶数（order）"></a>calc_slab_order 根据 slab 对象的大小（size）计算分配的阶数（order）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">calc_slab_order：根据对象大小、最小阶数、最大阶数和允许的浪费比例，计算 slab 的分配阶数。</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">	size：slab 中单个对象的大小。</span></span><br><span class="line"><span class="comment">	min_order：分配的最小阶数。</span></span><br><span class="line"><span class="comment">	max_order：分配的最大阶数。</span></span><br><span class="line"><span class="comment">	fract_leftover：允许的浪费比例（分数形式，如 16 表示 1/16）。</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">	返回计算出的 slab 分配阶数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">阶数的影响：</span></span><br><span class="line"><span class="comment">	阶数为 order 时，slab 的大小为 PAGE_SIZE * 2^order。</span></span><br><span class="line"><span class="comment">	较低的阶数（如 order = 0）优先被使用，因为它不会导致页面分配器的碎片化。</span></span><br><span class="line"><span class="comment">	较高的阶数虽然可以容纳更多对象，但可能会浪费更多内存。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">浪费控制：</span></span><br><span class="line"><span class="comment">	如果 slab 的浪费空间超过总大小的 1/16（或其他指定比例），则尝试更高的阶数。</span></span><br><span class="line"><span class="comment">	通过这种方式，函数在内存利用率和性能之间取得平衡。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">最小对象数：</span></span><br><span class="line"><span class="comment">	为了提高性能，slab 中必须包含足够数量的对象。如果对象数量过少，会导致频繁操作部分 slab 列表（partial list），增加锁争用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">最大阶数限制：</span></span><br><span class="line"><span class="comment">	当达到 max_order 时，函数优先选择较低的阶数，即使这会导致更多的内存浪费。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">calc_slab_order</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> size,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">int</span> min_order, <span class="type">unsigned</span> <span class="type">int</span> max_order,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">int</span> fract_leftover)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> order;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从 min_order 开始，逐步尝试更高的阶数，直到 max_order</span></span><br><span class="line">	<span class="keyword">for</span> (order = min_order; order &lt;= max_order; order++) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> slab_size = (<span class="type">unsigned</span> <span class="type">int</span>)PAGE_SIZE &lt;&lt; order;	<span class="comment">//计算 slab 大小</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> rem;</span><br><span class="line"></span><br><span class="line">		rem = slab_size % size;	<span class="comment">//算 slab 大小与对象大小的余数，表示浪费的空间</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (rem &lt;= slab_size / fract_leftover)	<span class="comment">//检查浪费比例</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="calculate-order-计算-slab-的阶数（order）"><a href="#calculate-order-计算-slab-的阶数（order）" class="headerlink" title="calculate_order 计算 slab 的阶数（order）"></a>calculate_order 计算 slab 的阶数（order）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> slub_min_order;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> slub_max_order =</span><br><span class="line">	IS_ENABLED(CONFIG_SLUB_TINY) ? <span class="number">1</span> : PAGE_ALLOC_COSTLY_ORDER;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> slub_min_objects;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">calculate_order</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> order;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> min_objects;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> max_objects;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> min_order;</span><br><span class="line"></span><br><span class="line">	min_objects = slub_min_objects;</span><br><span class="line">	<span class="keyword">if</span> (!min_objects) &#123;	<span class="comment">//如果 slub_min_objects 未设置（为 0），则根据系统的 CPU 数量计算最小对象数</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 一些架构只会在内联 cpu 时更新它们，所以如果它只是 1，请不要相信这个数字。</span></span><br><span class="line"><span class="comment">		 * 但是我们也不想总是使用 nr_cpu_ids，就像在其他一些架构上一样，可能有很多可能的 cpu，但永远不会在线。</span></span><br><span class="line"><span class="comment">		 * 在这里，我们权衡了尝试避免在看起来比实际大的系统上出现过高的 order 和在看起来比它们实际小的系统上出现过低的 order 过低。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> nr_cpus = num_present_cpus();</span><br><span class="line">		<span class="keyword">if</span> (nr_cpus &lt;= <span class="number">1</span>)</span><br><span class="line">			nr_cpus = nr_cpu_ids;</span><br><span class="line">		<span class="comment">//	fls返回nr_cpus最高有效位的位置</span></span><br><span class="line">		min_objects = <span class="number">4</span> * (fls(nr_cpus) + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* min_objects 不能为 0，因为 get_order （0） 未定义 */</span></span><br><span class="line">	max_objects = max(order_objects(slub_max_order, size), <span class="number">1U</span>);</span><br><span class="line">	min_objects = min(min_objects, max_objects);</span><br><span class="line"></span><br><span class="line">	min_order = <span class="type">max_t</span>(<span class="type">unsigned</span> <span class="type">int</span>, slub_min_order,</span><br><span class="line">			  get_order(min_objects * size));</span><br><span class="line">	<span class="keyword">if</span> (order_objects(min_order, size) &gt; MAX_OBJS_PER_PAGE)</span><br><span class="line">		<span class="keyword">return</span> get_order(size * MAX_OBJS_PER_PAGE) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 尝试查找 slab 的最佳配置。其工作原理是首先尝试生成具有最佳配置的布局，然后逐渐退出。</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 我们从最多接受 1/16 的浪费开始，并尝试从 min_objects 派生/slab_min_order 到 slab_max_order 中找到满足约束的最小顺序。请注意，增加 Order 只会导致相同或更少的小数浪费，而不会更多。</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 如果失败，我们将提高可接受的废弃物比例，然后重试。最后一次迭代的分数为 1/2 将有效地接受任何浪费，并给我们由 min_objects 确定的顺序，只要至少单个对象适合slab_max_order。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> fraction = <span class="number">16</span>; fraction &gt; <span class="number">1</span>; fraction /= <span class="number">2</span>) &#123;</span><br><span class="line">		order = calc_slab_order(size, min_order, slub_max_order,</span><br><span class="line">					fraction);</span><br><span class="line">		<span class="keyword">if</span> (order &lt;= slub_max_order)</span><br><span class="line">			<span class="keyword">return</span> order;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 回退到默认阶数</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	order = get_order(size);</span><br><span class="line">	<span class="keyword">if</span> (order &lt;= MAX_PAGE_ORDER)</span><br><span class="line">		<span class="keyword">return</span> order;</span><br><span class="line">	<span class="keyword">return</span> -ENOSYS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="oo-make-描述-slab-的分配配置"><a href="#oo-make-描述-slab-的分配配置" class="headerlink" title="oo_make 描述 slab 的分配配置"></a>oo_make 描述 slab 的分配配置</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 字长结构，可以原子更新或读取，并且包含给定顺序的 slab 将包含的对象的顺序和数量。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> kmem_cache_order_objects <span class="title function_">oo_make</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> order,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// #define OO_SHIFT	16</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">x</span> =</span> &#123;</span><br><span class="line">		(order &lt;&lt; OO_SHIFT) + order_objects(order, size)</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="oo-objects-获取对象数量"><a href="#oo-objects-获取对象数量" class="headerlink" title="oo_objects 获取对象数量"></a>oo_objects 获取对象数量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> OO_SHIFT	16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OO_MASK		((1 &lt;&lt; OO_SHIFT) - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">oo_objects</span><span class="params">(<span class="keyword">struct</span> kmem_cache_order_objects x)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> x.x &amp; OO_MASK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="calculate-sizes-计算-slab-缓存中对象的布局"><a href="#calculate-sizes-计算-slab-缓存中对象的布局" class="headerlink" title="calculate_sizes 计算 slab 缓存中对象的布局"></a>calculate_sizes 计算 slab 缓存中对象的布局</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * calculate_sizes() determines the order and the distribution of data within</span></span><br><span class="line"><span class="comment"> * a slab object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">calculate_sizes</span><span class="params">(<span class="keyword">struct</span> kmem_cache_args *args, <span class="keyword">struct</span> kmem_cache *s)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">slab_flags_t</span> flags = s-&gt;flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> size = s-&gt;object_size;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> order;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 将对象大小向上舍入到下一个单词边界。我们只能将自由指针放在字边界处，这决定了自由指针的可能位置。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	size = ALIGN(size, <span class="keyword">sizeof</span>(<span class="type">void</span> *));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 对象的实际使用大小，包括对象本身和调试相关的元数据（如红区）</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	s-&gt;inuse = size;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (((flags &amp; SLAB_TYPESAFE_BY_RCU) &amp;&amp; !args-&gt;use_freeptr_offset) ||	<span class="comment">//RCU 安全</span></span><br><span class="line">	    (flags &amp; SLAB_POISON) || s-&gt;ctor ||									<span class="comment">//对象填充 构造函数</span></span><br><span class="line">	    ((flags &amp; SLAB_RED_ZONE) &amp;&amp;											<span class="comment">//红区</span></span><br><span class="line">	     (s-&gt;object_size &lt; <span class="keyword">sizeof</span>(<span class="type">void</span> *) || slub_debug_orig_size(s)))) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 将空闲指针放置在对象末尾 */</span></span><br><span class="line">		s-&gt;offset = size;	<span class="comment">//自由指针偏移量</span></span><br><span class="line">		size += <span class="keyword">sizeof</span>(<span class="type">void</span> *);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((flags &amp; SLAB_TYPESAFE_BY_RCU) &amp;&amp; args-&gt;use_freeptr_offset) &#123;</span><br><span class="line">		s-&gt;offset = args-&gt;freeptr_offset;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 如果没有特殊要求，则将空闲指针放置在对象的中间位置，以减少越界访问的风险。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//自由指针偏移量</span></span><br><span class="line">		s-&gt;offset = ALIGN_DOWN(s-&gt;object_size / <span class="number">2</span>, <span class="keyword">sizeof</span>(<span class="type">void</span> *));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	kasan_cache_create(s, &amp;size, &amp;s-&gt;flags);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *SLUB 从偏移量 0 开始，紧接着存储一个对象。为了对齐对象，我们只需调整每个对象的大小以符合对齐方式即可。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	size = ALIGN(size, s-&gt;align);</span><br><span class="line">	s-&gt;size = size;</span><br><span class="line">	s-&gt;reciprocal_size = reciprocal_value(size);	<span class="comment">//每个对象的大小的倒数，用于快速计算对象数量</span></span><br><span class="line">	order = calculate_order(size);	<span class="comment">// 计算 slab 的阶数（order），即每个 slab 占用的页面数</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((<span class="type">int</span>)order &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	s-&gt;allocflags = __GFP_COMP;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (s-&gt;flags &amp; SLAB_CACHE_DMA)</span><br><span class="line">		s-&gt;allocflags |= GFP_DMA;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (s-&gt;flags &amp; SLAB_CACHE_DMA32)</span><br><span class="line">		s-&gt;allocflags |= GFP_DMA32;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (s-&gt;flags &amp; SLAB_RECLAIM_ACCOUNT)</span><br><span class="line">		s-&gt;allocflags |= __GFP_RECLAIMABLE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Determine the number of objects per slab</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	s-&gt;oo = oo_make(order, size);	<span class="comment">//每个 slab 中的对象数量</span></span><br><span class="line">	s-&gt;min = oo_make(get_order(size), size);	<span class="comment">//每个 slab 的最小对象数量</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> !!oo_objects(s-&gt;oo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="alloc-slab-page-分配一个新的-slab-页面"><a href="#alloc-slab-page-分配一个新的-slab-页面" class="headerlink" title="alloc_slab_page 分配一个新的 slab 页面"></a>alloc_slab_page 分配一个新的 slab 页面</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Slab allocation and freeing</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> slab *<span class="title function_">alloc_slab_page</span><span class="params">(<span class="type">gfp_t</span> flags, <span class="type">int</span> node,</span></span><br><span class="line"><span class="params">		<span class="keyword">struct</span> kmem_cache_order_objects oo)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">folio</span> *<span class="title">folio</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>;</span></span><br><span class="line">	<span class="comment">//从 oo 中提取分配的阶数（order）。阶数决定了分配的页数，2^order 表示分配的页数</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> order = oo_order(oo);</span><br><span class="line">	<span class="comment">//#define	NUMA_NO_NODE	(-1)</span></span><br><span class="line">	<span class="keyword">if</span> (node == NUMA_NO_NODE)	<span class="comment">// node 为 NUMA_NO_NODE，表示不指定 NUMA 节点，调用 alloc_frozen_pages 分配页</span></span><br><span class="line">		folio = (<span class="keyword">struct</span> folio *)alloc_frozen_pages(flags, order);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="comment">//指定了 NUMA 节点，调用 __alloc_frozen_pages 在指定节点上分配页</span></span><br><span class="line">		folio = (<span class="keyword">struct</span> folio *)__alloc_frozen_pages(flags, order, node, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!folio)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	slab = folio_slab(folio);	<span class="comment">//将 folio 转换为 slab 结构体</span></span><br><span class="line">	__folio_set_slab(folio);	<span class="comment">//设置 folio 的 slab 标志，表明该 folio 已被用作 slab</span></span><br><span class="line">	<span class="comment">//检查内存回收标志</span></span><br><span class="line">	<span class="keyword">if</span> (folio_is_pfmemalloc(folio))	<span class="comment">//检查 folio 是否是由内存回收路径分配的（pfmemalloc 标志）</span></span><br><span class="line">		slab_set_pfmemalloc(slab);	<span class="comment">//slab_set_pfmemalloc 设置 slab 的 pfmemalloc 标志，表明该 slab 是为内存回收保留的</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> slab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="set-freepointer-设置空闲指针"><a href="#set-freepointer-设置空闲指针" class="headerlink" title="set_freepointer 设置空闲指针"></a>set_freepointer 设置空闲指针</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 返回自由列表指针 （ptr）。通过强化，这将使用保存指针的地址的 XOR 和每个缓存的随机数进行混淆。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">freeptr_t</span> <span class="title function_">freelist_ptr_encode</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> kmem_cache *s,</span></span><br><span class="line"><span class="params">					    <span class="type">void</span> *ptr, <span class="type">unsigned</span> <span class="type">long</span> ptr_addr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> encoded;</span><br><span class="line">	encoded = (<span class="type">unsigned</span> <span class="type">long</span>)ptr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (<span class="type">freeptr_t</span>)&#123;.v = encoded&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">set_freepointer</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">void</span> *object, <span class="type">void</span> *fp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> freeptr_addr = (<span class="type">unsigned</span> <span class="type">long</span>)object + s-&gt;offset;</span><br><span class="line"></span><br><span class="line">	*(<span class="type">freeptr_t</span> *)freeptr_addr = freelist_ptr_encode(s, fp, freeptr_addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="setup-object-初始化对象"><a href="#setup-object-初始化对象" class="headerlink" title="setup_object 初始化对象"></a>setup_object 初始化对象</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">setup_object</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">void</span> *object)</span></span><br><span class="line">&#123;</span><br><span class="line">	setup_object_debug(s, object);</span><br><span class="line">	object = kasan_init_slab_obj(s, object);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(s-&gt;ctor)) &#123;</span><br><span class="line">		kasan_unpoison_new_object(s, object);</span><br><span class="line">		s-&gt;ctor(object);</span><br><span class="line">		kasan_poison_new_object(s, object);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="allocate-slab-分配一个新的-slab"><a href="#allocate-slab-分配一个新的-slab" class="headerlink" title="allocate_slab 分配一个新的 slab"></a>allocate_slab 分配一个新的 slab</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> slab *<span class="title function_">allocate_slab</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">gfp_t</span> flags, <span class="type">int</span> node)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">oo</span> =</span> s-&gt;oo;</span><br><span class="line">	<span class="type">gfp_t</span> alloc_gfp;</span><br><span class="line">	<span class="type">void</span> *start, *p, *next;</span><br><span class="line">	<span class="type">int</span> idx;</span><br><span class="line">	<span class="type">bool</span> shuffle;</span><br><span class="line"></span><br><span class="line">	flags &amp;= gfp_allowed_mask;</span><br><span class="line"></span><br><span class="line">	flags |= s-&gt;allocflags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 让初始高阶分配在内存压力下失败，因此我们回退到最小订单分配。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	alloc_gfp = (flags | __GFP_NOWARN | __GFP_NORETRY) &amp; ~__GFP_NOFAIL;	<span class="comment">//避免警告和重试，同时移除 __GFP_NOFAIL</span></span><br><span class="line">	<span class="comment">//允许直接回收（__GFP_DIRECT_RECLAIM），且当前分配的阶数（oo_order(oo)）大于最小阶数（oo_order(s-&gt;min)），则调整标志以限制内存分配的行为</span></span><br><span class="line">	<span class="keyword">if</span> ((alloc_gfp &amp; __GFP_DIRECT_RECLAIM) &amp;&amp; oo_order(oo) &gt; oo_order(s-&gt;min))</span><br><span class="line">		alloc_gfp = (alloc_gfp | __GFP_NOMEMALLOC) &amp; ~__GFP_RECLAIM;</span><br><span class="line"></span><br><span class="line">	slab = alloc_slab_page(alloc_gfp, node, oo);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!slab)) &#123;</span><br><span class="line">		<span class="comment">//如果失败（slab 为 NULL），则降级到最小阶数（s-&gt;min）并重试</span></span><br><span class="line">		oo = s-&gt;min;</span><br><span class="line">		alloc_gfp = flags;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 分配可能由于碎片而失败。</span></span><br><span class="line"><span class="comment">		 * 如果可能，请尝试较低顺序的分配</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		slab = alloc_slab_page(alloc_gfp, node, oo);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(!slab))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		stat(s, ORDER_FALLBACK);	<span class="comment">//如果降级成功，调用 stat 更新统计信息，记录降级事件</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	slab-&gt;objects = oo_objects(oo);	<span class="comment">//每个 slab 中的对象数量</span></span><br><span class="line">	slab-&gt;inuse = <span class="number">0</span>;				<span class="comment">//已使用对象数</span></span><br><span class="line">	slab-&gt;frozen = <span class="number">0</span>;				<span class="comment">//冻结对象数</span></span><br><span class="line"></span><br><span class="line">	account_slab(slab, oo_order(oo), s, flags);	<span class="comment">//更新 slab 的内存使用统计</span></span><br><span class="line"></span><br><span class="line">	slab-&gt;slab_cache = s;			<span class="comment">//设置 slab 的缓存指针（slab_cache）为当前 kmem_cache</span></span><br><span class="line">	<span class="comment">//设置对象链表</span></span><br><span class="line">	start = slab_address(slab);		<span class="comment">//获取 slab 的起始地址</span></span><br><span class="line"></span><br><span class="line">	shuffle = shuffle_freelist(s, slab);	<span class="comment">//调用 shuffle_freelist 决定是否需要随机化对象链表</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!shuffle) &#123;</span><br><span class="line">		slab-&gt;freelist = start;</span><br><span class="line">		start = setup_object(s, start);</span><br><span class="line">		<span class="comment">//设置 slab 的空闲链表（freelist），并通过循环将所有对象链接起来</span></span><br><span class="line">		<span class="comment">//从第一个对象开始，遍历 slab 中的所有对象，直到倒数第二个对象（slab-&gt;objects - 1）</span></span><br><span class="line">		<span class="keyword">for</span> (idx = <span class="number">0</span>, p = start; idx &lt; slab-&gt;objects - <span class="number">1</span>; idx++) &#123;</span><br><span class="line">			next = p + s-&gt;size;	<span class="comment">//对象大小（s-&gt;size），计算下一个对象的地址</span></span><br><span class="line">			next = setup_object(s, next);</span><br><span class="line">			set_freepointer(s, p, next);	<span class="comment">//将它们链接到空闲链表中</span></span><br><span class="line">			p = next;			<span class="comment">//将当前指针移动到下一个对象</span></span><br><span class="line">		&#125;</span><br><span class="line">		set_freepointer(s, p, <span class="literal">NULL</span>);	<span class="comment">//最后一个对象的空闲指针设置为 NULL</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> slab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="new-slab-为指定的-kmem-cache-分配一个新的-slab"><a href="#new-slab-为指定的-kmem-cache-分配一个新的-slab" class="headerlink" title="new_slab 为指定的 kmem_cache 分配一个新的 slab"></a>new_slab 为指定的 kmem_cache 分配一个新的 slab</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> slab *<span class="title function_">new_slab</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">gfp_t</span> flags, <span class="type">int</span> node)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(flags &amp; GFP_SLAB_BUG_MASK))</span><br><span class="line">		flags = kmalloc_fix_flags(flags);</span><br><span class="line">	<span class="comment">//构造函数和 __GFP_ZERO 标志可能会冲突：__GFP_ZERO 会将分配的内存清零，而构造函数可能依赖未清零的内存</span></span><br><span class="line">	WARN_ON_ONCE(s-&gt;ctor &amp;&amp; (flags &amp; __GFP_ZERO));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> allocate_slab(s,</span><br><span class="line">		flags &amp; (GFP_RECLAIM_MASK | GFP_CONSTRAINT_MASK), node);	<span class="comment">//保留与内存回收和约束相关的标志</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="—————-内存初始化相关函数——————"><a href="#—————-内存初始化相关函数——————" class="headerlink" title="—————-内存初始化相关函数——————"></a>—————-内存初始化相关函数——————</h2><h2 id="init-kmem-cache-node-初始化-kmem-cache-node-结构体"><a href="#init-kmem-cache-node-初始化-kmem-cache-node-结构体" class="headerlink" title="init_kmem_cache_node 初始化 kmem_cache_node 结构体"></a>init_kmem_cache_node 初始化 kmem_cache_node 结构体</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">init_kmem_cache_node</span><span class="params">(<span class="keyword">struct</span> kmem_cache_node *n)</span></span><br><span class="line">&#123;</span><br><span class="line">	n-&gt;nr_partial = <span class="number">0</span>;</span><br><span class="line">	spin_lock_init(&amp;n-&gt;list_lock);</span><br><span class="line">	INIT_LIST_HEAD(&amp;n-&gt;partial);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_DEBUG</span></span><br><span class="line">	atomic_long_set(&amp;n-&gt;nr_slabs, <span class="number">0</span>);</span><br><span class="line">	atomic_long_set(&amp;n-&gt;total_objects, <span class="number">0</span>);</span><br><span class="line">	INIT_LIST_HEAD(&amp;n-&gt;full);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="add-partial-添加-slab-到部分空闲链表"><a href="#add-partial-添加-slab-到部分空闲链表" class="headerlink" title="__add_partial 添加 slab 到部分空闲链表"></a>__add_partial 添加 slab 到部分空闲链表</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 管理部分分配的板。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">__add_partial(<span class="keyword">struct</span> kmem_cache_node *n, <span class="keyword">struct</span> slab *slab, <span class="type">int</span> tail)</span><br><span class="line">&#123;</span><br><span class="line">	n-&gt;nr_partial++;	<span class="comment">//表示当前节点中部分分配的 slab 数量增加了一个</span></span><br><span class="line">	<span class="keyword">if</span> (tail == DEACTIVATE_TO_TAIL)</span><br><span class="line">		list_add_tail(&amp;slab-&gt;slab_list, &amp;n-&gt;partial);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		list_add(&amp;slab-&gt;slab_list, &amp;n-&gt;partial);</span><br><span class="line">	slab_set_node_partial(slab);	<span class="comment">//标记该 slab 属于部分分配状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="early-kmem-cache-node-alloc-早期分配-kmem-cache-node"><a href="#early-kmem-cache-node-alloc-早期分配-kmem-cache-node" class="headerlink" title="early_kmem_cache_node_alloc 早期分配 kmem_cache_node"></a>early_kmem_cache_node_alloc 早期分配 kmem_cache_node</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">kmem_cache_node</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 当前没有 kmalloc_node 的支持，因此需要手动分配。</span></span><br><span class="line"><span class="comment"> * 这是为 slab 缓存的第一个 slab 分配内存，因此不存在并发访问问题。</span></span><br><span class="line"><span class="comment"> * 该函数仅用于为 kmem_cache_node 分配内存，主要用于引导尚未初始化的节点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">early_kmem_cache_node_alloc</span><span class="params">(<span class="type">int</span> node)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">n</span>;</span></span><br><span class="line"></span><br><span class="line">	BUG_ON(kmem_cache_node-&gt;size &lt; <span class="keyword">sizeof</span>(<span class="keyword">struct</span> kmem_cache_node));</span><br><span class="line"></span><br><span class="line">	slab = new_slab(kmem_cache_node, GFP_NOWAIT, node);</span><br><span class="line"></span><br><span class="line">	BUG_ON(!slab);</span><br><span class="line">	<span class="keyword">if</span> (slab_nid(slab) != node) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;SLUB: Unable to allocate memory from node %d\n&quot;</span>, node);</span><br><span class="line">		pr_err(<span class="string">&quot;SLUB: Allocating a useless per node structure in order to be able to continue\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	n = slab-&gt;freelist;</span><br><span class="line">	BUG_ON(!n);</span><br><span class="line"></span><br><span class="line">	slab-&gt;freelist = get_freepointer(kmem_cache_node, n);</span><br><span class="line">	slab-&gt;inuse = <span class="number">1</span>;	<span class="comment">//表示已使用一个对象</span></span><br><span class="line">	kmem_cache_node-&gt;node[node] = n;	<span class="comment">//将分配的 kmem_cache_node 对象存储到对应的 NUMA 节点中</span></span><br><span class="line">	init_kmem_cache_node(n);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 这里不需要锁，因为它刚刚初始化，没有并发访问。</span></span><br><span class="line"><span class="comment">	 * 将 slab 添加到部分空闲链表（partial list）中，便于后续分配和管理</span></span><br><span class="line"><span class="comment">	 * 使用 DEACTIVATE_TO_HEAD 标志表示将 slab 添加到链表头部</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	__add_partial(n, slab, DEACTIVATE_TO_HEAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="init-kmem-cache-nodes-初始化-NUMA-节点相关数据"><a href="#init-kmem-cache-nodes-初始化-NUMA-节点相关数据" class="headerlink" title="init_kmem_cache_nodes 初始化 NUMA 节点相关数据"></a>init_kmem_cache_nodes 初始化 NUMA 节点相关数据</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> for_each_node_mask(node, mask)                                  \</span></span><br><span class="line"><span class="meta">	for ((node) = 0; (node) &lt; 1 &amp;&amp; !nodes_empty(mask); (node)++)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">init_kmem_cache_nodes</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> node;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历 slab_nodes 中的所有节点</span></span><br><span class="line">	<span class="comment">//slab_nodes 是一个位掩码，表示系统中启用的节点</span></span><br><span class="line">	for_each_node_mask(node, slab_nodes) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">n</span>;</span></span><br><span class="line">		<span class="comment">//表示系统还处于早期初始化阶段</span></span><br><span class="line">		<span class="keyword">if</span> (slab_state == DOWN) &#123;</span><br><span class="line">			early_kmem_cache_node_alloc(node);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		n = kmem_cache_alloc_node(kmem_cache_node,</span><br><span class="line">						GFP_KERNEL, node);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!n) &#123;</span><br><span class="line">			free_kmem_cache_nodes(s);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		init_kmem_cache_node(n);</span><br><span class="line">		s-&gt;node[node] = n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="alloc-kmem-cache-cpus-分配-CPU-相关的-slab-缓存数据"><a href="#alloc-kmem-cache-cpus-分配-CPU-相关的-slab-缓存数据" class="headerlink" title="alloc_kmem_cache_cpus 分配 CPU 相关的 slab 缓存数据"></a>alloc_kmem_cache_cpus 分配 CPU 相关的 slab 缓存数据</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">init_kmem_cache_cpus</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> cpu;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> *<span class="title">c</span>;</span></span><br><span class="line"></span><br><span class="line">	for_each_possible_cpu(cpu) &#123;	<span class="comment">//遍历所有可能的 CPU</span></span><br><span class="line">		c = per_cpu_ptr(s-&gt;cpu_slab, cpu);	<span class="comment">//获取每个 CPU 的缓存指针</span></span><br><span class="line">		<span class="comment">/* 初始化每个 CPU 缓存的本地锁（lock）。</span></span><br><span class="line"><span class="comment">		该锁用于保护 CPU 缓存的并发访问，确保分配和释放操作的线程安全 */</span></span><br><span class="line">		local_lock_init(&amp;c-&gt;lock);</span><br><span class="line">		<span class="comment">/*为当前 CPU 缓存生成一个初始事务 ID（tid）。</span></span><br><span class="line"><span class="comment">		tid 用于跟踪内存分配和释放的事务，帮助检测并发冲突或其他异常情况。 */</span></span><br><span class="line">		c-&gt;tid = init_tid(cpu);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">alloc_kmem_cache_cpus</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s)</span></span><br><span class="line">&#123;</span><br><span class="line">	BUILD_BUG_ON(PERCPU_DYNAMIC_EARLY_SIZE &lt;</span><br><span class="line">			NR_KMALLOC_TYPES * KMALLOC_SHIFT_HIGH *</span><br><span class="line">			<span class="keyword">sizeof</span>(<span class="keyword">struct</span> kmem_cache_cpu));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *必须对齐到双字边界，双 cmpxchg 指令才能工作;请参见 __pcpu_double_call_return_bool（）。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	s-&gt;cpu_slab = __alloc_percpu(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> kmem_cache_cpu),</span><br><span class="line">				     <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="type">void</span> *));	<span class="comment">// 为每个 CPU 分配一个 kmem_cache_cpu 结构。</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!s-&gt;cpu_slab)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	init_kmem_cache_cpus(s);	<span class="comment">//对分配的 cpu_slab 结构进行初始化</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="sysfs-slab-add-将-slab-缓存添加到-sysfs-文件系统中"><a href="#sysfs-slab-add-将-slab-缓存添加到-sysfs-文件系统中" class="headerlink" title="sysfs_slab_add 将 slab 缓存添加到 sysfs 文件系统中"></a>sysfs_slab_add 将 slab 缓存添加到 sysfs 文件系统中</h2><ul>
<li>slab 缓存对象暴露到 sysfs 文件系统中，以便用户或开发者可以通过文件系统查看和调试 slab 缓存的状态</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create a unique string id for a slab cache:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Format	:[flags-]size</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *<span class="title function_">create_unique_id</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *name = kmalloc(ID_STR_LENGTH, GFP_KERNEL);</span><br><span class="line">	<span class="type">char</span> *p = name;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!name)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">	*p++ = <span class="string">&#x27;:&#x27;</span>;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * First flags affecting slabcache operations. We will only</span></span><br><span class="line"><span class="comment">	 * get here for aliasable slabs so we do not need to support</span></span><br><span class="line"><span class="comment">	 * too many flags. The flags here must cover all flags that</span></span><br><span class="line"><span class="comment">	 * are matched during merging to guarantee that the id is</span></span><br><span class="line"><span class="comment">	 * unique.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (s-&gt;flags &amp; SLAB_CACHE_DMA)</span><br><span class="line">		*p++ = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">	<span class="keyword">if</span> (s-&gt;flags &amp; SLAB_CACHE_DMA32)</span><br><span class="line">		*p++ = <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line">	<span class="keyword">if</span> (s-&gt;flags &amp; SLAB_RECLAIM_ACCOUNT)</span><br><span class="line">		*p++ = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">	<span class="keyword">if</span> (s-&gt;flags &amp; SLAB_CONSISTENCY_CHECKS)</span><br><span class="line">		*p++ = <span class="string">&#x27;F&#x27;</span>;</span><br><span class="line">	<span class="keyword">if</span> (s-&gt;flags &amp; SLAB_ACCOUNT)</span><br><span class="line">		*p++ = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">	<span class="keyword">if</span> (p != name + <span class="number">1</span>)</span><br><span class="line">		*p++ = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">	p += <span class="built_in">snprintf</span>(p, ID_STR_LENGTH - (p - name), <span class="string">&quot;%07u&quot;</span>, s-&gt;size);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON(p &gt; name + ID_STR_LENGTH - <span class="number">1</span>)) &#123;</span><br><span class="line">		kfree(name);</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line">	&#125;</span><br><span class="line">	kmsan_unpoison_memory(name, p - name);</span><br><span class="line">	<span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> <span class="title">slab_ktype</span> =</span> &#123;</span><br><span class="line">	.sysfs_ops = &amp;slab_sysfs_ops,</span><br><span class="line">	.release = kmem_cache_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> <span class="title">slab_attr_group</span> =</span> &#123;</span><br><span class="line">	.attrs = slab_attrs,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">sysfs_slab_add</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kset</span> *<span class="title">kset</span> =</span> cache_kset(s);</span><br><span class="line">	<span class="type">int</span> unmergeable = slab_unmergeable(s);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!unmergeable &amp;&amp; disable_higher_order_debug &amp;&amp;</span><br><span class="line">			(slub_debug &amp; DEBUG_METADATA_FLAGS))</span><br><span class="line">		unmergeable = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unmergeable) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Slabcache can never be merged so we can use the name proper.</span></span><br><span class="line"><span class="comment">		 * This is typically the case for debug situations. In that</span></span><br><span class="line"><span class="comment">		 * case we can catch duplicate names easily.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		sysfs_remove_link(&amp;slab_kset-&gt;kobj, s-&gt;name);</span><br><span class="line">		name = s-&gt;name;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 为板创建一个唯一的名称作为符号链接的目标。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		name = create_unique_id(s);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(name))</span><br><span class="line">			<span class="keyword">return</span> PTR_ERR(name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	s-&gt;kobj.kset = kset;	<span class="comment">//初始化并添加内核对象</span></span><br><span class="line">	<span class="comment">//将 kobject 添加到 sysfs</span></span><br><span class="line">	err = kobject_init_and_add(&amp;s-&gt;kobj, &amp;slab_ktype, <span class="literal">NULL</span>, <span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	<span class="comment">//创建属性组</span></span><br><span class="line">	err = sysfs_create_group(&amp;s-&gt;kobj, &amp;slab_attr_group);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> out_del_kobj;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!unmergeable) &#123;</span><br><span class="line">		<span class="comment">/* Setup first alias */</span></span><br><span class="line">		sysfs_slab_alias(s, s-&gt;name);</span><br><span class="line">	&#125;</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> (!unmergeable)</span><br><span class="line">		kfree(name);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">out_del_kobj:</span><br><span class="line">	kobject_del(&amp;s-&gt;kobj);</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="kmem-cache-release-释放-slab-缓存"><a href="#kmem-cache-release-释放-slab-缓存" class="headerlink" title="__kmem_cache_release 释放 slab 缓存"></a>__kmem_cache_release 释放 slab 缓存</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kmem_cache_free - 解除分配对象</span></span><br><span class="line"><span class="comment"> * @s：分配来自的缓存。</span></span><br><span class="line"><span class="comment"> * @x：之前分配的对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 释放以前从此缓存中分配的对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kmem_cache_free</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">void</span> *x)</span></span><br><span class="line">&#123;</span><br><span class="line">	s = cache_from_obj(s, x);</span><br><span class="line">	<span class="keyword">if</span> (!s)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	trace_kmem_cache_free(_RET_IP_, x, s);</span><br><span class="line">	slab_free(s, virt_to_slab(x), x, _RET_IP_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">free_kmem_cache_nodes</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> node;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">n</span>;</span></span><br><span class="line"></span><br><span class="line">	for_each_kmem_cache_node(s, node, n) &#123;</span><br><span class="line">		s-&gt;node[node] = <span class="literal">NULL</span>;</span><br><span class="line">		kmem_cache_free(kmem_cache_node, n);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __kmem_cache_release(<span class="keyword">struct</span> kmem_cache *s)</span><br><span class="line">&#123;</span><br><span class="line">	cache_random_seq_destroy(s);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_SLUB_TINY</span></span><br><span class="line">	free_percpu(s-&gt;cpu_slab);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	free_kmem_cache_nodes(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="do-kmem-cache-create-创建一个新的-slab-缓存（slab-cache）"><a href="#do-kmem-cache-create-创建一个新的-slab-缓存（slab-cache）" class="headerlink" title="do_kmem_cache_create 创建一个新的 slab 缓存（slab cache）"></a>do_kmem_cache_create 创建一个新的 slab 缓存（slab cache）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">do_kmem_cache_create</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">			 <span class="type">unsigned</span> <span class="type">int</span> size, <span class="keyword">struct</span> kmem_cache_args *args,</span></span><br><span class="line"><span class="params">			 <span class="type">slab_flags_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> err = -EINVAL;</span><br><span class="line"></span><br><span class="line">	s-&gt;name = name;</span><br><span class="line">	s-&gt;size = s-&gt;object_size = size;</span><br><span class="line"></span><br><span class="line">	s-&gt;flags = kmem_cache_flags(flags, s-&gt;name);</span><br><span class="line"></span><br><span class="line">	s-&gt;align = args-&gt;align;</span><br><span class="line">	s-&gt;ctor = args-&gt;ctor;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!calculate_sizes(args, s))	<span class="comment">//调用 calculate_sizes 函数计算 slab 缓存中对象的布局，包括对齐和元数据的偏移量</span></span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//根据对象大小设置部分 slab 列表的最小值（min_partial）。</span></span><br><span class="line">	<span class="comment">//对象越大，部分 slab 列表的最小值越大，以减少对页面分配器的频繁调用。</span></span><br><span class="line">	s-&gt;min_partial = <span class="type">min_t</span>(<span class="type">unsigned</span> <span class="type">long</span>, MAX_PARTIAL, ilog2(s-&gt;size) / <span class="number">2</span>);</span><br><span class="line">	s-&gt;min_partial = <span class="type">max_t</span>(<span class="type">unsigned</span> <span class="type">long</span>, MIN_PARTIAL, s-&gt;min_partial);</span><br><span class="line"></span><br><span class="line">	set_cpu_partial(s);	<span class="comment">//调用 set_cpu_partial 函数初始化 CPU 局部缓存，用于优化 slab 分配的性能。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果 slab 已启动，则初始化预先计算的随机空闲列表 */</span></span><br><span class="line">	<span class="keyword">if</span> (slab_state &gt;= UP) &#123;</span><br><span class="line">		<span class="keyword">if</span> (init_cache_random_seq(s))</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!init_kmem_cache_nodes(s))	<span class="comment">//初始化与 NUMA 节点相关的数据</span></span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!alloc_kmem_cache_cpus(s))	<span class="comment">//分配与 CPU 相关的 slab 缓存数据</span></span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 在早期启动期间不采用 Mutex */</span></span><br><span class="line">	<span class="keyword">if</span> (slab_state &lt;= UP)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 无法创建 sysfs 文件对于 SLUB 功能并不重要。</span></span><br><span class="line"><span class="comment">	 * 如果失败，请继续创建缓存，而不创建这些文件。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (sysfs_slab_add(s))	<span class="comment">//尝试将 slab 缓存添加到 sysfs 文件系统中</span></span><br><span class="line">		pr_err(<span class="string">&quot;SLUB: Unable to add cache %s to sysfs\n&quot;</span>, s-&gt;name);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (s-&gt;flags &amp; SLAB_STORE_USER)</span><br><span class="line">		debugfs_slab_add(s);	<span class="comment">//将 slab 缓存添加到 debugfs 文件系统中，用于调试目的</span></span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		__kmem_cache_release(s);	<span class="comment">//调用 __kmem_cache_release 释放已分配的资源</span></span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="bootstrap-初始化早期-kmem-cache-结构"><a href="#bootstrap-初始化早期-kmem-cache-结构" class="headerlink" title="bootstrap 初始化早期 kmem_cache 结构"></a>bootstrap 初始化早期 kmem_cache 结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 用于使用页面分配器分配的早期 kmem_cache 结构。</span></span><br><span class="line"><span class="comment"> * 正确分配它们，然后修复可能指向错误 kmem_cache 结构的指针。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> kmem_cache * __init <span class="title function_">bootstrap</span><span class="params">(<span class="keyword">struct</span> kmem_cache *static_cache)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> node;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">s</span> =</span> kmem_cache_zalloc(kmem_cache, GFP_NOWAIT);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">n</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">memcpy</span>(s, static_cache, kmem_cache-&gt;object_size);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 这会很早运行，只有引导处理器应该启动。 即使不是真的，IRQ 也没有上架，所以我们不能四处触发 IPI。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//刷新 CPU slab</span></span><br><span class="line">	__flush_cpu_slab(s, smp_processor_id());</span><br><span class="line">	for_each_kmem_cache_node(s, node, n) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">		list_for_each_entry(p, &amp;n-&gt;partial, slab_list)</span><br><span class="line">			p-&gt;slab_cache = s;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_DEBUG</span></span><br><span class="line">		list_for_each_entry(p, &amp;n-&gt;full, slab_list)</span><br><span class="line">			p-&gt;slab_cache = s;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	&#125;</span><br><span class="line">	list_add(&amp;s-&gt;<span class="built_in">list</span>, &amp;slab_caches);</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="kmem-cache-init-初始化-kmem-cache-和-kmem-cache-node"><a href="#kmem-cache-init-初始化-kmem-cache-和-kmem-cache-node" class="headerlink" title="kmem_cache_init  初始化 kmem_cache 和 kmem_cache_node"></a>kmem_cache_init  初始化 kmem_cache 和 kmem_cache_node</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 跟踪我们kmem_cache_nodes为其分配的 NUMA 节点。</span></span><br><span class="line"><span class="comment"> * 对应于 node_state[N_NORMAL_MEMORY]，但在内存热插拔/热删除作期间可能会暂时不同。受 slab_mutex 保护。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">nodemask_t</span> slab_nodes;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">kmem_cache_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> __initdata <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> <span class="title">boot_kmem_cache</span>,</span></span><br><span class="line"><span class="class">		<span class="title">boot_kmem_cache_node</span>;</span></span><br><span class="line">	<span class="type">int</span> node;</span><br><span class="line"></span><br><span class="line">	kmem_cache_node = &amp;boot_kmem_cache_node;</span><br><span class="line">	kmem_cache = &amp;boot_kmem_cache;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *初始化我们将为每个节点结构分配的 nodemask。在这里，我们还不需要slab_mutex。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//遍历所有具有正常内存的节点（N_NORMAL_MEMORY），并将它们添加到 slab_nodes 节点掩码中</span></span><br><span class="line">	for_each_node_state(node, N_NORMAL_MEMORY)</span><br><span class="line">		node_set(node, slab_nodes);</span><br><span class="line">	<span class="comment">//创建基础 slab 缓存</span></span><br><span class="line">	create_boot_cache(kmem_cache_node, <span class="string">&quot;kmem_cache_node&quot;</span>,</span><br><span class="line">			<span class="keyword">sizeof</span>(<span class="keyword">struct</span> kmem_cache_node),</span><br><span class="line">			SLAB_HWCACHE_ALIGN | SLAB_NO_OBJ_EXT, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	hotplug_memory_notifier(slab_memory_callback, SLAB_CALLBACK_PRI);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//表示分配器已经部分初始化，可以分配节点结构</span></span><br><span class="line">	slab_state = PARTIAL;</span><br><span class="line">	<span class="comment">//创建主 slab 缓存</span></span><br><span class="line">	create_boot_cache(kmem_cache, <span class="string">&quot;kmem_cache&quot;</span>,</span><br><span class="line">			offsetof(<span class="keyword">struct</span> kmem_cache, node) +</span><br><span class="line">				nr_node_ids * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> kmem_cache_node *),</span><br><span class="line">			SLAB_HWCACHE_ALIGN | SLAB_NO_OBJ_EXT, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">//调用 bootstrap 函数完成 kmem_cache 和 kmem_cache_node 的初始化，替换临时的 boot_kmem_cache 和 boot_kmem_cache_node</span></span><br><span class="line">	kmem_cache = bootstrap(&amp;boot_kmem_cache);</span><br><span class="line">	kmem_cache_node = bootstrap(&amp;boot_kmem_cache_node);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化 kmalloc 缓存*/</span></span><br><span class="line">	setup_kmalloc_cache_index_table();	<span class="comment">//设置 kmalloc 缓存索引表</span></span><br><span class="line">	create_kmalloc_caches();			<span class="comment">//创建 kmalloc 缓存</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化 slab 缓存的空闲列表随机化功能，以增强安全性，防止内存攻击 */</span></span><br><span class="line">	init_freelist_randomization();</span><br><span class="line"></span><br><span class="line">	cpuhp_setup_state_nocalls(CPUHP_SLUB_DEAD, <span class="string">&quot;slub:dead&quot;</span>, <span class="literal">NULL</span>,</span><br><span class="line">				  slub_cpu_dead);</span><br><span class="line">	<span class="comment">//SLUB: HWalign=32, Order=0-3, MinObjects=0, CPUs=1, Nodes=1</span></span><br><span class="line">	pr_info(<span class="string">&quot;SLUB: HWalign=%d, Order=%u-%u, MinObjects=%u, CPUs=%u, Nodes=%u\n&quot;</span>,</span><br><span class="line">		cache_line_size(),</span><br><span class="line">		slub_min_order, slub_max_order, slub_min_objects,</span><br><span class="line">		nr_cpu_ids, nr_node_ids);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="kmem-cache-init-late-Kmem-缓存初始化延迟"><a href="#kmem-cache-init-late-Kmem-缓存初始化延迟" class="headerlink" title="kmem_cache_init_late Kmem 缓存初始化延迟"></a>kmem_cache_init_late Kmem 缓存初始化延迟</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">kmem_cache_init_late</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_SLUB_TINY</span></span><br><span class="line">	flushwq = alloc_workqueue(<span class="string">&quot;slub_flushwq&quot;</span>, WQ_MEM_RECLAIM, <span class="number">0</span>);</span><br><span class="line">	WARN_ON(!flushwq);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="—————-内存分配相关函数——————"><a href="#—————-内存分配相关函数——————" class="headerlink" title="—————-内存分配相关函数——————"></a>—————-内存分配相关函数——————</h2><h2 id="slab-lock-slab-unlock"><a href="#slab-lock-slab-unlock" class="headerlink" title="slab_lock slab_unlock"></a>slab_lock slab_unlock</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Per slab locking using the pagelock</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> <span class="title function_">slab_lock</span><span class="params">(<span class="keyword">struct</span> slab *slab)</span></span><br><span class="line">&#123;</span><br><span class="line">	bit_spin_lock(PG_locked, &amp;slab-&gt;__page_flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> <span class="title function_">slab_unlock</span><span class="params">(<span class="keyword">struct</span> slab *slab)</span></span><br><span class="line">&#123;</span><br><span class="line">	bit_spin_unlock(PG_locked, &amp;slab-&gt;__page_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="get-freelist-获取-slab-的空闲列表"><a href="#get-freelist-获取-slab-的空闲列表" class="headerlink" title="get_freelist 获取 slab 的空闲列表"></a>get_freelist 获取 slab 的空闲列表</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span></span><br><span class="line">__update_freelist_slow(<span class="keyword">struct</span> slab *slab,</span><br><span class="line">		      <span class="type">void</span> *freelist_old, <span class="type">unsigned</span> <span class="type">long</span> counters_old,</span><br><span class="line">		      <span class="type">void</span> *freelist_new, <span class="type">unsigned</span> <span class="type">long</span> counters_new)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	slab_lock(slab);</span><br><span class="line">	<span class="keyword">if</span> (slab-&gt;freelist == freelist_old &amp;&amp;</span><br><span class="line">	    slab-&gt;counters == counters_old) &#123;</span><br><span class="line">		slab-&gt;freelist = freelist_new;</span><br><span class="line">		slab-&gt;counters = counters_new;</span><br><span class="line">		ret = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	slab_unlock(slab);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 必须禁用中断（以便回退代码正常工作），通常通过 _irqsave（） 锁变体。在 PREEMPT_RT 上，preempt_disable（） 是 bit_spin_lock（） 的一部分，就足够了，因为该策略不允许在 hardirq 上下文中进行任何分配/释放作。因此，没有什么可以中断作。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> __slab_update_freelist(<span class="keyword">struct</span> kmem_cache *s, <span class="keyword">struct</span> slab *slab,</span><br><span class="line">		<span class="type">void</span> *freelist_old, <span class="type">unsigned</span> <span class="type">long</span> counters_old,</span><br><span class="line">		<span class="type">void</span> *freelist_new, <span class="type">unsigned</span> <span class="type">long</span> counters_new,</span><br><span class="line">		<span class="type">const</span> <span class="type">char</span> *n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">bool</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (USE_LOCKLESS_FAST_PATH())</span><br><span class="line">		lockdep_assert_irqs_disabled();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (s-&gt;flags &amp; __CMPXCHG_DOUBLE) &#123;</span><br><span class="line">		ret = __update_freelist_fast(slab, freelist_old, counters_old,</span><br><span class="line">				            freelist_new, counters_new);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ret = __update_freelist_slow(slab, freelist_old, counters_old,</span><br><span class="line">				            freelist_new, counters_new);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (likely(ret))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	cpu_relax();</span><br><span class="line">	stat(s, CMPXCHG_DOUBLE_FAIL);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SLUB_DEBUG_CMPXCHG</span></span><br><span class="line">	pr_info(<span class="string">&quot;%s %s: cmpxchg double redo &quot;</span>, n, s-&gt;name);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 检查 slab-&gt;freelist，然后将 freelist 转移到每 CPU freelist 或停用 slab。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果返回值不为 NULL，则 slab 仍处于冻结状态。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果此函数返回 NULL，则表示 slab 已解冻。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> *<span class="title function_">get_freelist</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="keyword">struct</span> slab *slab)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> <span class="title">new</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> counters;</span><br><span class="line">	<span class="type">void</span> *freelist;</span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(this_cpu_ptr(&amp;s-&gt;cpu_slab-&gt;lock));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		freelist = slab-&gt;freelist;</span><br><span class="line">		counters = slab-&gt;counters;</span><br><span class="line"></span><br><span class="line">		new.counters = counters;</span><br><span class="line"></span><br><span class="line">		new.inuse = slab-&gt;objects;</span><br><span class="line">		new.frozen = freelist != <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">while</span> (!__slab_update_freelist(s, slab,</span><br><span class="line">		freelist, counters,</span><br><span class="line">		<span class="literal">NULL</span>, new.counters,</span><br><span class="line">		<span class="string">&quot;get_freelist&quot;</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> freelist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="get-partial-获取部分-slab-的空闲列表"><a href="#get-partial-获取部分-slab-的空闲列表" class="headerlink" title="get_partial 获取部分 slab 的空闲列表"></a>get_partial 获取部分 slab 的空闲列表</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 尝试从特定节点分配部分 slab。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> slab *<span class="title function_">get_partial_node</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s,</span></span><br><span class="line"><span class="params">				     <span class="keyword">struct</span> kmem_cache_node *n,</span></span><br><span class="line"><span class="params">				     <span class="keyword">struct</span> partial_context *pc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>, *<span class="title">slab2</span>, *<span class="title">partial</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> partial_slabs = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 猥亵检查。如果我们错误地没有看到 partial slab，那么我们只分配一个空 slab。如果我们错误地尝试获取部分 slab，但没有可用的 slab，则 get_partial（） 将返回 NULL。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!n || !n-&gt;nr_partial)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	spin_lock_irqsave(&amp;n-&gt;list_lock, flags);</span><br><span class="line">	list_for_each_entry_safe(slab, slab2, &amp;n-&gt;partial, slab_list) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!pfmemalloc_match(slab, pc-&gt;flags))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (IS_ENABLED(CONFIG_SLUB_TINY) || kmem_cache_debug(s)) &#123;</span><br><span class="line">			<span class="type">void</span> *object = alloc_single_from_partial(s, n, slab,</span><br><span class="line">							pc-&gt;orig_size);</span><br><span class="line">			<span class="keyword">if</span> (object) &#123;</span><br><span class="line">				partial = slab;</span><br><span class="line">				pc-&gt;object = object;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		remove_partial(n, slab);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!partial) &#123;</span><br><span class="line">			partial = slab;</span><br><span class="line">			stat(s, ALLOC_FROM_PARTIAL);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> ((slub_get_cpu_partial(s) == <span class="number">0</span>)) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			put_cpu_partial(s, slab, <span class="number">0</span>);</span><br><span class="line">			stat(s, CPU_PARTIAL_NODE);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (++partial_slabs &gt; slub_get_cpu_partial(s) / <span class="number">2</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);</span><br><span class="line">	<span class="keyword">return</span> partial;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *获取 partial slab，将其锁定并返回。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> slab *<span class="title function_">get_partial</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">int</span> node,</span></span><br><span class="line"><span class="params">				<span class="keyword">struct</span> partial_context *pc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>;</span></span><br><span class="line">	<span class="type">int</span> searchnode = node;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (node == NUMA_NO_NODE)</span><br><span class="line">		searchnode = numa_mem_id();</span><br><span class="line"></span><br><span class="line">	slab = get_partial_node(s, get_node(s, searchnode), pc);</span><br><span class="line">	<span class="keyword">if</span> (slab || (node != NUMA_NO_NODE &amp;&amp; (pc-&gt;flags &amp; __GFP_THISNODE)))</span><br><span class="line">		<span class="keyword">return</span> slab;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> get_any_partial(s, pc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="deactivate-slab-处理-slab-的去激活"><a href="#deactivate-slab-处理-slab-的去激活" class="headerlink" title="deactivate_slab 处理 slab 的去激活"></a>deactivate_slab 处理 slab 的去激活</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将 CPU slab 的空闲对象链表（freelist）合并到 slab 的全局空闲链表中，解冻 slab，并将其放置到适当的 slab 列表中（如部分 slab 列表或空 slab 列表）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">deactivate_slab</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="keyword">struct</span> slab *slab,</span></span><br><span class="line"><span class="params">			    <span class="type">void</span> *freelist)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">n</span> =</span> get_node(s, slab_nid(slab));</span><br><span class="line">	<span class="type">int</span> free_delta = <span class="number">0</span>;</span><br><span class="line">	<span class="type">void</span> *nextfree, *freelist_iter, *freelist_tail;</span><br><span class="line">	<span class="type">int</span> tail = DEACTIVATE_TO_HEAD;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> <span class="title">new</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> <span class="title">old</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (READ_ONCE(slab-&gt;freelist)) &#123;</span><br><span class="line">		stat(s, DEACTIVATE_REMOTE_FREES);</span><br><span class="line">		tail = DEACTIVATE_TO_TAIL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 遍历 CPU slab 的空闲链表，统计空闲对象的数量（free_delta）</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	freelist_tail = <span class="literal">NULL</span>;</span><br><span class="line">	freelist_iter = freelist;</span><br><span class="line">	<span class="keyword">while</span> (freelist_iter) &#123;</span><br><span class="line">		nextfree = get_freepointer(s, freelist_iter);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 链表中存在损坏的对象, 跳过损坏的部分</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (freelist_corrupted(s, slab, &amp;freelist_iter, nextfree))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		freelist_tail = freelist_iter;</span><br><span class="line">		free_delta++;</span><br><span class="line"></span><br><span class="line">		freelist_iter = nextfree;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 第二阶段：解冻 slab，同时将每 CPU 的空闲列表拼接到 slab 的空闲列表的头部。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		old.freelist = READ_ONCE(slab-&gt;freelist);</span><br><span class="line">		old.counters = READ_ONCE(slab-&gt;counters);</span><br><span class="line">		VM_BUG_ON(!old.frozen);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Determine target state of the slab */</span></span><br><span class="line">		new.counters = old.counters;</span><br><span class="line">		new.frozen = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (freelist_tail) &#123;</span><br><span class="line">			new.inuse -= free_delta;</span><br><span class="line">			set_freepointer(s, freelist_tail, old.freelist);</span><br><span class="line">			new.freelist = freelist;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			new.freelist = old.freelist;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">while</span> (!slab_update_freelist(s, slab,</span><br><span class="line">		old.freelist, old.counters,</span><br><span class="line">		new.freelist, new.counters,</span><br><span class="line">		<span class="string">&quot;unfreezing slab&quot;</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 第 3 阶段：根据更新的状态作 slab 列表。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!new.inuse &amp;&amp; n-&gt;nr_partial &gt;= s-&gt;min_partial) &#123;</span><br><span class="line">		stat(s, DEACTIVATE_EMPTY);</span><br><span class="line">		discard_slab(s, slab);</span><br><span class="line">		stat(s, FREE_SLAB);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (new.freelist) &#123;</span><br><span class="line">		spin_lock_irqsave(&amp;n-&gt;list_lock, flags);</span><br><span class="line">		add_partial(n, slab, tail);</span><br><span class="line">		spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);</span><br><span class="line">		stat(s, tail);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		stat(s, DEACTIVATE_FULL);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="slab-alloc-慢速分配函数"><a href="#slab-alloc-慢速分配函数" class="headerlink" title="__slab_alloc 慢速分配函数"></a>__slab_alloc 慢速分配函数</h2><ul>
<li>1.尝试从无锁空闲列表中分配对象</li>
<li>2.如果无锁空闲列表为空，则尝试从常规空闲列表中获取对象</li>
<li>3.如果常规空闲列表也为空，则尝试从部分 slab 列表中获取对象</li>
<li>4.如果部分 slab 列表也为空，则调用页面分配器分配一个新的 slab</li>
<li>5.如果分配成功，则返回对象指针，否则返回 NULL</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 慢速路径的触发条件</span></span><br><span class="line"><span class="comment">无锁空闲列表为空：</span></span><br><span class="line"><span class="comment">快速路径依赖于无锁空闲列表来快速分配内存对象。如果该列表为空，则需要进入慢速路径。</span></span><br><span class="line"><span class="comment">调试任务：</span></span><br><span class="line"><span class="comment">如果启用了调试功能（如内存跟踪或一致性检查），慢速路径会执行额外的调试操作。</span></span><br><span class="line"><span class="comment">2. 处理逻辑</span></span><br><span class="line"><span class="comment">接管常规空闲列表：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如果常规空闲列表（regular freelist）中有新释放的对象，慢速路径会将其接管并转换为无锁空闲列表，同时清空常规空闲列表。</span></span><br><span class="line"><span class="comment">这种操作仍然非常高效，因为无需从其他数据结构中分配新对象。</span></span><br><span class="line"><span class="comment">回退到部分 slab 列表：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如果常规空闲列表也无法满足分配需求，慢速路径会尝试从部分 slab 列表（partial slab lists）中获取对象。</span></span><br><span class="line"><span class="comment">它会从部分 slab 的空闲列表中取出第一个对象用于分配，并将剩余的对象移动到无锁空闲列表中。</span></span><br><span class="line"><span class="comment">分配新 slab：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如果部分 slab 列表也无法提供对象，慢速路径会调用页面分配器（page allocator）分配一个新的 slab。</span></span><br><span class="line"><span class="comment">这是最慢的路径，因为它涉及到分配新的物理内存页并初始化 slab 数据结</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *___slab_alloc(<span class="keyword">struct</span> kmem_cache *s, <span class="type">gfp_t</span> gfpflags, <span class="type">int</span> node,</span><br><span class="line">			  <span class="type">unsigned</span> <span class="type">long</span> addr, <span class="keyword">struct</span> kmem_cache_cpu *c, <span class="type">unsigned</span> <span class="type">int</span> orig_size)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> *freelist;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">partial_context</span> <span class="title">pc</span>;</span></span><br><span class="line">	<span class="type">bool</span> try_thisnode = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	stat(s, ALLOC_SLOWPATH);</span><br><span class="line"></span><br><span class="line">reread_slab:</span><br><span class="line"></span><br><span class="line">	slab = READ_ONCE(c-&gt;slab);</span><br><span class="line">	<span class="keyword">if</span> (!slab) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 如果节点不在线或没有正常内存，则忽略 Node constraint</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(node != NUMA_NO_NODE &amp;&amp;</span><br><span class="line">			     !node_isset(node, slab_nodes)))</span><br><span class="line">			node = NUMA_NO_NODE;</span><br><span class="line">		<span class="keyword">goto</span> new_slab;	<span class="comment">//尝试分配一个新的 slab</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!node_match(slab, node))) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * same as above but node_match() being false already</span></span><br><span class="line"><span class="comment">		 * implies node != NUMA_NO_NODE</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!node_isset(node, slab_nodes)) &#123;</span><br><span class="line">			node = NUMA_NO_NODE;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			stat(s, ALLOC_NODE_MISMATCH);</span><br><span class="line">			<span class="keyword">goto</span> deactivate_slab;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * By rights, we should be searching for a slab page that was</span></span><br><span class="line"><span class="comment">	 * PFMEMALLOC but right now, we are losing the pfmemalloc</span></span><br><span class="line"><span class="comment">	 * information when the page leaves the per-cpu allocator</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!pfmemalloc_match(slab, gfpflags)))</span><br><span class="line">		<span class="keyword">goto</span> deactivate_slab;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 必须再次检查 c-&gt;slab，以防我们被抢占并更改 */</span></span><br><span class="line">	local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(slab != c-&gt;slab)) &#123;</span><br><span class="line">		local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">		<span class="keyword">goto</span> reread_slab;</span><br><span class="line">	&#125;</span><br><span class="line">	freelist = c-&gt;freelist;</span><br><span class="line">	<span class="keyword">if</span> (freelist)</span><br><span class="line">		<span class="keyword">goto</span> load_freelist;</span><br><span class="line"></span><br><span class="line">	freelist = get_freelist(s, slab);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!freelist) &#123;</span><br><span class="line">		c-&gt;slab = <span class="literal">NULL</span>;</span><br><span class="line">		c-&gt;tid = next_tid(c-&gt;tid);</span><br><span class="line">		local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">		stat(s, DEACTIVATE_BYPASS);</span><br><span class="line">		<span class="keyword">goto</span> new_slab;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	stat(s, ALLOC_REFILL);</span><br><span class="line"></span><br><span class="line">load_freelist:</span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(this_cpu_ptr(&amp;s-&gt;cpu_slab-&gt;lock));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * freelist 指向要使用的对象列表。slab 指向从中获取对象的 slab。该 slab 必须被冻结，每 CPU 分配才能正常工作。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	VM_BUG_ON(!c-&gt;slab-&gt;frozen);</span><br><span class="line">	c-&gt;freelist = get_freepointer(s, freelist);</span><br><span class="line">	c-&gt;tid = next_tid(c-&gt;tid);</span><br><span class="line">	local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">	<span class="keyword">return</span> freelist;</span><br><span class="line"></span><br><span class="line">deactivate_slab:</span><br><span class="line"></span><br><span class="line">	local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">	<span class="keyword">if</span> (slab != c-&gt;slab) &#123;</span><br><span class="line">		local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">		<span class="keyword">goto</span> reread_slab;</span><br><span class="line">	&#125;</span><br><span class="line">	freelist = c-&gt;freelist;</span><br><span class="line">	c-&gt;slab = <span class="literal">NULL</span>;</span><br><span class="line">	c-&gt;freelist = <span class="literal">NULL</span>;</span><br><span class="line">	c-&gt;tid = next_tid(c-&gt;tid);</span><br><span class="line">	local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">	deactivate_slab(s, slab, freelist);</span><br><span class="line"></span><br><span class="line">new_slab:</span><br><span class="line"></span><br><span class="line">new_objects:</span><br><span class="line"></span><br><span class="line">	pc.flags = gfpflags;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 当指示首选节点但没有__GFP_THISNODE</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 1） 尝试仅通过在 pc.flags 中为 get_partial（） __GFP_THISNODE来从目标节点获取部分 slab</span></span><br><span class="line"><span class="comment">	 * 2） 如果 1） 失败，请尝试使用 GPF_NOWAIT |__GFP_THISNODE机会主义</span></span><br><span class="line"><span class="comment">	 * 3） 如果 2） 失败，请使用原始 GFP标志重试，这将允许 get_partial（） 在可能从其他节点分配新页面之前尝试其他节点的部分列表</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(node != NUMA_NO_NODE &amp;&amp; !(gfpflags &amp; __GFP_THISNODE)</span><br><span class="line">		     &amp;&amp; try_thisnode))</span><br><span class="line">		pc.flags = GFP_NOWAIT | __GFP_THISNODE;</span><br><span class="line"></span><br><span class="line">	pc.orig_size = orig_size;</span><br><span class="line">	slab = get_partial(s, node, &amp;pc);	<span class="comment">//尝试从部分 slab 列表中获取一个 slab</span></span><br><span class="line">	<span class="keyword">if</span> (slab) &#123;</span><br><span class="line">		freelist = freeze_slab(s, slab);	<span class="comment">//将 slab 冻结</span></span><br><span class="line">		<span class="keyword">goto</span> retry_load_slab;				<span class="comment">//继续分配</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果部分 slab 列表无法满足需求，调用 new_slab 分配一个新的 slab</span></span><br><span class="line">	slub_put_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line">	slab = new_slab(s, pc.flags, node);</span><br><span class="line">	c = slub_get_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!slab)) &#123;	<span class="comment">//分配失败</span></span><br><span class="line">		<span class="comment">//检查是否可以尝试其他节点</span></span><br><span class="line">		<span class="keyword">if</span> (node != NUMA_NO_NODE &amp;&amp; !(gfpflags &amp; __GFP_THISNODE)</span><br><span class="line">		    &amp;&amp; try_thisnode) &#123;</span><br><span class="line">			try_thisnode = <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">goto</span> new_objects;	<span class="comment">//如果可以，重新尝试分配。</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	stat(s, ALLOC_SLAB);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 还没有其他对 slab 的引用，因此我们可以在没有 cmpxchg 的情况下自由地使用它</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//初始化新 slab</span></span><br><span class="line">	freelist = slab-&gt;freelist;</span><br><span class="line">	slab-&gt;freelist = <span class="literal">NULL</span>;</span><br><span class="line">	slab-&gt;inuse = slab-&gt;objects;</span><br><span class="line">	slab-&gt;frozen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">retry_load_slab:</span><br><span class="line"></span><br><span class="line">	local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(c-&gt;slab)) &#123;</span><br><span class="line">		<span class="type">void</span> *flush_freelist = c-&gt;freelist;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">flush_slab</span> =</span> c-&gt;slab;</span><br><span class="line"></span><br><span class="line">		c-&gt;slab = <span class="literal">NULL</span>;</span><br><span class="line">		c-&gt;freelist = <span class="literal">NULL</span>;</span><br><span class="line">		c-&gt;tid = next_tid(c-&gt;tid);</span><br><span class="line"></span><br><span class="line">		local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">		deactivate_slab(s, flush_slab, flush_freelist);</span><br><span class="line"></span><br><span class="line">		stat(s, CPUSLAB_FLUSH);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">goto</span> retry_load_slab;</span><br><span class="line">	&#125;</span><br><span class="line">	c-&gt;slab = slab;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">goto</span> load_freelist;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ___slab_alloc（） 的包装器，用于尚未禁用抢占的上下文。通过重新获取每 CPU 区域指针来补偿可能的 cpu 更改。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *__slab_alloc(<span class="keyword">struct</span> kmem_cache *s, <span class="type">gfp_t</span> gfpflags, <span class="type">int</span> node,</span><br><span class="line">			  <span class="type">unsigned</span> <span class="type">long</span> addr, <span class="keyword">struct</span> kmem_cache_cpu *c, <span class="type">unsigned</span> <span class="type">int</span> orig_size)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> *p;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PREEMPT_COUNT</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 在禁用抢占之前，我们可能已被抢占并重新安排在不同的 CPU 上。需要重新加载 cpu 区域指针。</span></span><br><span class="line"><span class="comment">	 * 禁用抢占以避免在获取 cpu_slab 时被抢占。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	c = slub_get_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	p = ___slab_alloc(s, gfpflags, node, addr, c, orig_size);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PREEMPT_COUNT</span></span><br><span class="line">	<span class="comment">//启用抢占</span></span><br><span class="line">	slub_put_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="slab-alloc-node-内存分配函数"><a href="#slab-alloc-node-内存分配函数" class="headerlink" title="__slab_alloc_node 内存分配函数"></a>__slab_alloc_node 内存分配函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *__slab_alloc_node(<span class="keyword">struct</span> kmem_cache *s,</span><br><span class="line">		<span class="type">gfp_t</span> gfpflags, <span class="type">int</span> node, <span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">size_t</span> orig_size)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> *<span class="title">c</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> tid;</span><br><span class="line">	<span class="type">void</span> *object;</span><br><span class="line"></span><br><span class="line">redo:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 必须通过此 cpu ptr 读取 kmem_cache CPU 数据。已启用抢占。我们可以在从一个 cpu 区域读取数据时在 cpu 之间来回切换。只要我们在执行 cmpxchg 时再次使用原始 cpu，这并不重要。</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 我们必须保证 tid 和 kmem_cache_cpu 在同一个 cpu 上检索。我们首先读取 kmem_cache_cpu 指针，然后使用它来读取 tid。如果我们在两次读取之间被抢占并切换到另一个 cpu，那没关系，因为两者仍然与同一个 cpu 相关联，cmpxchg 稍后将验证 cpu。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	c = raw_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line">	tid = READ_ONCE(c-&gt;tid);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 这里使用的 Irqless 对象 alloc/free 算法取决于获取 cpu_slab 数据的顺序。tid 应该在 C 上的任何内容之前获取，以保证与前一个 tid 关联的对象和 slab 不会与当前 tid 一起使用。如果我们先获取 tid，object 和 slab 可能是与下一个 tid 关联的，我们的 alloc/free 请求将失败。在这种情况下，我们将重试。所以，没问题。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	barrier();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 事务 ID 对于每个 CPU 和每个 CPU 队列上的每个作都是全局唯一的。</span></span><br><span class="line"><span class="comment">	 * 因此，他们可以保证cmpxchg_double发生在正确的处理器上，并且两者之间没有对链表的作。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	object = c-&gt;freelist;</span><br><span class="line">	slab = c-&gt;slab;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!USE_LOCKLESS_FAST_PATH() ||</span><br><span class="line">	    unlikely(!object || !slab || !node_match(slab, node))) &#123;</span><br><span class="line">		<span class="comment">//慢速分配</span></span><br><span class="line">		object = __slab_alloc(s, gfpflags, node, addr, c, orig_size);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">void</span> *next_object = get_freepointer_safe(s, object);	<span class="comment">//获取空闲列表中的下一个对象指针</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * cmpxchg 仅在没有其他作且我们使用的是正确的处理器时才会匹配。</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * cmpxchg 以原子方式执行以下作（没有锁语义！</span></span><br><span class="line"><span class="comment">		 * 1.将第一个指针重新定位到当前每 CPU 区域。</span></span><br><span class="line"><span class="comment">		 * 2.验证 tid 和 freelist 是否未更改</span></span><br><span class="line"><span class="comment">		 * 3.如果未更改，请替换 tid 和 freelist</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * 由于这是没有锁语义的，因此保护仅针对在此 CPU 上执行的代码 * 而不是* 其他 CPU 的访问。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(!__update_cpu_freelist_fast(s, object, next_object, tid))) &#123;	<span class="comment">// 尝试原子更新空闲列表（通过 cmpxchg 实现）</span></span><br><span class="line">			<span class="comment">//如果更新失败（如由于并发操作导致的冲突），记录失败信息并重试分配（跳转到 redo 标签）</span></span><br><span class="line">			note_cmpxchg_failure(<span class="string">&quot;slab_alloc&quot;</span>, s, tid);</span><br><span class="line">			<span class="keyword">goto</span> redo;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//预取下一个空闲对象的指针，优化后续分配的性能</span></span><br><span class="line">		prefetch_freepointer(s, next_object);</span><br><span class="line">		<span class="comment">//更新分配统计信息，记录快速路径的使用情况</span></span><br><span class="line">		stat(s, ALLOC_FASTPATH);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="slab-alloc-node-分配内存"><a href="#slab-alloc-node-分配内存" class="headerlink" title="slab_alloc_node 分配内存"></a>slab_alloc_node 分配内存</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 内联 fastpath，以便分配函数 （kmalloc， kmem_cache_alloc） 将 fastpath 折叠到其函数中。</span></span><br><span class="line"><span class="comment"> * 因此，对于可以在 fastpath 上满足的请求，没有函数调用开销。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 快速路径首先尝试从无锁空闲列表（lockless freelist）中分配对象。如果失败，则回退到慢速路径（__slab_alloc_node）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 否则，我们可以简单地从无锁空闲列表中选择下一个对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> __fastpath_inline <span class="type">void</span> *<span class="title function_">slab_alloc_node</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="keyword">struct</span> list_lru *lru,</span></span><br><span class="line"><span class="params">		<span class="type">gfp_t</span> gfpflags, <span class="type">int</span> node, <span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">size_t</span> orig_size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> *object;</span><br><span class="line">	<span class="type">bool</span> init = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	s = slab_pre_alloc_hook(s, gfpflags);	<span class="comment">//nothing</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!s))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	object = kfence_alloc(s, orig_size, gfpflags);	<span class="comment">//NULL</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(object))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	object = __slab_alloc_node(s, gfpflags, node, addr, orig_size);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 当 init 等于 &#x27;true&#x27; 时，就像 kzalloc（） 系列一样，只有 @orig_size 个字节可能被归零，而不是 s-&gt;object_size如果由于 memcg_slab_post_alloc_hook（） 而失败，object 将被设置为 NULL</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	slab_post_alloc_hook(s, lru, gfpflags, <span class="number">1</span>, &amp;object, init, orig_size);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="kmalloc-cache-noprof-分配内存"><a href="#kmalloc-cache-noprof-分配内存" class="headerlink" title="__kmalloc_cache_noprof 分配内存"></a>__kmalloc_cache_noprof 分配内存</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *__kmalloc_cache_noprof(<span class="keyword">struct</span> kmem_cache *s, <span class="type">gfp_t</span> gfpflags, <span class="type">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> *ret = slab_alloc_node(s, <span class="literal">NULL</span>, gfpflags, NUMA_NO_NODE,</span><br><span class="line">					    _RET_IP_, size);</span><br><span class="line"></span><br><span class="line">	trace_kmalloc(_RET_IP_, ret, size, s-&gt;size, gfpflags, NUMA_NO_NODE);</span><br><span class="line"></span><br><span class="line">	ret = kasan_kmalloc(s, ret, size, gfpflags);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__kmalloc_cache_noprof);</span><br></pre></td></tr></table></figure>

<h2 id="kmem-cache-alloc-lru-noprof-分配LRU内存"><a href="#kmem-cache-alloc-lru-noprof-分配LRU内存" class="headerlink" title="kmem_cache_alloc_lru_noprof 分配LRU内存"></a>kmem_cache_alloc_lru_noprof 分配LRU内存</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">kmem_cache_alloc_lru_noprof</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="keyword">struct</span> list_lru *lru,</span></span><br><span class="line"><span class="params">			   <span class="type">gfp_t</span> gfpflags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> *ret = slab_alloc_node(s, lru, gfpflags, NUMA_NO_NODE, _RET_IP_,</span><br><span class="line">				    s-&gt;object_size);</span><br><span class="line"></span><br><span class="line">	trace_kmem_cache_alloc(_RET_IP_, ret, s, gfpflags, NUMA_NO_NODE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(kmem_cache_alloc_lru_noprof);</span><br></pre></td></tr></table></figure>

<h2 id="kmalloc-large-node-noprof-分配大内存块"><a href="#kmalloc-large-node-noprof-分配大内存块" class="headerlink" title="__kmalloc_large_node_noprof 分配大内存块"></a>__kmalloc_large_node_noprof 分配大内存块</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 为避免不必要的开销，我们直接将大型分配请求传递给页面分配器。</span></span><br><span class="line"><span class="comment"> * 我们使用 __GFP_COMP，因为我们需要知道分配顺序以便在 kfree 中正确释放页面。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *___kmalloc_large_node(<span class="type">size_t</span> size, <span class="type">gfp_t</span> flags, <span class="type">int</span> node)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">folio</span> *<span class="title">folio</span>;</span></span><br><span class="line">	<span class="type">void</span> *ptr = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> order = get_order(size);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(flags &amp; GFP_SLAB_BUG_MASK))</span><br><span class="line">		flags = kmalloc_fix_flags(flags);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 添加 __GFP_COMP 标志，确保分配的页面可以正确地被释放（需要知道分配阶数） */</span></span><br><span class="line">	flags |= __GFP_COMP;</span><br><span class="line">	<span class="comment">/* 分配页面 */</span></span><br><span class="line">	folio = (<span class="keyword">struct</span> folio *)alloc_pages_node_noprof(node, flags, order);</span><br><span class="line">	<span class="keyword">if</span> (folio) &#123;</span><br><span class="line">		<span class="comment">/* 获取页面的起始地址 */</span></span><br><span class="line">		ptr = folio_address(folio);</span><br><span class="line">		<span class="comment">/* 更新页面的统计信息（lruvec_stat_mod_folio），标记为不可回收的 slab 内存 */</span></span><br><span class="line">		lruvec_stat_mod_folio(folio, NR_SLAB_UNRECLAIMABLE_B,</span><br><span class="line">				      PAGE_SIZE &lt;&lt; order);</span><br><span class="line">		<span class="comment">/* 指示它是通过 kmalloc 分配的大块内存（__folio_set_large_kmalloc） */</span></span><br><span class="line">		__folio_set_large_kmalloc(folio);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ptr = kasan_kmalloc_large(ptr, size, flags);</span><br><span class="line">	<span class="comment">/* As ptr might get tagged, call kmemleak hook after KASAN. */</span></span><br><span class="line">	kmemleak_alloc(ptr, size, <span class="number">1</span>, flags);</span><br><span class="line">	kmsan_kmalloc_large(ptr, size, flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *__kmalloc_large_node_noprof(<span class="type">size_t</span> size, <span class="type">gfp_t</span> flags, <span class="type">int</span> node)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> *ret = ___kmalloc_large_node(size, flags, node);</span><br><span class="line"></span><br><span class="line">	trace_kmalloc(_RET_IP_, ret, size, PAGE_SIZE &lt;&lt; get_order(size),</span><br><span class="line">		      flags, node);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__kmalloc_large_node_noprof);</span><br></pre></td></tr></table></figure>

<h2 id="do-kmalloc-node-分配内存"><a href="#do-kmalloc-node-分配内存" class="headerlink" title="__do_kmalloc_node 分配内存"></a>__do_kmalloc_node 分配内存</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline</span><br><span class="line"><span class="type">void</span> *__do_kmalloc_node(<span class="type">size_t</span> size, kmem_buckets *b, <span class="type">gfp_t</span> flags, <span class="type">int</span> node,</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">long</span> caller)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">s</span>;</span></span><br><span class="line">	<span class="type">void</span> *ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(size &gt; KMALLOC_MAX_CACHE_SIZE)) &#123;</span><br><span class="line">		ret = __kmalloc_large_node_noprof(size, flags, node);</span><br><span class="line">		trace_kmalloc(caller, ret, size,</span><br><span class="line">			      PAGE_SIZE &lt;&lt; get_order(size), flags, node);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!size))</span><br><span class="line">		<span class="keyword">return</span> ZERO_SIZE_PTR;</span><br><span class="line"></span><br><span class="line">	s = kmalloc_slab(size, b, flags, caller);</span><br><span class="line">	</span><br><span class="line">	ret = slab_alloc_node(s, <span class="literal">NULL</span>, flags, node, caller, size);</span><br><span class="line">	ret = kasan_kmalloc(s, ret, size, flags);</span><br><span class="line">	trace_kmalloc(caller, ret, size, s-&gt;size, flags, node);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="kvmalloc-node-尝试分配物理上连续的内存块。如果分配失败，则会回退到非连续内存分配（通过-vmalloc）"><a href="#kvmalloc-node-尝试分配物理上连续的内存块。如果分配失败，则会回退到非连续内存分配（通过-vmalloc）" class="headerlink" title="__kvmalloc_node 尝试分配物理上连续的内存块。如果分配失败，则会回退到非连续内存分配（通过 vmalloc）"></a>__kvmalloc_node 尝试分配物理上连续的内存块。如果分配失败，则会回退到非连续内存分配（通过 vmalloc）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * __kvmalloc_node - 尝试分配物理连续内存，但在失败时回退到非连续 (vmalloc) 分配。</span></span><br><span class="line"><span class="comment"> * @size: 请求的大小。</span></span><br><span class="line"><span class="comment"> * @b: 要从中分配的 kmalloc 桶集合。</span></span><br><span class="line"><span class="comment"> * @flags: 分配的 gfp 掩码 - 必须与 GFP_KERNEL 兼容（超集）。</span></span><br><span class="line"><span class="comment"> * @node: 要分配的 numa 节点。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 使用 kmalloc 获取内存，但如果分配失败，则回退到 vmalloc 分配器。使用 kvfree 释放内存。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 不支持 GFP_NOWAIT 和 GFP_ATOMIC，也不支持 __GFP_NORETRY 修饰符。</span></span><br><span class="line"><span class="comment"> * 支持 __GFP_RETRY_MAYFAIL，且仅在 kmalloc 优于 vmalloc 回退时使用，因为回退可能会导致明显的性能缺陷。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值: 指向分配内存的指针，失败时返回 %NULL。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *__kvmalloc_node_noprof(DECL_BUCKET_PARAMS(size, b), <span class="type">gfp_t</span> flags, <span class="type">int</span> node)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> *ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 对于子页面请求，回退到 vmalloc 实际上没有意义</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ret = __do_kmalloc_node(size, PASS_BUCKET_PARAM(b),</span><br><span class="line">				kmalloc_gfp_adjust(flags, size),</span><br><span class="line">				node, _RET_IP_);</span><br><span class="line">	<span class="comment">/* 如果请求的内存大小小于或等于页面大小（PAGE_SIZE），即使 kmalloc 失败，</span></span><br><span class="line"><span class="comment">	 * 也不会回退到 vmalloc，因为对于小内存块，使用 vmalloc 不合理。 */</span></span><br><span class="line">	<span class="keyword">if</span> (ret || size &lt;= PAGE_SIZE)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 不支持通过 vmalloc 进行非睡眠分配 */</span></span><br><span class="line">	<span class="keyword">if</span> (!gfpflags_allow_blocking(flags))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果请求的内存大小超过 INT_MAX，认为这是一个不合理的请求 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(size &gt; INT_MAX)) &#123;</span><br><span class="line">		WARN_ON_ONCE(!(flags &amp; __GFP_NOWARN));</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* kvmalloc() 始终可以使用 VM_ALLOW_HUGE_VMAP，</span></span><br><span class="line"><span class="comment">	* 因为调用者已经无法对结果指针做任何假设，</span></span><br><span class="line"><span class="comment">	* 也无法进行保护操作。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">return</span> __vmalloc_node_range_noprof(size, <span class="number">1</span>, VMALLOC_START, VMALLOC_END,</span><br><span class="line">			flags, PAGE_KERNEL, VM_ALLOW_HUGE_VMAP,</span><br><span class="line">			node, __builtin_return_address(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__kvmalloc_node_noprof);</span><br></pre></td></tr></table></figure>

<h2 id="——————–内存释放相关函数——————"><a href="#——————–内存释放相关函数——————" class="headerlink" title="——————–内存释放相关函数——————"></a>——————–内存释放相关函数——————</h2><h2 id="slab-free-释放内存"><a href="#slab-free-释放内存" class="headerlink" title="__slab_free 释放内存"></a>__slab_free 释放内存</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 路径处理速度慢。这仍然可以频繁调用，因为在大多数处理负载中，对象的生命周期比 cpu slab 长。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 因此，我们仍然尝试减少缓存行的使用。只需拿起石板锁并释放该物品。如果不需要额外的部分板处理，那么我们可以立即返回。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __slab_free(<span class="keyword">struct</span> kmem_cache *s, <span class="keyword">struct</span> slab *slab,</span><br><span class="line">			<span class="type">void</span> *head, <span class="type">void</span> *tail, <span class="type">int</span> cnt,</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">long</span> addr)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> *prior;</span><br><span class="line">	<span class="type">int</span> was_frozen;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> <span class="title">new</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> counters;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">n</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">	<span class="type">bool</span> on_node_partial;</span><br><span class="line"></span><br><span class="line">	stat(s, FREE_SLOWPATH);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_SLUB_TINY) || kmem_cache_debug(s)) &#123;</span><br><span class="line">		free_to_partial_list(s, slab, head, tail, cnt, addr);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//释放对象并更新 slab 状态</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (unlikely(n)) &#123;</span><br><span class="line">			spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);</span><br><span class="line">			n = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		prior = slab-&gt;freelist;</span><br><span class="line">		counters = slab-&gt;counters;</span><br><span class="line">		set_freepointer(s, tail, prior);</span><br><span class="line">		new.counters = counters;</span><br><span class="line">		was_frozen = new.frozen;</span><br><span class="line">		new.inuse -= cnt;</span><br><span class="line">		<span class="keyword">if</span> ((!new.inuse || !prior) &amp;&amp; !was_frozen) &#123;</span><br><span class="line">			<span class="comment">/* Needs to be taken off a list */</span></span><br><span class="line">			<span class="keyword">if</span> (!kmem_cache_has_cpu_partial(s) || prior) &#123;</span><br><span class="line"></span><br><span class="line">				n = get_node(s, slab_nid(slab));</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * Speculatively acquire the list_lock.</span></span><br><span class="line"><span class="comment">				 * If the cmpxchg does not succeed then we may</span></span><br><span class="line"><span class="comment">				 * drop the list_lock without any processing.</span></span><br><span class="line"><span class="comment">				 *</span></span><br><span class="line"><span class="comment">				 * Otherwise the list_lock will synchronize with</span></span><br><span class="line"><span class="comment">				 * other processors updating the list of slabs.</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				spin_lock_irqsave(&amp;n-&gt;list_lock, flags);</span><br><span class="line"></span><br><span class="line">				on_node_partial = slab_test_node_partial(slab);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">while</span> (!slab_update_freelist(s, slab,</span><br><span class="line">		prior, counters,</span><br><span class="line">		head, new.counters,</span><br><span class="line">		<span class="string">&quot;__slab_free&quot;</span>));</span><br><span class="line">	<span class="comment">//处理未加锁的情况</span></span><br><span class="line">	<span class="keyword">if</span> (likely(!n)) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (likely(was_frozen)) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * The list lock was not taken therefore no list</span></span><br><span class="line"><span class="comment">			 * activity can be necessary.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			stat(s, FREE_FROZEN);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (kmem_cache_has_cpu_partial(s) &amp;&amp; !prior) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * If we started with a full slab then put it onto the</span></span><br><span class="line"><span class="comment">			 * per cpu partial list.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			put_cpu_partial(s, slab, <span class="number">1</span>);</span><br><span class="line">			stat(s, CPU_PARTIAL_FREE);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//处理部分 slab 列表</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This slab was partially empty but not on the per-node partial list,</span></span><br><span class="line"><span class="comment">	 * in which case we shouldn&#x27;t manipulate its list, just return.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (prior &amp;&amp; !on_node_partial) &#123;</span><br><span class="line">		spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!new.inuse &amp;&amp; n-&gt;nr_partial &gt;= s-&gt;min_partial))</span><br><span class="line">		<span class="keyword">goto</span> slab_empty;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Objects left in the slab. If it was not on the partial list before</span></span><br><span class="line"><span class="comment">	 * then add it.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!kmem_cache_has_cpu_partial(s) &amp;&amp; unlikely(!prior)) &#123;</span><br><span class="line">		add_partial(n, slab, DEACTIVATE_TO_TAIL);</span><br><span class="line">		stat(s, FREE_ADD_PARTIAL);</span><br><span class="line">	&#125;</span><br><span class="line">	spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">slab_empty:</span><br><span class="line">	<span class="keyword">if</span> (prior) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Slab on the partial list.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		remove_partial(n, slab);</span><br><span class="line">		stat(s, FREE_REMOVE_PARTIAL);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);</span><br><span class="line">	stat(s, FREE_SLAB);</span><br><span class="line">	discard_slab(s, slab);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="do-slab-free-释放内存"><a href="#do-slab-free-释放内存" class="headerlink" title="do_slab_free 释放内存"></a>do_slab_free 释放内存</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 具有强制内联的 Fastpath 以生成 kfree 和 kmem_cache_free，无需额外的函数调用即可执行 fastpath 释放。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 只有当我们释放到该处理器的当前 cpu slab 时，快速路径才可用。如果我们之前刚刚分配了 item，则通常会出现这种情况。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果 fastpath 不可用，则回退到 __slab_free 我们处理各种特殊处理。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 通过指定 head 和 tail ptr 以及对象计数 （cnt），可以批量释放具有多个对象（所有对象都指向同一个 slab）的空闲列表。由正在设置的尾部指针指示批量释放。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> <span class="title function_">do_slab_free</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s,</span></span><br><span class="line"><span class="params">				<span class="keyword">struct</span> slab *slab, <span class="type">void</span> *head, <span class="type">void</span> *tail,</span></span><br><span class="line"><span class="params">				<span class="type">int</span> cnt, <span class="type">unsigned</span> <span class="type">long</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> *<span class="title">c</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> tid;</span><br><span class="line">	<span class="type">void</span> **freelist;</span><br><span class="line"></span><br><span class="line">redo:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 确定当前每个 CPU 的 cpus slab。之后 cpu 可能会发生变化。但是，这并不重要，因为数据是通过此指针检索的。如果我们在 cmpxchg 期间位于同一个 cpu 上，那么 free 将成功。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	c = raw_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line">	tid = READ_ONCE(c-&gt;tid);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 与 __slab_alloc_node（） 中 barrier（） 的注释相同 */</span></span><br><span class="line">	barrier();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(slab != c-&gt;slab)) &#123;</span><br><span class="line">		<span class="comment">//目标 slab 与当前 CPU 的 slab 不匹配，调用慢速路径函数 __slab_free 处理释放</span></span><br><span class="line">		__slab_free(s, slab, head, tail, cnt, addr);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (USE_LOCKLESS_FAST_PATH()) &#123;</span><br><span class="line">		freelist = READ_ONCE(c-&gt;freelist);</span><br><span class="line"></span><br><span class="line">		set_freepointer(s, tail, freelist);	<span class="comment">//将需要释放的对象链表拼接到空闲链表上</span></span><br><span class="line">		<span class="comment">//使用 __update_cpu_freelist_fast 尝试原子更新空闲链表</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(!__update_cpu_freelist_fast(s, freelist, head, tid))) &#123;</span><br><span class="line">			note_cmpxchg_failure(<span class="string">&quot;slab_free&quot;</span>, s, tid);</span><br><span class="line">			<span class="keyword">goto</span> redo;	<span class="comment">//更新失败（如由于并发操作导致的冲突），记录失败信息并重试</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;	<span class="comment">//慢速路径的回退</span></span><br><span class="line">		<span class="comment">/* 在本地锁下更新免费列表*/</span></span><br><span class="line">		local_lock(&amp;s-&gt;cpu_slab-&gt;lock);</span><br><span class="line">		c = this_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(slab != c-&gt;slab)) &#123;</span><br><span class="line">			local_unlock(&amp;s-&gt;cpu_slab-&gt;lock);</span><br><span class="line">			<span class="keyword">goto</span> redo;</span><br><span class="line">		&#125;</span><br><span class="line">		tid = c-&gt;tid;</span><br><span class="line">		freelist = c-&gt;freelist;</span><br><span class="line"></span><br><span class="line">		set_freepointer(s, tail, freelist);</span><br><span class="line">		c-&gt;freelist = head;</span><br><span class="line">		c-&gt;tid = next_tid(tid);</span><br><span class="line"></span><br><span class="line">		local_unlock(&amp;s-&gt;cpu_slab-&gt;lock);</span><br><span class="line">	&#125;</span><br><span class="line">	stat_add(s, FREE_FASTPATH, cnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="slab-free-释放内存-1"><a href="#slab-free-释放内存-1" class="headerlink" title="slab_free 释放内存"></a>slab_free 释放内存</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __fastpath_inline</span><br><span class="line"><span class="type">void</span> <span class="title function_">slab_free</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="keyword">struct</span> slab *slab, <span class="type">void</span> *object,</span></span><br><span class="line"><span class="params">	       <span class="type">unsigned</span> <span class="type">long</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">	memcg_slab_free_hook(s, slab, &amp;object, <span class="number">1</span>);</span><br><span class="line">	alloc_tagging_slab_free_hook(s, slab, &amp;object, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (likely(slab_free_hook(s, object, slab_want_init_on_free(s), <span class="literal">false</span>)))</span><br><span class="line">		do_slab_free(s, slab, object, object, <span class="number">1</span>, addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="kfree-释放内存"><a href="#kfree-释放内存" class="headerlink" title="kfree 释放内存"></a>kfree 释放内存</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kfree - free previously allocated memory</span></span><br><span class="line"><span class="comment"> * @object: pointer returned by kmalloc() or kmem_cache_alloc()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If @object is NULL, no operation is performed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *object)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">folio</span> *<span class="title">folio</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">s</span>;</span></span><br><span class="line">	<span class="type">void</span> *x = (<span class="type">void</span> *)object;</span><br><span class="line"></span><br><span class="line">	trace_kfree(_RET_IP_, object);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(ZERO_OR_NULL_PTR(object)))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	folio = virt_to_folio(object);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!folio_test_slab(folio))) &#123;</span><br><span class="line">		free_large_kmalloc(folio, (<span class="type">void</span> *)object);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	slab = folio_slab(folio);</span><br><span class="line">	s = slab-&gt;slab_cache;</span><br><span class="line">	slab_free(s, slab, x, _RET_IP_);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(kfree);</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/wdfk-prog">Liya Huang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://wdfk-prog.space/posts/e8f76fed/">https://wdfk-prog.space/posts/e8f76fed/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://wdfk-prog.space" target="_blank">wdfk-prog的个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/linux/">linux</a><a class="post-meta__tags" href="/tags/mm/">mm</a></div><div class="post-share"><div class="social-share" data-image="/images/covers/07.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/images/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/images/alipay.png" target="_blank"><img class="post-qr-code-img" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/alipay.png" alt="支付寶"/></a><div class="post-qr-code-desc">支付寶</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/1a09ef0b/" title="assembly"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/09.jpg" onerror="onerror=null;src='/images/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">assembly</div></div><div class="info-2"><div class="info-item-1">[TOC] THUMB2指令集THUMB2 指令集深度解析：从入门到精通THUMB2 指令集是在嵌入式系统领域广受欢迎的 ARM 架构的一项关键技术。它巧妙地结合了 16 位指令的紧凑代码密度和 32 位指令的强大性能，为资源受限的设备提供了高效的解决方案。本文将从历史背景、核心原理、应用场景、入门实践、安全考量、生态系统、性能监控和未来趋势等多个维度，为您全面解析 THUMB2 指令集。 一、 历史与背景为了解决什么特定问题而诞生？ THUMB2 技术的诞生主要是为了解决早期 ARM 架构在嵌入式应用中的一个核心矛盾：性能与代码密度之间的权衡。  ARM 指令集：提供强大的 32 位指令，性能出色，但指令均为 32 位定长，导致代码体积较大，对于内存（尤其是昂贵的片上闪存和 RAM）有限的嵌入式系统而言，成本较高。 Thumb 指令集（第一代）：作为对策，ARM 推出了 16 位的 Thumb 指令集，它是 ARM 指令集的一个子集。 这显著减小了代码体积（约 30%-40%），降低了功耗和内存需求。 然而，Thumb 指令集功能有限，性能相比 32 位 ARM 指令集有所下降...</div></div></div></a><a class="pagination-related" href="/posts/ce7dcbe/" title="vmstat"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/06.jpg" onerror="onerror=null;src='/images/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">vmstat</div></div><div class="info-2"><div class="info-item-1">[TOC] mm\vmstat.cinit_mm_internals 初始化内存管理（MM）子系统中，那些依赖于其他核心子系统（如workqueue、cpuhp）已经建立的、更深层次的内部组件。它并非内存管理的最早期初始化（如物理页帧分配器的建立），而是一个第二阶段的、功能性的初始化  12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/* * 这是一个静态的、仅在初始化阶段调用的函数，负责初始化内存管理（MM）的内部组件。 */void __init init_mm_internals(void)&#123;	/* ret: 用于接收函数返回值，__maybe_unused属性告诉编译器，在某些配置下	 *      （如非SMP），这个变量可能未被使用，不要因此产生警告。*/	int ret __maybe_unused;	/*	 * 为MM子系统分配一个名为&quot;mm_percpu_...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/c674e474/" title="init"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/06.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-03</div><div class="info-item-2">init</div></div><div class="info-2"><div class="info-item-1"> [TOC] init&#x2F;init_task.c 内核线程的一个核心特征是：它们没有自己独立的用户地址空间。它们只在内核空间运行，而内核地址空间是所有进程共享的。因此，内核线程不需要一个属于自己的内存描述符 struct mm_struct，所以它们的 task-&gt;mm 指针通常是 NULL  init_task 就是大名鼎鼎的 PID 0 进程，也常被称为 swapper 进程。从它的标志位 .flags &#x3D; PF_KTHREAD 可以看出，它是一个内核线程。  init_task 的调度策略(policy)是 SCHED_NORMAL，这意味着它是一个普通的分时调度任务，而不是实时任务。但是初始化阶段调用了init_idle()，使得它的sched_class 是 SCHED_IDLE，这样它就可以作为 CPU 的空闲任务运行。但是fork出来的其他进程继承的还是 SCHED_NORMAL 策略。  进程的“始祖”：init_task 是系统中所有进程的祖先。在系统启动后，它会创建第一个内核线程 kernel_init（它最终会成为 PID 1 的 i...</div></div></div></a><a class="pagination-related" href="/posts/d32d8ac9/" title="clocksource"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/02.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-03</div><div class="info-item-2">clocksource</div></div><div class="info-2"><div class="info-item-1">[TOC] clocksource 内核时钟源(Kernel Clocksource) 为内核提供统一的时间基准历史与背景这项技术是为了解决什么特定问题而诞生的？clocksource框架的诞生是为了解决Linux内核中一个根本性的问题：如何以一种统一、可移植的方式来处理多样化的硬件计时器。  硬件的多样性：不同的CPU架构和平台提供了五花八门的硬件计时器，例如x86上的TSC（时间戳计数器）、HPET（高精度事件定时器）、ACPI PM Timer，以及ARM平台上的Architected Timer等。这些计时器的精度、速度、稳定性和编程接口各不相同。 缺乏统一抽象：在clocksource框架出现之前，内核中的时间管理代码与特定的硬件架构和计时器紧密耦合。这使得将内核移植到新平台变得困难，也难以在运行时动态选择最优的计时器硬件。 对高精度的需求：随着系统应用（如实时系统、高频交易、性能剖析）对时间精度要求的提高，内核需要一个能够充分利用现代高精度计时器硬件的框架。  clocksource框架通过创建一个通用的抽象层，将这些底层硬件计时器的差异性隐藏起来，为内核的上层时间子...</div></div></div></a><a class="pagination-related" href="/posts/5a79feca/" title="dma"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/02.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-03</div><div class="info-item-2">dma</div></div><div class="info-2"><div class="info-item-1">[TOC] drivers&#x2F;dma DMA引擎与映射(DMA Engine &amp; Mapping) 内核统一的直接内存访问框架历史与背景这项技术是为了解决什么特定问题而诞生的？DMA（Direct Memory Access，直接内存访问）框架的诞生是为了解决一个根本性的性能瓶颈问题，并为内核提供一个统一、可移植的解决方案。  解决CPU性能瓶颈：在没有DMA的系统中，当外设（如网卡、磁盘）需要与内存交换大量数据时，CPU必须亲自担当“搬运工”的角色。这种方式被称为PIO（Programmed I&#x2F;O），CPU需要逐字节或逐字地从设备读取数据再写入内存，或者反之。对于高速设备，这会消耗大量的CPU周期，导致CPU无暇处理其他计算任务，严重影响系统整体性能。DMA技术通过引入一个专门的硬件控制器（DMAC），允许外设在没有CPU干预的情况下直接与内存进行数据传输，从而将CPU解放出来。 抽象硬件差异：不同的CPU架构和SoC平台，其DMA控制器的设计和编程接口千差万别。如果没有一个统一的软件框架，设备驱动程序的开发者将不得不为每一种不同的DMAC编写特定的...</div></div></div></a><a class="pagination-related" href="/posts/6ce74947/" title="regmap"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/08.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-03</div><div class="info-item-2">regmap</div></div><div class="info-2"><div class="info-item-1">[TOC] regmapRegmap 简介Regmap 是 Linux 内核中的一个子系统，用于抽象和管理设备寄存器的访问。它为驱动程序提供了统一的接口，支持多种总线（如 I2C、SPI、MMIO 等）上的寄存器操作，同时提供了缓存、锁机制和调试功能。Regmap 的设计目标是简化驱动开发，减少重复代码，并提高寄存器访问的效率和安全性。  工作原理1. 核心概念 寄存器映射 (Register Map):Regmap 将设备的寄存器抽象为一个统一的映射，屏蔽了底层总线的差异。  寄存器缓存:Regmap 提供了可选的寄存器缓存机制，用于减少总线访问次数，提高性能。  寄存器访问控制:通过配置文件（struct regmap_config），可以定义哪些寄存器是可读、可写或易失的。  总线适配器:Regmap 支持多种总线（如 I2C、SPI、MMIO 等），通过总线适配器实现具体的读写操作。   2. 数据结构 struct regmap:表示寄存器映射的核心数据结构，包含寄存器的地址、值、缓存等信息。  struct regmap_config:配置寄存器映射的结构体，用于定义...</div></div></div></a><a class="pagination-related" href="/posts/ba80502e/" title="cpu"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/03.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-03</div><div class="info-item-2">cpu</div></div><div class="info-2"><div class="info-item-1">[TOC] include&#x2F;linux&#x2F;cpumask.hcpumask_check 验证当前cpu数量是否超过了配置的最大cpu数量,并返回cpu1234567891011121314151617// 验证当前cpu数量是否超过了配置的最大cpu数量static __always_inline void cpu_max_bits_warn(unsigned int cpu, unsigned int bits)&#123;#ifdef CONFIG_DEBUG_PER_CPU_MAPS	WARN_ON_ONCE(cpu &gt;= bits);#endif /* CONFIG_DEBUG_PER_CPU_MAPS */&#125;/* verify cpu argument to cpumask_* operators *///验证当前cpu数量是否超过了配置的最大cpu数量static __always_inline unsigned int cpumask_check(unsigned int cpu)&#123;    //small_cpumask_...</div></div></div></a><a class="pagination-related" href="/posts/dd631879/" title="kallsyms"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/08.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-06</div><div class="info-item-2">kallsyms</div></div><div class="info-2"><div class="info-item-1">  [TOC] kernel&#x2F;kallsyms.c 内核符号表(Kernel Symbols) 运行时内核符号解析 历史与背景这项技术是为了解决什么特定问题而诞生的？kallsyms（Kernel All Symbols）机制的诞生是为了解决在内核运行时动态解析符号地址的核心需求。一个符号（Symbol）是程序中的一个构建块，通常指代一个函数名或变量名。内核在运行时，更倾向于直接使用内存地址（如 0xffffffff81c33580）而不是符号名（如 schedule）。 然而，在很多场景下，将地址转换回人类可读的符号名是至关重要的：  内核调试与错误分析：当内核发生严重错误（Kernel Panic）或“oops”时，它会打印出当时的寄存器状态和函数调用栈（Call Trace）。 如果调用栈仅仅是一串十六进制地址，那么对于开发者来说几乎是无用的。kallsyms 机制使得内核能够在崩溃时，当场将这些地址解析成具体的函数名和偏移量，极大地简化了调试过程。 动态模块加载：内核模块（Loadable Kernel Modules, LKM）在加载时需要链接到内核主镜像中的...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/avatar.png" onerror="this.onerror=null;this.src='/images/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Liya Huang</div><div class="author-info-description">WORK-LIFE BALANCE</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">417</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">49</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">53</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/wdfk-prog"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/wdfk-prog" rel="external nofollow noreferrer" target="_blank" title="GitHub"><i class="fab fa-github" style="color: #181717;"></i></a><a class="social-icon" href="https://wdfk-prog.blog.csdn.net/" rel="external nofollow noreferrer" target="_blank" title="CSDN"><i class="fas fa-blog" style="color: #FC5531;"></i></a><a class="social-icon" href="mailto:1425075683@qq.com" rel="external nofollow noreferrer" target="_blank" title="E-mail"><i class="fas fa-envelope" style="color: #4A4A4A;"></i></a><a class="social-icon" href="/images/wechat-qrcode.jpg" target="_blank" title="微信公众号"><i class="fab fa-weixin" style="color: #07C160;"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss" style="color: #EE802F;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎光临！有任何问题或想法，欢迎在文章下留言交流，或者通过 <a href='/about/'>关于页面</a> 联系我。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#mm-slub-c-SLUB%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8-The-SLUB-Allocator-%E7%8E%B0%E4%BB%A3%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1%E7%BC%93%E5%AD%98%E7%9A%84%E6%A0%B8%E5%BF%83"><span class="toc-number">1.</span> <span class="toc-text">mm&#x2F;slub.c SLUB内存分配器(The SLUB Allocator) 现代内核对象缓存的核心</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%86%E5%8F%B2%E4%B8%8E%E8%83%8C%E6%99%AF"><span class="toc-number">1.0.1.</span> <span class="toc-text">历史与背景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%99%E9%A1%B9%E6%8A%80%E6%9C%AF%E6%98%AF%E4%B8%BA%E4%BA%86%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E7%89%B9%E5%AE%9A%E9%97%AE%E9%A2%98%E8%80%8C%E8%AF%9E%E7%94%9F%E7%9A%84%EF%BC%9F"><span class="toc-number">1.0.1.1.</span> <span class="toc-text">这项技术是为了解决什么特定问题而诞生的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%83%E7%9A%84%E5%8F%91%E5%B1%95%E7%BB%8F%E5%8E%86%E4%BA%86%E5%93%AA%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9A%84%E9%87%8C%E7%A8%8B%E7%A2%91%E6%88%96%E7%89%88%E6%9C%AC%E8%BF%AD%E4%BB%A3%EF%BC%9F"><span class="toc-number">1.0.1.2.</span> <span class="toc-text">它的发展经历了哪些重要的里程碑或版本迭代？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E5%89%8D%E8%AF%A5%E6%8A%80%E6%9C%AF%E7%9A%84%E7%A4%BE%E5%8C%BA%E6%B4%BB%E8%B7%83%E5%BA%A6%E5%92%8C%E4%B8%BB%E6%B5%81%E5%BA%94%E7%94%A8%E6%83%85%E5%86%B5%E5%A6%82%E4%BD%95%EF%BC%9F"><span class="toc-number">1.0.1.3.</span> <span class="toc-text">目前该技术的社区活跃度和主流应用情况如何？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.0.2.</span> <span class="toc-text">核心原理与设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%83%E7%9A%84%E6%A0%B8%E5%BF%83%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.0.2.1.</span> <span class="toc-text">它的核心工作原理是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%83%E7%9A%84%E4%B8%BB%E8%A6%81%E4%BC%98%E5%8A%BF%E4%BD%93%E7%8E%B0%E5%9C%A8%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2%EF%BC%9F"><span class="toc-number">1.0.2.2.</span> <span class="toc-text">它的主要优势体现在哪些方面？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%83%E5%AD%98%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%B7%B2%E7%9F%A5%E7%9A%84%E5%8A%A3%E5%8A%BF%E3%80%81%E5%B1%80-%E9%99%90%E6%80%A7%E6%88%96%E5%9C%A8%E7%89%B9%E5%AE%9A%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E4%B8%8D%E9%80%82%E7%94%A8%E6%80%A7%EF%BC%9F"><span class="toc-number">1.0.2.3.</span> <span class="toc-text">它存在哪些已知的劣势、局-限性或在特定场景下的不适用性？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.0.3.</span> <span class="toc-text">使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%85%B7%E4%BD%93%E7%9A%84%E4%B8%9A%E5%8A%A1%E6%88%96%E6%8A%80%E6%9C%AF%E5%9C%BA%E6%99%AF%E4%B8%8B%EF%BC%8C%E5%AE%83%E6%98%AF%E9%A6%96%E9%80%89%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9F%E8%AF%B7%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%E3%80%82"><span class="toc-number">1.0.3.1.</span> <span class="toc-text">在哪些具体的业务或技术场景下，它是首选解决方案？请举例说明。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E5%90%A6%E6%9C%89%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E8%AF%A5%E6%8A%80%E6%9C%AF%E7%9A%84%E5%9C%BA%E6%99%AF%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.0.3.2.</span> <span class="toc-text">是否有不推荐使用该技术的场景？为什么？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90"><span class="toc-number">1.0.4.</span> <span class="toc-text">对比分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E5%B0%86%E5%85%B6-%E4%B8%8E-%E5%85%B6%E4%BB%96%E7%9B%B8%E4%BC%BC%E6%8A%80%E6%9C%AF-%E8%BF%9B%E8%A1%8C%E8%AF%A6%E7%BB%86%E5%AF%B9%E6%AF%94%E3%80%82"><span class="toc-number">1.0.4.1.</span> <span class="toc-text">请将其 与 其他相似技术 进行详细对比。</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mm-folio-c-%E5%86%85%E5%AD%98%E9%A1%B5%E6%9D%9F-Memory-Folios-%E7%AE%80%E5%8C%96%E5%A4%A7%E9%A1%B5%E5%92%8C%E9%A1%B5%E9%9D%A2%E7%BC%93%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">mm&#x2F;folio.c 内存页束(Memory Folios) 简化大页和页面缓存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%86%E5%8F%B2%E4%B8%8E%E8%83%8C%E6%99%AF-1"><span class="toc-number">2.0.1.</span> <span class="toc-text">历史与背景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%99%E9%A1%B9%E6%8A%80%E6%9C%AF%E6%98%AF%E4%B8%BA%E4%BA%86%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E7%89%B9%E5%AE%9A%E9%97%AE%E9%A2%98%E8%80%8C%E8%AF%9E%E7%94%9F%E7%9A%84%EF%BC%9F-1"><span class="toc-number">2.0.1.1.</span> <span class="toc-text">这项技术是为了解决什么特定问题而诞生的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%83%E7%9A%84%E5%8F%91%E5%B1%95%E7%BB%8F%E5%8E%86%E4%BA%86%E5%93%AA%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9A%84%E9%87%8C%E7%A8%8B%E7%A2%91%E6%88%96%E7%89%88%E6%9C%AC%E8%BF%AD%E4%BB%A3%EF%BC%9F-1"><span class="toc-number">2.0.1.2.</span> <span class="toc-text">它的发展经历了哪些重要的里程碑或版本迭代？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E5%89%8D%E8%AF%A5%E6%8A%80%E6%9C%AF%E7%9A%84%E7%A4%BE%E5%8C%BA%E6%B4%BB%E8%B7%83%E5%BA%A6%E5%92%8C%E4%B8%BB%E6%B5%81%E5%BA%94%E7%94%A8%E6%83%85%E5%86%B5%E5%A6%82%E4%BD%95%EF%BC%9F-1"><span class="toc-number">2.0.1.3.</span> <span class="toc-text">目前该技术的社区活跃度和主流应用情况如何？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AE%BE%E8%AE%A1-1"><span class="toc-number">2.0.2.</span> <span class="toc-text">核心原理与设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%83%E7%9A%84%E6%A0%B8%E5%BF%83%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-1"><span class="toc-number">2.0.2.1.</span> <span class="toc-text">它的核心工作原理是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%83%E7%9A%84%E4%B8%BB%E8%A6%81%E4%BC%98%E5%8A%BF%E4%BD%93%E7%8E%B0%E5%9C%A8%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2%EF%BC%9F-1"><span class="toc-number">2.0.2.2.</span> <span class="toc-text">它的主要优势体现在哪些方面？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%83%E5%AD%98%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%B7%B2%E7%9F%A5%E7%9A%84%E5%8A%A3%E5%8A%BF%E3%80%81%E5%B1%80%E9%99%90%E6%80%A7%E6%88%96%E5%9C%A8%E7%89%B9%E5%AE%9A%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E4%B8%8D%E9%80%82%E7%94%A8%E6%80%A7%EF%BC%9F"><span class="toc-number">2.0.2.3.</span> <span class="toc-text">它存在哪些已知的劣势、局限性或在特定场景下的不适用性？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-number">2.0.3.</span> <span class="toc-text">使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%85%B7%E4%BD%93%E7%9A%84%E4%B8%9A%E5%8A%A1%E6%88%96%E6%8A%80%E6%9C%AF%E5%9C%BA%E6%99%AF%E4%B8%8B%EF%BC%8C%E5%AE%83%E6%98%AF%E9%A6%96%E9%80%89%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9F%E8%AF%B7%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%E3%80%82-1"><span class="toc-number">2.0.3.1.</span> <span class="toc-text">在哪些具体的业务或技术场景下，它是首选解决方案？请举例说明。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E5%90%A6%E6%9C%89%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E8%AF%A5%E6%8A%80%E6%9C%AF%E7%9A%84%E5%9C%BA%E6%99%AF%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F-1"><span class="toc-number">2.0.3.2.</span> <span class="toc-text">是否有不推荐使用该技术的场景？为什么？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90-1"><span class="toc-number">2.0.4.</span> <span class="toc-text">对比分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E5%B0%86%E5%85%B6-%E4%B8%8E-%E5%85%B6%E4%BB%96%E7%9B%B8%E4%BC%BC%E6%8A%80%E6%9C%AF-%E8%BF%9B%E8%A1%8C%E8%AF%A6%E7%BB%86%E5%AF%B9%E6%AF%94%E3%80%82-1"><span class="toc-number">2.0.4.1.</span> <span class="toc-text">请将其 与 其他相似技术 进行详细对比。</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#include-asm-generic-getorder-h"><span class="toc-number">3.</span> <span class="toc-text">include&#x2F;asm-generic&#x2F;getorder.h</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#get-order-%E8%AE%A1%E7%AE%97%E7%BB%99%E5%AE%9A%E5%A4%A7%E5%B0%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%9D%97%E6%89%80%E9%9C%80%E7%9A%84%E9%A1%B5%E6%95%B0"><span class="toc-number">3.1.</span> <span class="toc-text">get_order 计算给定大小的内存块所需的页数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mm-slab-h"><span class="toc-number">4.</span> <span class="toc-text">mm&#x2F;slab.h</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#folio-slab-%E5%B0%86-folio-%E8%BD%AC%E6%8D%A2%E4%B8%BA-slab-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">4.1.</span> <span class="toc-text">folio_slab 将 folio 转换为 slab 结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#slab-folio-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">4.2.</span> <span class="toc-text">slab folio 结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kmem-cache-args-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">4.3.</span> <span class="toc-text">kmem_cache_args 结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kmalloc-index-%E8%AE%A1%E7%AE%97-kmalloc-%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="toc-number">4.4.</span> <span class="toc-text">kmalloc_index 计算 kmalloc 的索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kmalloc-type-%E8%AE%A1%E7%AE%97-kmalloc-%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.5.</span> <span class="toc-text">kmalloc_type 计算 kmalloc 的类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kmalloc-%E5%88%86%E9%85%8D%E5%86%85%E6%A0%B8%E5%86%85%E5%AD%98"><span class="toc-number">4.6.</span> <span class="toc-text">kmalloc 分配内核内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kzalloc-%E5%88%86%E9%85%8D%E5%B9%B6%E6%B8%85%E9%9B%B6%E5%86%85%E6%A0%B8%E5%86%85%E5%AD%98"><span class="toc-number">4.7.</span> <span class="toc-text">kzalloc 分配并清零内核内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kcalloc-%E5%88%86%E9%85%8D%E6%95%B0%E7%BB%84%E5%B9%B6%E6%B8%85%E9%9B%B6"><span class="toc-number">4.8.</span> <span class="toc-text">kcalloc 分配数组并清零</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kmem-cache-zalloc-%E5%88%86%E9%85%8D-slab-%E7%BC%93%E5%AD%98%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98"><span class="toc-number">4.9.</span> <span class="toc-text">kmem_cache_zalloc 分配 slab 缓存中的内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kmem-cache-create-usercopy-%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E6%8B%B7%E8%B4%9D%E7%BC%93%E5%AD%98"><span class="toc-number">4.10.</span> <span class="toc-text">kmem_cache_create_usercopy 创建用户拷贝缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kmem-cache-default-args-%E5%88%9B%E5%BB%BA%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E7%9A%84-slab-%E7%BC%93%E5%AD%98"><span class="toc-number">4.11.</span> <span class="toc-text">__kmem_cache_default_args 创建默认参数的 slab 缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kmem-cache-create-%E5%88%9B%E5%BB%BA-slab-%E7%BC%93%E5%AD%98-%E4%BC%A0%E5%85%A5%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E5%AF%B9%E9%BD%90%E5%80%BC"><span class="toc-number">4.12.</span> <span class="toc-text">__kmem_cache_create 创建 slab 缓存 传入构造函数与对齐值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kmem-cache-create-%E5%88%9B%E5%BB%BA-slab-%E7%BC%93%E5%AD%98"><span class="toc-number">4.13.</span> <span class="toc-text">kmem_cache_create 创建 slab 缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KMEM-CACHE-%E5%88%9B%E5%BB%BA-slab-%E7%BC%93%E5%AD%98"><span class="toc-number">4.14.</span> <span class="toc-text">KMEM_CACHE 创建 slab 缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kmem-cache-alloc-lru-noprof-%E5%88%86%E9%85%8D-LRU-%E7%BC%93%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.15.</span> <span class="toc-text">kmem_cache_alloc_lru_noprof 分配 LRU 缓存中的对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kvmalloc-array-%E5%88%86%E9%85%8D%E5%A4%A7%E6%95%B0%E7%BB%84"><span class="toc-number">4.16.</span> <span class="toc-text">kvmalloc_array 分配大数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kmalloc-slab-%E6%9F%A5%E6%89%BE-kmalloc-%E7%BC%93%E5%AD%98"><span class="toc-number">4.17.</span> <span class="toc-text">kmalloc_slab 查找 kmalloc 缓存</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#include-linux-slab-h"><span class="toc-number">5.</span> <span class="toc-text">include&#x2F;linux&#x2F;slab.h</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#kmem-cache-alloc-node-%E5%9C%A8%E6%8C%87%E5%AE%9A%E8%8A%82%E7%82%B9%E4%B8%8A%E5%88%86%E9%85%8D%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.1.</span> <span class="toc-text">kmem_cache_alloc_node 在指定节点上分配对象</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#include-linux-vmalloc-h"><span class="toc-number">6.</span> <span class="toc-text">include&#x2F;linux&#x2F;vmalloc.h</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#vmalloc-%E5%88%86%E9%85%8D%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-number">6.1.</span> <span class="toc-text">__vmalloc 分配虚拟内存</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mm-slab-common-c"><span class="toc-number">7.</span> <span class="toc-text">mm&#x2F;slab_common.c</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#calculate-alignment-%E8%AE%A1%E7%AE%97%E5%AF%B9%E9%BD%90%E8%A6%81%E6%B1%82"><span class="toc-number">7.1.</span> <span class="toc-text">calculate_alignment 计算对齐要求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#create-boot-cache-%E5%9C%A8%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E9%98%B6%E6%AE%B5%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA-slab-%E7%BC%93%E5%AD%98"><span class="toc-number">7.2.</span> <span class="toc-text">create_boot_cache 在系统启动阶段创建一个 slab 缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#slab-unmergeable-%E6%A3%80%E6%9F%A5-slab-%E6%98%AF%E5%90%A6%E4%B8%8D%E5%8F%AF%E5%90%88%E5%B9%B6"><span class="toc-number">7.3.</span> <span class="toc-text">slab_unmergeable 检查 slab 是否不可合并</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#setup-kmalloc-cache-index-table-%E8%AE%BE%E7%BD%AE-kmalloc-%E7%BC%93%E5%AD%98%E7%B4%A2%E5%BC%95%E8%A1%A8"><span class="toc-number">7.4.</span> <span class="toc-text">setup_kmalloc_cache_index_table 设置 kmalloc 缓存索引表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new-kmalloc-cache-%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84-kmalloc-%E7%BC%93%E5%AD%98"><span class="toc-number">7.5.</span> <span class="toc-text">new_kmalloc_cache 创建新的 kmalloc 缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#create-kmalloc-caches-%E5%88%9B%E5%BB%BA-kmalloc-%E7%BC%93%E5%AD%98"><span class="toc-number">7.6.</span> <span class="toc-text">create_kmalloc_caches 创建 kmalloc 缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#create-cache-%E5%88%9B%E5%BB%BA-slab-%E7%BC%93%E5%AD%98"><span class="toc-number">7.7.</span> <span class="toc-text">create_cache 创建 slab 缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kmem-cache-create-args-%E5%88%9B%E5%BB%BA-kmem-cache"><span class="toc-number">7.8.</span> <span class="toc-text">__kmem_cache_create_args 创建 kmem_cache</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mm-slub-c"><span class="toc-number">8.</span> <span class="toc-text">mm&#x2F;slub.c</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#order-objects-%E8%AE%A1%E7%AE%97%E5%9C%A8%E7%BB%99%E5%AE%9A%E9%98%B6%E6%95%B0%EF%BC%88order%EF%BC%89%E4%B8%8B%EF%BC%8C%E4%B8%80%E4%B8%AA-slab-%E4%B8%AD%E5%8F%AF%E4%BB%A5%E5%AE%B9%E7%BA%B3%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%95%B0%E9%87%8F"><span class="toc-number">8.1.</span> <span class="toc-text">order_objects 计算在给定阶数（order）下，一个 slab 中可以容纳的对象数量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#calc-slab-order-%E6%A0%B9%E6%8D%AE-slab-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%A7%E5%B0%8F%EF%BC%88size%EF%BC%89%E8%AE%A1%E7%AE%97%E5%88%86%E9%85%8D%E7%9A%84%E9%98%B6%E6%95%B0%EF%BC%88order%EF%BC%89"><span class="toc-number">8.2.</span> <span class="toc-text">calc_slab_order 根据 slab 对象的大小（size）计算分配的阶数（order）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#calculate-order-%E8%AE%A1%E7%AE%97-slab-%E7%9A%84%E9%98%B6%E6%95%B0%EF%BC%88order%EF%BC%89"><span class="toc-number">8.3.</span> <span class="toc-text">calculate_order 计算 slab 的阶数（order）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#oo-make-%E6%8F%8F%E8%BF%B0-slab-%E7%9A%84%E5%88%86%E9%85%8D%E9%85%8D%E7%BD%AE"><span class="toc-number">8.4.</span> <span class="toc-text">oo_make 描述 slab 的分配配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#oo-objects-%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E6%95%B0%E9%87%8F"><span class="toc-number">8.5.</span> <span class="toc-text">oo_objects 获取对象数量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#calculate-sizes-%E8%AE%A1%E7%AE%97-slab-%E7%BC%93%E5%AD%98%E4%B8%AD%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%83%E5%B1%80"><span class="toc-number">8.6.</span> <span class="toc-text">calculate_sizes 计算 slab 缓存中对象的布局</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#alloc-slab-page-%E5%88%86%E9%85%8D%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84-slab-%E9%A1%B5%E9%9D%A2"><span class="toc-number">8.7.</span> <span class="toc-text">alloc_slab_page 分配一个新的 slab 页面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#set-freepointer-%E8%AE%BE%E7%BD%AE%E7%A9%BA%E9%97%B2%E6%8C%87%E9%92%88"><span class="toc-number">8.8.</span> <span class="toc-text">set_freepointer 设置空闲指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#setup-object-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AF%B9%E8%B1%A1"><span class="toc-number">8.9.</span> <span class="toc-text">setup_object 初始化对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#allocate-slab-%E5%88%86%E9%85%8D%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84-slab"><span class="toc-number">8.10.</span> <span class="toc-text">allocate_slab 分配一个新的 slab</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new-slab-%E4%B8%BA%E6%8C%87%E5%AE%9A%E7%9A%84-kmem-cache-%E5%88%86%E9%85%8D%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84-slab"><span class="toc-number">8.11.</span> <span class="toc-text">new_slab 为指定的 kmem_cache 分配一个新的 slab</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94-%E5%86%85%E5%AD%98%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94"><span class="toc-number">8.12.</span> <span class="toc-text">—————-内存初始化相关函数——————</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#init-kmem-cache-node-%E5%88%9D%E5%A7%8B%E5%8C%96-kmem-cache-node-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">8.13.</span> <span class="toc-text">init_kmem_cache_node 初始化 kmem_cache_node 结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#add-partial-%E6%B7%BB%E5%8A%A0-slab-%E5%88%B0%E9%83%A8%E5%88%86%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8"><span class="toc-number">8.14.</span> <span class="toc-text">__add_partial 添加 slab 到部分空闲链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#early-kmem-cache-node-alloc-%E6%97%A9%E6%9C%9F%E5%88%86%E9%85%8D-kmem-cache-node"><span class="toc-number">8.15.</span> <span class="toc-text">early_kmem_cache_node_alloc 早期分配 kmem_cache_node</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#init-kmem-cache-nodes-%E5%88%9D%E5%A7%8B%E5%8C%96-NUMA-%E8%8A%82%E7%82%B9%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE"><span class="toc-number">8.16.</span> <span class="toc-text">init_kmem_cache_nodes 初始化 NUMA 节点相关数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#alloc-kmem-cache-cpus-%E5%88%86%E9%85%8D-CPU-%E7%9B%B8%E5%85%B3%E7%9A%84-slab-%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE"><span class="toc-number">8.17.</span> <span class="toc-text">alloc_kmem_cache_cpus 分配 CPU 相关的 slab 缓存数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sysfs-slab-add-%E5%B0%86-slab-%E7%BC%93%E5%AD%98%E6%B7%BB%E5%8A%A0%E5%88%B0-sysfs-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%AD"><span class="toc-number">8.18.</span> <span class="toc-text">sysfs_slab_add 将 slab 缓存添加到 sysfs 文件系统中</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kmem-cache-release-%E9%87%8A%E6%94%BE-slab-%E7%BC%93%E5%AD%98"><span class="toc-number">8.19.</span> <span class="toc-text">__kmem_cache_release 释放 slab 缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#do-kmem-cache-create-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84-slab-%E7%BC%93%E5%AD%98%EF%BC%88slab-cache%EF%BC%89"><span class="toc-number">8.20.</span> <span class="toc-text">do_kmem_cache_create 创建一个新的 slab 缓存（slab cache）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bootstrap-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%A9%E6%9C%9F-kmem-cache-%E7%BB%93%E6%9E%84"><span class="toc-number">8.21.</span> <span class="toc-text">bootstrap 初始化早期 kmem_cache 结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kmem-cache-init-%E5%88%9D%E5%A7%8B%E5%8C%96-kmem-cache-%E5%92%8C-kmem-cache-node"><span class="toc-number">8.22.</span> <span class="toc-text">kmem_cache_init  初始化 kmem_cache 和 kmem_cache_node</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kmem-cache-init-late-Kmem-%E7%BC%93%E5%AD%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%BB%B6%E8%BF%9F"><span class="toc-number">8.23.</span> <span class="toc-text">kmem_cache_init_late Kmem 缓存初始化延迟</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94"><span class="toc-number">8.24.</span> <span class="toc-text">—————-内存分配相关函数——————</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#slab-lock-slab-unlock"><span class="toc-number">8.25.</span> <span class="toc-text">slab_lock slab_unlock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#get-freelist-%E8%8E%B7%E5%8F%96-slab-%E7%9A%84%E7%A9%BA%E9%97%B2%E5%88%97%E8%A1%A8"><span class="toc-number">8.26.</span> <span class="toc-text">get_freelist 获取 slab 的空闲列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#get-partial-%E8%8E%B7%E5%8F%96%E9%83%A8%E5%88%86-slab-%E7%9A%84%E7%A9%BA%E9%97%B2%E5%88%97%E8%A1%A8"><span class="toc-number">8.27.</span> <span class="toc-text">get_partial 获取部分 slab 的空闲列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#deactivate-slab-%E5%A4%84%E7%90%86-slab-%E7%9A%84%E5%8E%BB%E6%BF%80%E6%B4%BB"><span class="toc-number">8.28.</span> <span class="toc-text">deactivate_slab 处理 slab 的去激活</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#slab-alloc-%E6%85%A2%E9%80%9F%E5%88%86%E9%85%8D%E5%87%BD%E6%95%B0"><span class="toc-number">8.29.</span> <span class="toc-text">__slab_alloc 慢速分配函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#slab-alloc-node-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%87%BD%E6%95%B0"><span class="toc-number">8.30.</span> <span class="toc-text">__slab_alloc_node 内存分配函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#slab-alloc-node-%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="toc-number">8.31.</span> <span class="toc-text">slab_alloc_node 分配内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kmalloc-cache-noprof-%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="toc-number">8.32.</span> <span class="toc-text">__kmalloc_cache_noprof 分配内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kmem-cache-alloc-lru-noprof-%E5%88%86%E9%85%8DLRU%E5%86%85%E5%AD%98"><span class="toc-number">8.33.</span> <span class="toc-text">kmem_cache_alloc_lru_noprof 分配LRU内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kmalloc-large-node-noprof-%E5%88%86%E9%85%8D%E5%A4%A7%E5%86%85%E5%AD%98%E5%9D%97"><span class="toc-number">8.34.</span> <span class="toc-text">__kmalloc_large_node_noprof 分配大内存块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#do-kmalloc-node-%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="toc-number">8.35.</span> <span class="toc-text">__do_kmalloc_node 分配内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kvmalloc-node-%E5%B0%9D%E8%AF%95%E5%88%86%E9%85%8D%E7%89%A9%E7%90%86%E4%B8%8A%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%9D%97%E3%80%82%E5%A6%82%E6%9E%9C%E5%88%86%E9%85%8D%E5%A4%B1%E8%B4%A5%EF%BC%8C%E5%88%99%E4%BC%9A%E5%9B%9E%E9%80%80%E5%88%B0%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%EF%BC%88%E9%80%9A%E8%BF%87-vmalloc%EF%BC%89"><span class="toc-number">8.36.</span> <span class="toc-text">__kvmalloc_node 尝试分配物理上连续的内存块。如果分配失败，则会回退到非连续内存分配（通过 vmalloc）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%93%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94"><span class="toc-number">8.37.</span> <span class="toc-text">——————–内存释放相关函数——————</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#slab-free-%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98"><span class="toc-number">8.38.</span> <span class="toc-text">__slab_free 释放内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#do-slab-free-%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98"><span class="toc-number">8.39.</span> <span class="toc-text">do_slab_free 释放内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#slab-free-%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98-1"><span class="toc-number">8.40.</span> <span class="toc-text">slab_free 释放内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kfree-%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98"><span class="toc-number">8.41.</span> <span class="toc-text">kfree 释放内存</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/48974a1a/" title="mq-deadline"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/08.jpg" onerror="this.onerror=null;this.src='/images/404.jpg'" alt="mq-deadline"/></a><div class="content"><a class="title" href="/posts/48974a1a/" title="mq-deadline">mq-deadline</a><time datetime="2025-10-10T09:35:34.893Z" title="更新于 2025-10-10 17:35:34">2025-10-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/44c8f818/" title="list"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/10.jpg" onerror="this.onerror=null;this.src='/images/404.jpg'" alt="list"/></a><div class="content"><a class="title" href="/posts/44c8f818/" title="list">list</a><time datetime="2025-10-10T08:51:23.325Z" title="更新于 2025-10-10 16:51:23">2025-10-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/447af9b5/" title="genhd"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/09.jpg" onerror="this.onerror=null;this.src='/images/404.jpg'" alt="genhd"/></a><div class="content"><a class="title" href="/posts/447af9b5/" title="genhd">genhd</a><time datetime="2025-10-10T08:50:59.612Z" title="更新于 2025-10-10 16:50:59">2025-10-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/ed4b199f/" title="class"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/01.jpg" onerror="this.onerror=null;this.src='/images/404.jpg'" alt="class"/></a><div class="content"><a class="title" href="/posts/ed4b199f/" title="class">class</a><time datetime="2025-10-10T08:38:03.324Z" title="更新于 2025-10-10 16:38:03">2025-10-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/aa511041/" title="blk-core"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/07.jpg" onerror="this.onerror=null;this.src='/images/404.jpg'" alt="blk-core"/></a><div class="content"><a class="title" href="/posts/aa511041/" title="blk-core">blk-core</a><time datetime="2025-10-10T08:15:30.737Z" title="更新于 2025-10-10 16:15:30">2025-10-10</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/images/covers/07.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">文档</div><div class="footer-flex-content"><a href="/categories/linux/" target="_blank" title="🚀 linux">🚀 linux</a><a href="/categories/rt-thread/" target="_blank" title="📑 rt-thread">📑 rt-thread</a><a href="/categories/uboot/" target="_blank" title="📌 uboot">📌 uboot</a><a href="/categories/LoraWan/" target="_blank" title="⚔️ LoraWan">⚔️ LoraWan</a><a href="/categories/hpatch/" target="_blank" title="❓ hpatch">❓ hpatch</a><a href="/categories/git/" target="_blank" title="⚡️ git">⚡️ git</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/gallery/" target="_blank" title="图库">图库</a><a href="/messageboard/" target="_blank" title="留言板">留言板</a><a href="/shuoshuo/" target="_blank" title="说说">说说</a><a href="/link/" target="_blank" title="示例">示例</a><a href="/link/" target="_blank" title="友链">友链</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">框架</div><div class="footer-flex-content"><a href="https://hexo.io/zh-cn/" rel="external nofollow noreferrer" target="_blank" title="Hexo">Hexo</a><a href="https://butterfly.js.org/" rel="external nofollow noreferrer" target="_blank" title="Butterfly">Butterfly</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">贊助</div><div class="footer-flex-content"><div><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/alipay.png" alt='wdfk_prog' width='100px' height='100px'></div></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Liya Huang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo 8.0.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.1</a></span></div><div class="footer_custom_text">你好，欢迎来到我的 <a href="/about/">数字花园</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天" style="display:none"><i class="fas fa-message"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script><script>(() => {
  const abcjsInit = () => {
    const abcjsFn = () => {
      setTimeout(() => {
        const sheets = document.querySelectorAll(".abc-music-sheet")
        for (let i = 0; i < sheets.length; i++) {
          const ele = sheets[i]
          if (ele.children.length > 0) continue

          // Parse parameters from data-params attribute
          let params = {}
          const dp = ele.getAttribute("data-params")
          if (dp) {
            try {
              params = JSON.parse(dp)
            } catch (e) {
              console.error("Failed to parse data-params:", e)
            }
          }

          // Merge parsed parameters with the responsive option
          // Ensures params content appears before responsive
          const options = { ...params, responsive: "resize" }

          // Render the music score using ABCJS.renderAbc
          ABCJS.renderAbc(ele, ele.innerHTML, options)
        }
      }, 100)
    }

    if (typeof ABCJS === "object") {
      abcjsFn()
    } else {
      btf.getScript("https://cdn.jsdelivr.net/npm/abcjs/dist/abcjs-basic-min.min.js").then(abcjsFn)
    }
  }

  if (window.pjax) {
    abcjsInit()
  } else {
    window.addEventListener("load", abcjsInit)
  }

  btf.addGlobalFn("encrypt", abcjsInit, "abcjs")
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: 'Ov23livBmwx65h3XIdfT',
      clientSecret: '9f23bdaa2ea11322f9f405d77bcdc27166077a7d',
      repo: 'wdfk-prog.github.io',
      owner: 'wdfk-prog',
      admin: ['wdfk-prog'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || 'efbf4bf10e62c2f221fb0fa6b854e5d1'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script>window.newestComments = {
  changeContent: content => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<code>.*?<\/code>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g, "") // remove html tag

    if (content.length > 150) {
      content = content.substring(0, 150) + '...'
    }
    return content
  },

  generateHtml: (array, ele) => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class="aside-list-item">'

        if (true && array[i].avatar) {
          const imgAttr = 'data-lazy-src'
          const lazyloadNative = ''
          result += `<a href="${array[i].url}" class="thumbnail"><img ${imgAttr}="${array[i].avatar}" alt="${array[i].nick}" ${lazyloadNative}></a>`
        }

        result += `<div class="content">
        <a class="comment" href="${array[i].url}" title="${array[i].content}">${array[i].content}</a>
        <div class="name"><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '暂无评论'
    }

    ele.innerHTML = result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh(ele)
  },

  newestCommentInit: (name, getComment) => {
    const $dom = document.querySelector('#card-newest-comments .aside-list')
    if ($dom) {
      const data = btf.saveToLocal.get(name)
      if (data) {
        newestComments.generateHtml(JSON.parse(data), $dom)
      } else {
        getComment($dom)
      }
    }
  },

  run: (name, getComment) => {
    newestComments.newestCommentInit(name, getComment)
    btf.addGlobalFn('pjaxComplete', () => newestComments.newestCommentInit(name, getComment), name)
  }
}</script><script>window.addEventListener('load', () => {
  const keyName = 'github-newest-comments'
  const { changeContent, generateHtml, run } = window.newestComments

  const findTrueUrl = (array, ele) => {
    Promise.all(array.map(item =>
      fetch(item.url).then(resp => resp.json()).then(data => {
        let urlArray = data.body ? data.body.match(/(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?/ig) : []
        if (!Array.isArray(urlArray) || urlArray.length === 0) {
          urlArray = [`${data.html_url}`]
        }
        if (data.user.login === 'utterances-bot') {
          return urlArray.pop()
        } else {
          return urlArray.shift()
        }
      })
    )).then(res => {
        array = array.map((i,index)=> {
          return {
            ...i,
            url: res[index]
          }
        })

        btf.saveToLocal.set(keyName, JSON.stringify(array), 10/(60*24))
        generateHtml(array, ele)
    });
  }

  const getComment = ele => {
    fetch('https://api.github.com/repos/wdfk-prog/wdfk-prog.github.io/issues/comments?sort=updated&direction=desc&per_page=6&page=1',{
      "headers": {
        Accept: 'application/vnd.github.v3.html+json'
      }
    })
      .then(response => response.json())
      .then(data => {
        const githubArray = data.map(item => {
          return {
            'avatar': item.user.avatar_url,
            'content': changeContent(item.body_html || item.body),
            'nick': item.user.login,
            'url': item.issue_url,
            'date': item.updated_at
          }
        })
        findTrueUrl(githubArray, ele)
      }).catch(e => {
        console.error(e)
        ele.textContent= "无法获取评论，请确认相关配置是否正确"
      })
  }
  run(keyName, getComment)
})</script><div class="aplayer no-destroy" data-id="60198" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="false" data-volume="0.5"></div><script>
  var titleTime, OriginTitile = document.title;
  document.addEventListener("visibilitychange", function() {
    if (document.hidden) {
      titleTime = setTimeout(function() {
        document.title = "w(ﾟДﾟ)w 不要走！再看看嘛！";
      }, 300);
    } else {
      document.title = "♪(^∇^*)欢迎回来！" + OriginTitile;
      titleTime = setTimeout(function() {
        document.title = OriginTitile;
      }, 2000);
    }
  });
</script>
<script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script>(() => {
  window.ChatraID = '5cPWcnA8HKGzg5hoc'
  window.Chatra = window.Chatra || function() {
    (window.Chatra.q = window.Chatra.q || []).push(arguments)
  }

  btf.getScript('https://call.chatra.io/chatra.js').then(() => {
    const isChatBtn = true
    const isChatHideShow = true

    if (isChatBtn) {
      const close = () => {
        Chatra('minimizeWidget')
        Chatra('hide')
      }

      const open = () => {
        Chatra('openChat', true)
        Chatra('show')
      }

      window.ChatraSetup = { startHidden: true }
    
      window.chatBtnFn = () => document.getElementById('chatra').classList.contains('chatra--expanded') ? close() : open()

      document.getElementById('chat-btn').style.display = 'block'
    } else if (isChatHideShow) {
      window.chatBtn = {
        hide: () => Chatra('hide'),
        show: () => Chatra('show')
      }
    }
  })
})()</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: true,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      true
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-MF3J339H" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript></div><script src="https://cdn.jsdelivr.net/npm/echarts@5.5.1/dist/echarts.min.js"></script>
        
        <script>
            document.addEventListener("DOMContentLoaded", function() {
                const heatmapChartDom = document.getElementById('heatmapChart');
                if(heatmapChartDom){
                    const heatmapChart = echarts.init(heatmapChartDom, 'dark');
                    const cellSize = [18, 18];
                    
                    const groupByYear = (data) => {
                        const result = {};
                        data.forEach(([date, value]) => {
                            const [year] = date.split('-').map(Number);
                            if (!result[year]) {
                                result[year] = [];
                            }
                            result[year].push([date, value]);
                        });
                        return result;
                    };
                    
                    const groupedData = groupByYear([["2025-10-03",392],["2025-10-04",5],["2025-10-06",9],["2025-10-07",8],["2025-10-10",3]]);
                    const years = Object.keys(groupedData).reverse();
                    
                    var initYear = parseInt(heatmapChartDom.getAttribute('year')) || new Date().getFullYear();
                    const minYear = years[years.length - 1];
                    const maxYear = years[0];
                    if (initYear < minYear || initYear > maxYear) {
                        initYear = maxYear;
                    }
                    console.log('[hexo-graph]generateHeatmapChart|initYear:', initYear, 'minYear:', minYear, 'maxYear:', maxYear);
                    
                    heatmapChart.setOption({
                        grid: {},
                        tooltip: { 
                            position: 'top', 
                            formatter: params => `${params.value[0]}: ${params.value[1]} Articles` 
                        },
                        calendar: { 
                            top: '10%',
                            left: 'left', 
                            right: '8%',
                            range: initYear,
                            cellSize: cellSize, 
                            splitLine: { lineStyle: { color: '#E0E0E0', width: 1 } }, 
                            itemStyle: { borderWidth: 1, borderColor: '#E0E0E0' }, 
                            dayLabel: { show: false },
                            monthLabel: { show: true },
                            yearLabel: { show: false },
                        },
                        visualMap: { 
                            show: true,
                            right: '8%',
                            bottom: '5%',
                            type: 'piecewise',
                            orient: 'horizontal',
                            text: ['More', 'Less'],
                            min: 0,
                            max: Math.max(...groupedData[initYear].map(item => item[1])),
                            inRange: { color: ["#ACE7AE","#69C16D","#549F57"] }
                        },
                        legend: {
                            type: 'scroll',
                            icon: 'none',
                            data: years,
                            orient: 'vertical',
                            top: '5%',
                            right: 'right',
                            itemWidth: 20,
                            itemHeight: 20,
                            itemGap: 10,
                            pageIconSize: 10,
                            pageTextStyle: { fontSize: 14 },
                            selectedMode: 'single',
                        },
                        series: years.map(year => ({
                            type: 'heatmap',
                            coordinateSystem: 'calendar',
                            data: groupedData[year],
                            name: year,
                            emphasis: {
                                disabled: true,
                            },
                            silent: year !== initYear,
                        })),
                    });
                    
                    // init selected year
                    heatmapChart.dispatchAction({
                        type: 'legendSelect',
                        name: initYear,
                    });
                    
                    heatmapChart.on('legendselectchanged', function(params) {
                        console.log('[hexo-graph]generateHeatmapChart|legendselectchanged:', params);
                        const selectedYear = Object.keys(params.selected).find(key => params.selected[key]);
                        if (selectedYear && groupedData[selectedYear]) {
                            heatmapChart.setOption({
                                calendar: {
                                    range: selectedYear,
                                },
                                visualMap: {
                                    max: Math.max(...groupedData[selectedYear].map(item => item[1])),
                                },
                                series: years.map(year => ({
                                    type: 'heatmap',
                                    coordinateSystem: 'calendar',
                                    data: groupedData[year],
                                    name: year,
                                    emphasis: {
                                        disabled: true,
                                    },
                                    silent: year !== selectedYear,
                                })),
                            });
                        }
                    });
                    
                    heatmapChart.on('click', function (params) {
                        if (params.componentType === 'series') {
                            const [year, month] = params.value[0].split('-');
                            window.location.href = '/archives/' + year + '/' + month;
                        }
                    });
                }
            });
        </script>
    
        
        <script>
            document.addEventListener("DOMContentLoaded", function() {
                const monthlyChartDom = document.getElementById('monthlyChart');
                if(monthlyChartDom){
                    const monthlyChart = echarts.init(monthlyChartDom, 'dark');
                    monthlyChart.setOption({
                        xAxis: { 
                            type: 'category', 
                            data: ["2025-10"], 
                            axisLabel: { fontSize: 14, fontWeight: 'bold', fontFamily: 'Microsoft YaHei, SimSun, serif' }
                        },
                        yAxis: { type: 'value', splitLine: { lineStyle: { type: 'dashed', color: '#ccc' } } },
                        series: [{
                            name: 'Articles',
                            type: 'line',
                            data: [417],
                            smooth: true,
                            lineStyle: { color: '#5470C6', width: 2 },
                            itemStyle: { color: '#5470C6' },
                            areaStyle: { color: 'rgba(84, 112, 198, 0.4)' },
                            symbolSize: 10,
                            label: {
                                show: true,
                                position: 'top',
                                formatter: params => params.value,
                                fontSize: 14,
                                color: '#000',
                                fontWeight: 'bold',
                                fontFamily: 'Microsoft YaHei, SimSun, serif'
                            }
                        }]
                    });

                    monthlyChart.on('click', function (params) {
                        const [year, month] = params.name.split('-');
                        window.location.href = '/archives/' + year + '/' + month;
                    });
                }
            })
        </script>
    
        
        <script>
            document.addEventListener("DOMContentLoaded", function() {
                const tagsChartDom = document.getElementById('tagsChart');
                if(tagsChartDom){
                    const tagsChart = echarts.init(tagsChartDom, 'dark');
                    tagsChart.setOption({
                        tooltip: { trigger: 'item', formatter: '{b}: {c} ({d}%)' },
                        series: [{
                            type: 'pie',
                            radius: '60%',
                            data: [{"name":"linux","value":230},{"name":"uboot","value":68},{"name":"kernel","value":61},{"name":"rt-thread","value":44},{"name":"u-boot分类","value":44},{"name":"drivers","value":39},{"name":"fs","value":37},{"name":"other","value":28}],
                            label: {
                                position: 'outside',
                                formatter: '{b} {c} ({d}%)',
                                fontSize: 14,
                                fontWeight: 'bold',
                                fontFamily: 'Microsoft YaHei, SimSun, serif'
                            },
                            color: ["#5470C6","#91CC75","#FAC858","#EE6666","#73C0DE","#3BA272","#FC8452","#9A60B4"],
                            labelLine: { show: true }
                        }],
                        legend: {
                            bottom: '0',
                            left: 'center',
                            data: [{"name":"linux","value":230},{"name":"uboot","value":68},{"name":"kernel","value":61},{"name":"rt-thread","value":44},{"name":"u-boot分类","value":44},{"name":"drivers","value":39},{"name":"fs","value":37},{"name":"other","value":28}].map(tag => tag.name),
                            textStyle: { fontSize: 14, fontWeight: 'bold', fontFamily: 'Microsoft YaHei, SimSun, serif' }
                        }
                    });

                    tagsChart.on('click', function (params) {
                        window.location.href = '/tags/' + params.name;
                    });
                }
            })
        </script>
    
        
        <script>
            document.addEventListener("DOMContentLoaded", function() {
                const categoriesChartDom = document.getElementById('categoriesChart');
                if(categoriesChartDom){
                    const categoriesChart = echarts.init(categoriesChartDom, 'dark');
                    categoriesChart.setOption({
                        xAxis: { type: 'value', splitLine: { lineStyle: { type: 'dashed', color: '#ccc' } } },
                        yAxis: { 
                            type: 'category', 
                            data: [{"name":"linux","value":230},{"name":"uboot","value":68},{"name":"kernel","value":61},{"name":"rt-thread","value":44},{"name":"u-boot分类","value":44}].map(category => category.name).reverse(), 
                            axisLabel: { fontSize: 14, fontWeight: 'bold', fontFamily: 'Microsoft YaHei, SimSun, serif' }
                        },
                        series: [{
                            name: 'Category Count',
                            type: 'bar',
                            data: [{"name":"linux","value":230},{"name":"uboot","value":68},{"name":"kernel","value":61},{"name":"rt-thread","value":44},{"name":"u-boot分类","value":44}].map(category => category.value).reverse(),
                            label: {
                                show: true,
                                position: 'right',
                                formatter: params => params.value,
                                fontSize: 14,
                                color: '#000',
                                fontWeight: 'bold',
                                fontFamily: 'Microsoft YaHei, SimSun, serif'
                            },
                            itemStyle: {
                                color: new echarts.graphic.LinearGradient(0, 0, 1, 0, [
                                    { offset: 0, color: '#91CC75' },
                                    { offset: 1, color: '#73C0DE' }
                                ])
                            }
                        }]
                    });

                    categoriesChart.on('click', function (params) {
                        window.location.href = '/categories/' + params.name;
                    });
                }
            });
        </script>
    
        
        <script>
            document.addEventListener("DOMContentLoaded", function() {
                const categoriesTreeChartDom = document.getElementById('categoriesTreeChart');
                if(categoriesTreeChartDom){
                    const treeChart = echarts.init(categoriesTreeChartDom, 'dark');
                    treeChart.setOption({
                        title: {
                            text: '操作提示：单击展开分类，双击进入具体分类页面',
                            textStyle: {
                                fontSize: 12,
                                color: '#999',
                                fontWeight: 'normal'
                            },
                            bottom: 0,
                            left: 'center'
                        },
                        tooltip: {
                            trigger: 'item',
                            triggerOn: 'mousemove'
                        },
                        series: [{
                            type: 'tree',
                            data: [{"name":"Categories","children":[{"name":"git","children":[],"count":6,"path":"git"},{"name":"hpatch","children":[{"name":"libdivsufsort","children":[],"count":3,"path":"hpatch/libdivsufsort"},{"name":"SA-IS","children":[],"count":1,"path":"hpatch/SA-IS"}],"count":10,"path":"hpatch"},{"name":"LoraWan","children":[{"name":"LoRaWAN标准","children":[{"name":"LoRaWAN-Specification_ZH_CN","children":[{"name":"LoRaWAN-Specification_ZH_CN-190102","children":[{"name":"chapter","children":[],"count":20,"path":"LoraWan/LoRaWAN标准/LoRaWAN-Specification_ZH_CN/LoRaWAN-Specification_ZH_CN-190102/chapter"}],"count":22,"path":"LoraWan/LoRaWAN标准/LoRaWAN-Specification_ZH_CN/LoRaWAN-Specification_ZH_CN-190102"}],"count":22,"path":"LoraWan/LoRaWAN标准/LoRaWAN-Specification_ZH_CN"}],"count":22,"path":"LoraWan/LoRaWAN标准"}],"count":23,"path":"LoraWan"},{"name":"MCU","children":[],"count":23,"path":"MCU"},{"name":"linux","children":[{"name":"block","children":[],"count":8,"path":"linux/block"},{"name":"include","children":[],"count":10,"path":"linux/include"},{"name":"fs","children":[],"count":37,"path":"linux/fs"},{"name":"drivers","children":[{"name":"base","children":[],"count":14,"path":"linux/drivers/base"},{"name":"tty","children":[],"count":2,"path":"linux/drivers/tty"},{"name":"clk","children":[],"count":2,"path":"linux/drivers/clk"}],"count":39,"path":"linux/drivers"},{"name":"kernel","children":[{"name":"rcu","children":[],"count":3,"path":"linux/kernel/rcu"},{"name":"lock","children":[],"count":7,"path":"linux/kernel/lock"},{"name":"irq","children":[],"count":5,"path":"linux/kernel/irq"},{"name":"sched","children":[],"count":7,"path":"linux/kernel/sched"},{"name":"time","children":[],"count":10,"path":"linux/kernel/time"}],"count":61,"path":"linux/kernel"},{"name":"lib","children":[],"count":19,"path":"linux/lib"},{"name":"security","children":[],"count":1,"path":"linux/security"},{"name":"scripts","children":[],"count":2,"path":"linux/scripts"},{"name":"other","children":[],"count":17,"path":"linux/other"},{"name":"mm","children":[],"count":19,"path":"linux/mm"},{"name":"arch","children":[{"name":"arm","children":[],"count":10,"path":"linux/arch/arm"}],"count":10,"path":"linux/arch"}],"count":230,"path":"linux"},{"name":"tmc5160","children":[],"count":1,"path":"tmc5160"},{"name":"rt-thread","children":[{"name":"其他资料","children":[{"name":"fatfs","children":[],"count":1,"path":"rt-thread/其他资料/fatfs"}],"count":1,"path":"rt-thread/其他资料"}],"count":44,"path":"rt-thread"},{"name":"uboot","children":[{"name":"other","children":[],"count":12,"path":"uboot/other"},{"name":"子目录","children":[],"count":10,"path":"uboot/子目录"},{"name":"u-boot分类","children":[{"name":"arch","children":[{"name":"arm","children":[],"count":2,"path":"uboot/u-boot分类/arch/arm"}],"count":3,"path":"uboot/u-boot分类/arch"},{"name":"boot","children":[],"count":4,"path":"uboot/u-boot分类/boot"},{"name":"api","children":[],"count":1,"path":"uboot/u-boot分类/api"},{"name":"common","children":[],"count":10,"path":"uboot/u-boot分类/common"},{"name":"cmd","children":[],"count":1,"path":"uboot/u-boot分类/cmd"},{"name":"dm","children":[],"count":15,"path":"uboot/u-boot分类/dm"},{"name":"env","children":[],"count":1,"path":"uboot/u-boot分类/env"},{"name":"lib","children":[],"count":4,"path":"uboot/u-boot分类/lib"},{"name":"include","children":[],"count":3,"path":"uboot/u-boot分类/include"},{"name":"fdt","children":[],"count":1,"path":"uboot/u-boot分类/fdt"},{"name":"test","children":[],"count":1,"path":"uboot/u-boot分类/test"}],"count":44,"path":"uboot/u-boot分类"}],"count":68,"path":"uboot"},{"name":"杂谈","children":[],"count":8,"path":"杂谈"},{"name":"freertos","children":[],"count":1,"path":"freertos"}],"count":0,"path":""}],
                            initialTreeDepth: -1,
                            top: '5%',
                            bottom: '10%',
                            left: '0%',
                            right: '0%',
                            symbolSize: 15,
                            layout: 'orthogonal',
                            orient: 'TB',
                            itemStyle: {
                                color: '#91CC75',
                                borderColor: '#73C0DE'
                            },
                            label: {
                                position: 'bottom',
                                verticalAlign: 'middle',
                                align: 'center',
                                fontSize: 14,
                                distance: 28,
                                formatter: function(params) {
                                    return params.data.name + (params.data.count ? ' (' + params.data.count + ')' : '');
                                }
                            },
                            leaves: {
                                label: {
                                    position: 'top',
                                    verticalAlign: 'middle',
                                    align: 'center'
                                }
                            },
                            emphasis: {
                                focus: 'descendant'
                            },
                            expandAndCollapse: true
                        }]
                    });

                    treeChart.on('dblclick', function (params) {
                        if (params.data && params.data.path) {
                            window.location.href = '/categories/' + params.data.path;
                        }
                    });
                }
            });
        </script>
    
    <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"react":{"opacity":0.7},"log":false});</script></body></html>