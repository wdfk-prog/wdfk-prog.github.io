<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>kernel | wdfk-prog的个人博客</title><meta name="author" content="Liya Huang"><meta name="copyright" content="Liya Huang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[TOC] arch&#x2F;arm&#x2F;kernel&#x2F;: Linux 32位ARM内核的体系结构特定实现arch&#x2F;arm&#x2F;kernel&#x2F; 目录是 Linux 内核中专门负责 32 位 ARM 架构体系结构相关代码实现的核心区域。它包含了将通用内核代码与 ARM 处理器及其外围硬件紧密结合的底层逻辑。简单来说，它是 Linux 内核在 ARM 平台上运行的“神经中枢和硬件适配器”">
<meta property="og:type" content="article">
<meta property="og:title" content="kernel">
<meta property="og:url" content="https://wdfk-prog.space/posts/5dd29aab/index.html">
<meta property="og:site_name" content="wdfk-prog的个人博客">
<meta property="og:description" content="[TOC] arch&#x2F;arm&#x2F;kernel&#x2F;: Linux 32位ARM内核的体系结构特定实现arch&#x2F;arm&#x2F;kernel&#x2F; 目录是 Linux 内核中专门负责 32 位 ARM 架构体系结构相关代码实现的核心区域。它包含了将通用内核代码与 ARM 处理器及其外围硬件紧密结合的底层逻辑。简单来说，它是 Linux 内核在 ARM 平台上运行的“神经中枢和硬件适配器”">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wdfk-prog.space/images/covers/03.jpg">
<meta property="article:published_time" content="2025-10-03T01:01:49.000Z">
<meta property="article:modified_time" content="2025-10-03T09:23:29.043Z">
<meta property="article:author" content="Liya Huang">
<meta property="article:tag" content="arch">
<meta property="article:tag" content="arm">
<meta property="article:tag" content="linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wdfk-prog.space/images/covers/03.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "kernel",
  "url": "https://wdfk-prog.space/posts/5dd29aab/",
  "image": "https://wdfk-prog.space/images/covers/03.jpg",
  "datePublished": "2025-10-03T01:01:49.000Z",
  "dateModified": "2025-10-03T09:23:29.043Z",
  "author": [
    {
      "@type": "Person",
      "name": "Liya Huang",
      "url": "https://github.com/wdfk-prog"
    }
  ]
}</script><link rel="shortcut icon" href="/images/favicon.png"><link rel="canonical" href="https://wdfk-prog.space/posts/5dd29aab/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//static.cloudflareinsights.com"/><link rel="preconnect" href="//www.clarity.ms"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxxxxx"/><meta name="baidu-site-verification" content="xxxxxxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-3978542742563797',
  enable_page_level_ads: 'true'
});</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?3c49dd4913ab43efb1bfc8d12b1cded9";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-PF2CVP2PL4"></script><script>window.dataLayer = window.dataLayer || []
function gtag(){dataLayer.push(arguments)}
gtag('js', new Date())
gtag('config', 'G-PF2CVP2PL4')
btf.addGlobalFn('pjaxComplete', () => {
  gtag('config', 'G-PF2CVP2PL4', {'page_path': window.location.pathname})
}, 'google_analytics')
</script><script defer="defer" data-pjax="data-pjax" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;17ff914b5e28493597b7dc19f3356022&quot;}"></script><script>(function(c,l,a,r,i,t,y){
    c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
    t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
    y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
})(window, document, "clarity", "script", "tkaenn1tjv");
</script><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
"https://www.googletagmanager.com/gtm.js?id="+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-MF3J339H');
btf.addGlobalFn('pjaxComplete', () => {
  dataLayer.push({'event': 'pjaxComplete', 'page_title': document.title, 'page_location': location.href, 'page_path': window.location.pathname})
}, 'google_tag_manager')</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":false,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'kernel',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.0.0"><link rel="alternate" href="/atom.xml" title="wdfk-prog的个人博客" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (true) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(/images/subtle-texture.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/avatar.png" onerror="this.onerror=null;this.src='/images/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">414</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">49</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">53</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book-open"></i><span> 页面</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fas fa-quote-left"></i><span> 说说</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 示例</span></a></li></ul></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/songs/"><i class="fa-fw fas fa-music"></i><span> 歌曲</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/images/covers/03.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/my-logo.png" alt="Logo"><span class="site-name">wdfk-prog的个人博客</span></a><a class="nav-page-title" href="/"><span class="site-name">kernel</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book-open"></i><span> 页面</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fas fa-quote-left"></i><span> 说说</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 示例</span></a></li></ul></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/songs/"><i class="fa-fw fas fa-music"></i><span> 歌曲</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">kernel<a class="post-edit-link" href="null_posts/linux/arch/arm/kernel.md" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-10-03T01:01:49.000Z" title="发表于 2025-10-03 09:01:49">2025-10-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-03T09:23:29.043Z" title="更新于 2025-10-03 17:23:29">2025-10-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/linux/">linux</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/linux/arch/">arch</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/linux/arch/arm/">arm</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">27.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>104分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/5dd29aab/#post-comment"><span class="gitalk-comment-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;已经过了&quot;,&quot;messageNext&quot;:&quot;自上次更新以来，文章的内容可能已经过时&quot;,&quot;postUpdate&quot;:&quot;2025-10-03 17:23:29&quot;}" hidden></div><p>[TOC]</p>
<h1 id="arch-arm-kernel-Linux-32位ARM内核的体系结构特定实现"><a href="#arch-arm-kernel-Linux-32位ARM内核的体系结构特定实现" class="headerlink" title="arch&#x2F;arm&#x2F;kernel&#x2F;: Linux 32位ARM内核的体系结构特定实现"></a>arch&#x2F;arm&#x2F;kernel&#x2F;: Linux 32位ARM内核的体系结构特定实现</h1><p><code>arch/arm/kernel/</code> 目录是 Linux 内核中专门负责 <strong>32 位 ARM 架构体系结构相关代码实现的核心区域</strong>。它包含了将通用内核代码与 ARM 处理器及其外围硬件紧密结合的底层逻辑。简单来说，它是 Linux 内核在 ARM 平台上运行的“<strong>神经中枢和硬件适配器</strong>”。</p>
<hr>
<h3 id="一、-核心职责"><a href="#一、-核心职责" class="headerlink" title="一、 核心职责"></a>一、 核心职责</h3><p><code>arch/arm/kernel/</code> 目录下的代码负责 Linux 内核在 ARM 架构上运行的所有关键底层功能，包括：</p>
<ol>
<li><strong>早期 CPU 初始化</strong>: 在主内核 C 代码开始执行后，进行更详细的 CPU 模式设置、缓存和 MMU (内存管理单元) 的初始化。</li>
<li><strong>内存管理设置</strong>: 建立虚拟内存与物理内存的映射（页表），这是所有后续内存访问的基础。</li>
<li><strong>异常与中断处理</strong>: 定义和处理 ARM 处理器产生的各种异常（如数据中止、预取中止、未定义指令、软件中断等）和中断请求。这是内核响应硬件事件和系统调用的核心机制。</li>
<li><strong>系统调用分发</strong>: 提供用户空间应用程序通过软件中断（SWI&#x2F;SVC 指令）进入内核并调用系统服务的入口点和分发机制。</li>
<li><strong>多处理器支持 (SMP)</strong>: 实现 ARM 多核系统上各个 CPU 核心的启动、同步和通信机制。</li>
<li><strong>计时器和调度</strong>: 管理系统定时器，为进程调度提供周期性的时钟中断。</li>
<li><strong>电源管理</strong>: 处理 ARM 处理器和系统级的电源管理策略和状态转换。</li>
</ol>
<hr>
<h3 id="二、-解决的技术问题"><a href="#二、-解决的技术问题" class="headerlink" title="二、 解决的技术问题"></a>二、 解决的技术问题</h3><ul>
<li><strong>体系结构异构性</strong>: ARM 处理器家族庞大，不同型号（ARMv5、ARMv6、ARMv7）和实现（Cortex-A 系列、Cortex-M 系列，虽然 Cortex-M 通常运行的是裸机或 RTOS）在细节上存在差异。<code>arch/arm/kernel/</code> 通过宏定义、条件编译和函数指针，适配了这些差异。</li>
<li><strong>特权级切换与安全</strong>: 用户程序在非特权模式下运行，需要安全地切换到内核特权模式来执行敏感操作。<code>arch/arm/kernel/</code> 提供了这种模式切换的机制（通过异常向量）。</li>
<li><strong>性能优化</strong>: 对于中断处理、系统调用等高频操作，使用汇编语言进行精细优化，以减少延迟和提高吞吐量。</li>
<li><strong>复杂硬件抽象</strong>: 将底层中断控制器、MMU 等硬件的复杂操作抽象化，向上层通用内核提供统一的接口。</li>
</ul>
<hr>
<h3 id="三、-关键文件深度解析"><a href="#三、-关键文件深度解析" class="headerlink" title="三、 关键文件深度解析"></a>三、 关键文件深度解析</h3><h4 id="1-head-S"><a href="#1-head-S" class="headerlink" title="1. head.S"></a>1. <code>head.S</code></h4><p>这个文件是<strong>主内核的汇编入口点</strong>。它在 <code>arch/arm/boot/compressed/misc.c</code> 中的解压程序完成任务后，将控制权移交到此处。这是主内核开始执行的第一段汇编代码。</p>
<ul>
<li><strong>核心功能</strong>:<ul>
<li><strong>设置 CPU 模式</strong>: 将 CPU 设置到 Supervisor 模式，禁用中断。</li>
<li><strong>清空 BSS 段</strong>: 清零内核的 BSS 段（未初始化数据），这是 C 语言环境的必要准备。</li>
<li><strong>调用 <code>start_kernel()</code></strong>: 最后，它会跳转到 <code>init/main.c</code> 中的 <code>start_kernel()</code> 函数。从这里开始，Linux 内核的主体（C 语言代码）正式接管系统。</li>
</ul>
</li>
<li><strong>与 <code>arch/arm/boot/compressed/head.S</code> 的区别</strong>: 前者是解压程序的入口，任务是解压内核；后者是解压后主内核的入口，任务是建立 C 语言环境并启动内核。</li>
</ul>
<h4 id="2-entry-armv-S"><a href="#2-entry-armv-S" class="headerlink" title="2. entry-armv.S"></a>2. <code>entry-armv.S</code></h4><p>这是一个<strong>核心的汇编文件</strong>，包含了 ARM 处理器所有异常（包括中断和系统调用）的统一入口点。</p>
<ul>
<li><strong>核心功能</strong>:<ul>
<li><strong>异常向量表</strong>: 定义了 ARM 处理器的异常向量表（Reset, Undefined Instruction, Software Interrupt (SWI&#x2F;SVC), Prefetch Abort, Data Abort, IRQ, FIQ）。当对应的异常发生时，CPU 硬件会自动跳转到这里定义的地址。</li>
<li><strong>保存上下文</strong>: 当异常发生时，CPU 会自动保存部分寄存器。<code>entry-armv.S</code> 的代码会进一步将所有通用寄存器、浮点寄存器、栈指针等保存到当前任务的内核栈上，形成完整的<strong>上下文 (Context)</strong>。这是实现任务切换和异常返回的基础。</li>
<li><strong>模式切换</strong>: 从用户模式或其他异常模式安全地切换到内核特权模式。</li>
<li><strong>分发</strong>: 根据异常类型，将控制权分发给 C 语言实现的异常处理函数（如 <code>do_undefinstr</code>, <code>do_data_abort</code>, <code>do_irq</code>）。</li>
<li><strong>系统调用入口</strong>: 特别地，它实现了系统调用的汇编入口。当用户进程执行 <code>svc</code> (或 <code>swi</code>) 指令时，CPU 进入 SVC 模式并跳转到 SWI 向量。这里的代码会解析系统调用号和参数，并最终调用 C 语言的系统调用处理函数 <code>sys_call_table</code>。</li>
<li><strong>恢复上下文与返回</strong>: 异常处理完成后，将保存的上下文从栈中恢复到寄存器，并执行 <code>rfe</code> (Return From Exception) 或 <code>subs pc, lr, #0</code> 指令返回到异常发生前的代码位置。</li>
</ul>
</li>
</ul>
<h4 id="3-traps-c"><a href="#3-traps-c" class="headerlink" title="3. traps.c"></a>3. <code>traps.c</code></h4><p>该文件包含了 ARM 处理器各种<strong>非中断性异常</strong>的 C 语言处理函数。</p>
<ul>
<li><strong>核心功能</strong>:<ul>
<li><code>do_undefinstr()</code>: 处理未定义指令异常。当 CPU 尝试执行一个不认识的指令时发生。</li>
<li><code>do_prefetch_abort()</code>: 处理预取中止异常。当 CPU 尝试获取一个非法地址的指令时发生。</li>
<li><code>do_data_abort()</code>: 处理数据中止异常。当 CPU 尝试访问一个非法地址的数据时发生（例如，用户空间尝试访问内核空间数据）。这是实现<strong>虚拟内存保护</strong>和<strong>缺页处理</strong>的关键。</li>
<li><code>do_bad_stack()</code>: 处理栈损坏等异常。</li>
<li>这些函数通常会检查错误的类型，打印内核错误信息（Oops），并可能终止引发错误的进程。</li>
</ul>
</li>
</ul>
<h4 id="4-irq-c"><a href="#4-irq-c" class="headerlink" title="4. irq.c"></a>4. <code>irq.c</code></h4><p>该文件实现了 ARM 架构的<strong>中断管理</strong>通用逻辑。</p>
<ul>
<li><strong>核心功能</strong>:<ul>
<li><strong>中断控制器抽象</strong>: 为不同的 ARM 平台中断控制器（如 GIC）提供了一个通用的抽象层，使得上层内核无需关心具体的中断硬件细节。</li>
<li><strong>中断注册与注销</strong>: 提供了 <code>request_irq()</code> 和 <code>free_irq()</code> 等 API，供设备驱动程序注册或注销中断处理函数。</li>
<li><strong>中断使能与禁用</strong>: 控制特定中断线的使能和禁用。</li>
<li><strong>中断服务例程 (ISR) 的分发</strong>: 当 <code>entry-armv.S</code> 将中断事件分发到 C 语言层面的 <code>handle_irq()</code> 或 <code>asm_do_IRQ()</code> 时，<code>irq.c</code> 中的逻辑会查找并执行已注册的设备驱动程序 ISR。</li>
<li><strong>软中断 (Softirq)</strong> 和 <strong>工作队列 (Workqueue)</strong> 的上下文管理。</li>
</ul>
</li>
</ul>
<h4 id="5-smp-c"><a href="#5-smp-c" class="headerlink" title="5. smp.c"></a>5. <code>smp.c</code></h4><p>该文件实现了 ARM 架构下的<strong>多处理器（Symmetric Multi-Processing, SMP）支持</strong>。</p>
<ul>
<li><strong>核心功能</strong>:<ul>
<li><strong>次级 CPU 启动</strong>: 在 ARM 多核系统中，只有一个 CPU（通常是 CPU0）由 Bootloader 启动。<code>smp.c</code> 包含了唤醒其他次级 CPU 核心并使其进入内核运行的代码和机制。</li>
<li><strong>IPI (Inter-Processor Interrupt) 管理</strong>: 实现 CPU 之间发送和接收软件中断的机制。IPI 用于 CPU 间的同步、调度和缓存一致性维护（如 TLB 刷新）。</li>
<li><strong>CPU 热插拔</strong>: 支持在运行时动态添加或移除 CPU 核心（如果硬件和平台支持）。</li>
<li><strong>CPU 间同步原语</strong>: 可能包含一些底层 CPU 间同步的汇编辅助函数。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="四、-总结"><a href="#四、-总结" class="headerlink" title="四、 总结"></a>四、 总结</h3><p><code>arch/arm/kernel/</code> 目录是 Linux 内核的<strong>ARM 体系结构适配层</strong>。它将 ARM 处理器特有的低层细节（如异常向量、MMU、缓存控制、CPU 模式）封装起来，向上层提供了通用、抽象的接口，使得 Linux 内核的大部分 C 语言代码可以保持平台无关性。</p>
<p>它是理解 ARM Linux 系统如何从裸机引导到完整运行的关键所在，涉及到 CPU 启动、内存初始化、中断处理和系统调用等所有底层机制。</p>
<h1 id="进入内核流程"><a href="#进入内核流程" class="headerlink" title="进入内核流程"></a>进入内核流程</h1><ol>
<li>从解压代码中解压代码后跳转进入<code>stext</code>汇编代码开始执行</li>
<li><code>__lookup_processor_type</code> 循环查找processor_type中匹配的cpu信息</li>
<li>没有找到匹配的处理器类型，调用<code>__error_p</code>函数打印错误信息并进入死循环</li>
<li>找到匹配的处理器类型，调用具体的cpu_flush函数,完成处理器的初始化<ul>
<li>V7M 处理器调用<code>__v7m_cm7_setup</code>函数</li>
</ul>
<ol>
<li>异常向量表的地址存储在SCB的VTOR寄存器中，以便处理器能够正确地跳转到异常处理程序。</li>
<li>启用UsageFault、BusFault和MemManage异常，以便在发生这些异常时能够进行处理。</li>
<li>设置SVC（超级用户调用）和PendSV（挂起的系统服务调用）的优先级，以便在异常发生时能够正确地处理这些异常。</li>
<li>通过SVC指令切换到线程模式，并设置堆栈指针（sp）指向init_thread_union + THREAD_START_SP，以便为线程模式准备好堆栈。<ul>
<li>分配THREAD_SIZE大小的栈空间</li>
</ul>
</li>
<li>计算异常返回值，设置控制寄存器（CONTROL）为非特权模式，以便在异常返回时能够正确地恢复处理器状态。</li>
<li>配置缓存（如果硬件支持），以提高系统性能。</li>
<li>配置系统控制寄存器以确保8字节堆栈对齐，以满足ARM Cortex-M7的对齐要求。</li>
</ol>
</li>
<li>进入<code>__after_proc_init</code>函数,根据配置禁用数据缓存、分支预测和指令缓存。最后，将控制寄存器的值存储到SCB中，并将异常返回值传递给<code>__mmap_switched</code>函数，以继续执行后续的启动流程。</li>
<li>调用<code>__mmap_switched</code>函数，完成内核的初始化工作。</li>
</ol>
<h1 id="arch-arm-kernel-vmlinux-lds"><a href="#arch-arm-kernel-vmlinux-lds" class="headerlink" title="arch&#x2F;arm&#x2F;kernel&#x2F;vmlinux.lds"></a>arch&#x2F;arm&#x2F;kernel&#x2F;vmlinux.lds</h1><ul>
<li>通过lds链接脚本可知入口函数为<code>stext</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(stext)</span><br></pre></td></tr></table></figure>

<h1 id="asm-offsets-c-为汇编代码生成C结构体偏移量"><a href="#asm-offsets-c-为汇编代码生成C结构体偏移量" class="headerlink" title="asm-offsets.c: 为汇编代码生成C结构体偏移量"></a>asm-offsets.c: 为汇编代码生成C结构体偏移量</h1><p>此文件不是一个常规的内核驱动程序, 而是一个在<strong>内核编译期间</strong>运行的特殊工具。它的核心作用是计算Linux内核中常用C语言结构体 (<code>struct</code>) 内部各个成员的<strong>内存偏移量</strong> (offset), 并将这些偏移量定义为汇编语言可以理解和使用的常量。</p>
<h3 id="在单核无MMU的STM32H750平台上的原理与作用"><a href="#在单核无MMU的STM32H750平台上的原理与作用" class="headerlink" title="在单核无MMU的STM32H750平台上的原理与作用"></a>在单核无MMU的STM32H750平台上的原理与作用</h3><p>对于STM32H750这样的平台, 内核的许多底层操作, 特别是上下文切换、异常处理和启动代码, 都是用高度优化的汇编语言编写的。这些汇编代码需要直接访问C语言定义的内核数据结构, 例如 <code>task_struct</code> (任务描述符) 或 <code>thread_info</code> (线程信息栈)。</p>
<p>然而, 汇编语言本身并不知道C结构体的布局。例如, 汇编代码无法直接理解 <code>current_task-&gt;thread_info-&gt;flags</code> 这样的表达式。它需要知道 <code>flags</code> 成员相对于 <code>thread_info</code> 结构体起始地址的精确字节偏移量。这个偏移量可能会因为内核版本的变化、配置选项的不同或编译器的差异而改变。</p>
<p><code>asm-offsets.c</code> 这个工具就是为了解决这个问题而存在的。在每次编译内核时:</p>
<ol>
<li>它会被编译并执行。</li>
<li>它利用C语言的 <code>offsetof()</code> 宏来计算出所有需要的偏移量。</li>
<li>它将这些计算结果以汇编语法 (<code>.equ</code> 或 <code>#define</code>) 的形式输出到一个头文件中 (通常是 <code>asm-offsets.h</code> 或 <code>offsets.h</code>)。</li>
<li>内核的汇编文件 (<code>.S</code> 文件) 会包含这个自动生成的头文件, 从而获得所有结构体成员的最新、最准确的偏移量。</li>
</ol>
<p>对于STM32H750平台, 这尤其重要, 因为:</p>
<ul>
<li><strong>MPU配置</strong>: <code>#ifdef CONFIG_ARM_MPU</code> 块中的定义对于配置内存保护单元至关重要。汇编代码需要知道MPU相关结构体的布局, 以便正确地将值写入MPU寄存器。</li>
<li><strong>异常处理</strong>: <code>pt_regs</code> 结构体的布局定义了在发生异常时, CPU寄存器在堆栈上的保存顺序。异常处理的汇编代码必须知道每个寄存器(如<code>PC</code>, <code>SP</code>, <code>R0</code>)的准确偏移量才能正确地保存和恢复现场。</li>
<li><strong>上下文切换</strong>: 汇编代码需要知道 <code>thread_info</code> 中 <code>cpu_context</code> 的位置, 以便保存和恢复任务切换时的寄存器上下文。</li>
</ul>
<p>总之, 这个文件是连接C语言世界和底层汇编世界的桥梁, 它为汇编代码提供了访问内核核心数据结构的精确”地址地图”, 保证了内核在特定硬件平台上的正确运行。</p>
<hr>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 确保编译器和目标兼容. APCS-26是旧的ARM过程调用标准, 内核需要32位的APCS.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__APCS_26__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> Sorry, your compiler targets APCS-26 but this kernel requires APCS-32</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数. 这个程序在编译内核的主机上运行.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// DEFINE宏(在kbuild头文件中定义)会打印出 &quot; #define &lt;name&gt; &lt;value&gt; &quot; 格式的字符串.</span></span><br><span class="line">  <span class="comment">// BLANK宏打印一个空行, 用于格式化输出.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// --- task_struct 结构体偏移量 ---</span></span><br><span class="line">  DEFINE(TSK_ACTIVE_MM,		offsetof(<span class="keyword">struct</span> task_struct, active_mm));  <span class="comment">// active_mm指向进程的内存描述符.</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_STACKPROTECTOR <span class="comment">// 如果启用了栈保护</span></span></span><br><span class="line">  DEFINE(TSK_STACK_CANARY,	offsetof(<span class="keyword">struct</span> task_struct, stack_canary)); <span class="comment">// 栈&quot;金丝雀&quot;值, 用于检测栈溢出.</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  BLANK();</span><br><span class="line">  <span class="comment">// --- thread_info 结构体偏移量, 这是与任务紧密相关的底层信息 ---</span></span><br><span class="line">  DEFINE(TI_FLAGS,		offsetof(<span class="keyword">struct</span> thread_info, flags));        <span class="comment">// 线程标志位 (如: 是否有信号待处理).</span></span><br><span class="line">  DEFINE(TI_PREEMPT,		offsetof(<span class="keyword">struct</span> thread_info, preempt_count)); <span class="comment">// 内核抢占计数器.</span></span><br><span class="line">  DEFINE(TI_CPU,		offsetof(<span class="keyword">struct</span> thread_info, cpu));          <span class="comment">// 当前任务运行在哪个CPU上 (单核系统上恒为0).</span></span><br><span class="line">  DEFINE(TI_CPU_DOMAIN,		offsetof(<span class="keyword">struct</span> thread_info, cpu_domain));   <span class="comment">// CPU的电源域.</span></span><br><span class="line">  DEFINE(TI_CPU_SAVE,		offsetof(<span class="keyword">struct</span> thread_info, cpu_context));  <span class="comment">// CPU上下文保存区域, 上下文切换时使用.</span></span><br><span class="line">  DEFINE(TI_ABI_SYSCALL,	offsetof(<span class="keyword">struct</span> thread_info, abi_syscall));  <span class="comment">// 系统调用ABI相关.</span></span><br><span class="line">  DEFINE(TI_TP_VALUE,		offsetof(<span class="keyword">struct</span> thread_info, tp_value));     <span class="comment">// TLS线程指针值.</span></span><br><span class="line">  DEFINE(TI_FPSTATE,		offsetof(<span class="keyword">struct</span> thread_info, fpstate));      <span class="comment">// 浮点/SIMD单元状态.</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_VFP <span class="comment">// 如果配置了VFP(矢量浮点)协rocessor, STM32H750有</span></span></span><br><span class="line">  DEFINE(TI_VFPSTATE,		offsetof(<span class="keyword">struct</span> thread_info, vfpstate));     <span class="comment">// VFP状态.</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP <span class="comment">// 如果是多核系统 (STM32H750不是)</span></span></span><br><span class="line">  DEFINE(VFP_CPU,		offsetof(<span class="keyword">union</span> vfp_state, hard.cpu));        <span class="comment">// VFP状态属于哪个CPU.</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  DEFINE(SOFTIRQ_DISABLE_OFFSET,SOFTIRQ_DISABLE_OFFSET); <span class="comment">// 软中断禁用偏移量.</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARM_THUMBEE <span class="comment">// 如果配置了ThumbEE扩展</span></span></span><br><span class="line">  DEFINE(TI_THUMBEE_STATE,	offsetof(<span class="keyword">struct</span> thread_info, thumbee_state));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_IWMMXT <span class="comment">// 如果配置了Intel WMMX扩展</span></span></span><br><span class="line">  DEFINE(TI_IWMMXT_STATE,	offsetof(<span class="keyword">struct</span> thread_info, fpstate.iwmmxt));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  BLANK();</span><br><span class="line">  <span class="comment">// --- pt_regs 结构体偏移量, 定义了异常发生时寄存器在栈上的保存布局 ---</span></span><br><span class="line">  DEFINE(S_R0,			offsetof(<span class="keyword">struct</span> pt_regs, ARM_r0));</span><br><span class="line">  DEFINE(S_R1,			offsetof(<span class="keyword">struct</span> pt_regs, ARM_r1));</span><br><span class="line">  DEFINE(S_R2,			offsetof(<span class="keyword">struct</span> pt_regs, ARM_r2));</span><br><span class="line">  DEFINE(S_R3,			offsetof(<span class="keyword">struct</span> pt_regs, ARM_r3));</span><br><span class="line">  DEFINE(S_R4,			offsetof(<span class="keyword">struct</span> pt_regs, ARM_r4));</span><br><span class="line">  DEFINE(S_R5,			offsetof(<span class="keyword">struct</span> pt_regs, ARM_r5));</span><br><span class="line">  DEFINE(S_R6,			offsetof(<span class="keyword">struct</span> pt_regs, ARM_r6));</span><br><span class="line">  DEFINE(S_R7,			offsetof(<span class="keyword">struct</span> pt_regs, ARM_r7));       <span class="comment">// R7可能是帧指针或系统调用号.</span></span><br><span class="line">  DEFINE(S_R8,			offsetof(<span class="keyword">struct</span> pt_regs, ARM_r8));</span><br><span class="line">  DEFINE(S_R9,			offsetof(<span class="keyword">struct</span> pt_regs, ARM_r9));</span><br><span class="line">  DEFINE(S_R10,			offsetof(<span class="keyword">struct</span> pt_regs, ARM_r10));</span><br><span class="line">  DEFINE(S_FP,			offsetof(<span class="keyword">struct</span> pt_regs, ARM_fp));       <span class="comment">// R11, 帧指针(Frame Pointer).</span></span><br><span class="line">  DEFINE(S_IP,			offsetof(<span class="keyword">struct</span> pt_regs, ARM_ip));       <span class="comment">// R12, 过程调用间scratch寄存器.</span></span><br><span class="line">  DEFINE(S_SP,			offsetof(<span class="keyword">struct</span> pt_regs, ARM_sp));       <span class="comment">// R13, 堆栈指针(Stack Pointer).</span></span><br><span class="line">  DEFINE(S_LR,			offsetof(<span class="keyword">struct</span> pt_regs, ARM_lr));       <span class="comment">// R14, 链接寄存器(Link Register).</span></span><br><span class="line">  DEFINE(S_PC,			offsetof(<span class="keyword">struct</span> pt_regs, ARM_pc));       <span class="comment">// R15, 程序计数器(Program Counter).</span></span><br><span class="line">  DEFINE(S_PSR,			offsetof(<span class="keyword">struct</span> pt_regs, ARM_cpsr));     <span class="comment">// 当前程序状态寄存器.</span></span><br><span class="line">  DEFINE(S_OLD_R0,		offsetof(<span class="keyword">struct</span> pt_regs, ARM_ORIG_r0));  <span class="comment">// 原始的R0值 (在系统调用中可能被修改).</span></span><br><span class="line">  DEFINE(PT_REGS_SIZE,		<span class="keyword">sizeof</span>(<span class="keyword">struct</span> pt_regs));                 <span class="comment">//整个pt_regs结构体的大小.</span></span><br><span class="line">  DEFINE(SVC_DACR,		offsetof(<span class="keyword">struct</span> svc_pt_regs, dacr));     <span class="comment">// 在SVC模式下保存的域访问控制寄存器.</span></span><br><span class="line">  DEFINE(SVC_TTBCR,		offsetof(<span class="keyword">struct</span> svc_pt_regs, ttbcr));    <span class="comment">// 在SVC模式下保存的转换表基址控制寄存器.</span></span><br><span class="line">  DEFINE(SVC_REGS_SIZE,		<span class="keyword">sizeof</span>(<span class="keyword">struct</span> svc_pt_regs));             <span class="comment">// SVC模式保存区域的大小.</span></span><br><span class="line">  BLANK();</span><br><span class="line">  <span class="comment">// --- 信号处理帧的偏移量 ---</span></span><br><span class="line">  DEFINE(SIGFRAME_RC3_OFFSET,	offsetof(<span class="keyword">struct</span> sigframe, retcode[<span class="number">3</span>]));</span><br><span class="line">  DEFINE(RT_SIGFRAME_RC3_OFFSET, offsetof(<span class="keyword">struct</span> rt_sigframe, sig.retcode[<span class="number">3</span>]));</span><br><span class="line">  BLANK();</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CACHE_L2X0 <span class="comment">// 如果配置了L2X0二级缓存控制器</span></span></span><br><span class="line">  <span class="comment">// --- L2X0 缓存控制器寄存器结构体的偏移量 ---</span></span><br><span class="line">  DEFINE(L2X0_R_PHY_BASE,	offsetof(<span class="keyword">struct</span> l2x0_regs, phy_base));</span><br><span class="line">  DEFINE(L2X0_R_AUX_CTRL,	offsetof(<span class="keyword">struct</span> l2x0_regs, aux_ctrl));</span><br><span class="line">  <span class="comment">// ... 其他L2缓存寄存器</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  BLANK();</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CPU_HAS_ASID <span class="comment">// 如果CPU支持ASID(地址空间ID)</span></span></span><br><span class="line">  DEFINE(MM_CONTEXT_ID,		offsetof(<span class="keyword">struct</span> mm_struct, context.id.counter));</span><br><span class="line">  BLANK();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="comment">// --- 内存管理相关结构体偏移量 ---</span></span><br><span class="line">  DEFINE(VMA_VM_MM,		offsetof(<span class="keyword">struct</span> vm_area_struct, vm_mm));   <span class="comment">// VMA指向其所属的mm_struct.</span></span><br><span class="line">  DEFINE(VMA_VM_FLAGS,		offsetof(<span class="keyword">struct</span> vm_area_struct, vm_flags)); <span class="comment">// VMA的标志位.</span></span><br><span class="line">  BLANK();</span><br><span class="line">  DEFINE(VM_EXEC,	       	VM_EXEC); <span class="comment">// VM_EXEC标志位的值本身.</span></span><br><span class="line">  BLANK();</span><br><span class="line">  DEFINE(PAGE_SZ,	       	PAGE_SIZE); <span class="comment">// 系统页大小 (通常是4096).</span></span><br><span class="line">  BLANK();</span><br><span class="line">  DEFINE(SYS_ERROR0,		<span class="number">0x9f0000</span>); <span class="comment">// 内核错误码的起始值.</span></span><br><span class="line">  BLANK();</span><br><span class="line">  <span class="comment">// --- 处理器和机器描述符的偏移量, 用于早期启动 ---</span></span><br><span class="line">  DEFINE(SIZEOF_MACHINE_DESC,	<span class="keyword">sizeof</span>(<span class="keyword">struct</span> machine_desc));</span><br><span class="line">  DEFINE(MACHINFO_TYPE,		offsetof(<span class="keyword">struct</span> machine_desc, nr));</span><br><span class="line">  DEFINE(MACHINFO_NAME,		offsetof(<span class="keyword">struct</span> machine_desc, name));</span><br><span class="line">  BLANK();</span><br><span class="line">  DEFINE(PROC_INFO_SZ,		<span class="keyword">sizeof</span>(<span class="keyword">struct</span> proc_info_list));</span><br><span class="line">  DEFINE(PROCINFO_INITFUNC,	offsetof(<span class="keyword">struct</span> proc_info_list, __cpu_flush));</span><br><span class="line">  DEFINE(PROCINFO_MM_MMUFLAGS,	offsetof(<span class="keyword">struct</span> proc_info_list, __cpu_mm_mmu_flags));</span><br><span class="line">  DEFINE(PROCINFO_IO_MMUFLAGS,	offsetof(<span class="keyword">struct</span> proc_info_list, __cpu_io_mmu_flags));</span><br><span class="line">  BLANK();</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MULTI_DABORT <span class="comment">// 如果支持多种数据异常处理</span></span></span><br><span class="line">  DEFINE(PROCESSOR_DABT_FUNC,	offsetof(<span class="keyword">struct</span> processor, _data_abort));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MULTI_PABORT <span class="comment">// 如果支持多种预取异常处理</span></span></span><br><span class="line">  DEFINE(PROCESSOR_PABT_FUNC,	offsetof(<span class="keyword">struct</span> processor, _prefetch_abort));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MULTI_CPU <span class="comment">// 如果支持多种CPU类型</span></span></span><br><span class="line">  DEFINE(CPU_SLEEP_SIZE,	offsetof(<span class="keyword">struct</span> processor, suspend_size));</span><br><span class="line">  DEFINE(CPU_DO_SUSPEND,	offsetof(<span class="keyword">struct</span> processor, do_suspend));</span><br><span class="line">  DEFINE(CPU_DO_RESUME,		offsetof(<span class="keyword">struct</span> processor, do_resume));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MULTI_CACHE <span class="comment">// 如果支持多种缓存操作</span></span></span><br><span class="line">  DEFINE(CACHE_FLUSH_KERN_ALL,	offsetof(<span class="keyword">struct</span> cpu_cache_fns, flush_kern_all));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARM_CPU_SUSPEND <span class="comment">// 如果支持CPU挂起</span></span></span><br><span class="line">  DEFINE(SLEEP_SAVE_SP_SZ,	<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sleep_save_sp));</span><br><span class="line">  DEFINE(SLEEP_SAVE_SP_PHYS,	offsetof(<span class="keyword">struct</span> sleep_save_sp, save_ptr_stash_phys));</span><br><span class="line">  DEFINE(SLEEP_SAVE_SP_VIRT,	offsetof(<span class="keyword">struct</span> sleep_save_sp, save_ptr_stash));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="comment">// --- ARM SMCCC (安全监控调用约定) 相关的偏移量 ---</span></span><br><span class="line">  DEFINE(ARM_SMCCC_QUIRK_ID_OFFS,	offsetof(<span class="keyword">struct</span> arm_smccc_quirk, id));</span><br><span class="line">  DEFINE(ARM_SMCCC_QUIRK_STATE_OFFS,	offsetof(<span class="keyword">struct</span> arm_smccc_quirk, state));</span><br><span class="line">  BLANK();</span><br><span class="line">  <span class="comment">// --- DMA方向的定义 ---</span></span><br><span class="line">  DEFINE(DMA_BIDIRECTIONAL,	DMA_BIDIRECTIONAL);</span><br><span class="line">  DEFINE(DMA_TO_DEVICE,		DMA_TO_DEVICE);</span><br><span class="line">  DEFINE(DMA_FROM_DEVICE,	DMA_FROM_DEVICE);</span><br><span class="line">  BLANK();</span><br><span class="line">  <span class="comment">// --- 缓存行大小相关的定义 ---</span></span><br><span class="line">  DEFINE(CACHE_WRITEBACK_ORDER, __CACHE_WRITEBACK_ORDER);</span><br><span class="line">  DEFINE(CACHE_WRITEBACK_GRANULE, __CACHE_WRITEBACK_GRANULE);</span><br><span class="line">  BLANK();</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARM_MPU <span class="comment">// 如果配置了ARM MPU, 这对STM32H750至关重要</span></span></span><br><span class="line">  <span class="comment">// --- MPU区域信息结构体的偏移量 ---</span></span><br><span class="line">  DEFINE(MPU_RNG_INFO_RNGS,	offsetof(<span class="keyword">struct</span> mpu_rgn_info, rgns)); <span class="comment">// 指向MPU区域数组.</span></span><br><span class="line">  DEFINE(MPU_RNG_INFO_USED,	offsetof(<span class="keyword">struct</span> mpu_rgn_info, used)); <span class="comment">// 已使用的区域数量.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// --- 单个MPU区域结构体的偏移量和大小 ---</span></span><br><span class="line">  DEFINE(MPU_RNG_SIZE,		<span class="keyword">sizeof</span>(<span class="keyword">struct</span> mpu_rgn));             <span class="comment">// 单个MPU区域描述符的大小.</span></span><br><span class="line">  DEFINE(MPU_RGN_DRBAR,	offsetof(<span class="keyword">struct</span> mpu_rgn, drbar));  <span class="comment">// 区域基地址寄存器的值.</span></span><br><span class="line">  DEFINE(MPU_RGN_DRSR,	offsetof(<span class="keyword">struct</span> mpu_rgn, drsr));   <span class="comment">// 区域大小和使能寄存器的值.</span></span><br><span class="line">  DEFINE(MPU_RGN_DRACR,	offsetof(<span class="keyword">struct</span> mpu_rgn, dracr));  <span class="comment">// 区域访问控制寄存器的值.</span></span><br><span class="line">  DEFINE(MPU_RGN_PRBAR,	offsetof(<span class="keyword">struct</span> mpu_rgn, prbar));  <span class="comment">// (Cortex-A) 保护区基地址.</span></span><br><span class="line">  DEFINE(MPU_RGN_PRLAR,	offsetof(<span class="keyword">struct</span> mpu_rgn, prlar));  <span class="comment">// (Cortex-A) 保护区限制地址.</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="comment">// --- kexec (内核重启动) 相关的偏移量 ---</span></span><br><span class="line">  DEFINE(KEXEC_START_ADDR,	offsetof(<span class="keyword">struct</span> kexec_relocate_data, kexec_start_address));</span><br><span class="line">  DEFINE(KEXEC_INDIR_PAGE,	offsetof(<span class="keyword">struct</span> kexec_relocate_data, kexec_indirection_page));</span><br><span class="line">  DEFINE(KEXEC_MACH_TYPE,	offsetof(<span class="keyword">struct</span> kexec_relocate_data, kexec_mach_type));</span><br><span class="line">  DEFINE(KEXEC_R2,		offsetof(<span class="keyword">struct</span> kexec_relocate_data, kexec_r2));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 正常退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="arch-arm-include-asm-glue-proc-h"><a href="#arch-arm-include-asm-glue-proc-h" class="headerlink" title="arch&#x2F;arm&#x2F;include&#x2F;asm&#x2F;glue-proc.h"></a>arch&#x2F;arm&#x2F;include&#x2F;asm&#x2F;glue-proc.h</h1><ul>
<li>根据不同架构执行不同的代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CPU_V7M</span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> CPU_NAME</span></span><br><span class="line"><span class="meta">#  <span class="keyword">undef</span>  MULTI_CPU</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> MULTI_CPU</span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> CPU_NAME cpu_v7m</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MULTI_CPU</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cpu_proc_init			__glue(CPU_NAME,_proc_init)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cpu_proc_fin			__glue(CPU_NAME,_proc_fin)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cpu_reset			__glue(CPU_NAME,_reset)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cpu_do_idle			__glue(CPU_NAME,_do_idle)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cpu_dcache_clean_area		__glue(CPU_NAME,_dcache_clean_area)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cpu_do_switch_mm		__glue(CPU_NAME,_switch_mm)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cpu_set_pte_ext			__glue(CPU_NAME,_set_pte_ext)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cpu_suspend_size		__glue(CPU_NAME,_suspend_size)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cpu_do_suspend			__glue(CPU_NAME,_do_suspend)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cpu_do_resume			__glue(CPU_NAME,_do_resume)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="PROC-INFO-架构信息"><a href="#PROC-INFO-架构信息" class="headerlink" title="PROC_INFO 架构信息"></a>PROC_INFO 架构信息</h1><h2 id="arch-arm-include-asm-vmlinux-lds-h"><a href="#arch-arm-include-asm-vmlinux-lds-h" class="headerlink" title="arch&#x2F;arm&#x2F;include&#x2F;asm&#x2F;vmlinux.lds.h"></a>arch&#x2F;arm&#x2F;include&#x2F;asm&#x2F;vmlinux.lds.h</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//arch/arm/kernel/vmlinux.lds.S</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">- 这些值绝不能为空 </span></span><br><span class="line"><span class="comment">- 如果你必须注释掉这两个 assert 语句，则你的 binutils 太旧了（还有其他原因） </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ASSERT((__proc_info_end - __proc_info_begin), <span class="string">&quot;missing CPU support&quot;</span>)</span><br><span class="line"><span class="comment">// arch/arm/include/asm/vmlinux.lds.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROC_INFO							\</span></span><br><span class="line"><span class="meta">		. = ALIGN(4);						\</span></span><br><span class="line"><span class="meta">		__proc_info_begin = .;					\</span></span><br><span class="line"><span class="meta">		KEEP(*(.proc.info.init))				\</span></span><br><span class="line"><span class="meta">		__proc_info_end = .;</span></span><br></pre></td></tr></table></figure>

<h2 id="arch-arm-include-uapi-asm-hwcap-h-“hardware-capabilities”（硬件能力）"><a href="#arch-arm-include-uapi-asm-hwcap-h-“hardware-capabilities”（硬件能力）" class="headerlink" title="arch&#x2F;arm&#x2F;include&#x2F;uapi&#x2F;asm&#x2F;hwcap.h  “hardware capabilities”（硬件能力）"></a>arch&#x2F;arm&#x2F;include&#x2F;uapi&#x2F;asm&#x2F;hwcap.h  “hardware capabilities”（硬件能力）</h2><h3 id="HWCAP-flags-“hardware-capabilities”（硬件能力）"><a href="#HWCAP-flags-“hardware-capabilities”（硬件能力）" class="headerlink" title="HWCAP flags  “hardware capabilities”（硬件能力）"></a>HWCAP flags  “hardware capabilities”（硬件能力）</h3><ul>
<li>hwcap 是 “hardware capabilities”（硬件能力）的缩写，用于描述处理器支持的硬件特性或扩展功能。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * HWCAP flags - for elf_hwcap (in kernel) and AT_HWCAP</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* 描述: 支持 SWP 指令（交换寄存器和内存的值）。</span></span><br><span class="line"><span class="comment">用途: 用于原子操作，但在现代 ARM 处理器中已被更高效的指令替代。 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HWCAP_SWP	(1 &lt;&lt; 0) </span></span><br><span class="line"><span class="comment">/* 描述: 支持半字（16 位）加载和存储指令。</span></span><br><span class="line"><span class="comment">用途: 提高对 16 位数据的操作效率。 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HWCAP_HALF	(1 &lt;&lt; 1)</span></span><br><span class="line"><span class="comment">/* 描述: 支持 Thumb 指令集（16 位压缩指令）。</span></span><br><span class="line"><span class="comment">用途: 提高代码密度，减少内存占用。 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HWCAP_THUMB	(1 &lt;&lt; 2)</span></span><br><span class="line"><span class="comment">/* 描述: 支持 26 位地址模式（已过时）。</span></span><br><span class="line"><span class="comment">用途: 仅用于兼容旧的 ARM 处理器。 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HWCAP_26BIT	(1 &lt;&lt; 3)</span></span><br><span class="line"><span class="comment">/* 描述: 支持快速乘法指令。</span></span><br><span class="line"><span class="comment">用途: 提高整数乘法运算的性能。 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HWCAP_FAST_MULT	(1 &lt;&lt; 4)</span></span><br><span class="line"><span class="comment">/* 描述: 支持浮点协处理器（FPA）。</span></span><br><span class="line"><span class="comment">用途: 处理浮点运算，但已被 VFP 替代。 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HWCAP_FPA	(1 &lt;&lt; 5)</span></span><br><span class="line"><span class="comment">/* 描述: 支持向量浮点（VFP）指令集。</span></span><br><span class="line"><span class="comment">用途: 提高浮点运算性能 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HWCAP_VFP	(1 &lt;&lt; 6)</span></span><br><span class="line"><span class="comment">/* 描述: 支持增强的 DSP 指令集。</span></span><br><span class="line"><span class="comment">用途: 提高数字信号处理性能 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HWCAP_EDSP	(1 &lt;&lt; 7)</span></span><br><span class="line"><span class="comment">/* 描述: 支持 Jazelle（Java 加速）。</span></span><br><span class="line"><span class="comment">用途: 提高 Java 字节码的执行效率。 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HWCAP_JAVA	(1 &lt;&lt; 8)</span></span><br><span class="line"><span class="comment">/* 描述: 支持 Intel Wireless MMX 技术。</span></span><br><span class="line"><span class="comment">用途: 提高多媒体处理性能。 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HWCAP_IWMMXT	(1 &lt;&lt; 9)</span></span><br><span class="line"><span class="comment">/* 描述: 支持 Crunch 协处理器（已废弃）。</span></span><br><span class="line"><span class="comment">用途: 处理浮点运算，但已过时。 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HWCAP_CRUNCH	(1 &lt;&lt; 10)</span></span><br><span class="line"><span class="comment">/* 描述: 支持 ThumbEE（Thumb Execution Environment）。</span></span><br><span class="line"><span class="comment">用途: 提高嵌入式环境的性能 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HWCAP_THUMBEE	(1 &lt;&lt; 11)</span></span><br><span class="line"><span class="comment">/* 描述: 支持 NEON SIMD 指令集。</span></span><br><span class="line"><span class="comment">用途: 提高多媒体和信号处理性能。 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HWCAP_NEON	(1 &lt;&lt; 12)</span></span><br><span class="line"><span class="comment">/* 描述: 支持 VFPv3 浮点指令集。</span></span><br><span class="line"><span class="comment">用途: 提高浮点运算性能。 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HWCAP_VFPv3	(1 &lt;&lt; 13)</span></span><br><span class="line"><span class="comment">/* 描述: 支持 VFPv3-D16（16 个浮点寄存器）。</span></span><br><span class="line"><span class="comment">用途: 提供较小的浮点寄存器集，适用于资源受限的设备。 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HWCAP_VFPv3D16	(1 &lt;&lt; 14)</span></span><br><span class="line"><span class="comment">/* 描述: 支持线程本地存储（TLS）。</span></span><br><span class="line"><span class="comment">用途: 提高多线程程序的性能。 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HWCAP_TLS	(1 &lt;&lt; 15)</span></span><br><span class="line"><span class="comment">/* 描述: 支持 VFPv4 浮点指令集。</span></span><br><span class="line"><span class="comment">用途: 提供更高效的浮点运算。 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HWCAP_VFPv4	(1 &lt;&lt; 16)</span></span><br><span class="line"><span class="comment">/* 在 ARM 架构的早期版本中，整数除法通常需要通过软件模拟来实现，这会导致性能开销较大。</span></span><br><span class="line"><span class="comment"> * 从 ARMv7 版本开始，部分处理器引入了硬件支持的整数除法指令：</span></span><br><span class="line"><span class="comment"> 描述: 支持整数除法指令（ARM 模式）。</span></span><br><span class="line"><span class="comment"> 用途: 提高整数除法性能。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HWCAP_IDIVA	(1 &lt;&lt; 17)</span></span><br><span class="line"><span class="comment">/* 描述: 支持整数除法指令（Thumb 模式）。</span></span><br><span class="line"><span class="comment">用途: 提高整数除法性能。 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HWCAP_IDIVT	(1 &lt;&lt; 18)</span></span><br><span class="line"><span class="comment">/* 描述: 支持 32 个浮点寄存器（而非 16 个）。</span></span><br><span class="line"><span class="comment">用途: 提供更大的寄存器集以支持复杂计算。 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HWCAP_VFPD32	(1 &lt;&lt; 19)</span></span><br><span class="line"><span class="comment">/* 描述: 同时支持 HWCAP_IDIVA 和 HWCAP_IDIVT。</span></span><br><span class="line"><span class="comment">用途: 表示整数除法在 ARM 和 Thumb 模式下均可用。 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HWCAP_IDIV	(HWCAP_IDIVA | HWCAP_IDIVT)</span></span><br><span class="line"><span class="comment">/* 描述: 支持大物理地址扩展（Large Physical Address Extension）。</span></span><br><span class="line"><span class="comment">用途: 支持超过 4GB 的物理内存。 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HWCAP_LPAE	(1 &lt;&lt; 20)</span></span><br><span class="line"><span class="comment">/* 描述: 支持事件流（Event Stream）。</span></span><br><span class="line"><span class="comment">用途: 用于性能监控和调试。 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HWCAP_EVTSTRM	(1 &lt;&lt; 21)</span></span><br><span class="line"><span class="comment">/* 描述: 支持半精度浮点运算（FPHP）。</span></span><br><span class="line"><span class="comment">用途: 提高半精度浮点运算性能。 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HWCAP_FPHP	(1 &lt;&lt; 22)</span></span><br><span class="line"><span class="comment">/* 描述: 支持半精度 SIMD 运算。</span></span><br><span class="line"><span class="comment">用途: 提高 SIMD 半精度运算性能。 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HWCAP_ASIMDHP	(1 &lt;&lt; 23)</span></span><br><span class="line"><span class="comment">/* 描述: 支持双精度 SIMD 运算。</span></span><br><span class="line"><span class="comment">用途: 提高 SIMD 双精度运算性能。 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HWCAP_ASIMDDP	(1 &lt;&lt; 24)</span></span><br><span class="line"><span class="comment">/* 描述: 支持浮点 FMLA（Fused Multiply-Add）运算。</span></span><br><span class="line"><span class="comment">用途: 提高浮点乘加运算性能 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HWCAP_ASIMDFHM	(1 &lt;&lt; 25)</span></span><br><span class="line"><span class="comment">/* 描述: 支持 BF16（bfloat16）格式的 SIMD 运算。</span></span><br><span class="line"><span class="comment">用途: 提高机器学习和神经网络计算性能。 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HWCAP_ASIMDBF16	(1 &lt;&lt; 26)</span></span><br><span class="line"><span class="comment">/* 描述: 支持 8 位整数矩阵乘法（I8MM）。</span></span><br><span class="line"><span class="comment">用途: 提高低精度矩阵运算性能，常用于机器学习。 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HWCAP_I8MM	(1 &lt;&lt; 27)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * HWCAP2 flags - for elf_hwcap2 (in kernel) and AT_HWCAP2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* 描述: 支持 AES（高级加密标准）指令集。</span></span><br><span class="line"><span class="comment">用途: 提供硬件加速的 AES 加密和解密操作，显著提高对称加密算法的性能。</span></span><br><span class="line"><span class="comment">应用场景: 数据加密、VPN、SSL/TLS 等。 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HWCAP2_AES	(1 &lt;&lt; 0)</span></span><br><span class="line"><span class="comment">/* 描述: 支持 PMULL（多项式乘法）指令。</span></span><br><span class="line"><span class="comment">用途: 提供硬件加速的多项式乘法运算，通常用于 Galois/Counter Mode (GCM) 加密模式。</span></span><br><span class="line"><span class="comment">应用场景: GCM 模式的 AES 加密 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HWCAP2_PMULL	(1 &lt;&lt; 1)</span></span><br><span class="line"><span class="comment">/* 描述: 支持 SHA-1 哈希指令。</span></span><br><span class="line"><span class="comment">用途: 提供硬件加速的 SHA-1 哈希计算，显著提高哈希运算性能。</span></span><br><span class="line"><span class="comment">应用场景: 数据完整性校验、数字签名（尽管 SHA-1 已逐渐被弃用）。 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HWCAP2_SHA1	(1 &lt;&lt; 2)</span></span><br><span class="line"><span class="comment">/* 描述: 支持 SHA-2 哈希指令（包括 SHA-224 和 SHA-256）。</span></span><br><span class="line"><span class="comment">用途: 提供硬件加速的 SHA-2 哈希计算，显著提高安全哈希算法的性能。</span></span><br><span class="line"><span class="comment">应用场景: 数据完整性校验、数字签名、区块链等。 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HWCAP2_SHA2	(1 &lt;&lt; 3)</span></span><br><span class="line"><span class="comment">/* 描述: 支持 CRC32（循环冗余校验）指令。</span></span><br><span class="line"><span class="comment">用途: 提供硬件加速的 CRC32 校验计算，用于快速检测数据传输中的错误。</span></span><br><span class="line"><span class="comment">应用场景: 网络通信、存储设备的数据完整性校验。 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HWCAP2_CRC32	(1 &lt;&lt; 4)</span></span><br><span class="line"><span class="comment">/* 描述: 支持 Speculation Barrier（推测屏障）指令。</span></span><br><span class="line"><span class="comment">用途: 防止推测执行漏洞（如 Spectre 攻击），通过插入屏障指令限制处理器的推测执行行为。</span></span><br><span class="line"><span class="comment">应用场景: 安全性增强，防止侧信道攻击。 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HWCAP2_SB	(1 &lt;&lt; 5)</span></span><br><span class="line"><span class="comment">/* 描述: 支持 Speculative Store Bypass Safe（推测存储旁路安全）功能。</span></span><br><span class="line"><span class="comment">用途: 防止 Speculative Store Bypass（推测存储旁路）漏洞，通过硬件机制限制推测执行的影响。</span></span><br><span class="line"><span class="comment">应用场景: 安全性增强，防止侧信道攻击。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HWCAP2_SSBS	(1 &lt;&lt; 6)</span></span><br></pre></td></tr></table></figure>

<h2 id="arch-arm-include-asm-procinfo-h"><a href="#arch-arm-include-asm-procinfo-h" class="headerlink" title="arch&#x2F;arm&#x2F;include&#x2F;asm&#x2F;procinfo.h"></a>arch&#x2F;arm&#x2F;include&#x2F;asm&#x2F;procinfo.h</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *注意！ 如果我们使用 Struct 处理器，则始终定义 MULTI_CPU，否则此条目未使用，但仍然存在。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *注意！以下结构由汇编语言定义，而不是 C 代码。 有关更多信息，请查看：arch/arm/mm/proc-*。S 和 arch/arm/kernel/head 的 S 和 arch/arm/kernel/head 中。S</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	* Match ARM Cortex-M7 processor.</span></span><br><span class="line"><span class="comment">struct proc_info_list &#123;</span></span><br><span class="line"><span class="comment">unsigned int		cpu_val;			= 0x410fc270</span></span><br><span class="line"><span class="comment">unsigned int		cpu_mask;			= 0xff0ffff0</span></span><br><span class="line"><span class="comment">unsigned long		__cpu_mm_mmu_flags;	= 0</span></span><br><span class="line"><span class="comment">unsigned long		__cpu_io_mmu_flags;	= 0</span></span><br><span class="line"><span class="comment">unsigned long		__cpu_flush;		= __v7m_cm7_setup()</span></span><br><span class="line"><span class="comment">const char		*arch_name;				= &quot;armv7m&quot;</span></span><br><span class="line"><span class="comment">const char		*elf_name;				= &quot;v7m&quot;</span></span><br><span class="line"><span class="comment">unsigned int		elf_hwcap;			= HWCAP_EDSP</span></span><br><span class="line"><span class="comment">const char		*cpu_name;				= &quot;ARMv7-M&quot;</span></span><br><span class="line"><span class="comment">struct processor	*proc;				= cm7_processor_functions()</span></span><br><span class="line"><span class="comment">struct cpu_tlb_fns	*tlb;				= NULL</span></span><br><span class="line"><span class="comment">struct cpu_user_fns	*user;				= NULL</span></span><br><span class="line"><span class="comment">struct cpu_cache_fns	*cache;			= v7m_cache_fns()</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_info_list</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		cpu_val;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		cpu_mask;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		__cpu_mm_mmu_flags;	<span class="comment">/* used by head.S */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		__cpu_io_mmu_flags;	<span class="comment">/* used by head.S */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		__cpu_flush;		<span class="comment">/* used by head.S */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>		*arch_name;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>		*elf_name;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		elf_hwcap;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>		*cpu_name;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">processor</span>	*<span class="title">proc</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpu_tlb_fns</span>	*<span class="title">tlb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpu_user_fns</span>	*<span class="title">user</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpu_cache_fns</span>	*<span class="title">cache</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="arch-arm-mm-proc-macros-S"><a href="#arch-arm-mm-proc-macros-S" class="headerlink" title="arch&#x2F;arm&#x2F;mm&#x2F;proc-macros.S"></a>arch&#x2F;arm&#x2F;mm&#x2F;proc-macros.S</h2><h3 id="initfn"><a href="#initfn" class="headerlink" title="initfn"></a>initfn</h3><ul>
<li>这段代码的逻辑是通过 initfn 宏计算两个符号（func 和 base）之间的偏移量，并将结果存储为一个 32 位值。结合 initfn \initfunc, \name 的调用，具体逻辑如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.macro	initfn, func, base</span><br><span class="line">	.<span class="type">long</span>	\func - \base</span><br><span class="line">.endm</span><br></pre></td></tr></table></figure>

<h2 id="arch-arm-mm-proc-v7m-S"><a href="#arch-arm-mm-proc-v7m-S" class="headerlink" title="arch&#x2F;arm&#x2F;mm&#x2F;proc-v7m.S"></a>arch&#x2F;arm&#x2F;mm&#x2F;proc-v7m.S</h2><h3 id="ARMv7-M-处理器定义块"><a href="#ARMv7-M-处理器定义块" class="headerlink" title="ARMv7-M 处理器定义块"></a>ARMv7-M 处理器定义块</h3><p>此代码片段是Linux内核中的一段ARM汇编代码。其核心作用是定义一系列数据结构和函数指针, 以便内核能够识别和正确操作基于ARMv7-M架构的CPU (如此处特指的Cortex-M7)。它特别为无MMU (内存管理单元) 的单核系统 (如STM32H750) 进行了配置, 通过宏来生成一个处理器信息表 (<code>proc_info_list</code>) 中的条目。内核在启动时会查询这个表, 以找到与当前CPU匹配的配置, 并据此设置正确的中断&#x2F;异常处理器、缓存操作函数以及电源管理函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Cortex-M7 处理器函数</span><br><span class="line"> */</span><br><span class="line">	/*</span><br><span class="line">	 * globl_equ: 是一个汇编指令, 它将一个符号定义为全局的, 并使其等同于另一个符号.</span><br><span class="line">	 * 这里的几行指令是为了代码复用, 将为更通用的 &quot;v7m&quot; (ARMv7-M) 架构编写的函数,</span><br><span class="line">	 * 直接用作更具体的 &quot;cm7&quot; (Cortex-M7) CPU 的实现函数.</span><br><span class="line">	 * 这意味着 Cortex-M7 的处理器初始化、复位、空闲处理和&quot;内存切换&quot;功能都使用通用的 ARMv7-M 实现.</span><br><span class="line">	 */</span><br><span class="line">	globl_equ	cpu_cm7_proc_init,	cpu_v7m_proc_init		// 将 cm7 的初始化函数指向 v7m 的初始化函数</span><br><span class="line">	globl_equ	cpu_cm7_reset,		cpu_v7m_reset			// 将 cm7 的复位函数指向 v7m 的复位函数</span><br><span class="line">	globl_equ	cpu_cm7_do_idle,	cpu_v7m_do_idle			// 将 cm7 的空闲(idle)函数指向 v7m 的空闲函数</span><br><span class="line">	globl_equ	cpu_cm7_switch_mm,	cpu_v7m_switch_mm		// 将 cm7 的内存管理(mm)切换函数指向 v7m 的对应函数. 在无MMU系统上, 此函数通常为空操作.</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * define_processor_functions: 这是一个宏, 用于生成一个包含核心处理器操作函数指针的结构体.</span><br><span class="line">	 * @ v7m: 宏的第一个参数, 用于构成生成的结构体名称 (例如 v7m_processor_functions).</span><br><span class="line">	 * @ dabort=nommu_early_abort: 指定数据访问异常(Data Abort)的处理器为 nommu_early_abort. 函数名明确指出这是用于无MMU系统的异常处理.</span><br><span class="line">	 * @ pabort=legacy_pabort: 指定指令预取异常(Prefetch Abort)的处理器为 legacy_pabort.</span><br><span class="line">	 * @ nommu=1: 这是一个关键参数, 向宏明确指出这是为无MMU系统生成的配置.</span><br><span class="line">	 * 下面一行对 cm7 的定义复用了完全相同的配置, 表明其处理方式与通用的 v7m 一致.</span><br><span class="line">	 */</span><br><span class="line">	define_processor_functions v7m, dabort=nommu_early_abort, pabort=legacy_pabort, nommu=1</span><br><span class="line">	define_processor_functions cm7, dabort=nommu_early_abort, pabort=legacy_pabort, nommu=1</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * .section &quot;.rodata&quot;: 这是一个汇编指令, 用于将其后的数据放入 &quot;.rodata&quot; (只读数据) 段中.</span><br><span class="line">	 */</span><br><span class="line">	.section &quot;.rodata&quot;</span><br><span class="line">	/*</span><br><span class="line">	 * string: 这可能是一个自定义宏, 用于定义一个空字符结尾的字符串.</span><br><span class="line">	 * 下面几行定义了几个将在处理器信息结构体中引用的字符串常量.</span><br><span class="line">	 */</span><br><span class="line">	string cpu_arch_name, &quot;armv7m&quot;			// 定义字符串 &quot;armv7m&quot;, 代表CPU架构名称.</span><br><span class="line">	string cpu_elf_name &quot;v7m&quot;				// 定义字符串 &quot;v7m&quot;, 代表ELF文件格式的架构名称.</span><br><span class="line">	string cpu_v7m_name &quot;ARMv7-M&quot;			// 定义字符串 &quot;ARMv7-M&quot;, 用于显示给用户.</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * .section &quot;.proc.info.init&quot;, &quot;a&quot;: 切换到一个特殊的、名为 &quot;.proc.info.init&quot; 的数据段.</span><br><span class="line">	 * &quot;a&quot; 标志表示该段是可分配的(allocatable).</span><br><span class="line">	 * 链接器会收集所有目标文件中的这个段, 并将它们连接在一起, 形成一个处理器信息表.</span><br><span class="line">	 * 内核启动时会遍历这个表来找到与当前硬件匹配的处理器信息.</span><br><span class="line">	 */</span><br><span class="line">	.section &quot;.proc.info.init&quot;, &quot;a&quot;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * .macro __v7m_proc ... .endm: 定义一个名为 __v7m_proc 的汇编宏.</span><br><span class="line"> * 这个宏是一个模板, 用于方便地生成一个完整的 proc_info_list 结构体条目.</span><br><span class="line"> * @ name, initfunc, cache_fns, hwcaps, proc_fns: 这些是宏可以接受的参数.</span><br><span class="line"> */</span><br><span class="line">.macro __v7m_proc name, initfunc, cache_fns = nop_cache_fns, hwcaps = 0,  proc_fns = v7m_processor_functions</span><br><span class="line">	/*</span><br><span class="line">	 * .long: 这是一个汇编指令, 用于在当前位置插入一个32位的长字(long word).</span><br><span class="line">	 * 下面的每一条 .long 指令都对应 C语言中 proc_info_list 结构体的一个成员.</span><br><span class="line">	 * 对应 proc_info_list.__cpu_mm_mmu_flags 成员. 对于无MMU系统, 此值为0.</span><br><span class="line">	 */</span><br><span class="line">	.long	0</span><br><span class="line">	/*</span><br><span class="line">	 * 对应 proc_info_list.__cpu_io_mmu_flags 成员. 对于无MMU系统或没有IOMMU的系统, 此值为0.</span><br><span class="line">	 */</span><br><span class="line">	.long	0</span><br><span class="line">	/*</span><br><span class="line">	 * initfn: 这可能是另一个宏, 用于生成指向特定初始化函数的引用.</span><br><span class="line">	 * \initfunc 和 \name 是从宏参数中代入的.</span><br><span class="line">	 */</span><br><span class="line">	initfn	\initfunc, \name</span><br><span class="line">	/*</span><br><span class="line">	 * 插入一个指向 cpu_arch_name 字符串 (&quot;armv7m&quot;) 的指针.</span><br><span class="line">	 */</span><br><span class="line">	.long	cpu_arch_name</span><br><span class="line">	/*</span><br><span class="line">	 * 插入一个指向 cpu_elf_name 字符串 (&quot;v7m&quot;) 的指针.</span><br><span class="line">	 */</span><br><span class="line">	.long	cpu_elf_name</span><br><span class="line">	/*</span><br><span class="line">	 * 插入一个表示硬件能力的32位标志字.</span><br><span class="line">	 * HWCAP_HALF: 支持半字(16位)加载/存储指令.</span><br><span class="line">	 * HWCAP_THUMB: 支持Thumb指令集 (ARMv7-M只运行在Thumb-2模式).</span><br><span class="line">	 * HWCAP_FAST_MULT: 支持32位乘法指令.</span><br><span class="line">	 * \hwcaps: 允许在调用宏时传入额外的硬件能力标志.</span><br><span class="line">	 */</span><br><span class="line">	.long	HWCAP_HALF | HWCAP_THUMB | HWCAP_FAST_MULT | \hwcaps</span><br><span class="line">	/*</span><br><span class="line">	 * 插入一个指向 cpu_v7m_name 字符串 (&quot;ARMv7-M&quot;) 的指针.</span><br><span class="line">	 */</span><br><span class="line">	.long	cpu_v7m_name</span><br><span class="line">	/*</span><br><span class="line">	 * 插入一个指向处理器函数表 (由 define_processor_functions 宏生成) 的指针.</span><br><span class="line">	 * 默认值为 v7m_processor_functions.</span><br><span class="line">	 */</span><br><span class="line">	.long   \proc_fns</span><br><span class="line">	/*</span><br><span class="line">	 * 插入一个指向TLB(快表)操作函数表的指针. TLB是MMU的一部分, 在无MMU系统上此值为0.</span><br><span class="line">	 */</span><br><span class="line">	.long	0</span><br><span class="line">	/*</span><br><span class="line">	 * 插入一个指向用户空间辅助函数表的指针.</span><br><span class="line">	 */</span><br><span class="line">	.long	0</span><br><span class="line">	/*</span><br><span class="line">	 * 插入一个指向缓存(cache)操作函数表的指针.</span><br><span class="line">	 * 默认值为 nop_cache_fns, 表示缓存操作为空操作(no-operation),</span><br><span class="line">	 * 这可能意味着系统没有缓存, 或者缓存管理由硬件自动完成, 不需要软件干预.</span><br><span class="line">	 */</span><br><span class="line">	.long	\cache_fns</span><br><span class="line">.endm</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Match ARM Cortex-M7 processor.</span><br><span class="line">	struct proc_info_list &#123;</span><br><span class="line">	unsigned int		cpu_val;			= 0x410fc270</span><br><span class="line">	unsigned int		cpu_mask;			= 0xff0ffff0</span><br><span class="line">	unsigned long		__cpu_mm_mmu_flags;	= 0</span><br><span class="line">	unsigned long		__cpu_io_mmu_flags;	= 0</span><br><span class="line">	unsigned long		__cpu_flush;		= __v7m_cm7_setup()</span><br><span class="line">	const char		*arch_name;				= &quot;armv7m&quot;</span><br><span class="line">	const char		*elf_name;				= &quot;v7m&quot;</span><br><span class="line">	unsigned int		elf_hwcap;			= HWCAP_EDSP</span><br><span class="line">	const char		*cpu_name;				= &quot;ARMv7-M&quot;</span><br><span class="line">	struct processor	*proc;				= cm7_processor_functions()</span><br><span class="line">	struct cpu_tlb_fns	*tlb;				= NULL</span><br><span class="line">	struct cpu_user_fns	*user;				= NULL</span><br><span class="line">	struct cpu_cache_fns	*cache;			= v7m_cache_fns()</span><br><span class="line">	&#125;;</span><br><span class="line">	 */</span><br><span class="line">	.type	__v7m_cm7_proc_info, #object</span><br><span class="line">__v7m_cm7_proc_info:</span><br><span class="line">	.long	0x410fc270		/* ARM Cortex-M7 0xC27 */</span><br><span class="line">	.long	0xff0ffff0		/* Mask off revision, patch release */</span><br><span class="line">	__v7m_proc __v7m_cm7_proc_info, __v7m_cm7_setup, hwcaps = HWCAP_EDSP, cache_fns = v7m_cache_fns, proc_fns = cm7_processor_functions</span><br><span class="line">	.size	__v7m_cm7_proc_info, . - __v7m_cm7_proc_info</span><br></pre></td></tr></table></figure>

<h1 id="THREAD-SIZE-分配栈大小"><a href="#THREAD-SIZE-分配栈大小" class="headerlink" title="THREAD_SIZE 分配栈大小"></a>THREAD_SIZE 分配栈大小</h1><ol>
<li><code>__v7m_cm7_setup</code>函数中分配THREAD_SIZE大小的栈空间</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldr	sp, =init_thread_union + THREAD_START_SP	@ 设置堆栈指针SP</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>arch&#x2F;arm&#x2F;include&#x2F;asm&#x2F;thread_info.h 中定义了<code>THREAD_SIZE</code>为8192-8字节,预留8字节用于填充magic,用于溢出检测</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KASAN</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * KASan uses a lot of extra stack space so the thread size order needs to</span></span><br><span class="line"><span class="comment"> * be increased.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREAD_SIZE_ORDER	2</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREAD_SIZE_ORDER	1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREAD_SIZE		(PAGE_SIZE &lt;&lt; THREAD_SIZE_ORDER)    <span class="comment">//PAGE_SIZE 1&lt;&lt;12</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREAD_START_SP		(THREAD_SIZE - 8)				<span class="comment">//预留8字节用于填充magic,用于溢出检测</span></span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>arch&#x2F;arm&#x2F;kernel&#x2F;vmlinux.lds 中定义了<code>init_thread_union</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/asm-generic/vmlinux.lds.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_TASK_DATA(align)						\</span></span><br><span class="line"><span class="meta">	. = ALIGN(align);						\</span></span><br><span class="line"><span class="meta">	__start_init_stack = .;						\</span></span><br><span class="line"><span class="meta">	init_thread_union = .;						\</span></span><br><span class="line"><span class="meta">	init_stack = .;							\</span></span><br><span class="line"><span class="meta">	KEEP(*(.data..init_thread_info))				\</span></span><br><span class="line"><span class="meta">	. = __start_init_stack + THREAD_SIZE;				\</span></span><br><span class="line"><span class="meta">	__end_init_stack = .;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.data : AT(ADDR(.data) - 0)</span><br><span class="line">&#123;</span><br><span class="line">	.= ALIGN(((1 &lt;&lt; 12) &lt;&lt; 1));</span><br><span class="line">	__start_init_stack =.;</span><br><span class="line">	init_thread_union =.;</span><br><span class="line">	init_stack =.;</span><br><span class="line">	KEEP(*(.data..init_task))</span><br><span class="line">	KEEP(*(.data..init_thread_info)).=</span><br><span class="line">		__start_init_stack + ((1 &lt;&lt; 12) &lt;&lt; 1);</span><br><span class="line">	__end_init_stack =.;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h1 id="arch-arm-include-asm-assembler-h"><a href="#arch-arm-include-asm-assembler-h" class="headerlink" title="arch&#x2F;arm&#x2F;include&#x2F;asm&#x2F;assembler.h"></a>arch&#x2F;arm&#x2F;include&#x2F;asm&#x2F;assembler.h</h1><h2 id="setmode-用于在引导期间断言处于-SVC-模式"><a href="#setmode-用于在引导期间断言处于-SVC-模式" class="headerlink" title="setmode 用于在引导期间断言处于 SVC 模式"></a>setmode 用于在引导期间断言处于 SVC 模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#if defined(CONFIG_CPU_V7M)</span><br><span class="line">	/*</span><br><span class="line">	 * setMode 用于在引导期间断言处于 SVC 模式。对于 v7-M，这是在 __v7m_setup 中完成的，因此 setmode 在这里可以为空。</span><br><span class="line">	 */</span><br><span class="line">	.macro	setmode, mode, reg</span><br><span class="line">	.endm</span><br><span class="line">#elif defined(CONFIG_THUMB2_KERNEL)</span><br><span class="line">#else</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<h2 id="safe-svcmode-maskall-干净地进入-SVC-模式并屏蔽中断"><a href="#safe-svcmode-maskall-干净地进入-SVC-模式并屏蔽中断" class="headerlink" title="safe_svcmode_maskall 干净地进入 SVC 模式并屏蔽中断"></a>safe_svcmode_maskall 干净地进入 SVC 模式并屏蔽中断</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 帮助宏干净地进入 SVC 模式并屏蔽中断。reg 是宏要覆盖的暂存寄存器。</span><br><span class="line"> *</span><br><span class="line"> * 此宏用于在启动时强制 CPU 进入 SVC 模式。</span><br><span class="line"> * 您无法返回到原始模式。</span><br><span class="line"> */</span><br><span class="line">.macro safe_svcmode_maskall reg:req</span><br><span class="line">#if __LINUX_ARM_ARCH__ &gt;= 6 &amp;&amp; !defined(CONFIG_CPU_V7M)</span><br><span class="line">#else</span><br><span class="line">    //对于 v7-M，这是在 __v7m_setup 中完成的，因此 setmode 在这里可以为空。</span><br><span class="line">#endif</span><br><span class="line">.endm</span><br></pre></td></tr></table></figure>

<h2 id="str-va-将一个-32-位字存储到-sym-的虚拟地址"><a href="#str-va-将一个-32-位字存储到-sym-的虚拟地址" class="headerlink" title="str_va 将一个 32 位字存储到 \sym 的虚拟地址"></a>str_va 将一个 32 位字存储到 \sym 的虚拟地址</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * str_va - 将一个 32 位字存储到 \sym 的虚拟地址</span><br><span class="line"> */</span><br><span class="line">.macro		str_va, rn:req, sym:req, tmp:req, cond</span><br><span class="line">__ldst_va	str, \rn, \tmp, \sym, \cond, 0</span><br><span class="line">.endm</span><br></pre></td></tr></table></figure>

<h2 id="set-current-存储此-CPU-当前任务的任务指针"><a href="#set-current-存储此-CPU-当前任务的任务指针" class="headerlink" title="set_current 存储此 CPU 当前任务的任务指针"></a>set_current 存储此 CPU 当前任务的任务指针</h2><ul>
<li>将寄存器中的值存储到符号 __current 所表示的虚拟地址中</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">	/*</span><br><span class="line">	 * set_current - 存储此 CPU 当前任务的任务指针</span><br><span class="line">	 */</span><br><span class="line">	.macro		set_current, rn:req, tmp:req</span><br><span class="line">#if defined(CONFIG_CURRENT_POINTER_IN_TPIDRURO) || defined(CONFIG_SMP)</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_CPU_V6</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line">#else</span><br><span class="line">    //将寄存器中的值存储到符号 __current 所表示的虚拟地址中</span><br><span class="line">	str_va		\rn, __current, \tmp</span><br><span class="line">#endif</span><br><span class="line">	.endm</span><br></pre></td></tr></table></figure>

<h2 id="disable-irq-notrace-enable-irq-notrace"><a href="#disable-irq-notrace-enable-irq-notrace" class="headerlink" title="disable_irq_notrace enable_irq_notrace"></a>disable_irq_notrace enable_irq_notrace</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Enable and disable interrupts</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __LINUX_ARM_ARCH__ &gt;= 6</span></span><br><span class="line">	.macro	disable_irq_notrace</span><br><span class="line">	cpsid	i</span><br><span class="line">	.endm</span><br><span class="line"></span><br><span class="line">	.macro	enable_irq_notrace</span><br><span class="line">	cpsie	i</span><br><span class="line">	.endm</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="ldr-va-从符号-sym的虚拟地址加载一个32位的字"><a href="#ldr-va-从符号-sym的虚拟地址加载一个32位的字" class="headerlink" title="ldr_va 从符号\sym的虚拟地址加载一个32位的字"></a>ldr_va 从符号\sym的虚拟地址加载一个32位的字</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 声明一个名为 __ldst_va 的汇编宏。</span></span><br><span class="line"><span class="comment">	 * 它接受6个参数：</span></span><br><span class="line"><span class="comment">	 * op:     要执行的操作，如 ldr (加载), str (存储)。</span></span><br><span class="line"><span class="comment">	 * reg:    目标/源寄存器。</span></span><br><span class="line"><span class="comment">	 * tmp:    一个临时寄存器，用于存放符号的基地址。</span></span><br><span class="line"><span class="comment">	 * sym:    目标符号（如一个全局变量名）。</span></span><br><span class="line"><span class="comment">	 * cond:   条件码，如 eq (相等), ne (不等)，若无则为空。</span></span><br><span class="line"><span class="comment">	 * offset: 地址偏移量。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	.macro		__ldst_va, op, reg, tmp, sym, cond, offset</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Part 1: 获取符号的虚拟地址</span></span><br><span class="line"><span class="comment"> * ----------------------------</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __LINUX_ARM_ARCH__ &gt;= 7 || \</span></span><br><span class="line"><span class="meta">    !defined(CONFIG_ARM_HAS_GROUP_RELOCS) || \</span></span><br><span class="line"><span class="meta">    (defined(MODULE) &amp;&amp; defined(CONFIG_ARM_MODULE_PLTS))</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 这是现代或特定配置下的路径，通常更高效。</span></span><br><span class="line"><span class="comment">	 * 适用于：</span></span><br><span class="line"><span class="comment">	 * - ARMv7及以上架构。</span></span><br><span class="line"><span class="comment">	 * - 或，内核配置不支持“组重定位”。</span></span><br><span class="line"><span class="comment">	 * - 或，正在编译一个内核模块，并且该模块使用PLT（过程链接表）。</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * mov_l 是另一个宏，它会展开为一条或两条指令（如movw+movt或adr+ldr）</span></span><br><span class="line"><span class="comment">	 * 来将32位的符号地址&#x27;sym&#x27;加载到临时寄存器&#x27;tmp&#x27;中。</span></span><br><span class="line"><span class="comment">	 * &#x27;cond&#x27;参数会被传递给mov_l内部的指令。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	mov_l		\tmp, \sym, \cond</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 这是针对较旧架构（如ARMv6）且在特定配置下的备用路径。</span></span><br><span class="line"><span class="comment">	 * 这种情况下，获取地址的方式可能更复杂，例如需要通过全局偏移表(GOT)。</span></span><br><span class="line"><span class="comment">	 * (此代码片段中省略了这部分实现，但现实中它会存在)。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * ldr_va - 从符号\sym的虚拟地址加载一个32位的字。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 定义一个名为ldr_va的汇编宏。</span></span><br><span class="line"><span class="comment">	 * rd:     必需参数，目标寄存器。</span></span><br><span class="line"><span class="comment">	 * sym:    必需参数，要加载的变量符号名。</span></span><br><span class="line"><span class="comment">	 * cond:   可选参数，指令的条件码（如eq, ne）。</span></span><br><span class="line"><span class="comment">	 * tmp:    可选参数，用于地址计算的临时寄存器。</span></span><br><span class="line"><span class="comment">	 * offset: 可选参数，地址偏移量，默认为0。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	.macro		ldr_va, rd:req, sym:req, cond, tmp, offset=<span class="number">0</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * .ifnb \tmp: 如果调用时传入的&#x27;tmp&#x27;参数不是空的（not blank）。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	.ifnb		\tmp</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 如果提供了临时寄存器&#x27;tmp&#x27;，则调用内部宏__ldst_va。</span></span><br><span class="line"><span class="comment">	 * 参数传递：</span></span><br><span class="line"><span class="comment">	 *  - ldr:      指定操作是加载(load)。</span></span><br><span class="line"><span class="comment">	 *  - \rd:      最终的目标寄存器。</span></span><br><span class="line"><span class="comment">	 *  - \tmp:     用于地址计算的临时寄存器。</span></span><br><span class="line"><span class="comment">	 *  - ...其他参数照常传递...</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	__ldst_va	ldr, \rd, \tmp, \sym, \cond, \offset</span><br><span class="line">	.<span class="keyword">else</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 如果调用时没有提供&#x27;tmp&#x27;参数。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 同样调用内部宏__ldst_va，但这次将&#x27;tmp&#x27;参数的位置</span></span><br><span class="line"><span class="comment">	 * 传入了&#x27;\rd&#x27;。这等于告诉__ldst_va：“你没有别的临时寄存器可用，</span></span><br><span class="line"><span class="comment">	 * 就用目标寄存器rd自己来做地址计算的中转吧”。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	__ldst_va	ldr, \rd, \rd, \sym, \cond, \offset</span><br><span class="line">	.endif</span><br><span class="line">	.endm</span><br></pre></td></tr></table></figure>

<h2 id="ldr-this-cpu-从每个-CPU-的变量-‘sym’-加载一个-32-位字-插入寄存器-‘rd’"><a href="#ldr-this-cpu-从每个-CPU-的变量-‘sym’-加载一个-32-位字-插入寄存器-‘rd’" class="headerlink" title="ldr_this_cpu 从每个 CPU 的变量 ‘sym’ 加载一个 32 位字 插入寄存器 ‘rd’"></a>ldr_this_cpu 从每个 CPU 的变量 ‘sym’ 加载一个 32 位字 插入寄存器 ‘rd’</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * ldr_this_cpu - 从每CPU变量&#x27;sym&#x27;中加载一个32位字</span></span><br><span class="line"><span class="comment">	 *       到寄存器&#x27;rd&#x27;中，&#x27;rd&#x27;可以是堆栈指针。</span></span><br><span class="line"><span class="comment">	 *       使用&#x27;t1&#x27;和&#x27;t2&#x27;作为通用临时寄存器。如果&#x27;rd&#x27;不是sp，</span></span><br><span class="line"><span class="comment">	 *       它们可以和&#x27;rd&#x27;重叠。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 定义一个名为ldr_this_cpu的汇编宏，它接受四个必需的参数：</span></span><br><span class="line"><span class="comment">	 * rd: 目标寄存器</span></span><br><span class="line"><span class="comment">	 * sym: 要访问的per-CPU变量的符号名</span></span><br><span class="line"><span class="comment">	 * t1, t2: 临时寄存器</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	.macro		ldr_this_cpu, rd:req, sym:req, t1:req, t2:req</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ---- 分支一：单核（UP）系统 ----</span></span><br><span class="line"><span class="comment"> * 如果内核没有以SMP模式编译（即单核）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 对于单核系统，per-CPU变量就是普通的全局变量。</span></span><br><span class="line"><span class="comment">	 * ldr_va是一个宏，它会展开为一条简单的LDR指令，</span></span><br><span class="line"><span class="comment">	 * 直接从&#x27;sym&#x27;变量的地址加载值到&#x27;rd&#x27;寄存器。</span></span><br><span class="line"><span class="comment">	 * temp=\t1表示使用临时寄存器t1来存储中间结果。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ldr_va		\rd, \sym, tmp=\t1</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __LINUX_ARM_ARCH__ &gt;= 7 || \</span></span><br><span class="line"><span class="meta">      !defined(CONFIG_ARM_HAS_GROUP_RELOCS) || \</span></span><br><span class="line"><span class="meta">      (defined(MODULE) &amp;&amp; defined(CONFIG_ARM_MODULE_PLTS))</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	.endm</span><br></pre></td></tr></table></figure>

<h2 id="get-thread-info-获取当前线程信息"><a href="#get-thread-info-获取当前线程信息" class="headerlink" title="get_thread_info 获取当前线程信息"></a>get_thread_info 获取当前线程信息</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * get_current - load the task pointer of this CPU&#x27;s current task</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	.macro		get_current, rd:req</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_CURRENT_POINTER_IN_TPIDRURO) || defined(CONFIG_SMP)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	ldr_va		\rd, __current</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	.endm</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Get current thread_info.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	.macro	get_thread_info, rd</span><br><span class="line">	<span class="comment">/* thread_info is the first member of struct task_struct */</span></span><br><span class="line">	get_current \rd</span><br><span class="line">	.endm</span><br></pre></td></tr></table></figure>

<h1 id="arch-arm-include-asm-v7m-h"><a href="#arch-arm-include-asm-v7m-h" class="headerlink" title="arch&#x2F;arm&#x2F;include&#x2F;asm&#x2F;v7m.h"></a>arch&#x2F;arm&#x2F;include&#x2F;asm&#x2F;v7m.h</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//arch/arm/include/asm/assembler.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOMEM(x)	(x)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 当分支到具有位 [31：28] == 0xf 的地址时，将发生异常返回。</span></span><br><span class="line"><span class="comment"> 位 [27：5] 是保留的 （SBOP）。</span></span><br><span class="line"><span class="comment"> 如果处理器实现 FP 扩展位 [4] 定义异常帧是否为 FP 状态信息分配了空间，否则为 SBOP。</span></span><br><span class="line"><span class="comment"> 位 [3] 定义返回的模式（0 -&gt; 处理程序模式;1 -&gt; 线程模式）。</span></span><br><span class="line"><span class="comment"> 位 [2] 定义使用哪个 sp （0 -&gt; msp;1 -&gt; psp）。</span></span><br><span class="line"><span class="comment"> 位 [1：0] 固定为 0b01。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXC_RET_STACK_MASK			0x00000004</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXC_RET_THREADMODE_PROCESSSTACK		(3 &lt;&lt; 2)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Common defines for v7m cpus</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> V7M_SCS_ICTR			IOMEM(0xe000e004)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> V7M_SCS_ICTR_INTLINESNUM_MASK		0x0000000f</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BASEADDR_V7M_SCB		IOMEM(0xe000ed00)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> V7M_SCB_CPUID			0x00</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> V7M_SCB_ICSR			0x04</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> V7M_SCB_ICSR_PENDSVSET			(1 &lt;&lt; 28)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> V7M_SCB_ICSR_PENDSVCLR			(1 &lt;&lt; 27)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> V7M_SCB_ICSR_RETTOBASE			(1 &lt;&lt; 11)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> V7M_SCB_ICSR_VECTACTIVE			0x000001ff</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> V7M_SCB_VTOR			0x08</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> V7M_SCB_AIRCR			0x0c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> V7M_SCB_AIRCR_VECTKEY			(0x05fa &lt;&lt; 16)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> V7M_SCB_AIRCR_SYSRESETREQ		(1 &lt;&lt; 2)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> V7M_SCB_SCR			0x10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> V7M_SCB_SCR_SLEEPDEEP			(1 &lt;&lt; 2)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> V7M_SCB_CCR			0x14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> V7M_SCB_CCR_STKALIGN			(1 &lt;&lt; 9)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> V7M_SCB_CCR_DC				(1 &lt;&lt; 16)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> V7M_SCB_CCR_IC				(1 &lt;&lt; 17)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> V7M_SCB_CCR_BP				(1 &lt;&lt; 18)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> V7M_SCB_SHPR2			0x1c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> V7M_SCB_SHPR3			0x20</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> V7M_SCB_SHCSR			0x24</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> V7M_SCB_SHCSR_USGFAULTENA		(1 &lt;&lt; 18)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> V7M_SCB_SHCSR_BUSFAULTENA		(1 &lt;&lt; 17)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> V7M_SCB_SHCSR_MEMFAULTENA		(1 &lt;&lt; 16)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> V7M_xPSR_FRAMEPTRALIGN			0x00000200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> V7M_xPSR_EXCEPTIONNO			V7M_SCB_ICSR_VECTACTIVE</span></span><br></pre></td></tr></table></figure>

<h1 id="arch-arm-kernel-entry-header-S"><a href="#arch-arm-kernel-entry-header-S" class="headerlink" title="arch&#x2F;arm&#x2F;kernel&#x2F;entry-header.S"></a>arch&#x2F;arm&#x2F;kernel&#x2F;entry-header.S</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ARMv7-M 异常进入/退出宏。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * xPSR、ReturnAddress（）、LR （R14）、R12、R3、R2、R1 和 R0 是</span></span><br><span class="line"><span class="comment"> * 之前自动保存在当前堆栈（32 个单词）上</span></span><br><span class="line"><span class="comment"> * 切换到异常堆栈 （SP_main）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果在用户模式下出现异常，则SP_main</span></span><br><span class="line"><span class="comment"> *空。否则，SP_main 会自动对齐到 64 位</span></span><br><span class="line"><span class="comment"> * （CCR.STKALIGN 集）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Linux 假定在输入</span></span><br><span class="line"><span class="comment"> * 异常处理程序，否则可能会 BUG。中断</span></span><br><span class="line"><span class="comment"> * 在进入时被禁用，并在 Exit 宏中重新启用。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 从 SVC 或 PendSV 返回时使用 v7m_exception_slow_exit。</span></span><br><span class="line"><span class="comment"> * 返回内核模式时，我们不会从 exception 返回。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="v7m-exception-entry-进入中断"><a href="#v7m-exception-entry-进入中断" class="headerlink" title="v7m_exception_entry 进入中断"></a>v7m_exception_entry 进入中断</h2><ul>
<li><code>v7m_exception_entry</code>宏的主要目的是为ARMv7-M架构的异常处理程序提供一个安全且一致的运行环境。ARMv7-M处理器在发生异常时会自动保存部分寄存器状态，但这并不足以满足Linux内核的需求。Linux内核需要：<ol>
<li><strong>保存更多的寄存器状态</strong>：ARMv7-M自动保存的寄存器（如<code>xPSR</code>、<code>R0-R3</code>等）不足以满足内核的上下文切换需求，因此需要额外保存<code>R4-R11</code>等寄存器。</li>
<li><strong>禁用中断</strong>：Linux内核假定在进入异常处理程序时中断已被禁用，以避免中断干扰异常处理。</li>
<li><strong>对齐堆栈</strong>：ARMv7-M可能会自动对堆栈进行8字节对齐，Linux内核需要根据对齐情况调整堆栈指针。</li>
<li><strong>为异常处理程序准备上下文</strong>：将寄存器状态和其他必要信息存储到堆栈中，供异常处理程序使用。</li>
</ol>
</li>
<li><code>v7m_exception_entry</code>宏的作用可以总结为以下几点：</li>
</ul>
<ol>
<li><strong>确定异常堆栈</strong>：根据异常发生时的模式（用户模式或内核模式），选择主堆栈（<code>SP_main</code>）或进程堆栈（<code>PSP</code>）。</li>
<li><strong>保存寄存器状态</strong>：将所有需要的寄存器（包括<code>R0-R11</code>、<code>R12</code>、<code>LR</code>、<code>PC</code>和<code>xPSR</code>）保存到堆栈中。</li>
<li><strong>禁用中断</strong>：确保异常处理程序在执行时不会被中断干扰。</li>
<li><strong>调整堆栈对齐</strong>：根据<code>xPSR</code>中的对齐标志调整堆栈指针，确保堆栈对齐符合ARMv7-M架构的要求。</li>
<li><strong>为异常处理程序准备上下文</strong>：将寄存器状态和其他必要信息存储到堆栈中，供异常处理程序使用。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * ARMv7-M 异常进入/退出宏。</span><br><span class="line"> *</span><br><span class="line">在进入异常时，处理器会自动将xPSR、返回地址（ReturnAddress()）、LR (R14)、R12、R3、R2、R1和R0保存到当前堆栈（共32字节），然后切换到异常堆栈（SP_main）。</span><br><span class="line"></span><br><span class="line">如果异常发生在用户模式下，SP_main为空；否则，SP_main会自动对齐到64位（通过CCR.STKALIGN设置）。</span><br><span class="line"></span><br><span class="line">Linux假定在进入异常处理程序时中断已被禁用。如果不是这种情况，可能会导致BUG。在入口宏中禁用中断，并在退出宏中重新启用。</span><br><span class="line"></span><br><span class="line">v7m_exception_slow_exit用于从SVC或PendSV返回。当返回到内核模式时，不会从异常中返回。</span><br><span class="line"> */</span><br><span class="line">	.macro	v7m_exception_entry</span><br><span class="line">	/*</span><br><span class="line">	确定异常发生时处理器保存的寄存器位置。根据CPU进入异常时的模式，寄存器可能保存在主堆栈（SP_main）或进程堆栈（PSP）中。lr寄存器中的EXC_RETURN的第2位决定使用哪个堆栈。</span><br><span class="line">	*/</span><br><span class="line">	//TST lr, #EXC_RET_STACK_MASK检查lr寄存器的第4位。如果该位为1，则使用进程堆栈；否则，使用主堆栈</span><br><span class="line">	tst	lr, #EXC_RET_STACK_MASK</span><br><span class="line">	mrsne	r12, psp		//从PSP加载堆栈指针到r12。</span><br><span class="line">	moveq	r12, sp			//从SP_main加载堆栈指针到r12</span><br><span class="line"></span><br><span class="line">	//由于尾链（tail-chaining）的存在，r0-r3和r12的值可能与异常帧中保存的不一致，因此需要重新加载。</span><br><span class="line">	ldmia	r12!, &#123;r0-r3&#125;</span><br><span class="line"></span><br><span class="line">	@ Linux假定中断在进入异常处理程序时已被禁用。在分配堆栈空间之前禁用中断。</span><br><span class="line">	cpsid	i	// CPSID i指令禁用中断（IRQ）</span><br><span class="line">	//调整堆栈指针以分配空间，并将r0-r11寄存器的值压入堆栈</span><br><span class="line">	sub	sp, #PT_REGS_SIZE-S_IP	//为保存寄存器分配堆栈空间。</span><br><span class="line">	stmdb	sp!, &#123;r0-r11&#125;		//将r0-r11的值存储到堆栈中，并更新堆栈指针</span><br><span class="line"></span><br><span class="line">	// 加载保存的r12、lr、返回地址和xPSR。从现在开始，r0-r7用于信号处理，不会被修改，而r8-r12可以被覆盖。</span><br><span class="line">	mov	r9, r12</span><br><span class="line">	ldmia	r9!, &#123;r8, r10-r12&#125;</span><br><span class="line"></span><br><span class="line">	// 计算原始堆栈指针值。r9当前指向自动保存的xPSR上方的内存位置。如果CPU自动对堆栈进行了8字节对齐（xPSR的第9位设置），则堆栈中会额外包含一个32位值。</span><br><span class="line"></span><br><span class="line">	tst	r12, V7M_xPSR_FRAMEPTRALIGN</span><br><span class="line">	addne	r9, r9, #4	//如果设置了对齐位，则调整r9以跳过额外的32位值</span><br><span class="line"></span><br><span class="line">	@ 将保存的r12存储到堆栈中，并将sp加上偏移量存储到r8中，作为后续STM操作的基地址</span><br><span class="line">	str	r8, [sp, #S_IP]</span><br><span class="line">	add	r8, sp, #S_SP</span><br><span class="line">	@ store r13-r15, xPSR</span><br><span class="line">	stmia	r8!, &#123;r9-r12&#125;</span><br><span class="line">	@ store old_r0</span><br><span class="line">	str	r0, [r8]</span><br><span class="line">	.endm</span><br></pre></td></tr></table></figure>



<h2 id="v7m-exception-slow-exit-退出中断"><a href="#v7m-exception-slow-exit-退出中断" class="headerlink" title="v7m_exception_slow_exit 退出中断"></a>v7m_exception_slow_exit 退出中断</h2><ul>
<li>读取当前内核栈上的pt_regs结构体，从中提取出被中断任务的核心寄存器（SP, LR, PC, xPSR等），然后在<strong>目标任务的栈上</strong>（这里是PSP）<strong>手动重建一个硬件能够识别的、最小化的异常帧</strong>。最后，通过BX LR指令，触发硬件自动完成剩余的恢复工作。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * PendSV和SVC被配置为相同优先级。因为内核线程在SVC优先级运行，</span><br><span class="line"> * 它永远不会被抢占，所以这个返回路径永远不需要返回到一个内核线程。</span><br><span class="line"> * 这意味着，此宏处理的总是返回到用户模式（使用进程堆栈指针PSP）的场景。</span><br><span class="line"> */</span><br><span class="line">	.macro	v7m_exception_slow_exit ret_r0</span><br><span class="line">	/*</span><br><span class="line">	 * Step 1: 准备返回环境。</span><br><span class="line">	 * ----------------------</span><br><span class="line">	 * 首先关闭中断，确保接下来的上下文恢复操作是原子的。然后从全局变量</span><br><span class="line">	 * exc_ret 中加载特殊的EXC_RETURN值到LR寄存器。这个值是触发硬件</span><br><span class="line">	 * 异常返回机制的“钥匙”，它告诉硬件返回时应使用PSP，并进入线程模式。</span><br><span class="line">	 */</span><br><span class="line">	cpsid	i</span><br><span class="line">	ldr	lr, =exc_ret</span><br><span class="line">	ldr	lr, [lr]</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Step 2: 从内核栈上的pt_regs中提取核心寄存器。</span><br><span class="line">	 * ----------------------------------------------------</span><br><span class="line">	 * 内核栈(sp)上保存着一个完整的pt_regs结构体。我们首先需要从中读取出</span><br><span class="line">	 * 被中断任务的几个关键寄存器，以便后续在目标任务的栈上重建硬件帧。</span><br><span class="line">	 *</span><br><span class="line">	 * add r12, sp, #S_IP: 计算出pt_regs中ARM_ip字段的地址，放入r12。</span><br><span class="line">	 * ldmia r12, &#123;r1-r5&#125;: 从该地址开始，连续加载5个32位值到寄存器中。</span><br><span class="line">	 *   - r1 (临时) &lt;-- pt_regs.ARM_ip  (原始r12)</span><br><span class="line">	 *   - r2 (临时) &lt;-- pt_regs.ARM_sp  (原始SP，即我们要恢复的PSP)</span><br><span class="line">	 *   - r3 (临时) &lt;-- pt_regs.ARM_lr  (原始LR)</span><br><span class="line">	 *   - r4 (临时) &lt;-- pt_regs.ARM_pc  (原始PC)</span><br><span class="line">	 *   - r5 (临时) &lt;-- pt_regs.ARM_cpsr (原始xPSR)</span><br><span class="line">	 */</span><br><span class="line">	add	r12, sp, #S_IP</span><br><span class="line">	ldmia	r12, &#123;r1-r5&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Step 3: 精确重建硬件要求的栈对齐状态。</span><br><span class="line">	 * --------------------------------------------</span><br><span class="line">	 * 硬件在异常返回时，需要通过xPSR的第9位得知目标栈是否是8字节对齐的。</span><br><span class="line">	 * 我们必须根据从pt_regs中读出的原始SP值(在r2中)，来正确设置这个标志位。</span><br><span class="line">	 *</span><br><span class="line">	 * tst r2, #4: 检查原始SP的第2位是否为1（即地址是否是...100b）。</span><br><span class="line">	 * subne r2, r2, #4: 这行代码的意图可能是处理某些对齐的边界情况，</span><br><span class="line">	 *                   确保硬件帧的基地址正确。</span><br><span class="line">	 * orrne r5, V7M_xPSR_FRAMEPTRALIGN: 如果SP不是8字节对齐，则在xPSR(r5)中</span><br><span class="line">	 *                                   设置对齐标志位。</span><br><span class="line">	 * biceq r5, V7M_xPSR_FRAMEPTRALIGN: 如果SP是8字节对齐的，则清除xPSR(r5)中</span><br><span class="line">	 *                                   的对齐标志位。</span><br><span class="line">	 *</span><br><span class="line">	 * 经过这一步，r2(目标SP)和r5(目标xPSR)已经完全符合硬件要求。</span><br><span class="line">	 */</span><br><span class="line">	tst	r2, #4</span><br><span class="line">	subne	r2, r2, #4</span><br><span class="line">	orrne	r5, V7M_xPSR_FRAMEPTRALIGN</span><br><span class="line">	biceq	r5, V7M_xPSR_FRAMEPTRALIGN</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Step 4: 清理PC值并开始在目标栈上构建硬件帧。</span><br><span class="line">	 * ------------------------------------------------</span><br><span class="line">	 * 硬件要求PC值的最低位（Thumb位）必须为1，但地址本身必须是偶数。</span><br><span class="line">	 * 此处bic r4, #1是为了确保地址是偶数，硬件在跳转时会自动处理Thumb位。</span><br><span class="line">	 *</span><br><span class="line">	 * stmdb r2!, &#123;r1, r3-r5&#125;: 这是构建硬件帧的第一部分。在目标SP(r2)上，</span><br><span class="line">	 *                         按照硬件要求的顺序，压入r1(原始r12), r3(原始LR),</span><br><span class="line">	 *                         r4(原始PC), r5(原始xPSR)。</span><br><span class="line">	 */</span><br><span class="line">	bic	r4, #1</span><br><span class="line">	stmdb	r2!, &#123;r1, r3-r5&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Step 5: 从内核栈上加载剩余的低位寄存器。</span><br><span class="line">	 * ----------------------------------------------</span><br><span class="line">	 * 现在，我们需要从内核栈的pt_regs中加载原始的r0-r3。</span><br><span class="line">	 * ldmia sp, &#123;r1, r3-r5&#125;: 这一步的理解是，它从内核栈的pt_regs的</span><br><span class="line">	 *                        r1,r3,r4,r5位置加载值到临时寄存器。</span><br><span class="line">	 *                        这可能是为了准备下一步的写入。</span><br><span class="line">	 */</span><br><span class="line">	ldmia	sp, &#123;r1, r3-r5&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Step 6: 完成硬件帧的构建（写入r0-r3）。</span><br><span class="line">	 * ------------------------------------------</span><br><span class="line">	 * 这是最精妙的部分。根据宏参数ret_r0 (来自fast)，决定硬件帧中r0-r3的内容。</span><br><span class="line">	 *</span><br><span class="line">	 * .if \ret_r0: ret_r0非零，意味着fast=0，需要恢复所有寄存器。</span><br><span class="line">	 *   - stmdb r2!, &#123;r0, r3-r5&#125;: 这里的r0是当前CPU的r0，它应该是在上一步</span><br><span class="line">	 *     从pt_regs的r0位置加载而来的。这行指令将原始的r0, r1, r2, r3</span><br><span class="line">	 *     压入目标栈，完成硬件帧。这里的代码模式&#123;r0, r3-r5&#125;可能是一种</span><br><span class="line">	 *     写法技巧或特定版本的语法，其意图是压入r0-r3这四个值。</span><br><span class="line">	 *</span><br><span class="line">	 * .else: ret_r0为零，意味着fast=1，不需要恢复r0 (用作返回值)。</span><br><span class="line">	 *   - stmdb r2!, &#123;r1, r3-r5&#125;: 此时，硬件帧中r0的位置被写入了r1的值。</span><br><span class="line">	 *     因为此时的r0是系统调用的返回值，不能被覆盖。</span><br><span class="line">	 *</span><br><span class="line">	 * 经过这一步，一个完整的8寄存器硬件帧在目标栈上构建完毕。</span><br><span class="line">	 */</span><br><span class="line">	.if	\ret_r0</span><br><span class="line">	stmdb	r2!, &#123;r0, r3-r5&#125;</span><br><span class="line">	.else</span><br><span class="line">	stmdb	r2!, &#123;r1, r3-r5&#125;</span><br><span class="line">	.endif</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Step 7: 恢复CPU状态。</span><br><span class="line">	 * ---------------------</span><br><span class="line">	 * msr psp, r2: 将我们构建好的目标栈指针r2，写入到物理的进程堆栈指针PSP中。</span><br><span class="line">	 *</span><br><span class="line">	 * ldmia sp!, &#123;r0-r11&#125;: 从内核栈(sp)上一次性恢复r0-r11到CPU中。</span><br><span class="line">	 *                      这既恢复了被中断任务的r4-r11，也恢复了被用作</span><br><span class="line">	 *                      临时的r0-r3。同时，sp指针也向前移动，</span><br><span class="line">	 *                      相当于释放了pt_regs中这部分空间。</span><br><span class="line">	 *</span><br><span class="line">	 * add sp, sp, #PT_REGS_SIZE-S_IP: 彻底恢复内核栈指针，释放整个</span><br><span class="line">	 *                               pt_regs结构体的空间。</span><br><span class="line">	 *</span><br><span class="line">	 * cpsie i: 重新开启中断。</span><br><span class="line">	 */</span><br><span class="line">	msr	psp, r2</span><br><span class="line">	ldmia	sp!, &#123;r0-r11&#125;</span><br><span class="line">	add	sp, sp, #PT_REGS_SIZE-S_IP</span><br><span class="line">	cpsie	i</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Step 8: 执行硬件返回。</span><br><span class="line">	 * ---------------------</span><br><span class="line">	 * bx lr: 这是最后的魔法。LR寄存器中是我们第一步加载的EXC_RETURN值。</span><br><span class="line">	 *        CPU看到这个指令和LR中的特殊值，就会启动硬件自动恢复机制：</span><br><span class="line">	 *        它会从PSP指向的地址（我们刚刚构建的硬件帧）弹出8个寄存器，</span><br><span class="line">	 *        恢复CPU模式和PC，然后无缝地从被中断的地方继续执行。</span><br><span class="line">	 */</span><br><span class="line">	bx	lr</span><br><span class="line">	.endm</span><br></pre></td></tr></table></figure>

<h2 id="restore-user-regs-恢复寄存器"><a href="#restore-user-regs-恢复寄存器" class="headerlink" title="restore_user_regs 恢复寄存器."></a>restore_user_regs 恢复寄存器.</h2><ul>
<li>restore_user_regs 的唯一职责是，将在内核栈上保存的pt_regs结构体中的值，准确无误地加载回CPU的物理寄存器中，并执行最后的返回指令，让CPU从被中断的地方继续运行。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">.macro	restore_user_regs, fast = 0, offset = 0</span><br><span class="line"></span><br><span class="line">#ifndef CONFIG_THUMB2_KERNEL</span><br><span class="line">#elif defined(CONFIG_CPU_V7M)</span><br><span class="line">	@ V7M恢复。</span><br><span class="line">	@ 我们不需要在这里执行clrex（清除独占监视器），</span><br><span class="line">	@ 因为这是异常进入和退出序列的一部分，由硬件自动处理。</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * 1. 处理栈偏移</span><br><span class="line">	 */</span><br><span class="line">	.if	\offset</span><br><span class="line">	/* 如果调用时传入的offset参数非零，就执行这条指令。*/</span><br><span class="line">	add	sp, #\offset</span><br><span class="line">	.endif</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * 2. 委托给专家宏执行恢复</span><br><span class="line">	 */</span><br><span class="line">	v7m_exception_slow_exit ret_r0 = \fast</span><br><span class="line">#else</span><br><span class="line">#endif	/* !CONFIG_THUMB2_KERNEL */</span><br><span class="line">	.endm</span><br></pre></td></tr></table></figure>

<h2 id="scno-系统调用号-tbl-系统调用表指针-why-Linux-syscall-tsk-当前线程信息"><a href="#scno-系统调用号-tbl-系统调用表指针-why-Linux-syscall-tsk-当前线程信息" class="headerlink" title="scno (系统调用号) tbl (系统调用表指针) why (Linux syscall) tsk (当前线程信息)"></a>scno (系统调用号) tbl (系统调用表指针) why (Linux syscall) tsk (当前线程信息)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 这些是系统调用处理程序中使用的寄存器，理论上允许我们</span><br><span class="line"> * 向一个函数传递多达7个参数 - r0 到 r6。</span><br><span class="line"> * 对于Thumb模式，r7被保留用于存放系统调用号。</span><br><span class="line"> * tbl == why 是有意为之的。</span><br><span class="line"> * 在调用 ret_with_reschedule 时，我们必须至少设置 &quot;tsk&quot; 和 &quot;why&quot;。</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * scno .req r7:</span><br><span class="line"> * 定义 r7 寄存器的别名为 scno (syscall number)。</span><br><span class="line"> * 在ARM EABI的系统调用规范中，r7通常用于传递系统调用号。</span><br><span class="line"> * 当用户空间代码执行 SVC #0 指令时，内核的SVC Handler会从r7中</span><br><span class="line"> * 读取这个编号，以确定用户请求的是哪个系统调用。</span><br><span class="line"> */</span><br><span class="line">scno	.req	r7		@ syscall number</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * tbl .req r8:</span><br><span class="line"> * 定义 r8 寄存器的别名为 tbl (table)。</span><br><span class="line"> * 注释表明它用作“syscall table pointer”（系统调用表指针）。</span><br><span class="line"> * 内核在获取到系统调用号(scno)后，会以tbl(r8)为基地址，</span><br><span class="line"> * scno(r7)为索引，在系统调用表中查找到对应的C函数处理程序。</span><br><span class="line"> */</span><br><span class="line">tbl	.req	r8		@ syscall table pointer</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * why .req r8:</span><br><span class="line"> * 再次将 r8 寄存器定义为别名 why。</span><br><span class="line"> * 注释“Linux syscall (!= 0)”暗示了它的用途。why通常用于区分</span><br><span class="line"> * 不同的内核返回路径。当从一个常规的Linux系统调用返回时，why会被</span><br><span class="line"> * 设置为一个非零值。这与“tbl == why is intentional”的注释相呼应，</span><br><span class="line"> * 表明在系统调用处理的某个阶段，r8的角色会从“表指针”转变为</span><br><span class="line"> * “返回路径标识符”。这是一个寄存器复用的例子。</span><br><span class="line"> */</span><br><span class="line">why	.req	r8		@ Linux syscall (!= 0)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * tsk .req r9:</span><br><span class="line"> * 定义 r9 寄存器的别名为 tsk (task)。</span><br><span class="line"> * 它用于存放当前任务的 thread_info 结构体的指针。</span><br><span class="line"> * 在ARM Linux内核中，r9通常被保留作为一个“钦定”的寄存器，</span><br><span class="line"> * 用于快速访问当前任务的信息，相当于current_thread_info()。</span><br><span class="line"> */</span><br><span class="line">tsk	.req	r9		@ current thread_info</span><br></pre></td></tr></table></figure>

<h2 id="invoke-syscall-调用系统调用"><a href="#invoke-syscall-调用系统调用" class="headerlink" title="invoke_syscall (调用系统调用)"></a>invoke_syscall (调用系统调用)</h2><ol>
<li>参数校验：首先，它会检查用户传入的系统调用号（nr）是否在一个合法的范围内，防止恶意或错误地调用未定义的服务，这是一个基本的安全措施。</li>
<li>设置返回点：它会预先将系统调用执行完毕后应该返回的地址（由ret参数指定）加载到LR（链接寄存器）中。这样，当内核函数执行BX LR或MOV PC, LR时，就能正确地回到系统调用处理的后续流程中。</li>
<li>参数重载（可选）：在某些情况下（如系统调用被信号中断后重启），需要从栈上的pt_regs中重新加载参数。reload参数控制是否执行这个操作。</li>
<li>查表与跳转：这是最核心的一步。它以系统调用表（table）的基地址为准，以系统调用号（nr）为索引，计算出目标内核函数（如sys_read, sys_write）的地址，然后直接通过LDR PC, […]指令跳转到该函数去执行。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">	/*</span><br><span class="line">	 * 声明一个名为invoke_syscall的汇编宏，它接受table, nr, tmp, ret, reload五个参数。</span><br><span class="line">	 */</span><br><span class="line">	.macro	invoke_syscall, table, nr, tmp, ret, reload=0</span><br><span class="line">/*</span><br><span class="line"> * 如果内核配置了CONFIG_CPU_SPECTRE，则编译这部分代码以缓解Spectre漏洞。</span><br><span class="line"> */</span><br><span class="line">#ifdef CONFIG_CPU_SPECTRE</span><br><span class="line">	/* 将系统调用号(nr)移入一个临时寄存器(tmp)。*/</span><br><span class="line">	mov	\tmp, \nr</span><br><span class="line">	/* 比较系统调用号是否超出了系统定义的上限(NR_syscalls)。*/</span><br><span class="line">	cmp	\tmp, #NR_syscalls</span><br><span class="line">	/* movcs: 如果比较结果为CS(Carry Set, 表示nr &gt;= NR_syscalls)，则将tmp清零。</span><br><span class="line">	 *        这是一种安全措施，使得无效的调用号最终会跳转到sys_ni_syscall。*/</span><br><span class="line">	movcs	\tmp, #0</span><br><span class="line">	/* csdb: 条件同步屏障，是Spectre v1的缓解措施之一，用于防止恶意分支预测。*/</span><br><span class="line">	csdb</span><br><span class="line">	/* badr: 将返回地址(由ret标签指定)加载到LR寄存器。*/</span><br><span class="line">	badr	lr, \ret</span><br><span class="line">	/* .if \reload: 如果宏的reload参数非零，则执行以下代码块。</span><br><span class="line">	 *              这通常用于被信号中断后重启的系统调用。*/</span><br><span class="line">	.if	\reload</span><br><span class="line">	/* r1 = ®s-&gt;r0，计算出栈上pt_regs中r0的地址。*/</span><br><span class="line">	add	r1, sp, #S_R0 + S_OFF</span><br><span class="line">	/* ldmiacc: 从r1指向的地址，一次性加载r0-r6到CPU寄存器，恢复参数。*/</span><br><span class="line">	ldmiacc	r1, &#123;r0 - r6&#125;</span><br><span class="line">	/* stmiacc: 将r4, r5重新存入栈上，更新某些栈上传递的参数。*/</span><br><span class="line">	stmiacc	sp, &#123;r4, r5&#125;</span><br><span class="line">	.endif</span><br><span class="line">	/* ldrcc: 如果cmp的结果为CC(Carry Clear, 表示nr &lt; NR_syscalls)，则执行跳转。</span><br><span class="line">	 *        这是核心的分发指令：</span><br><span class="line">	 *        pc = table_base_addr + (tmp * 4)</span><br><span class="line">	 *        它以系统调用表(table)为基址，系统调用号(tmp)为索引，</span><br><span class="line">	 *        计算出目标内核函数的地址，并直接跳转过去执行。*/</span><br><span class="line">	ldrcc	pc, [\table, \tmp, lsl #2]</span><br><span class="line">#else</span><br><span class="line">/*</span><br><span class="line"> * 如果没有配置CONFIG_CPU_SPECTRE，则编译这部分不含缓解措施的、更高效的代码。</span><br><span class="line"> */</span><br><span class="line">	/* 比较系统调用号是否超出了系统定义的上限。*/</span><br><span class="line">	cmp	\nr, #NR_syscalls</span><br><span class="line">	/* 将返回地址(由ret标签指定)加载到LR寄存器。*/</span><br><span class="line">	badr	lr, \ret</span><br><span class="line">	/* 如果reload参数非零，则执行参数重载。*/</span><br><span class="line">	.if	\reload</span><br><span class="line">	add	r1, sp, #S_R0 + S_OFF</span><br><span class="line">	ldmiacc	r1, &#123;r0 - r6&#125;</span><br><span class="line">	stmiacc	sp, &#123;r4, r5&#125;</span><br><span class="line">	.endif</span><br><span class="line">	/* ldrcc: 如果nr有效，则计算目标函数地址并跳转执行。</span><br><span class="line">	 *        pc = table_base_addr + (nr * 4) */</span><br><span class="line">	ldrcc	pc, [\table, \nr, lsl #2]</span><br><span class="line">#endif</span><br><span class="line">	/* 宏定义结束。*/</span><br><span class="line">	.endm</span><br></pre></td></tr></table></figure>

<h3 id="Spectre漏洞是什么？一个生动的比喻"><a href="#Spectre漏洞是什么？一个生动的比喻" class="headerlink" title="Spectre漏洞是什么？一个生动的比喻"></a><strong>Spectre漏洞是什么？一个生动的比喻</strong></h3><p>想象一位非常<strong>性急但能干的图书管理员</strong>，他叫“预测执行”（Speculative Execution）。</p>
<ol>
<li><p><strong>用户请求</strong>：你（一个程序）向管理员要一本书，但需要提供一个复杂的索引号<code>X</code>。这个<code>X</code>的计算很慢，而且你可能没有权限访问它。</p>
</li>
<li><p><strong>管理员的“预测”</strong>：管理员不想干等，他非常聪明，会<strong>猜测</strong>你最终会要哪本书。比如，他根据你以前常借的书，猜测你这次可能要的是《烹饪大全》。</p>
</li>
<li><p><strong>提前拿书（预测执行）</strong>：在等你计算出<code>X</code>的时候，他就已经跑去书库，把《烹饪大全》拿了出来，甚至翻开了第一页放在桌上。<strong>这个过程非常快，但都是在“幕后”悄悄进行的。</strong></p>
</li>
<li><p><strong>最终检查</strong>：你终于计算出了索引号<code>X</code>，并把它交给管理员。</p>
<ul>
<li><strong>情况A（猜对了）</strong>：如果<code>X</code>正好对应《烹饪大全》，管理员直接把已经准备好的书给你，大大节省了时间。</li>
<li><strong>情况B（猜错了或无权限）</strong>：如果<code>X</code>对应的是《黑客秘籍》，而你没有权限访问，管理员会立刻意识到错误。他会<strong>撤销</strong>之前的操作，把《烹饪大全》放回书架，擦掉桌上的痕迹，然后正式地告诉你：“抱歉，你无权访问这本书。”</li>
</ul>
</li>
</ol>
<p><strong>漏洞在哪里？</strong></p>
<p>从表面上看，一切都安全无虞。你最终没有拿到不该拿的书。但问题在于，管理员在“预测执行”时，虽然最后撤销了操作，但他的行为<strong>留下了一些微小的、可被观察到的“副作用”（Side Effects）</strong>。</p>
<ul>
<li><strong>副作用</strong>：比如，他去拿《烹饪大全》时，那个书架上的灰尘被多擦掉了一点；或者他回来时，因为拿了本厚书，心跳稍微快了一点。</li>
</ul>
<p>一个<strong>精明的攻击者</strong>（另一个恶意程序）虽然看不到书的内容，但可以通过<strong>精确测量这些副作用</strong>（例如，通过测量访问某个内存地址的速度，即缓存攻击），来反推出管理员<strong>曾经预测性地访问过</strong>哪些数据。</p>
<p><strong>Spectre漏洞的核心</strong>：攻击者可以<strong>诱导</strong>处理器去<strong>预测性地执行</strong>一些它本不该执行的代码（比如访问内核或其他进程的敏感数据），即使这些操作最终会被撤销，但其执行过程中在CPU缓存（Cache）中留下的痕迹，会像“幽灵”一样泄露出本应保密的数据。它利用的是现代CPU为了追求性能而广泛使用的“预测执行”机制。</p>
<hr>
<h3 id="Spectre漏洞的两个主要变种"><a href="#Spectre漏洞的两个主要变种" class="headerlink" title="Spectre漏洞的两个主要变种"></a><strong>Spectre漏洞的两个主要变种</strong></h3><ol>
<li><p><strong>变种1：分支目标注入 (Bounds Check Bypass)</strong></p>
<ul>
<li><strong>原理</strong>：攻击者通过重复训练CPU的分支预测器，让它相信一个if条件判断总是会走向某个分支。然后，攻击者提供一个恶意的、会导致数组越界访问的索引。CPU在正式计算出索引越界之前，会<strong>预测性地</strong>执行那个分支，用恶意索引去访问内存中的敏感数据，从而将数据加载到缓存中。</li>
<li><strong>比喻</strong>：诱导图书管理员相信你总是借阅A区1-10号书架的书，然后突然给他一个11号书架的请求，在他反应过来“哦，越界了”之前，他已经预测性地跑去11号书架看了一眼。</li>
</ul>
</li>
<li><p><strong>变种2：分支历史注入 (Branch Target Injection)</strong></p>
<ul>
<li><strong>原理</strong>：这个变种更复杂，它利用了CPU中间接跳转（Indirect Branch）的预测机制。攻击者可以“毒化”分支目标缓冲器（BTB），让CPU在执行一个间接跳转时，错误地预测并跳转到攻击者指定的一小段代码（称为gadget）上，这段代码会访问敏感数据。</li>
<li><strong>比喻</strong>：在图书馆的索引卡片上（比如“烹饪类 -&gt; 见C区”），攻击者用一种特殊的方式涂改，让管理员在查找“烹饪类”时，错误地以为应该跑去“禁书区”看一眼。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="如何修复（或更准确地说，缓解）？"><a href="#如何修复（或更准确地说，缓解）？" class="headerlink" title="如何修复（或更准确地说，缓解）？"></a><strong>如何修复（或更准确地说，缓解）？</strong></h3><p>Spectre是CPU微架构的根本性设计问题，无法像普通软件Bug一样被“修复”，只能通过多种手段进行<strong>缓解（Mitigation）</strong>，而这些缓解措施通常会带来性能损失。</p>
<ol>
<li><p><strong>软件缓解</strong>：</p>
<ul>
<li><strong>增加屏障指令 (Fences)</strong>：在关键代码路径上插入内存或指令屏障，强制CPU停止预测，等待前序操作完成后再继续。这会显著影响性能。我们之前分析的<code>CSDB</code>（条件同步屏障）就是一种轻量级的屏障。</li>
<li><strong>Retpoline（返回蹦床）</strong>：这是针对变种2的一种非常有效的软件缓解技术。它将间接跳转替换为一个安全的、不会被恶意预测的无限循环（即“蹦床”），然后通过<code>ret</code>指令从这个循环中“弹出”到真正的目标地址。这阻止了CPU进行恶意的分支预测，但也会带来一定的性能开销。</li>
<li><strong>清除分支预测器历史</strong>：在特权级切换时（如从内核返回用户态），清除分支预测器的历史记录，防止用户态程序“毒化”的预测影响到内核。</li>
</ul>
</li>
<li><p><strong>编译器缓解</strong>：</p>
<ul>
<li>编译器可以自动在代码中插入缓解措施。例如，在数组访问前插入掩码操作，确保索引不会越界，从而防止变种1的攻击。</li>
</ul>
</li>
<li><p><strong>微码（Microcode）更新</strong>：</p>
<ul>
<li>CPU厂商（Intel, AMD, ARM）可以发布微码更新，为CPU增加新的指令（如IBRS, IBPB）来更好地控制预测行为。操作系统可以通过调用这些新指令来增强安全性。</li>
</ul>
</li>
<li><p><strong>硬件修复</strong>：</p>
<ul>
<li>这是最根本的解决方案。自Spectre被发现以来，新设计的CPU都在硬件层面加入了缓解措施，例如改进分支预测器使其更难被“毒化”，或者提供更细粒度的预测行为控制。但这需要购买新的硬件。</li>
</ul>
</li>
</ol>
<p><strong>总结</strong>：修复Spectre漏洞是一个系统性的工程，需要在<strong>操作系统、编译器、CPU微码和硬件设计</strong>等多个层面协同工作。这是一个在<strong>安全和性能</strong>之间不断进行艰难权衡的过程。您在内核代码中看到的<code>#ifdef CONFIG_CPU_SPECTRE</code>和<code>csdb</code>指令，正是这个宏大斗争在代码层面的具体体现。</p>
<h1 id="arch-arm-kernel-entry-common-S"><a href="#arch-arm-kernel-entry-common-S" class="headerlink" title="arch&#x2F;arm&#x2F;kernel&#x2F;entry-common.S"></a>arch&#x2F;arm&#x2F;kernel&#x2F;entry-common.S</h1><h2 id="ret-to-user-ret-to-user-from-irq-ret-slow-syscall"><a href="#ret-to-user-ret-to-user-from-irq-ret-slow-syscall" class="headerlink" title="ret_to_user ret_to_user_from_irq ret_slow_syscall"></a>ret_to_user ret_to_user_from_irq ret_slow_syscall</h2><ul>
<li>ret_to_user (系统调用的返回路径)<br>  当一个任务执行系统调用（例如 read(), write(), fork()）并且该调用执行完毕后，内核需要返回到该任务。它就会跳转到ret_to_user。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * &quot;慢速&quot;系统调用返回路径。&quot;why&quot;寄存器告诉我们这是否是一个真正的系统调用。</span><br><span class="line"> * 此处中断可能是开启的，所以我们总是先关闭它。注意我们用&quot;notrace&quot;版本</span><br><span class="line"> * 来避免不必要的追踪代码调用。do_work_pending()会在必要时更新状态。</span><br><span class="line"> */</span><br><span class="line">ENTRY(ret_to_user)</span><br><span class="line">ret_slow_syscall:</span><br><span class="line">#if IS_ENABLED(CONFIG_DEBUG_RSEQ)</span><br><span class="line">#endif</span><br><span class="line">	/*</span><br><span class="line">	 * 关键过渡点：在进入共享的返回路径之前，必须确保中断是关闭的，</span><br><span class="line">	 * 因为共享路径假定它在中断关闭的上下文中运行。</span><br><span class="line">	 */</span><br><span class="line">	disable_irq_notrace			@ 关闭中断</span><br><span class="line">ENTRY(ret_to_user_from_irq)</span><br><span class="line">	/*</span><br><span class="line">	 * 这是整个返回路径的核心检查点。</span><br><span class="line">	 * 它用极高的效率判断是否有任何“慢速工作”需要处理。</span><br><span class="line">	 */</span><br><span class="line"></span><br><span class="line">	/* r1 = current-&gt;thread_info-&gt;flags */</span><br><span class="line">	ldr	r1, [tsk, #TI_FLAGS]</span><br><span class="line"></span><br><span class="line">	/* 这是一个非常精妙的3指令序列，用于检查标志位 */</span><br><span class="line">	/* 1. 将flags字段左移16位。所有需要慢速处理的标志位（如_TIF_NEED_RESCHED）</span><br><span class="line">	      都被定义在32位flags的高16位。*/</span><br><span class="line">	/* 2. &#x27;s&#x27;后缀会根据操作结果更新CPSR状态寄存器中的Z(零)标志位。</span><br><span class="line">	      如果所有高16位都为0，则操作结果为0，Z位置1。</span><br><span class="line">	      如果任何高16位为1，则操作结果非0，Z位清0。*/</span><br><span class="line">	movs	r1, r1, lsl #16</span><br><span class="line"></span><br><span class="line">	/* bne: Branch if Not Equal (to zero) / 如果Z标志为0，则跳转。</span><br><span class="line">	 * 如果Z标志为0，说明movs结果非0，意味着有慢速工作待处理。</span><br><span class="line">	 * 因此，跳转到slow_work_pending去处理。*/</span><br><span class="line">	bne	slow_work_pending</span><br><span class="line">no_work_pending:</span><br><span class="line">	/* 如果代码执行到这里，说明flags中没有任何待处理工作。*/</span><br><span class="line"></span><br><span class="line">	/* 通知追踪系统，即将重新开启硬件中断。*/</span><br><span class="line">	//asm_trace_hardirqs_on save = 0</span><br><span class="line"></span><br><span class="line">	/* 通知上下文追踪系统，即将返回到非中断上下文。*/</span><br><span class="line">	// ct_user_enter save = 0</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_GCC_PLUGIN_STACKLEAK</span><br><span class="line">	/* 如果开启了栈泄漏检测，则调用函数擦除栈上可能残留的敏感数据。*/</span><br><span class="line">	// bl	stackleak_erase_on_task_stack</span><br><span class="line">#endif</span><br><span class="line">	/*</span><br><span class="line">	 * 这是最终的返回指令宏。它负责从当前任务的内核栈上恢复所有</span><br><span class="line">	 * 之前保存的CPU寄存器（包括硬件自动保存和软件手动保存的），</span><br><span class="line">	 * 并将控制权交还给被中断的代码。这是整个异常处理的终点。</span><br><span class="line">	 */</span><br><span class="line">	restore_user_regs fast = 0, offset = 0</span><br><span class="line">ENDPROC(ret_to_user_from_irq)</span><br><span class="line">ENDPROC(ret_to_user)</span><br></pre></td></tr></table></figure>

<h2 id="vector-swi-用户空间的程序调用内核时"><a href="#vector-swi-用户空间的程序调用内核时" class="headerlink" title="vector_swi 用户空间的程序调用内核时"></a>vector_swi 用户空间的程序调用内核时</h2><ol>
<li>建立内核环境：在手动保存了用户态寄存器（简化代码中省略了这部分）后，vector_swi首先会切换到内核的运行环境，最重要的一步是开启中断，允许更高优先级的中断来抢占正在执行的系统调用。</li>
<li>获取调用号：它遵循EABI规范，假定系统调用号已经由用户空间的C库放入了R7寄存器。这避免了旧ABI中需要反汇编SWI指令来解码调用号的复杂过程。</li>
<li>查表与分发：它以R7中的调用号为索引，在主系统调用表sys_call_table中找到对应的内核C函数地址。</li>
<li>调用与返回：通过invoke_syscall宏，它调用了查找到的C函数来执行具体的内核服务。这个宏还内置了对系统调用被信号中断后自动重启的支持。<br>集成追踪：在调用C函数前后，它都检查了追踪标志位，如果任务正在被strace等工具追踪，它会跳转到专门的__sys_trace路径，以便记录系统调用的参数和返回值。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(vector_swi)</span><br><span class="line">#ifdef CONFIG_CPU_V7M</span><br><span class="line">	v7m_exception_entry</span><br><span class="line">#else</span><br><span class="line">#endif</span><br><span class="line">	/*</span><br><span class="line">	 * Step 1: 内核态环境准备。</span><br><span class="line">	 * --------------------------</span><br><span class="line">	 * 在处理系统调用之前，内核需要完成一系列准备工作，并开启中断。</span><br><span class="line">	 */</span><br><span class="line">	//reload_current r10, ip		/* 宏：加载当前任务的thread_info到r10。*/</span><br><span class="line">	//zero_fp						/* 宏：清理帧指针寄存器（r11）。*/</span><br><span class="line">	//alignment_trap r10, ip, cr_alignment 	/* 宏：处理非对齐访问陷阱。*/</span><br><span class="line">	//asm_trace_hardirqs_on save=0			/* 宏：通知追踪器，中断即将开启。*/</span><br><span class="line">	enable_irq_notrace						/* 指令：开启可屏蔽中断(IRQ)。*/</span><br><span class="line">	//ct_user_exit save=0			/* 宏：通知上下文追踪器，已退出用户态。*/</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Step 2: 获取系统调用号。</span><br><span class="line">	 * --------------------------</span><br><span class="line">	 * 在EABI规范下，这个过程非常简单。</span><br><span class="line">	 */</span><br><span class="line"></span><br><span class="line">	/* #if defined(CONFIG_OABI_COMPAT) -&gt; false */</span><br><span class="line">	/* #elif defined(CONFIG_AEABI) -&gt; true */</span><br><span class="line">#if defined(CONFIG_OABI_COMPAT)</span><br><span class="line">#elif defined(CONFIG_AEABI)</span><br><span class="line">	/*</span><br><span class="line">	 * 注释：纯EABI用户空间总是将系统调用号放入scno(r7)寄存器中。</span><br><span class="line">	 * 在这里，内核什么都不用做。系统调用号已经在r7中了。</span><br><span class="line">	 */</span><br><span class="line">#elif defined(CONFIG_ARM_THUMB)</span><br><span class="line">#else</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Step 3: 准备查表并调用C函数。</span><br><span class="line">	 * --------------------------------</span><br><span class="line">	 */</span><br><span class="line">	/* 宏：禁用用户空间内存访问，防止在内核态发生意外的页错误。*/</span><br><span class="line">	// uaccess_disable tbl</span><br><span class="line">	/* 宏：获取当前任务的thread_info结构体指针。*/</span><br><span class="line">	get_thread_info tsk</span><br><span class="line"></span><br><span class="line">	/* 指令：加载内核主系统调用表(sys_call_table)的地址到tbl寄存器。*/</span><br><span class="line">	adr	tbl, sys_call_table</span><br><span class="line"></span><br><span class="line">	/* #if defined(CONFIG_OABI_COMPAT) -&gt; false */</span><br><span class="line">	/* #elif !defined(CONFIG_AEABI) -&gt; false */</span><br><span class="line">	/* #else -&gt; true */</span><br><span class="line">#if defined(CONFIG_OABI_COMPAT)</span><br><span class="line">#elif !defined(CONFIG_AEABI)</span><br><span class="line">#else</span><br><span class="line">	/* 对于EABI，我们仅需要将r7中的系统调用号保存到任务的thread_info中，</span><br><span class="line">	 * 以便追踪或调试。scno是r7的别名。*/</span><br><span class="line">	str	scno, [tsk, #TI_ABI_SYSCALL]</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	/* 宏：如果开启了追踪，从栈上重新加载r0-r3，因为它们可能在</span><br><span class="line">	 * 入口处的追踪代码中被修改过。*/</span><br><span class="line"> TRACE(	ldmia	sp, &#123;r0 - r3&#125;		)</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Step 4: 执行系统调用并处理重启逻辑。</span><br><span class="line">	 * --------------------------------------</span><br><span class="line">	 */</span><br><span class="line">local_restart:</span><br><span class="line">	/* 检查是否有追踪相关的标志位（如strace）。*/</span><br><span class="line">	ldr	r10, [tsk, #TI_FLAGS]</span><br><span class="line">	/* 系统调用C函数最多使用6个参数（r0-r5）。前4个已在寄存器中，</span><br><span class="line">	 * 这里将第5、6个参数（在r4, r5中）也压入栈，以备C函数通过栈来寻址。*/</span><br><span class="line">	stmdb	sp!, &#123;r4, r5&#125;</span><br><span class="line"></span><br><span class="line">	/* 检查_TIF_SYSCALL_WORK标志位，判断是否正在被追踪。*/</span><br><span class="line">	tst	r10, #_TIF_SYSCALL_WORK</span><br><span class="line">	/* 如果是，则跳转到专门的追踪处理路径__sys_trace。*/</span><br><span class="line">	bne	__sys_trace</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * 宏：这是核心的调用动作。</span><br><span class="line">	 * 它会以scno(r7)为索引，在tbl(sys_call_table)中找到函数指针，</span><br><span class="line">	 * 然后跳转执行。执行完毕后，C函数的返回值在r0中。</span><br><span class="line">	 * 如果系统调用被信号中断，返回时会跳转到local_restart重新执行。</span><br><span class="line">	 * 如果正常返回，则跳转到__ret_fast_syscall。</span><br><span class="line">	 */</span><br><span class="line">	invoke_syscall tbl, scno, r10, __ret_fast_syscall</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Step 5: 处理专有或无效的系统调用。</span><br><span class="line">	 * --------------------------------------</span><br><span class="line">	 * 如果invoke_syscall因为某些原因（如专有调用）返回到这里，</span><br><span class="line">	 * 则进行额外处理。</span><br><span class="line">	 */</span><br><span class="line">	add	r1, sp, #S_OFF</span><br><span class="line">2:	/* 比较系统调用号是否在ARM专有范围内。*/</span><br><span class="line">	cmp	scno, #(__ARM_NR_BASE - __NR_SYSCALL_BASE)</span><br><span class="line">	eor	r0, scno, #__NR_SYSCALL_BASE</span><br><span class="line">	/* 如果是，则跳转到arm_syscall处理。*/</span><br><span class="line">	bcs	arm_syscall</span><br><span class="line">	/* 否则，这是一个无效的系统调用。*/</span><br><span class="line">	mov	why, #0</span><br><span class="line">	/*</span><br><span class="line">	kernel/sys_ni.c</span><br><span class="line">	Non-implemented system calls get redirected here.</span><br><span class="line"></span><br><span class="line">	asmlinkage long sys_ni_syscall(void)</span><br><span class="line">	&#123;</span><br><span class="line">		return -ENOSYS;</span><br><span class="line">	&#125;</span><br><span class="line">	*/</span><br><span class="line">	b	sys_ni_syscall			@ 跳转到“系统调用未实现”的处理函数</span><br><span class="line"></span><br><span class="line">	/* #if defined(CONFIG_OABI_COMPAT) || !defined(CONFIG_AEABI) -&gt; false */</span><br><span class="line">#if defined(CONFIG_OABI_COMPAT) || !defined(CONFIG_AEABI)</span><br><span class="line">#endif</span><br><span class="line">ENDPROC(vector_swi)</span><br></pre></td></tr></table></figure>

<h2 id="slow-work-pending-异常和系统调用统一返回路径上的慢速工作处理程序"><a href="#slow-work-pending-异常和系统调用统一返回路径上的慢速工作处理程序" class="headerlink" title="slow_work_pending 异常和系统调用统一返回路径上的慢速工作处理程序"></a>slow_work_pending 异常和系统调用统一返回路径上的慢速工作处理程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 慢速工作处理的入口点。</span><br><span class="line"> */</span><br><span class="line">slow_work_pending:</span><br><span class="line">	/* 准备调用C函数do_work_pending的参数。*/</span><br><span class="line">	/* 第一个参数 r0 = 当前栈指针sp，即指向pt_regs结构体的指针。*/</span><br><span class="line">	mov	r0, sp				/* 注释：&#x27;regs&#x27; */</span><br><span class="line">	/* 第二个参数 r2 = why寄存器的值，用于区分入口是来自系统调用还是中断。*/</span><br><span class="line">	mov	r2, why				/* 注释：&#x27;syscall&#x27; */</span><br><span class="line">	/* 调用C函数do_work_pending。该函数负责处理所有慢速工作，</span><br><span class="line">	 * 如信号传递和任务调度。*/</span><br><span class="line">	bl	do_work_pending</span><br><span class="line"></span><br><span class="line">	/* 检查do_work_pending的返回值（在r0寄存器中）。*/</span><br><span class="line">	cmp	r0, #0</span><br><span class="line">	/* beq: Branch if Equal。如果返回值为0，说明所有工作已处理完毕，</span><br><span class="line">	 *      跳转到no_work_pending，执行快速返回流程。*/</span><br><span class="line">	beq	no_work_pending</span><br><span class="line"></span><br><span class="line">	/* 如果返回值不为0（通常小于0），则处理系统调用重启。*/</span><br><span class="line">	/* movlt: Move if Less Than。如果r0 &lt; 0，执行mov。</span><br><span class="line">	 *        将特殊的重启系统调用号__NR_restart_syscall的值加载到scno寄存器。*/</span><br><span class="line">	movlt	scno, #(__NR_restart_syscall - __NR_SYSCALL_BASE)</span><br><span class="line">	/* 将新的系统调用号写入任务的thread_info结构体中，以确保追踪工具（如ptrace）</span><br><span class="line">	 * 能观察到这次状态更新。*/</span><br><span class="line">	str	scno, [tsk, #TI_ABI_SYSCALL]	/* 注释：确保追踪器能看到更新 */</span><br><span class="line">	/* 由于do_work_pending可能已修改了寄存器，必须从栈上的pt_regs中</span><br><span class="line">	 * 重新加载系统调用的原始参数（r0-r6）。*/</span><br><span class="line">	ldmia	sp, &#123;r0 - r6&#125;			/* 注释：必须重载r0-r6 */</span><br><span class="line">	/* 无条件跳转到local_restart标签处，该标签下的代码会重新触发</span><br><span class="line">	 * 一个系统调用（现在是__NR_restart_syscall）。*/</span><br><span class="line">	b	local_restart			/* 注释：... 然后我们开始 */</span><br></pre></td></tr></table></figure>

<h2 id="ret-fast-syscall-ret-fast-syscall"><a href="#ret-fast-syscall-ret-fast-syscall" class="headerlink" title="ret_fast_syscall __ret_fast_syscall"></a>ret_fast_syscall __ret_fast_syscall</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 这是一个快速系统调用返回路径。我们在这里尽可能少做事，</span><br><span class="line"> * 比如避免将r0写入堆栈。我们只在禁用了追踪、上下文追踪和RSEQ调试时</span><br><span class="line"> * 才使用此路径——因为这些特性的开销会使此路径变得效率低下。</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"> * =============================================================================</span><br><span class="line"> * 版本一：当追踪等特性被禁用时，编译此部分，追求极致性能。</span><br><span class="line"> * =============================================================================</span><br><span class="line"> */</span><br><span class="line">#if !(IS_ENABLED(CONFIG_TRACE_IRQFLAGS) || IS_ENABLED(CONFIG_CONTEXT_TRACKING_USER) || \</span><br><span class="line">	IS_ENABLED(CONFIG_DEBUG_RSEQ))</span><br><span class="line">ret_fast_syscall:</span><br><span class="line">__ret_fast_syscall:ret_slow_syscall</span><br><span class="line">	/* UNWIND宏用于提供栈回溯信息给调试器。*/</span><br><span class="line"> UNWIND(.fnstart	)</span><br><span class="line"> UNWIND(.cantunwind	)</span><br><span class="line">	/* 关闭中断。*/</span><br><span class="line">	disable_irq_notrace</span><br><span class="line">	/* 重新检查thread_info-&gt;flags，看是否有系统调用追踪等标志被设置。*/</span><br><span class="line">	ldr	r1, [tsk, #TI_FLAGS]</span><br><span class="line">	/* 使用 lsl #16 和 &#x27;s&#x27; 后缀，高效地检查所有高16位的慢速工作标志。*/</span><br><span class="line">	movs	r1, r1, lsl #16</span><br><span class="line">	/* bne: 如果有标志位被设置，则跳转到慢速处理路径。*/</span><br><span class="line">	bne	fast_work_pending</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * 快速路径：没有待处理工作。调用寄存器恢复宏，并传入fast=1，</span><br><span class="line">	 * 这会跳过对r0（系统调用返回值）的恢复，从而提高效率。</span><br><span class="line">	 * restore_user_regs 宏执行完毕后，CPU的控制权已经通过 BX LR 指令返回到了用户空间</span><br><span class="line">	 */</span><br><span class="line">	restore_user_regs fast = 1, offset = S_OFF</span><br><span class="line"> UNWIND(.fnend		)</span><br><span class="line">ENDPROC(ret_fast_syscall)</span><br><span class="line"></span><br><span class="line">	/* 如果快速路径检查失败，则进入慢速路径。*/</span><br><span class="line">fast_work_pending:</span><br><span class="line">	/* 首先，必须将r0中的系统调用返回值保存回内核栈上的pt_regs结构体中。</span><br><span class="line">	 * &#x27;!&#x27;表示基址寄存器sp在操作后会被更新。*/</span><br><span class="line">	str	r0, [sp, #S_R0+S_OFF]!</span><br><span class="line">	/* 注释：然后顺着代码执行下去，“掉入”到work_pending处理路径。</span><br><span class="line">	 * (work_pending路径通常紧跟在这段代码之后，它会包含slow_work_pending的逻辑) */</span><br><span class="line">	/* fall through to work_pending */</span><br><span class="line">#else</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line">	/* 关闭中断。*/</span><br><span class="line">	disable_irq_notrace</span><br><span class="line">	/* 检查是否有慢速工作标志。*/</span><br><span class="line">	ldr	r1, [tsk, #TI_FLAGS]</span><br><span class="line">	movs	r1, r1, lsl #16</span><br><span class="line">	/* beq: 如果没有慢速工作，则直接跳转到no_work_pending，执行快速返回。</span><br><span class="line">	 *      注意，此时因为r0已经保存，所以可以直接使用标准的返回路径。*/</span><br><span class="line">	beq	no_work_pending</span><br><span class="line"> UNWIND(.fnend		)</span><br><span class="line">ENDPROC(ret_fast_syscall)</span><br></pre></td></tr></table></figure>

<h2 id="ret-from-fork-新创建的任务，在首次被调度器调度后，所执行的第一个函数"><a href="#ret-from-fork-新创建的任务，在首次被调度器调度后，所执行的第一个函数" class="headerlink" title="ret_from_fork 新创建的任务，在首次被调度器调度后，所执行的第一个函数"></a>ret_from_fork 新创建的任务，在首次被调度器调度后，所执行的第一个函数</h2><ul>
<li>是所有通过叉（）、克隆（）或线程创建（kthread_create）系统调用新创建的任务，在首次被调度器调度后，所执行的第一个函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 注释：这是从fork返回的方式。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义一个全局可用的汇编函数入口点，名为ret_from_fork。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ENTRY(ret_from_fork)</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 调用C函数schedule_tail。此函数负责执行调度器在上下文切换后</span></span><br><span class="line"><span class="comment">	 * 必需的收尾操作，例如释放前一个任务的运行队列锁。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	bl	schedule_tail</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 比较r5寄存器的值与0，并根据结果设置CPSR中的条件码标志位。</span></span><br><span class="line"><span class="comment">	 * 在copy_thread中，内核线程的r5被设置为其启动函数的地址，</span></span><br><span class="line"><span class="comment">	 * 而用户进程的r5被设置为0。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	cmp	r5, #<span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 以下三条指令均为条件执行指令，后缀&#x27;ne&#x27;(Not Equal)表示</span></span><br><span class="line"><span class="comment">	 * 仅当上一条cmp指令的结果不为0时才执行。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果r5不为0（即为内核线程），将r4的值移动到r0。</span></span><br><span class="line"><span class="comment">	 * r4中保存着创建时传递给内核线程的参数，r0是C调用约定的第一个参数寄存器。*/</span></span><br><span class="line">	movne	r0, r4</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果r5不为0，将标签&#x27;1&#x27;的地址加载到LR寄存器。</span></span><br><span class="line"><span class="comment">	 * 这是为后续的retne指令设置返回地址，以防内核线程函数返回。*/</span></span><br><span class="line">	badrne	lr, <span class="number">1f</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果r5不为0，执行&#x27;bx r5&#x27;，跳转到r5寄存器中的地址执行。</span></span><br><span class="line"><span class="comment">	 * 该地址即为内核线程的入口函数。*/</span></span><br><span class="line">	retne	r5</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 如果代码执行到标签&#x27;1&#x27;，说明cmp r5, #0的结果为0（即为用户进程）。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* ===================================================================</span></span><br><span class="line"><span class="comment">	* 内核线程在这里长时间运行...</span></span><br><span class="line"><span class="comment">	* 当它的主函数执行完毕，会执行一条标准的函数返回指令（如 BX LR）。</span></span><br><span class="line"><span class="comment">	* 此时，CPU会跳转到LR寄存器中存放的地址。</span></span><br><span class="line"><span class="comment">	* ===================================================================</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>:	<span class="comment">/* 6. 内核线程主函数返回后，执行会从这里继续！*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * get_thread_info tsk: 获取当前任务的thread_info指针。</span></span><br><span class="line"><span class="comment">	 * b ret_slow_syscall: 跳转到系统调用返回的慢速路径。</span></span><br><span class="line"><span class="comment">	 * 这条路径看似是为用户进程准备的，但为什么内核线程也要走？</span></span><br><span class="line"><span class="comment">	 * 因为在这条路径的更深处，会检查到当前任务正在退出，并最终调用do_exit()。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/* 获取当前任务的thread_info结构体指针，并存入tsk寄存器（通常是r9）。*/</span></span><br><span class="line">	get_thread_info tsk</span><br><span class="line">	<span class="comment">/* 无条件跳转到ret_slow_syscall标签。</span></span><br><span class="line"><span class="comment">	 * 这是系统调用的通用慢速返回路径，它将处理后续的返回用户空间事宜。*/</span></span><br><span class="line">	b	ret_slow_syscall</span><br><span class="line"><span class="comment">/* ret_from_fork过程结束。*/</span></span><br><span class="line">ENDPROC(ret_from_fork)</span><br></pre></td></tr></table></figure>

<h1 id="arch-arm-kernel-entry-v7m-S"><a href="#arch-arm-kernel-entry-v7m-S" class="headerlink" title="arch&#x2F;arm&#x2F;kernel&#x2F;entry-v7m.S"></a>arch&#x2F;arm&#x2F;kernel&#x2F;entry-v7m.S</h1><h2 id="Vector-table"><a href="#Vector-table" class="headerlink" title="Vector table"></a>Vector table</h2><ul>
<li>ARMv7-M架构的异常向量表定义了处理器在发生各种异常时应执行的处理程序地址。每个异常都有一个对应的入口点，处理器在发生异常时会跳转到这些入口点执行相应的处理逻辑。</li>
<li>在Linux内核中，异常向量表通常位于一个特定的汇编文件中，并且需要确保其自然对齐（即每个入口点的地址都应是4字节对齐的）。以下是一个典型的ARMv7-M异常向量表的定义示例：</li>
<li><code>vector_table</code>是异常向量表的入口点，包含了各种异常的处理程序地址。每个异常都有一个对应的处理函数，如果没有定义特定的处理函数，则使用<code>__invalid_entry</code>作为默认处理函数。</li>
<li><code>__invalid_entry</code>函数用于处理未定义的异常，它会打印异常信息并进入死循环，以防止系统继续运行。</li>
<li><code>__irq_entry</code>函数是外部硬件中断的统一入口点，它会保存当前任务的寄存器状态，切换到安全的IRQ栈，并调用通用的中断处理逻辑。处理完中断后，如果有需要推迟的工作，会触发PendSV异常来处理这些工作。</li>
<li><code>exc_ret</code>是一个全局符号，用于存储异常返回的地址。它通常被用作异常返回时的跳转目标。</li>
<li><code>__pendsv_entry</code>是PendSV异常的入口点，用于处理需要推迟的工作。它会在中断处理完毕后被调用，以确保系统能够正确地处理这些工作。</li>
<li><code>vector_swi</code>是SVC（Supervisor Call）异常的入口点，用于处理系统调用。它会在用户空间程序请求内核服务时被调用。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Vector table (Natural alignment need to be ensured)</span><br><span class="line"> */</span><br><span class="line">ENTRY(vector_table)</span><br><span class="line">	.long	0			@ 0 - Reset stack pointer</span><br><span class="line">	.long	__invalid_entry		@ 1 - Reset</span><br><span class="line">	.long	__invalid_entry		@ 2 - NMI</span><br><span class="line">	.long	__invalid_entry		@ 3 - HardFault</span><br><span class="line">	.long	__invalid_entry		@ 4 - MemManage</span><br><span class="line">	.long	__invalid_entry		@ 5 - BusFault</span><br><span class="line">	.long	__invalid_entry		@ 6 - UsageFault</span><br><span class="line">	.long	__invalid_entry		@ 7 - Reserved</span><br><span class="line">	.long	__invalid_entry		@ 8 - Reserved</span><br><span class="line">	.long	__invalid_entry		@ 9 - Reserved</span><br><span class="line">	.long	__invalid_entry		@ 10 - Reserved</span><br><span class="line">	.long	vector_swi		@ 11 - SVCall</span><br><span class="line">	.long	__invalid_entry		@ 12 - Debug Monitor</span><br><span class="line">	.long	__invalid_entry		@ 13 - Reserved</span><br><span class="line">	.long	__pendsv_entry		@ 14 - PendSV</span><br><span class="line">	.long	__invalid_entry		@ 15 - SysTick</span><br><span class="line">	//循环CONFIG_CPU_V7M_NUM_IRQ次,每个中断都执行__irq_entry</span><br><span class="line">	.rept	CONFIG_CPU_V7M_NUM_IRQ</span><br><span class="line">	.long	__irq_entry		@ External Interrupts</span><br><span class="line">	.endr</span><br><span class="line">	.align	2</span><br><span class="line">	.globl	exc_ret</span><br><span class="line">exc_ret:</span><br><span class="line">	.space	4</span><br></pre></td></tr></table></figure>

<h2 id="invalid-entry-打印异常信息进入死循环"><a href="#invalid-entry-打印异常信息进入死循环" class="headerlink" title="__invalid_entry 打印异常信息进入死循环"></a>__invalid_entry 打印异常信息进入死循环</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">__invalid_entry:</span><br><span class="line">	v7m_exception_entry</span><br><span class="line">#ifdef CONFIG_PRINTK	//启用printk 支持。删除它从内核映像中消除大部分消息字符串</span><br><span class="line">	adr	r0, strerr		//将异常信息字符串的地址加载到r0寄存器中，作为_printk的第一个参数</span><br><span class="line">	mrs	r1, ipsr		//将当前异常号（从IPSR寄存器中获取）加载到r1，表示触发异常的具体类型</span><br><span class="line">	mov	r2, lr			//将链接寄存器（LR）的值加载到r2，表示异常返回地址</span><br><span class="line">	bl	_printk			//调用_printk函数，打印上述信息。</span><br><span class="line">#endif</span><br><span class="line">	mov	r0, sp			//将当前堆栈指针（SP）的值加载到r0，作为show_regs的参数</span><br><span class="line">	bl	show_regs		//调用show_regs函数，显示当前寄存器的状态</span><br><span class="line">1:	b	1b				// 无限循环</span><br><span class="line">ENDPROC(__invalid_entry)</span><br></pre></td></tr></table></figure>

<h2 id="irq-entry"><a href="#irq-entry" class="headerlink" title="__irq_entry"></a>__irq_entry</h2><ol>
<li><strong>标准化现场</strong>：当中断发生时，首先调用v7m_exception_entry宏，在当前任务的内核栈上创建一个标准的struct pt_regs寄存器帧。</li>
<li><strong>切换到安全栈</strong>：为了防止中断服务程序耗尽任务内核栈，它会临时将CPU的栈指针切换到一个独立的、专用的<strong>IRQ栈</strong>。</li>
<li><strong>调用通用处理逻辑</strong>：在安全的IRQ栈上，调用高层的、用C语言实现的generic_handle_arch_irq函数。这个C函数会根据中断号，分发并执行由设备驱动程序注册的真实中断服务例程（ISR）。</li>
<li><strong>检查并推迟工作</strong>：在C函数处理完毕后，它会检查是否有因这次中断而产生的、需要稍后处理的慢速工作（如任务调度）。如果有，它并不立即执行，而是通过触发一个低优先级的<strong>PendSV异常</strong>来“委托”这项工作。</li>
<li><strong>快速返回</strong>：最后，执行一个简化的硬件返回序列，尽快退出中断，将CPU控制权交还。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 外部硬件中断（IRQ）的统一入口点。</span><br><span class="line"> */</span><br><span class="line">__irq_entry:</span><br><span class="line">	/*</span><br><span class="line">	 * 首先，调用通用异常入口宏，在当前任务的内核栈上</span><br><span class="line">	 * 创建一个标准的pt_regs寄存器保存帧。</span><br><span class="line">	 */</span><br><span class="line">	v7m_exception_entry</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * 注释：调用IRQ处理程序。</span><br><span class="line">	 */</span><br><span class="line">	/* 将当前SP（指向pt_regs）保存到r0。*/</span><br><span class="line">	mov	r0, sp</span><br><span class="line">	/* 将当前CPU的专用IRQ栈顶指针加载到SP寄存器，实现栈切换。*/</span><br><span class="line">	ldr_this_cpu sp, irq_stack_ptr, r1, r2</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * 注释：如果我们是在内核运行时发生中断，可能已经在使用IRQ栈了，</span><br><span class="line">	 *       这种情况下就恢复到原始值。</span><br><span class="line">	 */</span><br><span class="line">	/* 检查当前是否已在IRQ栈上（处理中断嵌套）。*/</span><br><span class="line">	subs	r2, sp, r0		/* SP是否高于IRQ栈底？*/</span><br><span class="line">	rsbscs	r2, r2, #THREAD_SIZE	/* ... 并且低于IRQ栈顶？*/</span><br><span class="line">	/* 如果是，则取消切换，恢复sp为r0。*/</span><br><span class="line">	movcs	sp, r0</span><br><span class="line"></span><br><span class="line">	/* 在IRQ栈上保存LR(EXC_RETURN)和原始SP(r0)，因为C函数调用会覆盖它们。*/</span><br><span class="line">	push	&#123;r0, lr&#125;</span><br><span class="line"></span><br><span class="line">	/* 注释：调用C函数，r0 = 指向pt_regs的指针。*/</span><br><span class="line">	/* 调用通用的C语言中断处理函数。*/</span><br><span class="line">	bl	generic_handle_arch_irq</span><br><span class="line"></span><br><span class="line">	/* 从IRQ栈上恢复LR和原始SP。*/</span><br><span class="line">	pop	&#123;r0, lr&#125;</span><br><span class="line">	/* 将SP切回到原始任务的内核栈。*/</span><br><span class="line">	mov	sp, r0</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * 注释：检查返回用户模式时是否有任何挂起的工作。</span><br><span class="line">	 */</span><br><span class="line">	/* 加载系统控制块(SCB)的基地址。*/</span><br><span class="line">	ldr	r1, =BASEADDR_V7M_SCB</span><br><span class="line">	/* 读取中断控制和状态寄存器(ICSR)。*/</span><br><span class="line">	ldr	r0, [r1, V7M_SCB_ICSR]</span><br><span class="line">	/* 检查RETTOBASE位，判断是否是嵌套中断返回。*/</span><br><span class="line">	tst	r0, V7M_SCB_ICSR_RETTOBASE</span><br><span class="line">	/* 如果是嵌套中断，则直接跳转到末尾，不检查调度。*/</span><br><span class="line">	beq	2f</span><br><span class="line"></span><br><span class="line">	/* 如果不是嵌套中断，则检查当前任务是否有慢速工作标志（如_TIF_NEED_RESCHED）。*/</span><br><span class="line">	get_thread_info tsk</span><br><span class="line">	ldr	r2, [tsk, #TI_FLAGS]</span><br><span class="line">	movs	r2, r2, lsl #16</span><br><span class="line">	/* 如果没有慢速工作，直接跳转到末尾。*/</span><br><span class="line">	beq	2f</span><br><span class="line">	/* 如果有慢速工作，则向ICSR写入，手动触发一次PendSV异常来处理它。*/</span><br><span class="line">	mov	r0, #V7M_SCB_ICSR_PENDSVSET</span><br><span class="line">	str	r0, [r1, V7M_SCB_ICSR]	/* 注释：触发PendSV */</span><br><span class="line"></span><br><span class="line">2:</span><br><span class="line">	/*</span><br><span class="line">	 * 注释：r0-r3和r12会在异常返回时自动恢复。r4-r7在v7m_exception_entry</span><br><span class="line">	 *       中也没有被破坏，所以严格来说不需要恢复。所以这里只需要恢复r8-r11。</span><br><span class="line">	 *       但最简单的方法是把r0-r11一起恢复了。</span><br><span class="line">	 */</span><br><span class="line">	/* 从任务内核栈上的pt_regs中恢复r0-r11。*/</span><br><span class="line">	ldmia	sp!, &#123;r0-r11&#125;</span><br><span class="line">	/* 调整SP，释放整个pt_regs结构体的空间。*/</span><br><span class="line">	add	sp, #PT_REGS_SIZE-S_IP</span><br><span class="line">	/* 重新开启中断。*/</span><br><span class="line">	cpsie	i</span><br><span class="line">	/* 执行硬件异常返回，硬件会自动利用栈上的硬件帧完成恢复。*/</span><br><span class="line">	bx	lr</span><br><span class="line">/* __irq_entry过程结束。*/</span><br><span class="line">ENDPROC(__irq_entry)</span><br></pre></td></tr></table></figure>

<h2 id="pendsv-entry-pensv中断进入"><a href="#pendsv-entry-pensv中断进入" class="headerlink" title="__pendsv_entry pensv中断进入"></a>__pendsv_entry pensv中断进入</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/* 这段代码是PendSV异常的入口点。*/</span><br><span class="line">__pendsv_entry:</span><br><span class="line">	/*</span><br><span class="line">	 * 这是一个宏，用于执行标准的异常入口操作。</span><br><span class="line">	 * 主要工作是：在硬件已经自动压栈（xPSR, PC, LR, r12, r3-r0）的基础上，</span><br><span class="line">	 * 将剩余的通用寄存器（r4-r11）也压入当前任务的内核栈中。</span><br><span class="line">	 * 执行完毕后，完整的CPU上下文都保存在了当前任务的栈上。</span><br><span class="line">	 */</span><br><span class="line">	v7m_exception_entry</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * 以下三行代码是关键：清除PendSV的挂起状态。</span><br><span class="line">	 * 如果不清除，一旦我们从这个异常中返回，它会立刻再次触发，导致系统死锁。</span><br><span class="line">	 */</span><br><span class="line">	@ 将系统控制块（SCB）的基地址加载到r1。</span><br><span class="line">	ldr	r1, =BASEADDR_V7M_SCB</span><br><span class="line">	@ 将“清除PendSV”的标志位值加载到r0。</span><br><span class="line">	mov	r0, #V7M_SCB_ICSR_PENDSVCLR</span><br><span class="line">	@ 将r0的值写入SCB的ICSR寄存器，硬件上清除PendSV的挂起请求。</span><br><span class="line">	str	r0, [r1, V7M_SCB_ICSR]	@ 清除PendSV</span><br><span class="line"></span><br><span class="line">	@ 这个宏的作用是获取当前正在运行任务的thread_info结构体指针，</span><br><span class="line">	@ 并将其放入一个预定义的寄存器中（通常是r9，别名为tsk）。</span><br><span class="line">	get_thread_info tsk</span><br><span class="line"></span><br><span class="line">	@ 将寄存器why设置为0（这可能用于调试或追踪，表示一个普通的异常退出）。</span><br><span class="line">	mov	why, #0</span><br><span class="line"></span><br><span class="line">	@ b: Branch指令，无条件跳转。</span><br><span class="line">	@ 跳转到ret_to_user_from_irq，这是所有中断和异常处理完毕后，</span><br><span class="line">	@ 返回到被中断代码（无论是内核线程还是用户进程）的通用路径。</span><br><span class="line">	b	ret_to_user_from_irq</span><br><span class="line">ENDPROC(__pendsv_entry)</span><br></pre></td></tr></table></figure>

<h2 id="switch-to"><a href="#switch-to" class="headerlink" title="__switch_to"></a>__switch_to</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/arm/include/asm/thread_info.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu_context_save</span> &#123;</span></span><br><span class="line">	__u32	r4;</span><br><span class="line">	__u32	r5;</span><br><span class="line">	__u32	r6;</span><br><span class="line">	__u32	r7;</span><br><span class="line">	__u32	r8;</span><br><span class="line">	__u32	r9;</span><br><span class="line">	__u32	sl;</span><br><span class="line">	__u32	fp;</span><br><span class="line">	__u32	sp;</span><br><span class="line">	__u32	pc;</span><br><span class="line">	__u32	extra[<span class="number">2</span>];		<span class="comment">/* Xscale &#x27;acc&#x27; register, etc */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 适用于ARMv7-M处理器的寄存器切换函数。</span><br><span class="line"> * 调用约定：</span><br><span class="line"> * r0 = 指向前一个任务的 task_struct 结构体的指针 (previous)</span><br><span class="line"> * r1 = 指向前一个任务的 thread_info 结构体的指针 (previous)</span><br><span class="line"> * r2 = 指向后一个任务的 thread_info 结构体的指针 (next)</span><br><span class="line"> *</span><br><span class="line"> * 内核保证 &quot;previous&quot; 和 &quot;next&quot; 不会是同一个任务。</span><br><span class="line"> */</span><br><span class="line">ENTRY(__switch_to)</span><br><span class="line">	.fnstart			@ 标记函数开始，供调试器使用。</span><br><span class="line">	.cantunwind			@ 告诉调试工具，此处的栈帧无法安全地“回溯”，因为我们正在手动修改栈。</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * ==========================================================</span><br><span class="line">	 * == Part 1: 保存前一个任务 (previous task) 的CPU上下文 ==</span><br><span class="line">	 * ==========================================================</span><br><span class="line">	 */</span><br><span class="line"></span><br><span class="line">	@ 计算&#x27;previous&#x27;任务的CPU寄存器保存区域的地址。</span><br><span class="line">	@ ip(r12) = r1 (previous-&gt;thread_info) + TI_CPU_SAVE (cpu_save字段的偏移量)。</span><br><span class="line">	add	ip, r1, #TI_CPU_SAVE</span><br><span class="line"></span><br><span class="line">	@ stmia: Store Multiple Increment After，多寄存器存数，地址增量在后。</span><br><span class="line">	@ ip!: &#x27;!&#x27;表示ip寄存器的值在操作后会被更新。</span><br><span class="line">	@ 将 r4 到 r11 这8个寄存器（被调用者需要保存的寄存器）的值，连续存入ip指向的内存中。</span><br><span class="line">	@ 存完后，ip的值会增加 8 * 4 = 32字节。</span><br><span class="line">	stmia	ip!, &#123;r4 - r11&#125;</span><br><span class="line"></span><br><span class="line">	@ 将当前栈指针(sp)的值存入ip指向的内存，然后ip地址加4。</span><br><span class="line">	str	sp, [ip], #4</span><br><span class="line">	@ 将链接寄存器(lr)的值（即返回地址）存入ip指向的内存，然后ip地址加4。</span><br><span class="line">	str	lr, [ip], #4</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * ==========================================================</span><br><span class="line">	 * == Part 2: 准备切换，并恢复下一个任务 (next task) 的上下文 ==</span><br><span class="line">	 * ==========================================================</span><br><span class="line">	 */</span><br><span class="line"></span><br><span class="line">	@ 保存&#x27;previous&#x27;任务的task_struct指针(r0)到r5，因为r0-r3在函数调用时可能会被修改。</span><br><span class="line">	mov	r5, r0</span><br><span class="line">	@ 保存&#x27;next&#x27;任务的thread_info指针(r2)到r6，同样是为了保护它不被接下来的函数调用破坏。</span><br><span class="line">	mov	r6, r2</span><br><span class="line"></span><br><span class="line">	@ 计算&#x27;next&#x27;任务的CPU寄存器保存区域的地址。</span><br><span class="line">	@ r4 = r2 (next-&gt;thread_info) + TI_CPU_SAVE (cpu_save字段的偏移量)。</span><br><span class="line">	add	r4, r2, #TI_CPU_SAVE</span><br><span class="line"></span><br><span class="line">	@ 调用内核的通知链，告知其他子系统（如profiling工具）将要发生任务切换。</span><br><span class="line">	@ 这是个可选的扩展点，不影响切换的核心逻辑。</span><br><span class="line">	ldr	r0, =thread_notify_head		@ r0 = &amp;thread_notify_head (第一个参数)</span><br><span class="line">	mov	r1, #THREAD_NOTIFY_SWITCH	@ r1 = THREAD_NOTIFY_SWITCH (第二个参数)</span><br><span class="line">	bl	atomic_notifier_call_chain	@ 调用C函数 atomic_notifier_call_chain</span><br><span class="line"></span><br><span class="line">	@ 恢复之前保存在r5和r6中的值。</span><br><span class="line">	mov	r0, r5</span><br><span class="line">	mov	r1, r6</span><br><span class="line"></span><br><span class="line">	@ ldmia: Load Multiple Increment After，多寄存器取数。</span><br><span class="line">	@ 从r4指向的内存（即&#x27;next&#x27;任务的保存区域）中，加载所有之前保存的寄存器。</span><br><span class="line">	@ 包括 r4-r11, ip(r12) 和 lr(r14)。</span><br><span class="line">	@ 此时，CPU的通用寄存器和链接寄存器已经是&#x27;next&#x27;任务的状态了。</span><br><span class="line">	ldmia	r4, &#123;r4 - r12, lr&#125;</span><br><span class="line"></span><br><span class="line">	@ 这是一个宏，用于更新系统中标识当前运行任务的指针。</span><br><span class="line">	@ 它会把&#x27;next&#x27;任务的thread_info指针(r1)设置到专门的寄存器或内存位置，</span><br><span class="line">	@ 这样内核中任何地方调用 current 或 smp_processor_id() 都能获取到正确的值。</span><br><span class="line">	set_current r1, r2</span><br><span class="line"></span><br><span class="line">	@ &#x27;ip&#x27;寄存器(r12)中存放的是&#x27;next&#x27;任务的栈顶指针（sp），是上一步ldmia加载进来的。</span><br><span class="line">	@ 这条指令将&#x27;next&#x27;任务的栈顶指针恢复到CPU的sp寄存器中。</span><br><span class="line">	@ 从这一刻起，栈已经切换完成。</span><br><span class="line">	mov	sp, ip</span><br><span class="line"></span><br><span class="line">	@ bx: Branch and Exchange, 跳转并切换指令集（此处主要是跳转）。</span><br><span class="line">	@ 跳转到lr寄存器中的地址。因为lr已经被恢复为&#x27;next&#x27;任务的返回地址，</span><br><span class="line">	@ 所以这条指令执行后，CPU会从&#x27;next&#x27;任务上次被中断的地方继续执行。</span><br><span class="line">	@ 上下文切换的最后一步，也是最神奇的一步，完成！</span><br><span class="line">	bx	lr</span><br><span class="line"></span><br><span class="line">	.fnend				@ 标记函数结束，供调试器使用。</span><br><span class="line">ENDPROC(__switch_to)		@ 声明函数__switch_to结束。</span><br></pre></td></tr></table></figure>

<h1 id="arch-arm-mm-proc-v7m-S-1"><a href="#arch-arm-mm-proc-v7m-S-1" class="headerlink" title="arch&#x2F;arm&#x2F;mm&#x2F;proc-v7m.S"></a>arch&#x2F;arm&#x2F;mm&#x2F;proc-v7m.S</h1><h2 id="v7m-cm7-setup-V7M处理器的初始化函数"><a href="#v7m-cm7-setup-V7M处理器的初始化函数" class="headerlink" title="__v7m_cm7_setup V7M处理器的初始化函数"></a>__v7m_cm7_setup V7M处理器的初始化函数</h2><ul>
<li><code>__v7m_cm7_setup</code>函数的主要作用是配置ARM Cortex-M7处理器的系统控制块（SCB）和异常处理机制。它设置了异常向量表、异常优先级、堆栈指针等，并根据需要配置缓存。</li>
</ul>
<ol>
<li><p>异常向量表的地址存储在SCB的VTOR寄存器中，以便处理器能够正确地跳转到异常处理程序。</p>
</li>
<li><p>启用UsageFault、BusFault和MemManage异常，以便在发生这些异常时能够进行处理。</p>
</li>
<li><p>设置SVC（超级用户调用）和PendSV（挂起的系统服务调用）的优先级，以便在异常发生时能够正确地处理这些异常。</p>
</li>
<li><p>通过SVC指令切换到线程模式，并设置堆栈指针（sp）指向init_thread_union + THREAD_START_SP，以便为线程模式准备好堆栈。</p>
<ul>
<li>分配THREAD_SIZE大小的栈空间</li>
</ul>
</li>
<li><p>计算异常返回值，设置控制寄存器（CONTROL）为非特权模式，以便在异常返回时能够正确地恢复处理器状态。</p>
</li>
<li><p>配置缓存（如果硬件支持），以提高系统性能。</p>
</li>
<li><p>配置系统控制寄存器以确保8字节堆栈对齐，以满足ARM Cortex-M7的对齐要求。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">__v7m_cm7_setup:</span><br><span class="line">	mov	r8, #(V7M_SCB_CCR_DC | V7M_SCB_CCR_IC| V7M_SCB_CCR_BP)</span><br><span class="line">	b	__v7m_setup_cont</span><br><span class="line">__v7m_setup_cont:</span><br><span class="line">	@ 配置 vector table 基地址</span><br><span class="line">	ldr	r0, =BASEADDR_V7M_SCB	//加载V7M_SCB的基地址</span><br><span class="line">	ldr	r12, =vector_table	//加载中断向量表的地址</span><br><span class="line">	str	r12, [r0, V7M_SCB_VTOR]	//将中断向量表的地址存储到SCB的VTOR寄存器中</span><br><span class="line">	@启用了UsageFault、BusFault和MemManage异常</span><br><span class="line">	ldr	r5, [r0, #V7M_SCB_SHCSR]</span><br><span class="line">	orr	r5, #(V7M_SCB_SHCSR_USGFAULTENA | V7M_SCB_SHCSR_BUSFAULTENA | V7M_SCB_SHCSR_MEMFAULTENA)</span><br><span class="line">	str	r5, [r0, #V7M_SCB_SHCSR]</span><br><span class="line"></span><br><span class="line">	@ 降低了SVC（超级用户调用）和PendSV（挂起的系统服务调用）的优先级</span><br><span class="line">	mov	r5, #0x80000000</span><br><span class="line">	str	r5, [r0, V7M_SCB_SHPR2]	@ set SVC priority</span><br><span class="line">	mov	r5, #0x00800000</span><br><span class="line">	str	r5, [r0, V7M_SCB_SHPR3]	@ set PendSV priority</span><br><span class="line"></span><br><span class="line">	@ 通过SVC指令切换到线程模式，并设置栈指针（sp）指向init_thread_union + THREAD_START_SP</span><br><span class="line">	badr	r1, 1f</span><br><span class="line">	ldr	r5, [r12, #11 * 4]	@ 读取SVC向量表的原始值。</span><br><span class="line">	str	r1, [r12, #11 * 4]	@ 将1标签地址写入向量表</span><br><span class="line">	dsb						@ 数据同步屏障，确保所有内存操作完成</span><br><span class="line">	mov	r6, lr				@ 保存链接寄存器</span><br><span class="line">	ldr	sp, =init_thread_union + THREAD_START_SP	@ 设置堆栈指针SP</span><br><span class="line">	cpsie	i				@ 启用中断</span><br><span class="line">	svc	#0					@ 触发SVC异常，切换到处理模式。</span><br><span class="line">1:	cpsid	i				@ 禁用中断</span><br><span class="line">	/* 计算exc_ret*/</span><br><span class="line">	orr	r10, lr, #EXC_RET_THREADMODE_PROCESSSTACK	//计算异常返回值，切换到线程模式</span><br><span class="line">	ldmia	sp, &#123;r0-r3, r12&#125;</span><br><span class="line">	str	r5, [r12, #11 * 4]	@ 恢复原始SVC向量表值。</span><br><span class="line">	mov	lr, r6			@ 恢复链接寄存器</span><br><span class="line"></span><br><span class="line">	@专用控制寄存器</span><br><span class="line">	mov	r1, #1</span><br><span class="line">	msr	control, r1		@ 将CONTROL寄存器设置为非特权模式</span><br><span class="line"></span><br><span class="line">	@ 配置缓存（如果硬件支持）</span><br><span class="line">	teq     r8, #0			//检查r8是否为零</span><br><span class="line">	stmiane	sp, &#123;r0-r6, lr&#125;		@  r8 不为零时，将寄存器的值保存到栈中，以便调用 v7m_invalidate_l1 时不会破坏这些寄存器的内容。</span><br><span class="line">	blne	v7m_invalidate_l1	//配置一级缓存（L1 Cache</span><br><span class="line">	teq     r8, #0			@重新评估条件</span><br><span class="line">	ldmiane	sp, &#123;r0-r6, lr&#125;		//从栈中恢复之前保存的寄存器值。</span><br><span class="line"></span><br><span class="line">	@ 配置 System Control Register 以确保 8 字节堆栈对齐</span><br><span class="line">	@ 请注意，STKALIGN 位是 RW 或 RAO。</span><br><span class="line">	ldr	r0, [r0, V7M_SCB_CCR]   @ system control register</span><br><span class="line">	orr	r0, #V7M_SCB_CCR_STKALIGN</span><br><span class="line">	orr	r0, r0, r8</span><br><span class="line"></span><br><span class="line">	ret	lr</span><br><span class="line">ENDPROC(__v7m_setup)</span><br></pre></td></tr></table></figure>

<h2 id="cpu-v7m-do-idle-进入空闲状态"><a href="#cpu-v7m-do-idle-进入空闲状态" class="headerlink" title="cpu_v7m_do_idle 进入空闲状态"></a>cpu_v7m_do_idle 进入空闲状态</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * cpu_v7m_do_idle（）</span><br><span class="line"> *</span><br><span class="line"> * 处理器空闲（例如，等待中断）。</span><br><span class="line"> *</span><br><span class="line"> * IRQ 已禁用。</span><br><span class="line"> */</span><br><span class="line">SYM_TYPED_FUNC_START(cpu_v7m_do_idle)</span><br><span class="line">	wfi</span><br><span class="line">	ret	lr</span><br><span class="line">SYM_FUNC_END(cpu_v7m_do_idle)</span><br></pre></td></tr></table></figure>

<h1 id="arch-arm-kernel-head-nommu-S"><a href="#arch-arm-kernel-head-nommu-S" class="headerlink" title="arch&#x2F;arm&#x2F;kernel&#x2F;head-nommu.S"></a>arch&#x2F;arm&#x2F;kernel&#x2F;head-nommu.S</h1><h2 id="stext-内核启动入口点"><a href="#stext-内核启动入口点" class="headerlink" title="stext 内核启动入口点"></a>stext 内核启动入口点</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 内核启动入口点。</span><br><span class="line"> * ---------------------------</span><br><span class="line"> * 这通常是从 decompressor 代码中调用的。 要求是：MMU = 关闭，D-cache = 关闭，I-cache = 不关心，r0 = 0，r1 = 机器 nr。</span><br><span class="line"> *</span><br><span class="line"> * 参见 linux/arch/arm/tools/mach-types 获取 r1 的完整机器编号列表。</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"> //include/linux/init.h</span><br><span class="line"> //#define __HEAD		.section	&quot;.head.text&quot;,&quot;ax&quot;</span><br><span class="line">	__HEAD</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_CPU_THUMBONLY //V7M使用</span><br><span class="line">	.thumb</span><br><span class="line">ENTRY(stext)</span><br><span class="line">#else</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_ARM_VIRT_EXT</span><br><span class="line">	bl	__hyp_stub_install</span><br><span class="line">#endif</span><br><span class="line">    //V7M 这里是一个空函数</span><br><span class="line">	@ 确保 SVC 模式和所有中断都被屏蔽</span><br><span class="line">	safe_svcmode_maskall r9 @ 并且 IRQ 已禁用</span><br><span class="line">#if defined(CONFIG_CPU_CP15)</span><br><span class="line">#elif defined(CONFIG_CPU_V7M)</span><br><span class="line">	ldr	r9, =BASEADDR_V7M_SCB</span><br><span class="line">	ldr	r9, [r9, V7M_SCB_CPUID]</span><br><span class="line">#else</span><br><span class="line">#endif</span><br><span class="line">	//  循环查找processor_type中匹配的cpu信息</span><br><span class="line">	bl	__lookup_processor_type		@ r5=procinfo r9=cpuid</span><br><span class="line">	movs	r10, r5					@ invalid processor (r5=0)?</span><br><span class="line">	// r5 = 0 进入</span><br><span class="line">	beq	__error_p					@ yes, error &#x27;p&#x27;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_ARM_MPU</span><br><span class="line">	bl	__setup_mpu</span><br><span class="line">#endif</span><br><span class="line">	//将标签1的地址保存到lr寄存器中,以便后续返回</span><br><span class="line">	badr	lr, 1f				@ return (PIC) address</span><br><span class="line">	ldr	r12, [r10, #PROCINFO_INITFUNC]	//加载PROCINFO_INITFUNC的偏移量</span><br><span class="line">	add	r12, r12, r10					//得到函数的实际地址</span><br><span class="line">	ret	r12								//跳转执行该函数	V7M执行 __v7m_cm7_setup()</span><br><span class="line">1:	ldr	lr, =__mmap_switched			//将符号 __mmap_switched 的函数地址加载到链接寄存器 lr 中</span><br><span class="line">	b	__after_proc_init				//跳转到 __after_proc_init，继续执行后续的启动流程</span><br><span class="line">ENDPROC(stext)</span><br></pre></td></tr></table></figure>

<h2 id="after-proc-init-内核启动后处理函数"><a href="#after-proc-init-内核启动后处理函数" class="headerlink" title="__after_proc_init 内核启动后处理函数"></a>__after_proc_init 内核启动后处理函数</h2><ol>
<li><code>__after_proc_init</code>函数的主要作用是设置控制寄存器（Control Register）和读取处理器ID。它在内核启动后执行，确保处理器处于正确的状态，并为后续的操作做好准备。</li>
<li>该函数首先加载SCB的基地址，然后根据配置禁用数据缓存、分支预测和指令缓存。最后，将控制寄存器的值存储到SCB中，并将异常返回值传递给<code>__mmap_switched</code>函数，以继续执行后续的启动流程。</li>
<li>该函数的实现依赖于ARM Cortex-M7架构的特性，使用了特定的寄存器和指令来完成这些操作。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Set the Control Register and Read the process ID.</span><br><span class="line"> */</span><br><span class="line">	.text</span><br><span class="line">__after_proc_init:</span><br><span class="line">//加载BASEADDR_V7M_SCB到R12</span><br><span class="line">M_CLASS(movw	r12, #:lower16:BASEADDR_V7M_SCB)</span><br><span class="line">M_CLASS(movt	r12, #:upper16:BASEADDR_V7M_SCB)</span><br><span class="line">#ifdef CONFIG_ARM_MPU</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_CPU_CP15</span><br><span class="line">#elif defined (CONFIG_CPU_V7M)</span><br><span class="line">	/* 对于 V7M 系统，我们希望像修改 SCTLR 一样修改 CCR*/</span><br><span class="line">#ifdef CONFIG_CPU_DCACHE_DISABLE</span><br><span class="line">	bic	r0, r0, #V7M_SCB_CCR_DC //r0, =V7M_SCB_CCR</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_CPU_BPREDICT_DISABLE</span><br><span class="line">	bic	r0, r0, #V7M_SCB_CCR_BP</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_CPU_ICACHE_DISABLE</span><br><span class="line">	bic	r0, r0, #V7M_SCB_CCR_IC</span><br><span class="line">#endif</span><br><span class="line">	str	r0, [r12, V7M_SCB_CCR]      //r0=V7M_SCB_CCR</span><br><span class="line">	/* 将 exc_ret 传递给 __mmap_switched*/</span><br><span class="line">	mov	r0, r10</span><br><span class="line">#endif /* CONFIG_CPU_CP15 elif CONFIG_CPU_V7M */</span><br><span class="line">	ret	lr  //跳转到__mmap_switched函数，继续执行后续的启动流程</span><br><span class="line">ENDPROC(__after_proc_init)</span><br></pre></td></tr></table></figure>


<h1 id="arch-arm-kernel-head-common-S"><a href="#arch-arm-kernel-head-common-S" class="headerlink" title="arch&#x2F;arm&#x2F;kernel&#x2F;head-common.S"></a>arch&#x2F;arm&#x2F;kernel&#x2F;head-common.S</h1><h2 id="error-死循环"><a href="#error-死循环" class="headerlink" title="__error 死循环"></a>__error 死循环</h2><ol>
<li>死循环</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__error:</span><br><span class="line">1:	mov	r0, r0</span><br><span class="line">	b	1b</span><br><span class="line">ENDPROC(__error)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="error-p"><a href="#error-p" class="headerlink" title="__error_p"></a>__error_p</h2><ol>
<li>打印R9 CPUID 值,并显示错误信息不支持的CPU架构</li>
<li>跳转进入<code>__error</code>,死循环</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">__error_p:</span><br><span class="line">#ifdef CONFIG_DEBUG_LL</span><br><span class="line">	adr	r0, str_p1</span><br><span class="line">	bl	printascii</span><br><span class="line">	mov	r0, r9</span><br><span class="line">	bl	printhex8</span><br><span class="line">	adr	r0, str_p2</span><br><span class="line">	bl	printascii</span><br><span class="line">	b	__error			//死循环</span><br><span class="line">str_p1:	.asciz	&quot;\nError: unrecognized/unsupported processor variant (0x&quot;</span><br><span class="line">str_p2:	.asciz	&quot;).\n&quot;</span><br><span class="line">	.align</span><br><span class="line">#endif</span><br><span class="line">ENDPROC(__error_p)</span><br></pre></td></tr></table></figure>

<h2 id="lookup-processor-type-循环查找processor-type中匹配的cpu信息"><a href="#lookup-processor-type-循环查找processor-type中匹配的cpu信息" class="headerlink" title="__lookup_processor_type 循环查找processor_type中匹配的cpu信息"></a>__lookup_processor_type 循环查找processor_type中匹配的cpu信息</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> c=* 该函数读取处理器 ID 寄存器（CP#15, CR0），并在链接器生成的处理器信息列表中查找与当前处理器匹配的条目。</span><br><span class="line"> * 由于此时 MMU 尚未启用，无法使用绝对地址，因此需要通过计算偏移量来访问处理器信息列表。</span><br><span class="line"> *</span><br><span class="line"> * r9 = CPUID</span><br><span class="line"> *返回：</span><br><span class="line"> * R3、R4、R6 损坏</span><br><span class="line"> * r5 = 物理地址空间中的 proc_info 指针</span><br><span class="line"> * r9 = cpuid（保留）</span><br><span class="line"> */</span><br><span class="line">__lookup_processor_type:</span><br><span class="line">	/*</span><br><span class="line">	 * Look in &lt;asm/procinfo.h&gt; for information about the __proc_info</span><br><span class="line">	 * structure.</span><br><span class="line">	 */</span><br><span class="line">	adr_l	r5, __proc_info_begin</span><br><span class="line">	adr_l	r6, __proc_info_end</span><br><span class="line">1:	ldmia	r5, &#123;r3, r4&#125;			@ r3 = value, r4 = mask</span><br><span class="line">	and	r4, r4, r9					@ 提取感兴趣的位</span><br><span class="line">	teq	r3, r4						@ 比较提取的位与处理器标识值。如果匹配，则跳转到标签 2</span><br><span class="line">	beq	2f</span><br><span class="line">	@ 将 r5 移动到下一个处理器信息条目</span><br><span class="line">	add	r5, r5, #PROC_INFO_SZ		@ sizeof(proc_info_list)</span><br><span class="line">	cmp	r5, r6						@ 检查是否到达列表末尾。</span><br><span class="line">	blo	1b							@ 如果未到达，则继续循环。</span><br><span class="line">	mov	r5, #0						@ 如果遍历完整个列表仍未找到匹配项，将 r5 设置为 0，表示未知处理器</span><br><span class="line">2:	ret	lr							@ 返回调用函数</span><br><span class="line">ENDPROC(__lookup_processor_type)</span><br></pre></td></tr></table></figure>

<h2 id="lookup-processor-type-查找处理器类型"><a href="#lookup-processor-type-查找处理器类型" class="headerlink" title="lookup_processor_type 查找处理器类型"></a>lookup_processor_type 查找处理器类型</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * This provides a C-API version of __lookup_processor_type</span><br><span class="line"> */</span><br><span class="line">ENTRY(lookup_processor_type)</span><br><span class="line">	stmfd	sp!, &#123;r4 - r6, r9, lr&#125;</span><br><span class="line">	mov	r9, r0</span><br><span class="line">	bl	__lookup_processor_type</span><br><span class="line">	mov	r0, r5</span><br><span class="line">	ldmfd	sp!, &#123;r4 - r6, r9, pc&#125;</span><br><span class="line">ENDPROC(lookup_processor_type)</span><br></pre></td></tr></table></figure>

<h2 id="mmap-switched-data-内核启动后数据段"><a href="#mmap-switched-data-内核启动后数据段" class="headerlink" title="__mmap_switched_data 内核启动后数据段"></a>__mmap_switched_data 内核启动后数据段</h2><ul>
<li>包含内核启动后需要初始化的数据段和BSS段的起始和结束地址，以及一些其他信息，如处理器ID、机器类型、ATAG指针等。</li>
<li>该数据段在内核启动后被<code>__mmap_switched</code>函数使用，以便在内核初始化过程中进行必要的设置和清理。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">	.align	2</span><br><span class="line">	.type	__mmap_switched_data, %object</span><br><span class="line">__mmap_switched_data:</span><br><span class="line">#ifdef CONFIG_XIP_KERNEL</span><br><span class="line">#ifndef CONFIG_XIP_DEFLATED_DATA</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	.long	__bss_start			@ r0</span><br><span class="line">	.long	__bss_stop			@ r1</span><br><span class="line">	.long	init_thread_union + THREAD_START_SP @ sp</span><br><span class="line"></span><br><span class="line">	.long	processor_id			@ r0</span><br><span class="line">	.long	__machine_arch_type		@ r1</span><br><span class="line">	.long	__atags_pointer			@ r2</span><br><span class="line">#ifdef CONFIG_CPU_CP15</span><br><span class="line">#else</span><br><span class="line">M_CLASS(.long	exc_ret)			@ r3</span><br><span class="line">AR_CLASS(.long	0)				@ r3</span><br><span class="line">#endif</span><br><span class="line">	.size	__mmap_switched_data, . - __mmap_switched_data</span><br><span class="line"></span><br><span class="line">	__FINIT</span><br><span class="line">	.text</span><br></pre></td></tr></table></figure>

<h2 id="mmap-switched-内核启动后处理函数"><a href="#mmap-switched-内核启动后处理函数" class="headerlink" title="__mmap_switched 内核启动后处理函数"></a>__mmap_switched 内核启动后处理函数</h2><ul>
<li><code>__mmap_switched</code>函数的主要作用是完成内核启动后的初始化工作.</li>
</ul>
<ol>
<li>清除未初始化的BSS段</li>
<li>保存处理器ID和机器类型等信息。它在内核启动过程中被调用，以确保内核在正确的状态下运行。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 以下代码片段在 MMU 模式下开启 MMU 的情况下执行，</span><br><span class="line"> * 并使用绝对地址;这与位置无关。</span><br><span class="line"> *</span><br><span class="line"> * r0 = cp#15 控制寄存器（M 类为 exc_ret）</span><br><span class="line"> * r1 = 计算机 ID</span><br><span class="line"> * R2 = ATAG/DTB 指针</span><br><span class="line"> * r9 = 处理器 ID</span><br><span class="line"> */</span><br><span class="line">	__INIT</span><br><span class="line">__mmap_switched:</span><br><span class="line"></span><br><span class="line">	mov	r7, r1</span><br><span class="line">	mov	r8, r2</span><br><span class="line">	mov	r10, r0</span><br><span class="line"></span><br><span class="line">	adr	r4, __mmap_switched_data</span><br><span class="line">	mov	fp, #0</span><br><span class="line"></span><br><span class="line">#if defined(CONFIG_XIP_DEFLATED_DATA)</span><br><span class="line">#elif defined(CONFIG_XIP_KERNEL)</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">   ARM(	ldmia	r4!, &#123;r0, r1, sp&#125; )</span><br><span class="line">   /*</span><br><span class="line">    r0 = __bss_start</span><br><span class="line">    r1 = __bss_stop</span><br><span class="line">    r3 = sp</span><br><span class="line">   */</span><br><span class="line"> THUMB(	ldmia	r4!, &#123;r0, r1, r3&#125; ) //从寄存器 r4 指向的内存地址加载 r0、r1 和r3，并更新 r4 的值（! 表示地址自增）</span><br><span class="line"> THUMB(	mov	sp, r3 )                //将 r3 的值移动到栈指针（sp）</span><br><span class="line">	sub	r2, r1, r0                  //计算 .bss 段的大小，结果存储在 r2 中，r1 是 .bss 段的结束地址，r0 是起始地址。</span><br><span class="line">	mov	r1, #0</span><br><span class="line">	bl	__memset			        @.bss 是未初始化的全局变量和静态变量所在的内存区域，清零是启动流程中的标准操作。</span><br><span class="line">                                    //加载 init_task 的地址到 r0，这是内核的初始任务结构（task_struct</span><br><span class="line">	adr_l	r0, init_task			@ get swapper task_struct</span><br><span class="line">    //将__current存储到符号 init_task 所表示的虚拟地址中</span><br><span class="line">    //init/init_task.c struct task_struct init_task __aligned(L1_CACHE_BYTES) = &#123;&#125;</span><br><span class="line">    //arch/arm/kernel/process.c  asmlinkage struct task_struct *__current;</span><br><span class="line">	set_current r0, r1              //设置当前任务为 init_task，这是内核调度器的起点。</span><br><span class="line">   /*</span><br><span class="line">    r0 = processor_id</span><br><span class="line">    r1 = __machine_arch_type</span><br><span class="line">    r2 = __atags_pointer</span><br><span class="line">    r3 = exc_ret</span><br><span class="line">   */</span><br><span class="line">	ldmia	r4, &#123;r0, r1, r2, r3&#125;    //从 r4 指向的内存地址加载 r0、r1、r2 和 r3，这些寄存器将用于保存硬件相关信息。</span><br><span class="line">	str	r9, [r0]			        @ Save processor ID</span><br><span class="line">	str	r7, [r1]			        @ Save machine type</span><br><span class="line">	str	r8, [r2]			        @ Save atags pointer</span><br><span class="line">	cmp	r3, #0                      @ 检查 exc_ret 是否为 0</span><br><span class="line">	strne	r10, [r3]			    @ 如果 exc_ret 不为0，将控制寄存器值（r10）存储到 r3 指向的地址。保存控制寄存器值</span><br><span class="line">#ifdef CONFIG_KASAN</span><br><span class="line">	bl	kasan_early_init</span><br><span class="line">#endif</span><br><span class="line">	mov	lr, #0                      //将链接寄存器（lr）清零，确保返回地址无效。</span><br><span class="line">	b	start_kernel                //跳转到内核的启动函数 start_kernel，继续执行内核初始化过程。</span><br><span class="line">ENDPROC(__mmap_switched)</span><br></pre></td></tr></table></figure>


<h1 id="——————————————–"><a href="#——————————————–" class="headerlink" title="——————————————–"></a>——————————————–</h1><h1 id="arch-arm-include-asm-cputype-h"><a href="#arch-arm-include-asm-cputype-h" class="headerlink" title="arch&#x2F;arm&#x2F;include&#x2F;asm&#x2F;cputype.h"></a>arch&#x2F;arm&#x2F;include&#x2F;asm&#x2F;cputype.h</h1><h2 id="read-cpuid-id-读取处理器ID"><a href="#read-cpuid-id-读取处理器ID" class="headerlink" title="read_cpuid_id 读取处理器ID"></a>read_cpuid_id 读取处理器ID</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_CPU_V7M)</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> __attribute_const__ <span class="title function_">read_cpuid_id</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> readl(BASEADDR_V7M_SCB + V7M_SCB_CPUID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> __attribute_const__ <span class="title function_">read_cpuid_cachetype</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> readl(BASEADDR_V7M_SCB + V7M_SCB_CTR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> __attribute_const__ <span class="title function_">read_cpuid_mputype</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> readl(BASEADDR_V7M_SCB + MPU_TYPE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="cpuid-feature-extract-处理器特征提取"><a href="#cpuid-feature-extract-处理器特征提取" class="headerlink" title="cpuid_feature_extract 处理器特征提取"></a>cpuid_feature_extract 处理器特征提取</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从SCB读取处理器ID寄存器的值</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> __attribute_const__ <span class="title function_">read_cpuid_ext</span><span class="params">(<span class="type">unsigned</span> offset)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> readl(BASEADDR_V7M_SCB + offset);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> __attribute_const__ <span class="title function_">cpuid_feature_extract_field</span><span class="params">(u32 features,</span></span><br><span class="line"><span class="params">								  <span class="type">int</span> field)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> feature = (features &gt;&gt; field) &amp; <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 特征寄存器是有符号值 */</span></span><br><span class="line">	<span class="keyword">if</span> (feature &gt; <span class="number">7</span>)</span><br><span class="line">		feature -= <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> feature;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cpuid_feature_extract(reg, field) \</span></span><br><span class="line"><span class="meta">	cpuid_feature_extract_field(read_cpuid_ext(reg), field)</span></span><br></pre></td></tr></table></figure>

<h1 id="arch-arm-kernel-devtree-c"><a href="#arch-arm-kernel-devtree-c" class="headerlink" title="arch&#x2F;arm&#x2F;kernel&#x2F;devtree.c"></a>arch&#x2F;arm&#x2F;kernel&#x2F;devtree.c</h1><h2 id="arch-info-架构信息"><a href="#arch-info-架构信息" class="headerlink" title="__arch_info 架构信息"></a>__arch_info 架构信息</h2><h3 id="arch-arm-include-asm-mach-arch-h"><a href="#arch-arm-include-asm-mach-arch-h" class="headerlink" title="arch&#x2F;arm&#x2F;include&#x2F;asm&#x2F;mach&#x2F;arch.h"></a>arch&#x2F;arm&#x2F;include&#x2F;asm&#x2F;mach&#x2F;arch.h</h3><ol>
<li>定义了<code>__arch_info</code>结构体，表示机器描述符的基本信息，包括机器类型、名称、DTB兼容性等。</li>
<li>该结构体用于在内核启动时识别和匹配不同的机器类型，以便进行适当的初始化和配置。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Machine type table - also only accessible during boot</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">machine_desc</span> __<span class="title">arch_info_begin</span>[], __<span class="title">arch_info_end</span>[];</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> for_each_machine_desc(p)			\</span></span><br><span class="line"><span class="meta">	for (p = __arch_info_begin; p &lt; __arch_info_end; p++)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Set of macros to define architecture features.  This is built into</span></span><br><span class="line"><span class="comment"> * a table by the linker.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACHINE_START(_type,_name)			\</span></span><br><span class="line"><span class="meta">static const struct machine_desc __mach_desc_##_type	\</span></span><br><span class="line"><span class="meta"> __used							\</span></span><br><span class="line"><span class="meta"> __section(<span class="string">&quot;.arch.info.init&quot;</span>) = &#123;			\</span></span><br><span class="line"><span class="meta">	.nr		= MACH_TYPE_##_type,		\</span></span><br><span class="line"><span class="meta">	.name		= _name,</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACHINE_END				\</span></span><br><span class="line"><span class="meta">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_MACHINE_START(_name, _namestr)		\</span></span><br><span class="line"><span class="meta">static const struct machine_desc __mach_desc_##_name	\</span></span><br><span class="line"><span class="meta"> __used							\</span></span><br><span class="line"><span class="meta"> __section(<span class="string">&quot;.arch.info.init&quot;</span>) = &#123;			\</span></span><br><span class="line"><span class="meta">	.nr		= ~0,				\</span></span><br><span class="line"><span class="meta">	.name		= _namestr,</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>arch&#x2F;arm&#x2F;kernel&#x2F;vmlinux.lds</li>
</ol>
<ul>
<li>其中定义了相关变量存储机器描述符信息的起始和结束地址。</li>
<li>使用<code>.arch.info.init</code>节来存储机器描述符信息，并使用<code>KEEP</code>指令确保这些信息在链接时不会被丢弃。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.init.arch.info : &#123;</span><br><span class="line"> __arch_info_begin = .;</span><br><span class="line"> KEEP(*(.arch.info.init))</span><br><span class="line"> __arch_info_end = .;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>例如<code>st,stm32h750</code>的机器描述符信息如下：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//arch/arm/mach-stm32/board-dt.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *<span class="type">const</span> stm32_compat[] __initconst = &#123;</span><br><span class="line">	<span class="string">&quot;st,stm32f429&quot;</span>,</span><br><span class="line">	<span class="string">&quot;st,stm32f469&quot;</span>,</span><br><span class="line">	<span class="string">&quot;st,stm32f746&quot;</span>,</span><br><span class="line">	<span class="string">&quot;st,stm32f769&quot;</span>,</span><br><span class="line">	<span class="string">&quot;st,stm32h743&quot;</span>,</span><br><span class="line">	<span class="string">&quot;st,stm32h750&quot;</span>,</span><br><span class="line">	<span class="string">&quot;st,stm32mp131&quot;</span>,</span><br><span class="line">	<span class="string">&quot;st,stm32mp133&quot;</span>,</span><br><span class="line">	<span class="string">&quot;st,stm32mp135&quot;</span>,</span><br><span class="line">	<span class="string">&quot;st,stm32mp151&quot;</span>,</span><br><span class="line">	<span class="string">&quot;st,stm32mp157&quot;</span>,</span><br><span class="line">	<span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DT_MACHINE_START(STM32DT, <span class="string">&quot;STM32 (Device Tree Support)&quot;</span>)</span><br><span class="line">	.dt_compat = stm32_compat,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARM_SINGLE_ARMV7M</span></span><br><span class="line">	.restart = armv7m_restart,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">MACHINE_END</span><br></pre></td></tr></table></figure>

<h3 id="arch-get-next-mach-获取下一个机器描述符"><a href="#arch-get-next-mach-获取下一个机器描述符" class="headerlink" title="arch_get_next_mach 获取下一个机器描述符"></a>arch_get_next_mach 获取下一个机器描述符</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">void</span> * __init <span class="title function_">arch_get_next_mach</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *<span class="type">const</span> **match)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">machine_desc</span> *<span class="title">mdesc</span> =</span> __arch_info_begin;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">machine_desc</span> *<span class="title">m</span> =</span> mdesc;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (m &gt;= __arch_info_end)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	mdesc++;</span><br><span class="line">	*match = m-&gt;dt_compat;</span><br><span class="line">	<span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="setup-machine-fdt-将-dtb-传递到内核时的计算机设置-返回struct-machine-desc信息"><a href="#setup-machine-fdt-将-dtb-传递到内核时的计算机设置-返回struct-machine-desc信息" class="headerlink" title="setup_machine_fdt 将 dtb 传递到内核时的计算机设置,返回struct machine_desc信息"></a>setup_machine_fdt 将 dtb 传递到内核时的计算机设置,返回struct machine_desc信息</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * setup_machine_fdt - Machine setup when an dtb was passed to the kernel</span></span><br><span class="line"><span class="comment"> * @dt_virt: virtual address of dt blob</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If a dtb was passed to the kernel in r2, then use it to choose the</span></span><br><span class="line"><span class="comment"> * correct machine_desc and to setup the system.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">struct</span> machine_desc * __init <span class="title function_">setup_machine_fdt</span><span class="params">(<span class="type">void</span> *dt_virt)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">machine_desc</span> *<span class="title">mdesc</span>, *<span class="title">mdesc_best</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	DT_MACHINE_START(GENERIC_DT, <span class="string">&quot;Generic DT based system&quot;</span>)</span><br><span class="line">		.l2c_aux_val = <span class="number">0x0</span>,</span><br><span class="line">		.l2c_aux_mask = ~<span class="number">0x0</span>,</span><br><span class="line">	MACHINE_END</span><br><span class="line"></span><br><span class="line">	mdesc_best = &amp;__mach_desc_GENERIC_DT;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!dt_virt || !early_init_dt_verify(dt_virt, __pa(dt_virt)))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	mdesc = of_flat_dt_match_machine(mdesc_best, arch_get_next_mach);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!mdesc) &#123;</span><br><span class="line">		<span class="type">const</span> <span class="type">char</span> *prop;</span><br><span class="line">		<span class="type">int</span> size;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> dt_root;</span><br><span class="line"></span><br><span class="line">		early_print(<span class="string">&quot;\nError: unrecognized/unsupported &quot;</span></span><br><span class="line">			    <span class="string">&quot;device tree compatible list:\n[ &quot;</span>);</span><br><span class="line"></span><br><span class="line">		dt_root = of_get_flat_dt_root();</span><br><span class="line">		prop = of_get_flat_dt_prop(dt_root, <span class="string">&quot;compatible&quot;</span>, &amp;size);</span><br><span class="line">		<span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			early_print(<span class="string">&quot;&#x27;%s&#x27; &quot;</span>, prop);</span><br><span class="line">			size -= <span class="built_in">strlen</span>(prop) + <span class="number">1</span>;</span><br><span class="line">			prop += <span class="built_in">strlen</span>(prop) + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		early_print(<span class="string">&quot;]\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		dump_machine_table(); <span class="comment">/* does not return */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 我们真的不想这样做，但有时固件会提供有问题的数据 */</span></span><br><span class="line">	<span class="keyword">if</span> (mdesc-&gt;dt_fixup)</span><br><span class="line">		mdesc-&gt;dt_fixup();</span><br><span class="line"></span><br><span class="line">	early_init_dt_scan_nodes();	<span class="comment">//扫描设备树节点</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 更改机器编号以匹配我们使用的 mdesc*/</span></span><br><span class="line">	__machine_arch_type = mdesc-&gt;nr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> mdesc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="arm-dt-init-cpu-maps-初始化CPU映射"><a href="#arm-dt-init-cpu-maps-初始化CPU映射" class="headerlink" title="arm_dt_init_cpu_maps 初始化CPU映射"></a>arm_dt_init_cpu_maps 初始化CPU映射</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * arm_dt_init_cpu_maps - 函数从设备树中检索 CPU 节点，并构建包含与逻辑 CPU 相关的 MPIDR 值的 cpu 逻辑映射数组</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 使用解析的 cpu 节点数更新 cpu 可能的掩码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">arm_dt_init_cpu_maps</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 临时逻辑映射使用被视为无效逻辑映射条目的 UINT_MAX 值进行初始化，因为逻辑映射必须包含 MPIDR[23：0] 值列表，其中 MPIDR[31：24] 必须读取为 0。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">cpu</span>, *<span class="title">cpus</span>;</span></span><br><span class="line">	<span class="type">int</span> found_method = <span class="number">0</span>;</span><br><span class="line">	u32 i, j, cpuidx = <span class="number">1</span>;</span><br><span class="line">	u32 mpidr = is_smp() ? read_cpuid_mpidr() &amp; MPIDR_HWID_BITMASK : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cpus)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="arch-arm-kernel-early-printk-c-早期printk打印"><a href="#arch-arm-kernel-early-printk-c-早期printk打印" class="headerlink" title="arch&#x2F;arm&#x2F;kernel&#x2F;early_printk.c 早期printk打印"></a>arch&#x2F;arm&#x2F;kernel&#x2F;early_printk.c 早期printk打印</h1><ol>
<li>调用.s文件进行printk打印</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">printascii</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">early_write</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">unsigned</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">	<span class="keyword">while</span> (n) &#123;</span><br><span class="line">		<span class="type">unsigned</span> l = min(n, <span class="keyword">sizeof</span>(buf)<span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">memcpy</span>(buf, s, l);</span><br><span class="line">		buf[l] = <span class="number">0</span>;</span><br><span class="line">		s += l;</span><br><span class="line">		n -= l;</span><br><span class="line">		printascii(buf);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">early_console_write</span><span class="params">(<span class="keyword">struct</span> console *con, <span class="type">const</span> <span class="type">char</span> *s, <span class="type">unsigned</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	early_write(s, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">console</span> <span class="title">early_console_dev</span> =</span> &#123;</span><br><span class="line">	.name =		<span class="string">&quot;earlycon&quot;</span>,</span><br><span class="line">	.write =	early_console_write,</span><br><span class="line">	.flags =	CON_PRINTBUFFER | CON_BOOT,</span><br><span class="line">	.index =	<span class="number">-1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">setup_early_printk</span><span class="params">(<span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">	early_console = &amp;early_console_dev;</span><br><span class="line">	register_console(&amp;early_console_dev);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">early_param(<span class="string">&quot;earlyprintk&quot;</span>, setup_early_printk);</span><br></pre></td></tr></table></figure>

<h1 id="arch-arm-kernel-setup-c"><a href="#arch-arm-kernel-setup-c" class="headerlink" title="arch&#x2F;arm&#x2F;kernel&#x2F;setup.c"></a>arch&#x2F;arm&#x2F;kernel&#x2F;setup.c</h1><h2 id="smp-setup-processor-id-处理器ID设置函数"><a href="#smp-setup-processor-id-处理器ID设置函数" class="headerlink" title="smp_setup_processor_id 处理器ID设置函数"></a>smp_setup_processor_id 处理器ID设置函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">smp_setup_processor_id</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	u32 mpidr = is_smp() ? read_cpuid_mpidr() &amp; MPIDR_HWID_BITMASK : <span class="number">0</span>;	<span class="comment">//非SMP:0</span></span><br><span class="line">	u32 cpu = MPIDR_AFFINITY_LEVEL(mpidr, <span class="number">0</span>);							<span class="comment">//非SMP:0</span></span><br><span class="line"></span><br><span class="line">	cpu_logical_map(<span class="number">0</span>) = cpu;											<span class="comment">//cpu_logical_map[0] = 0</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; nr_cpu_ids; ++i)</span><br><span class="line">		cpu_logical_map(i) = i == cpu ? <span class="number">0</span> : i;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * clear __my_cpu_offset on boot CPU to avoid hang caused by</span></span><br><span class="line"><span class="comment">	 * using percpu variable early, for example, lockdep will</span></span><br><span class="line"><span class="comment">	 * access percpu variable inside lock_release</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	set_my_cpu_offset(<span class="number">0</span>);												<span class="comment">//非SMP:do &#123;&#125; while(0)</span></span><br><span class="line"></span><br><span class="line">	pr_info(<span class="string">&quot;Booting Linux on physical CPU 0x%x\n&quot;</span>, mpidr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="lookup-processor-查找处理器类型"><a href="#lookup-processor-查找处理器类型" class="headerlink" title="lookup_processor 查找处理器类型"></a>lookup_processor 查找处理器类型</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> proc_info_list *<span class="title function_">lookup_processor</span><span class="params">(u32 midr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">proc_info_list</span> *<span class="title">list</span> =</span> lookup_processor_type(midr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">list</span>) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;CPU%u: configuration botched (ID %08x), CPU halted\n&quot;</span>,</span><br><span class="line">		       smp_processor_id(), midr);</span><br><span class="line">		<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">		<span class="comment">/* can&#x27;t use cpu_relax() here as it may require MMU setup */</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="get-cpu-architecture-获取CPU架构"><a href="#get-cpu-architecture-获取CPU架构" class="headerlink" title="__get_cpu_architecture 获取CPU架构"></a>__get_cpu_architecture 获取CPU架构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//arch/arm/include/asm/system_info.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CPU_ARCH_UNKNOWN	0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CPU_ARCH_ARMv3		1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CPU_ARCH_ARMv4		2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CPU_ARCH_ARMv4T		3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CPU_ARCH_ARMv5		4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CPU_ARCH_ARMv5T		5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CPU_ARCH_ARMv5TE	6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CPU_ARCH_ARMv5TEJ	7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CPU_ARCH_ARMv6		8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CPU_ARCH_ARMv7		9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CPU_ARCH_ARMv7M		10</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CPU_V7M</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __get_cpu_architecture(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> CPU_ARCH_ARMv7M;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="cpuid-init-hwcaps-设置CPU硬件能力"><a href="#cpuid-init-hwcaps-设置CPU硬件能力" class="headerlink" title="cpuid_init_hwcaps 设置CPU硬件能力"></a>cpuid_init_hwcaps 设置CPU硬件能力</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __init <span class="title function_">cpuid_init_hwcaps</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> block;</span><br><span class="line">	u32 isar5;</span><br><span class="line">	u32 isar6;</span><br><span class="line">	u32 pfr2;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cpu_architecture() &lt; CPU_ARCH_ARMv7)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">//识别是否支持整数除法指令</span></span><br><span class="line">	block = cpuid_feature_extract(CPUID_EXT_ISAR0, <span class="number">24</span>);</span><br><span class="line">	<span class="keyword">if</span> (block &gt;= <span class="number">2</span>)</span><br><span class="line">		elf_hwcap |= HWCAP_IDIVA;	<span class="comment">//支持整数除法指令</span></span><br><span class="line">	<span class="keyword">if</span> (block &gt;= <span class="number">1</span>)</span><br><span class="line">		elf_hwcap |= HWCAP_IDIVT;	<span class="comment">//Thumb 模式下的整数除法指令</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* LPAE 表示原子 ldrd/strd 指令 */</span></span><br><span class="line">	block = cpuid_feature_extract(CPUID_EXT_MMFR0, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (block &gt;= <span class="number">5</span>)</span><br><span class="line">		elf_hwcap |= HWCAP_LPAE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*检查支持的v8加密指令 */</span></span><br><span class="line">	isar5 = read_cpuid_ext(CPUID_EXT_ISAR5);</span><br><span class="line"></span><br><span class="line">	block = cpuid_feature_extract_field(isar5, <span class="number">4</span>);</span><br><span class="line">	<span class="keyword">if</span> (block &gt;= <span class="number">2</span>)</span><br><span class="line">		elf_hwcap2 |= HWCAP2_PMULL;</span><br><span class="line">	<span class="keyword">if</span> (block &gt;= <span class="number">1</span>)</span><br><span class="line">		elf_hwcap2 |= HWCAP2_AES;</span><br><span class="line"></span><br><span class="line">	block = cpuid_feature_extract_field(isar5, <span class="number">8</span>);</span><br><span class="line">	<span class="keyword">if</span> (block &gt;= <span class="number">1</span>)</span><br><span class="line">		elf_hwcap2 |= HWCAP2_SHA1;</span><br><span class="line"></span><br><span class="line">	block = cpuid_feature_extract_field(isar5, <span class="number">12</span>);</span><br><span class="line">	<span class="keyword">if</span> (block &gt;= <span class="number">1</span>)</span><br><span class="line">		elf_hwcap2 |= HWCAP2_SHA2;</span><br><span class="line"></span><br><span class="line">	block = cpuid_feature_extract_field(isar5, <span class="number">16</span>);</span><br><span class="line">	<span class="keyword">if</span> (block &gt;= <span class="number">1</span>)</span><br><span class="line">		elf_hwcap2 |= HWCAP2_CRC32;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 查看 Speculation barrier 指令 */</span></span><br><span class="line">	isar6 = read_cpuid_ext(CPUID_EXT_ISAR6);</span><br><span class="line">	block = cpuid_feature_extract_field(isar6, <span class="number">12</span>);</span><br><span class="line">	<span class="keyword">if</span> (block &gt;= <span class="number">1</span>)</span><br><span class="line">		elf_hwcap2 |= HWCAP2_SB;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 检查 Speculative Store Bypassing 控件 */</span></span><br><span class="line">	pfr2 = read_cpuid_ext(CPUID_EXT_PFR2);</span><br><span class="line">	block = cpuid_feature_extract_field(pfr2, <span class="number">4</span>);</span><br><span class="line">	<span class="keyword">if</span> (block &gt;= <span class="number">1</span>)</span><br><span class="line">		elf_hwcap2 |= HWCAP2_SSBS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="cacheid-init-缓存ID初始化函数"><a href="#cacheid-init-缓存ID初始化函数" class="headerlink" title="cacheid_init 缓存ID初始化函数"></a>cacheid_init 缓存ID初始化函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __init <span class="title function_">cacheid_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> arch = cpu_architecture();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (arch &gt;= CPU_ARCH_ARMv6) &#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> cachetype = read_cpuid_cachetype();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((arch == CPU_ARCH_ARMv7M) &amp;&amp; !(cachetype &amp; <span class="number">0xf000f</span>)) &#123;</span><br><span class="line">			cacheid = <span class="number">0</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((cachetype &amp; (<span class="number">7</span> &lt;&lt; <span class="number">29</span>)) == <span class="number">4</span> &lt;&lt; <span class="number">29</span>) &#123;</span><br><span class="line">			<span class="comment">/* ARMv7 register format */</span></span><br><span class="line">			arch = CPU_ARCH_ARMv7;</span><br><span class="line">			cacheid = CACHEID_VIPT_NONALIASING;</span><br><span class="line">			<span class="keyword">switch</span> (cachetype &amp; (<span class="number">3</span> &lt;&lt; <span class="number">14</span>)) &#123;</span><br><span class="line">			<span class="keyword">case</span> (<span class="number">1</span> &lt;&lt; <span class="number">14</span>):</span><br><span class="line">				cacheid |= CACHEID_ASID_TAGGED;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> (<span class="number">3</span> &lt;&lt; <span class="number">14</span>):</span><br><span class="line">				cacheid |= CACHEID_PIPT;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			arch = CPU_ARCH_ARMv6;</span><br><span class="line">			<span class="keyword">if</span> (cachetype &amp; (<span class="number">1</span> &lt;&lt; <span class="number">23</span>))</span><br><span class="line">				cacheid = CACHEID_VIPT_ALIASING;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				cacheid = CACHEID_VIPT_NONALIASING;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (cpu_has_aliasing_icache(arch))</span><br><span class="line">			cacheid |= CACHEID_VIPT_I_ALIASING;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		cacheid = CACHEID_VIVT;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pr_info(<span class="string">&quot;CPU: %s data cache, %s instruction cache\n&quot;</span>,</span><br><span class="line">		cache_is_vivt() ? <span class="string">&quot;VIVT&quot;</span> :</span><br><span class="line">		cache_is_vipt_aliasing() ? <span class="string">&quot;VIPT aliasing&quot;</span> :</span><br><span class="line">		cache_is_vipt_nonaliasing() ? <span class="string">&quot;PIPT / VIPT nonaliasing&quot;</span> : <span class="string">&quot;unknown&quot;</span>,</span><br><span class="line">		cache_is_vivt() ? <span class="string">&quot;VIVT&quot;</span> :</span><br><span class="line">		icache_is_vivt_asid_tagged() ? <span class="string">&quot;VIVT ASID tagged&quot;</span> :</span><br><span class="line">		icache_is_vipt_aliasing() ? <span class="string">&quot;VIPT aliasing&quot;</span> :</span><br><span class="line">		icache_is_pipt() ? <span class="string">&quot;PIPT&quot;</span> :</span><br><span class="line">		cache_is_vipt_nonaliasing() ? <span class="string">&quot;VIPT nonaliasing&quot;</span> : <span class="string">&quot;unknown&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="setup-processor-处理器设置函数"><a href="#setup-processor-处理器设置函数" class="headerlink" title="setup_processor 处理器设置函数"></a>setup_processor 处理器设置函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __init <span class="title function_">setup_processor</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> midr = read_cpuid_id();	<span class="comment">//读取处理器 ID 寄存器的值</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">proc_info_list</span> *<span class="title">list</span> =</span> lookup_processor(midr);	<span class="comment">//查找处理器类型</span></span><br><span class="line"></span><br><span class="line">	cpu_name = <span class="built_in">list</span>-&gt;cpu_name;</span><br><span class="line">	__cpu_architecture = __get_cpu_architecture();</span><br><span class="line"></span><br><span class="line">	init_proc_vtable(<span class="built_in">list</span>-&gt;proc);	<span class="comment">//需要 MULTI_CPU</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MULTI_TLB</span></span><br><span class="line">	cpu_tlb = *<span class="built_in">list</span>-&gt;tlb;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MULTI_USER</span></span><br><span class="line">	cpu_user = *<span class="built_in">list</span>-&gt;user;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MULTI_CACHE</span></span><br><span class="line">	cpu_cache = *<span class="built_in">list</span>-&gt;cache;	<span class="comment">//v7m_cache_fns</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">snprintf</span>(init_utsname()-&gt;machine, __NEW_UTS_LEN + <span class="number">1</span>, <span class="string">&quot;%s%c&quot;</span>,</span><br><span class="line">		 <span class="built_in">list</span>-&gt;arch_name, ENDIANNESS);</span><br><span class="line">	<span class="built_in">snprintf</span>(elf_platform, ELF_PLATFORM_SIZE, <span class="string">&quot;%s%c&quot;</span>,</span><br><span class="line">		 <span class="built_in">list</span>-&gt;elf_name, ENDIANNESS);</span><br><span class="line">	elf_hwcap = <span class="built_in">list</span>-&gt;elf_hwcap;</span><br><span class="line"></span><br><span class="line">	cpuid_init_hwcaps();	<span class="comment">//设置CPU硬件能力</span></span><br><span class="line">	<span class="comment">//CPU_32v7 使用</span></span><br><span class="line">	patch_aeabi_idiv();		<span class="comment">//修补 AEABI IDIV 函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_ARM_THUMB</span></span><br><span class="line">	elf_hwcap &amp;= ~(HWCAP_THUMB | HWCAP_IDIVT);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MMU</span></span><br><span class="line">	init_default_cache_policy(<span class="built_in">list</span>-&gt;__cpu_mm_mmu_flags);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	erratum_a15_798181_init();</span><br><span class="line"></span><br><span class="line">	elf_hwcap_fixup();</span><br><span class="line">	<span class="comment">//根据寄存器读取的值设置 CPU 的缓存 ID</span></span><br><span class="line">	cacheid_init(); <span class="comment">//cacheid 初始化函数</span></span><br><span class="line">	cpu_init();		<span class="comment">//非CONFIG_CPU_V7M进行设置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="request-standard-resources-请求标准资源"><a href="#request-standard-resources-请求标准资源" class="headerlink" title="request_standard_resources 请求标准资源"></a>request_standard_resources 请求标准资源</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Standard memory resources</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> <span class="title">mem_res</span>[] =</span> &#123;</span><br><span class="line">	&#123;</span><br><span class="line">		.name = <span class="string">&quot;Video RAM&quot;</span>,</span><br><span class="line">		.start = <span class="number">0</span>,</span><br><span class="line">		.end = <span class="number">0</span>,</span><br><span class="line">		.flags = IORESOURCE_MEM</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		.name = <span class="string">&quot;Kernel code&quot;</span>,</span><br><span class="line">		.start = <span class="number">0</span>,</span><br><span class="line">		.end = <span class="number">0</span>,</span><br><span class="line">		.flags = IORESOURCE_SYSTEM_RAM</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		.name = <span class="string">&quot;Kernel data&quot;</span>,</span><br><span class="line">		.start = <span class="number">0</span>,</span><br><span class="line">		.end = <span class="number">0</span>,</span><br><span class="line">		.flags = IORESOURCE_SYSTEM_RAM</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> video_ram   mem_res[0]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kernel_code mem_res[1]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kernel_data mem_res[2]</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __init <span class="title function_">request_standard_resources</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> machine_desc *mdesc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">phys_addr_t</span> start, end, res_end;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">res</span>;</span></span><br><span class="line">	u64 i;</span><br><span class="line"></span><br><span class="line">	kernel_code.start   = virt_to_phys(_text);</span><br><span class="line">	kernel_code.end     = virt_to_phys(__init_begin - <span class="number">1</span>);</span><br><span class="line">	kernel_data.start   = virt_to_phys(_sdata);</span><br><span class="line">	kernel_data.end     = virt_to_phys(_end - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	for_each_mem_range(i, &amp;start, &amp;end) &#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> boot_alias_start;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 在 memblock 中，end 指向范围后的第一个字节，而在资源中，end 指向范围中的最后一个字节。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		res_end = end - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 某些系统有一个仅用于--*启动的特殊内存别名。 我们需要向 kexec-tools 公布这个区域，以便它们知道可启动 RAM 的位置。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		boot_alias_start = phys_to_idmap(start);</span><br><span class="line">		<span class="comment">//CONFIG_MMU</span></span><br><span class="line">		<span class="keyword">if</span> (arm_has_idmap_alias() &amp;&amp; boot_alias_start != IDMAP_INVALID_ADDR) &#123;</span><br><span class="line">			res = memblock_alloc_or_panic(<span class="keyword">sizeof</span>(*res), SMP_CACHE_BYTES);</span><br><span class="line">			res-&gt;name = <span class="string">&quot;System RAM (boot alias)&quot;</span>;</span><br><span class="line">			res-&gt;start = boot_alias_start;</span><br><span class="line">			res-&gt;end = phys_to_idmap(res_end);</span><br><span class="line">			res-&gt;flags = IORESOURCE_MEM | IORESOURCE_BUSY;</span><br><span class="line">			request_resource(&amp;iomem_resource, res);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//malloc指针地址</span></span><br><span class="line">		res = memblock_alloc_or_panic(<span class="keyword">sizeof</span>(*res), SMP_CACHE_BYTES);</span><br><span class="line">		res-&gt;name  = <span class="string">&quot;System RAM&quot;</span>;</span><br><span class="line">		res-&gt;start = start;</span><br><span class="line">		res-&gt;end = res_end;</span><br><span class="line">		res-&gt;flags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;</span><br><span class="line">		<span class="comment">//插入资源树</span></span><br><span class="line">		request_resource(&amp;iomem_resource, res);</span><br><span class="line">		<span class="comment">//插入资源树</span></span><br><span class="line">		<span class="keyword">if</span> (kernel_code.start &gt;= res-&gt;start &amp;&amp;</span><br><span class="line">		    kernel_code.end &lt;= res-&gt;end)</span><br><span class="line">			request_resource(res, &amp;kernel_code);</span><br><span class="line">		<span class="keyword">if</span> (kernel_data.start &gt;= res-&gt;start &amp;&amp;</span><br><span class="line">		    kernel_data.end &lt;= res-&gt;end)</span><br><span class="line">			request_resource(res, &amp;kernel_data);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mdesc-&gt;video_start) &#123;</span><br><span class="line">		video_ram.start = mdesc-&gt;video_start;</span><br><span class="line">		video_ram.end   = mdesc-&gt;video_end;</span><br><span class="line">		request_resource(&amp;iomem_resource, &amp;video_ram);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Some machines don&#x27;t have the possibility of ever</span></span><br><span class="line"><span class="comment">	 * possessing lp0, lp1 or lp2</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (mdesc-&gt;reserve_lp0)</span><br><span class="line">		request_resource(&amp;ioport_resource, &amp;lp0);</span><br><span class="line">	<span class="keyword">if</span> (mdesc-&gt;reserve_lp1)</span><br><span class="line">		request_resource(&amp;ioport_resource, &amp;lp1);</span><br><span class="line">	<span class="keyword">if</span> (mdesc-&gt;reserve_lp2)</span><br><span class="line">		request_resource(&amp;ioport_resource, &amp;lp2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="setup-arch-设置体系结构"><a href="#setup-arch-设置体系结构" class="headerlink" title="setup_arch 设置体系结构"></a>setup_arch 设置体系结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">setup_arch</span><span class="params">(<span class="type">char</span> **cmdline_p)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">machine_desc</span> *<span class="title">mdesc</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">void</span> *atags_vaddr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (__atags_pointer)</span><br><span class="line">		atags_vaddr = FDT_VIRT_BASE(__atags_pointer);</span><br><span class="line"></span><br><span class="line">	setup_processor();	<span class="comment">//处理器设置函数</span></span><br><span class="line">	<span class="keyword">if</span> (atags_vaddr) &#123;</span><br><span class="line">        <span class="comment">//返回struct machine_desc信息</span></span><br><span class="line">        <span class="comment">//setup_machine_fdt函数会根据传入的dtb地址，返回对应的机器描述符信息</span></span><br><span class="line">		mdesc = setup_machine_fdt(atags_vaddr);</span><br><span class="line">		<span class="keyword">if</span> (mdesc)</span><br><span class="line">            <span class="comment">//预留fdt大小的空间</span></span><br><span class="line">			memblock_reserve(__atags_pointer,</span><br><span class="line">					 fdt_totalsize(atags_vaddr));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!mdesc)</span><br><span class="line">        <span class="comment">/* 使用atag方式尝试进行设置</span></span><br><span class="line"><span class="comment">        CONFIG_ATAGS没有配置直接报错</span></span><br><span class="line"><span class="comment">        early_print(&quot;no ATAGS support: can&#x27;t continue\n&quot;);</span></span><br><span class="line"><span class="comment">        while (true);</span></span><br><span class="line"><span class="comment">        unreachable(); */</span></span><br><span class="line">		mdesc = setup_machine_tags(atags_vaddr, __machine_arch_type);</span><br><span class="line">	<span class="keyword">if</span> (!mdesc) &#123;</span><br><span class="line">		early_print(<span class="string">&quot;\nError: invalid dtb and unrecognized/unsupported machine ID\n&quot;</span>);</span><br><span class="line">		early_print(<span class="string">&quot;  r1=0x%08x, r2=0x%08x\n&quot;</span>, __machine_arch_type,</span><br><span class="line">			    __atags_pointer);</span><br><span class="line">		<span class="keyword">if</span> (__atags_pointer)</span><br><span class="line">			early_print(<span class="string">&quot;  r2[]=%*ph\n&quot;</span>, <span class="number">16</span>, atags_vaddr);</span><br><span class="line">        <span class="comment">/* early_print(&quot;Available machine support:\n\nID (hex)\tNAME\n&quot;);</span></span><br><span class="line"><span class="comment">        for_each_machine_desc(p)</span></span><br><span class="line"><span class="comment">            early_print(&quot;%08x\t%s\n&quot;, p-&gt;nr, p-&gt;name);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        early_print(&quot;\nPlease check your kernel config and/or bootloader.\n&quot;);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        while (true) */</span></span><br><span class="line">		dump_machine_table();</span><br><span class="line">	&#125;</span><br><span class="line">	machine_desc = mdesc;</span><br><span class="line">	machine_name = mdesc-&gt;name;</span><br><span class="line">	dump_stack_set_arch_desc(<span class="string">&quot;%s&quot;</span>, mdesc-&gt;name);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mdesc-&gt;reboot_mode != REBOOT_HARD)</span><br><span class="line">		reboot_mode = mdesc-&gt;reboot_mode;</span><br><span class="line"></span><br><span class="line">	setup_initial_init_mm(_text, _etext, _edata, _end);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*也填充 cmd_line 供以后使用，保留boot_command_line */</span></span><br><span class="line">	<span class="comment">//boot_command_line从FDT中获取的参数</span></span><br><span class="line">	strscpy(cmd_line, boot_command_line, COMMAND_LINE_SIZE);</span><br><span class="line">	*cmdline_p = cmd_line;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//MMU 无使用</span></span><br><span class="line">	early_fixmap_init();</span><br><span class="line">	early_ioremap_init();</span><br><span class="line"></span><br><span class="line">	parse_early_param();	<span class="comment">//解析早期参数并设置内核参数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MMU</span></span><br><span class="line">	early_mm_init(mdesc);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	setup_dma_zone(mdesc);	</span><br><span class="line">	xen_early_init();</span><br><span class="line">	arm_efi_init();</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 在保留/分配任何内存之前，请确保正确设置 lowmem/highmem 的计算</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	adjust_lowmem_bounds();	<span class="comment">//设置memblock的限制地址</span></span><br><span class="line">	arm_memblock_init(mdesc);</span><br><span class="line">	<span class="comment">/* 内存可能已被删除，因此请重新计算边界。 */</span></span><br><span class="line">	adjust_lowmem_bounds();</span><br><span class="line"></span><br><span class="line">	early_ioremap_reset();	<span class="comment">//CONFIG_MMU</span></span><br><span class="line"></span><br><span class="line">	paging_init(mdesc);		<span class="comment">//初始化页表</span></span><br><span class="line">	kasan_init();</span><br><span class="line">	request_standard_resources(mdesc);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mdesc-&gt;restart) &#123;		<span class="comment">//armv7m_restart</span></span><br><span class="line">		__arm_pm_restart = mdesc-&gt;restart;</span><br><span class="line">		register_restart_handler(&amp;arm_restart_nb);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	unflatten_device_tree();</span><br><span class="line">    <span class="comment">//单核不需要执行</span></span><br><span class="line">	arm_dt_init_cpu_maps();</span><br><span class="line">   <span class="comment">/*  PSCI（Power State Coordination Interface，电源状态协调接口）是由 ARM 定义的一种标准化接口，</span></span><br><span class="line"><span class="comment">   用于在 ARM 架构的多核处理器中管理电源状态。它为操作系统（OS）和固件之间提供了一种统一的通信机制，</span></span><br><span class="line"><span class="comment">   主要用于实现 CPU 的电源管理功能，例如 CPU 的开关、挂起、休眠和系统关机等操作。 */</span></span><br><span class="line">	psci_dt_init();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!is_smp())</span><br><span class="line">		hyp_mode_check();</span><br><span class="line"></span><br><span class="line">	reserve_crashkernel();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mdesc-&gt;init_early)</span><br><span class="line">		mdesc-&gt;init_early();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="customize-machine-执行特定于开发板的初始化回调"><a href="#customize-machine-执行特定于开发板的初始化回调" class="headerlink" title="customize_machine: 执行特定于开发板的初始化回调"></a>customize_machine: 执行特定于开发板的初始化回调</h2><p>此函数是Linux内核ARM架构移植层中的一个标准化初始化钩子（hook）。它的核心作用是在内核启动的早期阶段, 调用一个由特定开发板或平台提供的、名为<code>init_machine</code>的C语言回调函数。这个回调函数用于执行那些无法通过设备树（Device Tree）来描述的、非常特殊的板级硬件初始化操作, 例如以编程方式注册平台设备。</p>
<h3 id="在单核无MMU的STM32H750平台上的原理与作用-1"><a href="#在单核无MMU的STM32H750平台上的原理与作用-1" class="headerlink" title="在单核无MMU的STM32H750平台上的原理与作用"></a>在单核无MMU的STM32H750平台上的原理与作用</h3><p>在像STM32H750这样的现代嵌入式系统上, 硬件的描述和初始化几乎完全由设备树（Device Tree）来驱动。内核会解析设备树, 并自动创建和注册其中描述的所有设备。因此, <code>init_machine</code>这种传统的、基于C代码的板级初始化方法<strong>基本上已被弃用</strong>。</p>
<p>对于一个标准的、基于设备树的STM32H750内核配置, <code>machine_desc-&gt;init_machine</code>这个函数指针<strong>几乎总是<code>NULL</code></strong>。<code>machine_desc</code>结构体本身是ARM架构的遗留产物。</p>
<p>因此, 在STM32H750的启动过程中, <code>customize_machine</code>这个函数虽然会因为<code>arch_initcall</code>的注册而被调用, 但其内部的<code>if</code>条件判断将为假, 函数会直接返回0, <strong>不执行任何实际操作</strong>。真正的平台设备初始化将由内核后续的设备树解析代码来完成。</p>
<p>这段代码的存在主要是为了保持对那些非常古老的、没有使用设备树的ARM开发板的向后兼容性。</p>
<hr>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这是一个静态的初始化函数.</span></span><br><span class="line"><span class="comment"> * __init 宏表示此函数仅在内核启动期间执行, 其占用的内存之后可以被回收.</span></span><br><span class="line"><span class="comment"> * @return: 总是返回0, 表示成功.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">customize_machine</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 原始注释翻译:</span></span><br><span class="line"><span class="comment">	 * 自定义平台设备, 或者添加新的设备.</span></span><br><span class="line"><span class="comment">	 * 在基于设备树(DT)的机器上, 如果没有提供回调函数, 我们会退回到从设备树填充机器信息,</span></span><br><span class="line"><span class="comment">	 * 否则我们将总是需要一个 init_machine 回调.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * machine_desc 是一个指向 struct machine_desc 的全局指针, 这个结构体描述了当前运行的机器(开发板)的特性.</span></span><br><span class="line"><span class="comment">	 * 它是ARM架构的一个历史悠久的组成部分.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 检查 machine_desc-&gt;init_machine 这个函数指针是否不为NULL.</span></span><br><span class="line"><span class="comment">	 * init_machine 是一个 void (*)(void) 类型的函数指针, 用于指向一个特定于板级的C代码初始化函数.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 在一个完全依赖设备树的现代STM32H750系统上, 不会有代码去设置这个指针, 因此它将保持为NULL.</span></span><br><span class="line"><span class="comment">	 * 这个 if 条件将不成立.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (machine_desc-&gt;init_machine)</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 如果 init_machine 指针有效(仅在非设备树的旧式开发板上),</span></span><br><span class="line"><span class="comment">		 * 则调用它所指向的函数, 以执行硬编码的板级初始化.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		machine_desc-&gt;init_machine();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 对于 initcall, 返回0表示初始化成功.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用 arch_initcall() 宏将 customize_machine 函数注册为一个初始化调用.</span></span><br><span class="line"><span class="comment"> * arch_initcall 是级别为 &quot;3&quot; 的 initcall.</span></span><br><span class="line"><span class="comment"> * 这意味着 customize_machine 函数将在内核启动过程中一个相对较早的、用于体系结构相关设置的阶段被调用.</span></span><br><span class="line"><span class="comment"> * 这确保了这个板级定制化的钩子能在任何依赖它的驱动程序被初始化之前执行.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">arch_initcall(customize_machine);</span><br></pre></td></tr></table></figure>

<h1 id="arch-arm-include-asm-switch-to-h"><a href="#arch-arm-include-asm-switch-to-h" class="headerlink" title="arch&#x2F;arm&#x2F;include&#x2F;asm&#x2F;switch_to.h"></a>arch&#x2F;arm&#x2F;include&#x2F;asm&#x2F;switch_to.h</h1><h2 id="switch-to-切换任务"><a href="#switch-to-切换任务" class="headerlink" title="switch_to 切换任务"></a>switch_to 切换任务</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __complete_pending_tlbi()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * switch_to（prev， next） 应从任务 &#x27;prev&#x27; 切换到 &#x27;next&#x27;</span></span><br><span class="line"><span class="comment"> * &#x27;prev&#x27; 永远不会与 &#x27;next&#x27; 相同。 schedule（） 本身</span></span><br><span class="line"><span class="comment"> * 包含内存屏障，告诉 GCC 不要缓存 &#x27;current&#x27;。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//根据不同架构执行不同的切换任务函数</span></span><br><span class="line"><span class="comment">//arch/arm/kernel/entry-v7m.S</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *__<span class="title">switch_to</span>(<span class="keyword">struct</span> <span class="title">task_struct</span> *, <span class="keyword">struct</span> <span class="title">thread_info</span> *, <span class="keyword">struct</span> <span class="title">thread_info</span> *);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> switch_to(prev,next,last)					\</span></span><br><span class="line"><span class="meta">do &#123;									\</span></span><br><span class="line"><span class="meta">	__complete_pending_tlbi();					\</span></span><br><span class="line"><span class="meta">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_CURRENT_POINTER_IN_TPIDRURO) || is_smp())	\</span></span><br><span class="line"><span class="meta">		__this_cpu_write(__entry_task, next);			\</span></span><br><span class="line"><span class="meta">	last = __switch_to(prev,task_thread_info(prev), task_thread_info(next));	\</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/wdfk-prog">Liya Huang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://wdfk-prog.space/posts/5dd29aab/">https://wdfk-prog.space/posts/5dd29aab/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://wdfk-prog.space" target="_blank">wdfk-prog的个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/linux/">linux</a><a class="post-meta__tags" href="/tags/arch/">arch</a><a class="post-meta__tags" href="/tags/arm/">arm</a></div><div class="post-share"><div class="social-share" data-image="/images/covers/03.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/images/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/images/alipay.png" target="_blank"><img class="post-qr-code-img" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/alipay.png" alt="支付寶"/></a><div class="post-qr-code-desc">支付寶</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/a2891af0/" title="mm"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/06.jpg" onerror="onerror=null;src='/images/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">mm</div></div><div class="info-2"><div class="info-item-1">[TOC] arch&#x2F;arm&#x2F;mm: 解剖Linux的NOMMU内存模型arch/arm/mm 目录包含了 ARM 架构的内存管理代码。在典型的带 MMU 的系统中，它的主要职责是处理虚拟内存、页表、TLB 管理等。但是，当内核被配置为在没有 MMU 的处理器（如 ARM Cortex-M 系列）上运行时，这个目录的功能会发生根本性的变化。 在 NOMMU 模式下，arch/arm/mm 的核心任务不再是管理复杂的虚拟地址空间，而是直接管理一个扁平的、统一的物理地址空间。  一、 NOMMU 的核心概念在深入代码之前，必须理解 NOMMU 环境下的几个基本事实：  单一扁平地址空间: 内核、所有用户进程、I&#x2F;O 内存都共享同一个物理地址空间。不存在虚拟地址到物理地址的转换。一个指针的值就是它在物理内存中的真实地址。 无内存保护: 由于没有 MMU，处理器无法在硬件层面阻止一个进程访问另一个进程或内核的内存。任何一个有缺陷的应用程序都可以直接读写内核内存，导致整个系统崩溃。 受限的进程模型: 传统的 fork() 系统调用（它依赖于写时复制技术，而这又...</div></div></div></a><a class="pagination-related" href="/posts/fc0f43c4/" title="clk-bulk"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/08.jpg" onerror="onerror=null;src='/images/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">clk-bulk</div></div><div class="info-2"><div class="info-item-1">[toc] drivers&#x2F;clk&#x2F;clk-bulk.c 批量时钟控制(Bulk Clock Control) 简化多路时钟管理历史与背景这项技术是为了解决什么特定问题而诞生的？drivers/clk/clk-bulk.c 文件实现了一套批量时钟控制的辅助API。这项技术并非一个独立的框架，而是对通用时钟框架（Common Clock Framework, CCF）的一个重要补充和优化。它的诞生是为了解决设备驱动程序中管理多个时钟资源时的代码冗余、逻辑复杂和易于出错的问题。 许多现代SoC中的复杂外设（如显示控制器、GPU、视频处理器）往往不只依赖一个时钟，而是需要一组时钟（例如，一个像素时钟、一个总线接口时钟、一个寄存器访问时钟）同时被使能才能正常工作。在没有clk-bulk API之前，驱动程序必须：  逐个调用devm_clk_get()来获取每一个时钟的句柄。 编写一个循环来逐个调用clk_prepare_enable()来使能这些时钟。 最关键也是最麻烦的是，必须编写复杂的错误处理代码。如果在使能第五个时钟时失败了，驱动程序必须手动地、按相反的顺序去...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/1a09ef0b/" title="assembly"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/08.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-03</div><div class="info-item-2">assembly</div></div><div class="info-2"><div class="info-item-1">[TOC] THUMB2指令集THUMB2 指令集深度解析：从入门到精通THUMB2 指令集是在嵌入式系统领域广受欢迎的 ARM 架构的一项关键技术。它巧妙地结合了 16 位指令的紧凑代码密度和 32 位指令的强大性能，为资源受限的设备提供了高效的解决方案。本文将从历史背景、核心原理、应用场景、入门实践、安全考量、生态系统、性能监控和未来趋势等多个维度，为您全面解析 THUMB2 指令集。 一、 历史与背景为了解决什么特定问题而诞生？ THUMB2 技术的诞生主要是为了解决早期 ARM 架构在嵌入式应用中的一个核心矛盾：性能与代码密度之间的权衡。  ARM 指令集：提供强大的 32 位指令，性能出色，但指令均为 32 位定长，导致代码体积较大，对于内存（尤其是昂贵的片上闪存和 RAM）有限的嵌入式系统而言，成本较高。 Thumb 指令集（第一代）：作为对策，ARM 推出了 16 位的 Thumb 指令集，它是 ARM 指令集的一个子集。 这显著减小了代码体积（约 30%-40%），降低了功耗和内存需求。 然而，Thumb 指令集功能有限，性能相比 32 位 ARM 指令集有所下降...</div></div></div></a><a class="pagination-related" href="/posts/6ca547a7/" title="debug"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/03.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-03</div><div class="info-item-2">debug</div></div><div class="info-2"><div class="info-item-1">[TOC] arch&#x2F;arm&#x2F;include&#x2F;debug&#x2F;stm32.Saddruart 添加debug串口地址1234.macro	addruart, rp, rv, tmp	ldr	\rp, =CONFIG_DEBUG_UART_PHYS @ physical base	ldr	\rv, =CONFIG_DEBUG_UART_VIRT @ virt base.endm  CONFIG_DEBUG_UART_PHYS 和 CONFIG_DEBUG_UART_VIRT1234567891011121314151617//arch/arm/Kconfig.debugconfig DEBUG_UART_VIRT	default DEBUG_UART_PHYS if !MMUconfig DEBUG_UART_PHYS	default 0x40011000 if STM32F4_DEBUG_UART || STM32F7_DEBUG_UART || \			STM32H7_DEBUG_UARTconfig STM32H7_DEBUG_UART	b...</div></div></div></a><a class="pagination-related" href="/posts/76116573/" title="lds"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/10.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-03</div><div class="info-item-2">lds</div></div><div class="info-2"><div class="info-item-1">[TOC] arch&#x2F;arm&#x2F;Makefile: 32位ARM架构的构建总指挥arch/arm/Makefile 是 Linux 内核 Kbuild 系统中专门为 32 位 ARM 架构服务的顶级 Makefile。它不是一个独立的可执行脚本，而是被主 Makefile 包含（include）进去的。它的核心职责是定义 ARM 架构独有的构建规则、配置编译选项，并将 Kconfig 中选择的平台配置转化为实际的构建命令。 可以将其视为一个“总指挥官”，它接收来自 .config 文件的战略指令，然后向编译器、链接器等“部队”下达精确的战术命令，以确保最终能为特定的 ARM 平台构建出正确、高效的内核。  一、 核心角色与职责 定制化主构建流程: 内核的主 Makefile 定义了通用的构建目标（如 vmlinux, modules）。arch/arm/Makefile 则对这些目标进行“重载”或“定制”，添加 ARM 架构特有的依赖和命令。  配置翻译官: 将 .config 文件中由 Kconfig 系统生成的高层配置选项（例如 CONFIG_ARCH_BC...</div></div></div></a><a class="pagination-related" href="/posts/46edaec4/" title="boot"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/01.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-03</div><div class="info-item-2">boot</div></div><div class="info-2"><div class="info-item-1">[TOC] arch&#x2F;arm&#x2F;boot: Linux 32位ARM架构的启动基石arch/arm/boot 目录是 Linux 内核源码中专门为 32 位 ARM 架构（AArch32）设计的启动代码所在地。它的核心使命是充当引导加载程序（Bootloader，如 U-Boot）与体系结构无关的通用内核代码之间的桥梁。这个目录下的代码负责处理内核启动最初始、最底层的阶段，为 C 语言环境的建立和主内核的执行做好万全准备。  一、 核心职责arch/arm/boot 目录下的代码和构建脚本共同完成了以下几项至关重要的任务：  生成可启动的内核镜像: 该目录下的 Makefile 是构建过程的核心，它负责将编译好的内核 vmlinux（一个 ELF 格式的文件）进行处理，最终生成 Bootloader 可以直接加载和执行的镜像格式，最常见的有 zImage 和 uImage。  内核解压缩: 为了减小存储体积和加快加载速度，内核镜像通常是经过压缩的。arch/arm/boot 包含了一个微型的、自解压的前端程序（Decompressor）。当 Bootloader...</div></div></div></a><a class="pagination-related" href="/posts/a90f3bcc/" title="lib"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/07.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-03</div><div class="info-item-2">lib</div></div><div class="info-2"><div class="info-item-1">[TOC] arch&#x2F;arm&#x2F;include&#x2F;asm&#x2F;delay.h该文件的核心原理是提供一个可插拔的、分层的延迟实现机制。它设计了一个抽象的arm_delay_ops操作函数集, 允许在系统启动时根据可用的硬件资源来选择并注册最优的延迟方法。  对于没有精确硬件定时器的旧系统: 它会回退到一种基于”每秒循环数”(loops_per_jiffy)的校准循环方法。内核在启动时会测量在一个系统时钟节拍(jiffy)内, CPU能执行多少次空循环, 从而计算出一个近似值。udelay的实现会根据这个校准值来计算需要执行多少次循环才能达到指定的微秒延迟。 对于拥有高精度硬件定时器的新系统(如STM32H750): 系统启动代码(通常是特定于板卡的平台代码)可以使用register_current_timer_delay函数来注册一个高精度的定时器(例如ARM Cortex-M内核自带的DWT周期计数器CYCCNT)。一旦注册成功, arm_delay_ops中的函数指针就会被更新为指向基于这个硬件定时器的延迟实现。这种实现方式会读取当前定时器计数值...</div></div></div></a><a class="pagination-related" href="/posts/70ad6c8b/" title="include"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/06.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-03</div><div class="info-item-2">include</div></div><div class="info-2"><div class="info-item-1">[TOC] arch&#x2F;arm&#x2F;include&#x2F;asm&#x2F;cache.h__read_mostly 大多数读取 __read_mostly用于标记大多数读取的变量,在编译时会将该变量放到.data..read_mostly段中  1#define __read_mostly __section(&quot;.data..read_mostly&quot;)  __read_mostly的作用是将变量放到.data..read_mostly段中,该段在内核启动时会被清零,所以该变量在内核启动时会被清零  arch&#x2F;arm&#x2F;include&#x2F;asm&#x2F;cmpxchg.harch_xchg_relaxed __arch_xchg 交换数据的逻辑都一样 使用ldrexb加载数据,它还会设置一个标志，表示该地址被标记为“独占访问”，以便后续的存储操作可以检查是否有其他处理器访问了该地址。 使用strexb存储数据,如果成功，返回0；如果失败，返回1，并且会清除“独占访问”标志。 如果strexb失败，循环会重新尝试加载...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/avatar.png" onerror="this.onerror=null;this.src='/images/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Liya Huang</div><div class="author-info-description">WORK-LIFE BALANCE</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">414</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">49</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">53</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/wdfk-prog"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/wdfk-prog" rel="external nofollow noreferrer" target="_blank" title="GitHub"><i class="fab fa-github" style="color: #181717;"></i></a><a class="social-icon" href="https://wdfk-prog.blog.csdn.net/" rel="external nofollow noreferrer" target="_blank" title="CSDN"><i class="fas fa-blog" style="color: #FC5531;"></i></a><a class="social-icon" href="mailto:1425075683@qq.com" rel="external nofollow noreferrer" target="_blank" title="E-mail"><i class="fas fa-envelope" style="color: #4A4A4A;"></i></a><a class="social-icon" href="/images/wechat-qrcode.jpg" target="_blank" title="微信公众号"><i class="fab fa-weixin" style="color: #07C160;"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss" style="color: #EE802F;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎光临！有任何问题或想法，欢迎在文章下留言交流，或者通过 <a href='/about/'>关于页面</a> 联系我。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#arch-arm-kernel-Linux-32%E4%BD%8DARM%E5%86%85%E6%A0%B8%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%89%B9%E5%AE%9A%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.</span> <span class="toc-text">arch&#x2F;arm&#x2F;kernel&#x2F;: Linux 32位ARM内核的体系结构特定实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81-%E6%A0%B8%E5%BF%83%E8%81%8C%E8%B4%A3"><span class="toc-number">1.0.1.</span> <span class="toc-text">一、 核心职责</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81-%E8%A7%A3%E5%86%B3%E7%9A%84%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98"><span class="toc-number">1.0.2.</span> <span class="toc-text">二、 解决的技术问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81-%E5%85%B3%E9%94%AE%E6%96%87%E4%BB%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90"><span class="toc-number">1.0.3.</span> <span class="toc-text">三、 关键文件深度解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-head-S"><span class="toc-number">1.0.3.1.</span> <span class="toc-text">1. head.S</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-entry-armv-S"><span class="toc-number">1.0.3.2.</span> <span class="toc-text">2. entry-armv.S</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-traps-c"><span class="toc-number">1.0.3.3.</span> <span class="toc-text">3. traps.c</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-irq-c"><span class="toc-number">1.0.3.4.</span> <span class="toc-text">4. irq.c</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-smp-c"><span class="toc-number">1.0.3.5.</span> <span class="toc-text">5. smp.c</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81-%E6%80%BB%E7%BB%93"><span class="toc-number">1.0.4.</span> <span class="toc-text">四、 总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E6%B5%81%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">进入内核流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#arch-arm-kernel-vmlinux-lds"><span class="toc-number">3.</span> <span class="toc-text">arch&#x2F;arm&#x2F;kernel&#x2F;vmlinux.lds</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#asm-offsets-c-%E4%B8%BA%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90C%E7%BB%93%E6%9E%84%E4%BD%93%E5%81%8F%E7%A7%BB%E9%87%8F"><span class="toc-number">4.</span> <span class="toc-text">asm-offsets.c: 为汇编代码生成C结构体偏移量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%8D%95%E6%A0%B8%E6%97%A0MMU%E7%9A%84STM32H750%E5%B9%B3%E5%8F%B0%E4%B8%8A%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BD%9C%E7%94%A8"><span class="toc-number">4.0.1.</span> <span class="toc-text">在单核无MMU的STM32H750平台上的原理与作用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#arch-arm-include-asm-glue-proc-h"><span class="toc-number">5.</span> <span class="toc-text">arch&#x2F;arm&#x2F;include&#x2F;asm&#x2F;glue-proc.h</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PROC-INFO-%E6%9E%B6%E6%9E%84%E4%BF%A1%E6%81%AF"><span class="toc-number">6.</span> <span class="toc-text">PROC_INFO 架构信息</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#arch-arm-include-asm-vmlinux-lds-h"><span class="toc-number">6.1.</span> <span class="toc-text">arch&#x2F;arm&#x2F;include&#x2F;asm&#x2F;vmlinux.lds.h</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#arch-arm-include-uapi-asm-hwcap-h-%E2%80%9Chardware-capabilities%E2%80%9D%EF%BC%88%E7%A1%AC%E4%BB%B6%E8%83%BD%E5%8A%9B%EF%BC%89"><span class="toc-number">6.2.</span> <span class="toc-text">arch&#x2F;arm&#x2F;include&#x2F;uapi&#x2F;asm&#x2F;hwcap.h  “hardware capabilities”（硬件能力）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HWCAP-flags-%E2%80%9Chardware-capabilities%E2%80%9D%EF%BC%88%E7%A1%AC%E4%BB%B6%E8%83%BD%E5%8A%9B%EF%BC%89"><span class="toc-number">6.2.1.</span> <span class="toc-text">HWCAP flags  “hardware capabilities”（硬件能力）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#arch-arm-include-asm-procinfo-h"><span class="toc-number">6.3.</span> <span class="toc-text">arch&#x2F;arm&#x2F;include&#x2F;asm&#x2F;procinfo.h</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#arch-arm-mm-proc-macros-S"><span class="toc-number">6.4.</span> <span class="toc-text">arch&#x2F;arm&#x2F;mm&#x2F;proc-macros.S</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#initfn"><span class="toc-number">6.4.1.</span> <span class="toc-text">initfn</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#arch-arm-mm-proc-v7m-S"><span class="toc-number">6.5.</span> <span class="toc-text">arch&#x2F;arm&#x2F;mm&#x2F;proc-v7m.S</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ARMv7-M-%E5%A4%84%E7%90%86%E5%99%A8%E5%AE%9A%E4%B9%89%E5%9D%97"><span class="toc-number">6.5.1.</span> <span class="toc-text">ARMv7-M 处理器定义块</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#THREAD-SIZE-%E5%88%86%E9%85%8D%E6%A0%88%E5%A4%A7%E5%B0%8F"><span class="toc-number">7.</span> <span class="toc-text">THREAD_SIZE 分配栈大小</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#arch-arm-include-asm-assembler-h"><span class="toc-number">8.</span> <span class="toc-text">arch&#x2F;arm&#x2F;include&#x2F;asm&#x2F;assembler.h</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#setmode-%E7%94%A8%E4%BA%8E%E5%9C%A8%E5%BC%95%E5%AF%BC%E6%9C%9F%E9%97%B4%E6%96%AD%E8%A8%80%E5%A4%84%E4%BA%8E-SVC-%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.1.</span> <span class="toc-text">setmode 用于在引导期间断言处于 SVC 模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#safe-svcmode-maskall-%E5%B9%B2%E5%87%80%E5%9C%B0%E8%BF%9B%E5%85%A5-SVC-%E6%A8%A1%E5%BC%8F%E5%B9%B6%E5%B1%8F%E8%94%BD%E4%B8%AD%E6%96%AD"><span class="toc-number">8.2.</span> <span class="toc-text">safe_svcmode_maskall 干净地进入 SVC 模式并屏蔽中断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#str-va-%E5%B0%86%E4%B8%80%E4%B8%AA-32-%E4%BD%8D%E5%AD%97%E5%AD%98%E5%82%A8%E5%88%B0-sym-%E7%9A%84%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80"><span class="toc-number">8.3.</span> <span class="toc-text">str_va 将一个 32 位字存储到 \sym 的虚拟地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#set-current-%E5%AD%98%E5%82%A8%E6%AD%A4-CPU-%E5%BD%93%E5%89%8D%E4%BB%BB%E5%8A%A1%E7%9A%84%E4%BB%BB%E5%8A%A1%E6%8C%87%E9%92%88"><span class="toc-number">8.4.</span> <span class="toc-text">set_current 存储此 CPU 当前任务的任务指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#disable-irq-notrace-enable-irq-notrace"><span class="toc-number">8.5.</span> <span class="toc-text">disable_irq_notrace enable_irq_notrace</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ldr-va-%E4%BB%8E%E7%AC%A6%E5%8F%B7-sym%E7%9A%84%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%8A%A0%E8%BD%BD%E4%B8%80%E4%B8%AA32%E4%BD%8D%E7%9A%84%E5%AD%97"><span class="toc-number">8.6.</span> <span class="toc-text">ldr_va 从符号\sym的虚拟地址加载一个32位的字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ldr-this-cpu-%E4%BB%8E%E6%AF%8F%E4%B8%AA-CPU-%E7%9A%84%E5%8F%98%E9%87%8F-%E2%80%98sym%E2%80%99-%E5%8A%A0%E8%BD%BD%E4%B8%80%E4%B8%AA-32-%E4%BD%8D%E5%AD%97-%E6%8F%92%E5%85%A5%E5%AF%84%E5%AD%98%E5%99%A8-%E2%80%98rd%E2%80%99"><span class="toc-number">8.7.</span> <span class="toc-text">ldr_this_cpu 从每个 CPU 的变量 ‘sym’ 加载一个 32 位字 插入寄存器 ‘rd’</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#get-thread-info-%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E4%BF%A1%E6%81%AF"><span class="toc-number">8.8.</span> <span class="toc-text">get_thread_info 获取当前线程信息</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#arch-arm-include-asm-v7m-h"><span class="toc-number">9.</span> <span class="toc-text">arch&#x2F;arm&#x2F;include&#x2F;asm&#x2F;v7m.h</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#arch-arm-kernel-entry-header-S"><span class="toc-number">10.</span> <span class="toc-text">arch&#x2F;arm&#x2F;kernel&#x2F;entry-header.S</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#v7m-exception-entry-%E8%BF%9B%E5%85%A5%E4%B8%AD%E6%96%AD"><span class="toc-number">10.1.</span> <span class="toc-text">v7m_exception_entry 进入中断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v7m-exception-slow-exit-%E9%80%80%E5%87%BA%E4%B8%AD%E6%96%AD"><span class="toc-number">10.2.</span> <span class="toc-text">v7m_exception_slow_exit 退出中断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#restore-user-regs-%E6%81%A2%E5%A4%8D%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">10.3.</span> <span class="toc-text">restore_user_regs 恢复寄存器.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#scno-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%B7-tbl-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%A1%A8%E6%8C%87%E9%92%88-why-Linux-syscall-tsk-%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E4%BF%A1%E6%81%AF"><span class="toc-number">10.4.</span> <span class="toc-text">scno (系统调用号) tbl (系统调用表指针) why (Linux syscall) tsk (当前线程信息)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#invoke-syscall-%E8%B0%83%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">10.5.</span> <span class="toc-text">invoke_syscall (调用系统调用)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Spectre%E6%BC%8F%E6%B4%9E%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%80%E4%B8%AA%E7%94%9F%E5%8A%A8%E7%9A%84%E6%AF%94%E5%96%BB"><span class="toc-number">10.5.1.</span> <span class="toc-text">Spectre漏洞是什么？一个生动的比喻</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spectre%E6%BC%8F%E6%B4%9E%E7%9A%84%E4%B8%A4%E4%B8%AA%E4%B8%BB%E8%A6%81%E5%8F%98%E7%A7%8D"><span class="toc-number">10.5.2.</span> <span class="toc-text">Spectre漏洞的两个主要变种</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%AE%E5%A4%8D%EF%BC%88%E6%88%96%E6%9B%B4%E5%87%86%E7%A1%AE%E5%9C%B0%E8%AF%B4%EF%BC%8C%E7%BC%93%E8%A7%A3%EF%BC%89%EF%BC%9F"><span class="toc-number">10.5.3.</span> <span class="toc-text">如何修复（或更准确地说，缓解）？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#arch-arm-kernel-entry-common-S"><span class="toc-number">11.</span> <span class="toc-text">arch&#x2F;arm&#x2F;kernel&#x2F;entry-common.S</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ret-to-user-ret-to-user-from-irq-ret-slow-syscall"><span class="toc-number">11.1.</span> <span class="toc-text">ret_to_user ret_to_user_from_irq ret_slow_syscall</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vector-swi-%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%B0%83%E7%94%A8%E5%86%85%E6%A0%B8%E6%97%B6"><span class="toc-number">11.2.</span> <span class="toc-text">vector_swi 用户空间的程序调用内核时</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#slow-work-pending-%E5%BC%82%E5%B8%B8%E5%92%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%BB%9F%E4%B8%80%E8%BF%94%E5%9B%9E%E8%B7%AF%E5%BE%84%E4%B8%8A%E7%9A%84%E6%85%A2%E9%80%9F%E5%B7%A5%E4%BD%9C%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-number">11.3.</span> <span class="toc-text">slow_work_pending 异常和系统调用统一返回路径上的慢速工作处理程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ret-fast-syscall-ret-fast-syscall"><span class="toc-number">11.4.</span> <span class="toc-text">ret_fast_syscall __ret_fast_syscall</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ret-from-fork-%E6%96%B0%E5%88%9B%E5%BB%BA%E7%9A%84%E4%BB%BB%E5%8A%A1%EF%BC%8C%E5%9C%A8%E9%A6%96%E6%AC%A1%E8%A2%AB%E8%B0%83%E5%BA%A6%E5%99%A8%E8%B0%83%E5%BA%A6%E5%90%8E%EF%BC%8C%E6%89%80%E6%89%A7%E8%A1%8C%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0"><span class="toc-number">11.5.</span> <span class="toc-text">ret_from_fork 新创建的任务，在首次被调度器调度后，所执行的第一个函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#arch-arm-kernel-entry-v7m-S"><span class="toc-number">12.</span> <span class="toc-text">arch&#x2F;arm&#x2F;kernel&#x2F;entry-v7m.S</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Vector-table"><span class="toc-number">12.1.</span> <span class="toc-text">Vector table</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#invalid-entry-%E6%89%93%E5%8D%B0%E5%BC%82%E5%B8%B8%E4%BF%A1%E6%81%AF%E8%BF%9B%E5%85%A5%E6%AD%BB%E5%BE%AA%E7%8E%AF"><span class="toc-number">12.2.</span> <span class="toc-text">__invalid_entry 打印异常信息进入死循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#irq-entry"><span class="toc-number">12.3.</span> <span class="toc-text">__irq_entry</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pendsv-entry-pensv%E4%B8%AD%E6%96%AD%E8%BF%9B%E5%85%A5"><span class="toc-number">12.4.</span> <span class="toc-text">__pendsv_entry pensv中断进入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#switch-to"><span class="toc-number">12.5.</span> <span class="toc-text">__switch_to</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#arch-arm-mm-proc-v7m-S-1"><span class="toc-number">13.</span> <span class="toc-text">arch&#x2F;arm&#x2F;mm&#x2F;proc-v7m.S</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#v7m-cm7-setup-V7M%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0"><span class="toc-number">13.1.</span> <span class="toc-text">__v7m_cm7_setup V7M处理器的初始化函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cpu-v7m-do-idle-%E8%BF%9B%E5%85%A5%E7%A9%BA%E9%97%B2%E7%8A%B6%E6%80%81"><span class="toc-number">13.2.</span> <span class="toc-text">cpu_v7m_do_idle 进入空闲状态</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#arch-arm-kernel-head-nommu-S"><span class="toc-number">14.</span> <span class="toc-text">arch&#x2F;arm&#x2F;kernel&#x2F;head-nommu.S</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#stext-%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E5%85%A5%E5%8F%A3%E7%82%B9"><span class="toc-number">14.1.</span> <span class="toc-text">stext 内核启动入口点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#after-proc-init-%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E5%90%8E%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-number">14.2.</span> <span class="toc-text">__after_proc_init 内核启动后处理函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#arch-arm-kernel-head-common-S"><span class="toc-number">15.</span> <span class="toc-text">arch&#x2F;arm&#x2F;kernel&#x2F;head-common.S</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#error-%E6%AD%BB%E5%BE%AA%E7%8E%AF"><span class="toc-number">15.1.</span> <span class="toc-text">__error 死循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#error-p"><span class="toc-number">15.2.</span> <span class="toc-text">__error_p</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lookup-processor-type-%E5%BE%AA%E7%8E%AF%E6%9F%A5%E6%89%BEprocessor-type%E4%B8%AD%E5%8C%B9%E9%85%8D%E7%9A%84cpu%E4%BF%A1%E6%81%AF"><span class="toc-number">15.3.</span> <span class="toc-text">__lookup_processor_type 循环查找processor_type中匹配的cpu信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lookup-processor-type-%E6%9F%A5%E6%89%BE%E5%A4%84%E7%90%86%E5%99%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">15.4.</span> <span class="toc-text">lookup_processor_type 查找处理器类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mmap-switched-data-%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E5%90%8E%E6%95%B0%E6%8D%AE%E6%AE%B5"><span class="toc-number">15.5.</span> <span class="toc-text">__mmap_switched_data 内核启动后数据段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mmap-switched-%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E5%90%8E%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-number">15.6.</span> <span class="toc-text">__mmap_switched 内核启动后处理函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%93"><span class="toc-number">16.</span> <span class="toc-text">——————————————–</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#arch-arm-include-asm-cputype-h"><span class="toc-number">17.</span> <span class="toc-text">arch&#x2F;arm&#x2F;include&#x2F;asm&#x2F;cputype.h</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#read-cpuid-id-%E8%AF%BB%E5%8F%96%E5%A4%84%E7%90%86%E5%99%A8ID"><span class="toc-number">17.1.</span> <span class="toc-text">read_cpuid_id 读取处理器ID</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cpuid-feature-extract-%E5%A4%84%E7%90%86%E5%99%A8%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96"><span class="toc-number">17.2.</span> <span class="toc-text">cpuid_feature_extract 处理器特征提取</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#arch-arm-kernel-devtree-c"><span class="toc-number">18.</span> <span class="toc-text">arch&#x2F;arm&#x2F;kernel&#x2F;devtree.c</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#arch-info-%E6%9E%B6%E6%9E%84%E4%BF%A1%E6%81%AF"><span class="toc-number">18.1.</span> <span class="toc-text">__arch_info 架构信息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#arch-arm-include-asm-mach-arch-h"><span class="toc-number">18.1.1.</span> <span class="toc-text">arch&#x2F;arm&#x2F;include&#x2F;asm&#x2F;mach&#x2F;arch.h</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#arch-get-next-mach-%E8%8E%B7%E5%8F%96%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9C%BA%E5%99%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">18.1.2.</span> <span class="toc-text">arch_get_next_mach 获取下一个机器描述符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#setup-machine-fdt-%E5%B0%86-dtb-%E4%BC%A0%E9%80%92%E5%88%B0%E5%86%85%E6%A0%B8%E6%97%B6%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AE%BE%E7%BD%AE-%E8%BF%94%E5%9B%9Estruct-machine-desc%E4%BF%A1%E6%81%AF"><span class="toc-number">18.2.</span> <span class="toc-text">setup_machine_fdt 将 dtb 传递到内核时的计算机设置,返回struct machine_desc信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#arm-dt-init-cpu-maps-%E5%88%9D%E5%A7%8B%E5%8C%96CPU%E6%98%A0%E5%B0%84"><span class="toc-number">18.3.</span> <span class="toc-text">arm_dt_init_cpu_maps 初始化CPU映射</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#arch-arm-kernel-early-printk-c-%E6%97%A9%E6%9C%9Fprintk%E6%89%93%E5%8D%B0"><span class="toc-number">19.</span> <span class="toc-text">arch&#x2F;arm&#x2F;kernel&#x2F;early_printk.c 早期printk打印</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#arch-arm-kernel-setup-c"><span class="toc-number">20.</span> <span class="toc-text">arch&#x2F;arm&#x2F;kernel&#x2F;setup.c</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#smp-setup-processor-id-%E5%A4%84%E7%90%86%E5%99%A8ID%E8%AE%BE%E7%BD%AE%E5%87%BD%E6%95%B0"><span class="toc-number">20.1.</span> <span class="toc-text">smp_setup_processor_id 处理器ID设置函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lookup-processor-%E6%9F%A5%E6%89%BE%E5%A4%84%E7%90%86%E5%99%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">20.2.</span> <span class="toc-text">lookup_processor 查找处理器类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#get-cpu-architecture-%E8%8E%B7%E5%8F%96CPU%E6%9E%B6%E6%9E%84"><span class="toc-number">20.3.</span> <span class="toc-text">__get_cpu_architecture 获取CPU架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cpuid-init-hwcaps-%E8%AE%BE%E7%BD%AECPU%E7%A1%AC%E4%BB%B6%E8%83%BD%E5%8A%9B"><span class="toc-number">20.4.</span> <span class="toc-text">cpuid_init_hwcaps 设置CPU硬件能力</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cacheid-init-%E7%BC%93%E5%AD%98ID%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0"><span class="toc-number">20.5.</span> <span class="toc-text">cacheid_init 缓存ID初始化函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#setup-processor-%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E7%BD%AE%E5%87%BD%E6%95%B0"><span class="toc-number">20.6.</span> <span class="toc-text">setup_processor 处理器设置函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#request-standard-resources-%E8%AF%B7%E6%B1%82%E6%A0%87%E5%87%86%E8%B5%84%E6%BA%90"><span class="toc-number">20.7.</span> <span class="toc-text">request_standard_resources 请求标准资源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#setup-arch-%E8%AE%BE%E7%BD%AE%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">20.8.</span> <span class="toc-text">setup_arch 设置体系结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#customize-machine-%E6%89%A7%E8%A1%8C%E7%89%B9%E5%AE%9A%E4%BA%8E%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9B%9E%E8%B0%83"><span class="toc-number">20.9.</span> <span class="toc-text">customize_machine: 执行特定于开发板的初始化回调</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%8D%95%E6%A0%B8%E6%97%A0MMU%E7%9A%84STM32H750%E5%B9%B3%E5%8F%B0%E4%B8%8A%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BD%9C%E7%94%A8-1"><span class="toc-number">20.9.1.</span> <span class="toc-text">在单核无MMU的STM32H750平台上的原理与作用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#arch-arm-include-asm-switch-to-h"><span class="toc-number">21.</span> <span class="toc-text">arch&#x2F;arm&#x2F;include&#x2F;asm&#x2F;switch_to.h</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#switch-to-%E5%88%87%E6%8D%A2%E4%BB%BB%E5%8A%A1"><span class="toc-number">21.1.</span> <span class="toc-text">switch_to 切换任务</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/1db9a982/" title="ext4"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/04.jpg" onerror="this.onerror=null;this.src='/images/404.jpg'" alt="ext4"/></a><div class="content"><a class="title" href="/posts/1db9a982/" title="ext4">ext4</a><time datetime="2025-10-07T03:18:15.310Z" title="更新于 2025-10-07 11:18:15">2025-10-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/b554c0f0/" title="mbcache"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/03.jpg" onerror="this.onerror=null;this.src='/images/404.jpg'" alt="mbcache"/></a><div class="content"><a class="title" href="/posts/b554c0f0/" title="mbcache">mbcache</a><time datetime="2025-10-07T03:16:04.099Z" title="更新于 2025-10-07 11:16:04">2025-10-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/88ab2b13/" title="fs-writeback"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/08.jpg" onerror="this.onerror=null;this.src='/images/404.jpg'" alt="fs-writeback"/></a><div class="content"><a class="title" href="/posts/88ab2b13/" title="fs-writeback">fs-writeback</a><time datetime="2025-10-07T03:08:29.811Z" title="更新于 2025-10-07 11:08:29">2025-10-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2089198e/" title="filesystems"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/03.jpg" onerror="this.onerror=null;this.src='/images/404.jpg'" alt="filesystems"/></a><div class="content"><a class="title" href="/posts/2089198e/" title="filesystems">filesystems</a><time datetime="2025-10-07T02:52:10.933Z" title="更新于 2025-10-07 10:52:10">2025-10-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/933a291e/" title="hweight"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/10.jpg" onerror="this.onerror=null;this.src='/images/404.jpg'" alt="hweight"/></a><div class="content"><a class="title" href="/posts/933a291e/" title="hweight">hweight</a><time datetime="2025-10-07T02:49:48.378Z" title="更新于 2025-10-07 10:49:48">2025-10-07</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/images/covers/03.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">文档</div><div class="footer-flex-content"><a href="/categories/linux/" target="_blank" title="🚀 linux">🚀 linux</a><a href="/categories/rt-thread/" target="_blank" title="📑 rt-thread">📑 rt-thread</a><a href="/categories/uboot/" target="_blank" title="📌 uboot">📌 uboot</a><a href="/categories/LoraWan/" target="_blank" title="⚔️ LoraWan">⚔️ LoraWan</a><a href="/categories/hpatch/" target="_blank" title="❓ hpatch">❓ hpatch</a><a href="/categories/git/" target="_blank" title="⚡️ git">⚡️ git</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/gallery/" target="_blank" title="图库">图库</a><a href="/messageboard/" target="_blank" title="留言板">留言板</a><a href="/shuoshuo/" target="_blank" title="说说">说说</a><a href="/link/" target="_blank" title="示例">示例</a><a href="/link/" target="_blank" title="友链">友链</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">框架</div><div class="footer-flex-content"><a href="https://hexo.io/zh-cn/" rel="external nofollow noreferrer" target="_blank" title="Hexo">Hexo</a><a href="https://butterfly.js.org/" rel="external nofollow noreferrer" target="_blank" title="Butterfly">Butterfly</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">贊助</div><div class="footer-flex-content"><div><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/alipay.png" alt='wdfk_prog' width='100px' height='100px'></div></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Liya Huang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo 8.0.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.1</a></span></div><div class="footer_custom_text">你好，欢迎来到我的 <a href="/about/">数字花园</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天" style="display:none"><i class="fas fa-message"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script><script>(() => {
  const abcjsInit = () => {
    const abcjsFn = () => {
      setTimeout(() => {
        const sheets = document.querySelectorAll(".abc-music-sheet")
        for (let i = 0; i < sheets.length; i++) {
          const ele = sheets[i]
          if (ele.children.length > 0) continue

          // Parse parameters from data-params attribute
          let params = {}
          const dp = ele.getAttribute("data-params")
          if (dp) {
            try {
              params = JSON.parse(dp)
            } catch (e) {
              console.error("Failed to parse data-params:", e)
            }
          }

          // Merge parsed parameters with the responsive option
          // Ensures params content appears before responsive
          const options = { ...params, responsive: "resize" }

          // Render the music score using ABCJS.renderAbc
          ABCJS.renderAbc(ele, ele.innerHTML, options)
        }
      }, 100)
    }

    if (typeof ABCJS === "object") {
      abcjsFn()
    } else {
      btf.getScript("https://cdn.jsdelivr.net/npm/abcjs/dist/abcjs-basic-min.min.js").then(abcjsFn)
    }
  }

  if (window.pjax) {
    abcjsInit()
  } else {
    window.addEventListener("load", abcjsInit)
  }

  btf.addGlobalFn("encrypt", abcjsInit, "abcjs")
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: 'Ov23livBmwx65h3XIdfT',
      clientSecret: '9f23bdaa2ea11322f9f405d77bcdc27166077a7d',
      repo: 'wdfk-prog.github.io',
      owner: 'wdfk-prog',
      admin: ['wdfk-prog'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || 'af9ddf27eef82483f23539a9c5841f92'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script>window.newestComments = {
  changeContent: content => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<code>.*?<\/code>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g, "") // remove html tag

    if (content.length > 150) {
      content = content.substring(0, 150) + '...'
    }
    return content
  },

  generateHtml: (array, ele) => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class="aside-list-item">'

        if (true && array[i].avatar) {
          const imgAttr = 'data-lazy-src'
          const lazyloadNative = ''
          result += `<a href="${array[i].url}" class="thumbnail"><img ${imgAttr}="${array[i].avatar}" alt="${array[i].nick}" ${lazyloadNative}></a>`
        }

        result += `<div class="content">
        <a class="comment" href="${array[i].url}" title="${array[i].content}">${array[i].content}</a>
        <div class="name"><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '暂无评论'
    }

    ele.innerHTML = result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh(ele)
  },

  newestCommentInit: (name, getComment) => {
    const $dom = document.querySelector('#card-newest-comments .aside-list')
    if ($dom) {
      const data = btf.saveToLocal.get(name)
      if (data) {
        newestComments.generateHtml(JSON.parse(data), $dom)
      } else {
        getComment($dom)
      }
    }
  },

  run: (name, getComment) => {
    newestComments.newestCommentInit(name, getComment)
    btf.addGlobalFn('pjaxComplete', () => newestComments.newestCommentInit(name, getComment), name)
  }
}</script><script>window.addEventListener('load', () => {
  const keyName = 'github-newest-comments'
  const { changeContent, generateHtml, run } = window.newestComments

  const findTrueUrl = (array, ele) => {
    Promise.all(array.map(item =>
      fetch(item.url).then(resp => resp.json()).then(data => {
        let urlArray = data.body ? data.body.match(/(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?/ig) : []
        if (!Array.isArray(urlArray) || urlArray.length === 0) {
          urlArray = [`${data.html_url}`]
        }
        if (data.user.login === 'utterances-bot') {
          return urlArray.pop()
        } else {
          return urlArray.shift()
        }
      })
    )).then(res => {
        array = array.map((i,index)=> {
          return {
            ...i,
            url: res[index]
          }
        })

        btf.saveToLocal.set(keyName, JSON.stringify(array), 10/(60*24))
        generateHtml(array, ele)
    });
  }

  const getComment = ele => {
    fetch('https://api.github.com/repos/wdfk-prog/wdfk-prog.github.io/issues/comments?sort=updated&direction=desc&per_page=6&page=1',{
      "headers": {
        Accept: 'application/vnd.github.v3.html+json'
      }
    })
      .then(response => response.json())
      .then(data => {
        const githubArray = data.map(item => {
          return {
            'avatar': item.user.avatar_url,
            'content': changeContent(item.body_html || item.body),
            'nick': item.user.login,
            'url': item.issue_url,
            'date': item.updated_at
          }
        })
        findTrueUrl(githubArray, ele)
      }).catch(e => {
        console.error(e)
        ele.textContent= "无法获取评论，请确认相关配置是否正确"
      })
  }
  run(keyName, getComment)
})</script><div class="aplayer no-destroy" data-id="60198" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="false" data-volume="0.5"></div><script>
  var titleTime, OriginTitile = document.title;
  document.addEventListener("visibilitychange", function() {
    if (document.hidden) {
      titleTime = setTimeout(function() {
        document.title = "w(ﾟДﾟ)w 不要走！再看看嘛！";
      }, 300);
    } else {
      document.title = "♪(^∇^*)欢迎回来！" + OriginTitile;
      titleTime = setTimeout(function() {
        document.title = OriginTitile;
      }, 2000);
    }
  });
</script>
<script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script>(() => {
  window.ChatraID = '5cPWcnA8HKGzg5hoc'
  window.Chatra = window.Chatra || function() {
    (window.Chatra.q = window.Chatra.q || []).push(arguments)
  }

  btf.getScript('https://call.chatra.io/chatra.js').then(() => {
    const isChatBtn = true
    const isChatHideShow = true

    if (isChatBtn) {
      const close = () => {
        Chatra('minimizeWidget')
        Chatra('hide')
      }

      const open = () => {
        Chatra('openChat', true)
        Chatra('show')
      }

      window.ChatraSetup = { startHidden: true }
    
      window.chatBtnFn = () => document.getElementById('chatra').classList.contains('chatra--expanded') ? close() : open()

      document.getElementById('chat-btn').style.display = 'block'
    } else if (isChatHideShow) {
      window.chatBtn = {
        hide: () => Chatra('hide'),
        show: () => Chatra('show')
      }
    }
  })
})()</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: true,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      true
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-MF3J339H" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript></div><script src="https://cdn.jsdelivr.net/npm/echarts@5.5.1/dist/echarts.min.js"></script>
        
        <script>
            document.addEventListener("DOMContentLoaded", function() {
                const heatmapChartDom = document.getElementById('heatmapChart');
                if(heatmapChartDom){
                    const heatmapChart = echarts.init(heatmapChartDom, 'dark');
                    const cellSize = [18, 18];
                    
                    const groupByYear = (data) => {
                        const result = {};
                        data.forEach(([date, value]) => {
                            const [year] = date.split('-').map(Number);
                            if (!result[year]) {
                                result[year] = [];
                            }
                            result[year].push([date, value]);
                        });
                        return result;
                    };
                    
                    const groupedData = groupByYear([["2025-10-03",392],["2025-10-04",5],["2025-10-06",9],["2025-10-07",8]]);
                    const years = Object.keys(groupedData).reverse();
                    
                    var initYear = parseInt(heatmapChartDom.getAttribute('year')) || new Date().getFullYear();
                    const minYear = years[years.length - 1];
                    const maxYear = years[0];
                    if (initYear < minYear || initYear > maxYear) {
                        initYear = maxYear;
                    }
                    console.log('[hexo-graph]generateHeatmapChart|initYear:', initYear, 'minYear:', minYear, 'maxYear:', maxYear);
                    
                    heatmapChart.setOption({
                        grid: {},
                        tooltip: { 
                            position: 'top', 
                            formatter: params => `${params.value[0]}: ${params.value[1]} Articles` 
                        },
                        calendar: { 
                            top: '10%',
                            left: 'left', 
                            right: '8%',
                            range: initYear,
                            cellSize: cellSize, 
                            splitLine: { lineStyle: { color: '#E0E0E0', width: 1 } }, 
                            itemStyle: { borderWidth: 1, borderColor: '#E0E0E0' }, 
                            dayLabel: { show: false },
                            monthLabel: { show: true },
                            yearLabel: { show: false },
                        },
                        visualMap: { 
                            show: true,
                            right: '8%',
                            bottom: '5%',
                            type: 'piecewise',
                            orient: 'horizontal',
                            text: ['More', 'Less'],
                            min: 0,
                            max: Math.max(...groupedData[initYear].map(item => item[1])),
                            inRange: { color: ["#ACE7AE","#69C16D","#549F57"] }
                        },
                        legend: {
                            type: 'scroll',
                            icon: 'none',
                            data: years,
                            orient: 'vertical',
                            top: '5%',
                            right: 'right',
                            itemWidth: 20,
                            itemHeight: 20,
                            itemGap: 10,
                            pageIconSize: 10,
                            pageTextStyle: { fontSize: 14 },
                            selectedMode: 'single',
                        },
                        series: years.map(year => ({
                            type: 'heatmap',
                            coordinateSystem: 'calendar',
                            data: groupedData[year],
                            name: year,
                            emphasis: {
                                disabled: true,
                            },
                            silent: year !== initYear,
                        })),
                    });
                    
                    // init selected year
                    heatmapChart.dispatchAction({
                        type: 'legendSelect',
                        name: initYear,
                    });
                    
                    heatmapChart.on('legendselectchanged', function(params) {
                        console.log('[hexo-graph]generateHeatmapChart|legendselectchanged:', params);
                        const selectedYear = Object.keys(params.selected).find(key => params.selected[key]);
                        if (selectedYear && groupedData[selectedYear]) {
                            heatmapChart.setOption({
                                calendar: {
                                    range: selectedYear,
                                },
                                visualMap: {
                                    max: Math.max(...groupedData[selectedYear].map(item => item[1])),
                                },
                                series: years.map(year => ({
                                    type: 'heatmap',
                                    coordinateSystem: 'calendar',
                                    data: groupedData[year],
                                    name: year,
                                    emphasis: {
                                        disabled: true,
                                    },
                                    silent: year !== selectedYear,
                                })),
                            });
                        }
                    });
                    
                    heatmapChart.on('click', function (params) {
                        if (params.componentType === 'series') {
                            const [year, month] = params.value[0].split('-');
                            window.location.href = '/archives/' + year + '/' + month;
                        }
                    });
                }
            });
        </script>
    
        
        <script>
            document.addEventListener("DOMContentLoaded", function() {
                const monthlyChartDom = document.getElementById('monthlyChart');
                if(monthlyChartDom){
                    const monthlyChart = echarts.init(monthlyChartDom, 'dark');
                    monthlyChart.setOption({
                        xAxis: { 
                            type: 'category', 
                            data: ["2025-10"], 
                            axisLabel: { fontSize: 14, fontWeight: 'bold', fontFamily: 'Microsoft YaHei, SimSun, serif' }
                        },
                        yAxis: { type: 'value', splitLine: { lineStyle: { type: 'dashed', color: '#ccc' } } },
                        series: [{
                            name: 'Articles',
                            type: 'line',
                            data: [414],
                            smooth: true,
                            lineStyle: { color: '#5470C6', width: 2 },
                            itemStyle: { color: '#5470C6' },
                            areaStyle: { color: 'rgba(84, 112, 198, 0.4)' },
                            symbolSize: 10,
                            label: {
                                show: true,
                                position: 'top',
                                formatter: params => params.value,
                                fontSize: 14,
                                color: '#000',
                                fontWeight: 'bold',
                                fontFamily: 'Microsoft YaHei, SimSun, serif'
                            }
                        }]
                    });

                    monthlyChart.on('click', function (params) {
                        const [year, month] = params.name.split('-');
                        window.location.href = '/archives/' + year + '/' + month;
                    });
                }
            })
        </script>
    
        
        <script>
            document.addEventListener("DOMContentLoaded", function() {
                const tagsChartDom = document.getElementById('tagsChart');
                if(tagsChartDom){
                    const tagsChart = echarts.init(tagsChartDom, 'dark');
                    tagsChart.setOption({
                        tooltip: { trigger: 'item', formatter: '{b}: {c} ({d}%)' },
                        series: [{
                            type: 'pie',
                            radius: '60%',
                            data: [{"name":"linux","value":227},{"name":"uboot","value":68},{"name":"kernel","value":61},{"name":"rt-thread","value":44},{"name":"u-boot分类","value":44},{"name":"drivers","value":39},{"name":"fs","value":37},{"name":"other","value":28}],
                            label: {
                                position: 'outside',
                                formatter: '{b} {c} ({d}%)',
                                fontSize: 14,
                                fontWeight: 'bold',
                                fontFamily: 'Microsoft YaHei, SimSun, serif'
                            },
                            color: ["#5470C6","#91CC75","#FAC858","#EE6666","#73C0DE","#3BA272","#FC8452","#9A60B4"],
                            labelLine: { show: true }
                        }],
                        legend: {
                            bottom: '0',
                            left: 'center',
                            data: [{"name":"linux","value":227},{"name":"uboot","value":68},{"name":"kernel","value":61},{"name":"rt-thread","value":44},{"name":"u-boot分类","value":44},{"name":"drivers","value":39},{"name":"fs","value":37},{"name":"other","value":28}].map(tag => tag.name),
                            textStyle: { fontSize: 14, fontWeight: 'bold', fontFamily: 'Microsoft YaHei, SimSun, serif' }
                        }
                    });

                    tagsChart.on('click', function (params) {
                        window.location.href = '/tags/' + params.name;
                    });
                }
            })
        </script>
    
        
        <script>
            document.addEventListener("DOMContentLoaded", function() {
                const categoriesChartDom = document.getElementById('categoriesChart');
                if(categoriesChartDom){
                    const categoriesChart = echarts.init(categoriesChartDom, 'dark');
                    categoriesChart.setOption({
                        xAxis: { type: 'value', splitLine: { lineStyle: { type: 'dashed', color: '#ccc' } } },
                        yAxis: { 
                            type: 'category', 
                            data: [{"name":"linux","value":227},{"name":"uboot","value":68},{"name":"kernel","value":61},{"name":"rt-thread","value":44},{"name":"u-boot分类","value":44}].map(category => category.name).reverse(), 
                            axisLabel: { fontSize: 14, fontWeight: 'bold', fontFamily: 'Microsoft YaHei, SimSun, serif' }
                        },
                        series: [{
                            name: 'Category Count',
                            type: 'bar',
                            data: [{"name":"linux","value":227},{"name":"uboot","value":68},{"name":"kernel","value":61},{"name":"rt-thread","value":44},{"name":"u-boot分类","value":44}].map(category => category.value).reverse(),
                            label: {
                                show: true,
                                position: 'right',
                                formatter: params => params.value,
                                fontSize: 14,
                                color: '#000',
                                fontWeight: 'bold',
                                fontFamily: 'Microsoft YaHei, SimSun, serif'
                            },
                            itemStyle: {
                                color: new echarts.graphic.LinearGradient(0, 0, 1, 0, [
                                    { offset: 0, color: '#91CC75' },
                                    { offset: 1, color: '#73C0DE' }
                                ])
                            }
                        }]
                    });

                    categoriesChart.on('click', function (params) {
                        window.location.href = '/categories/' + params.name;
                    });
                }
            });
        </script>
    
        
        <script>
            document.addEventListener("DOMContentLoaded", function() {
                const categoriesTreeChartDom = document.getElementById('categoriesTreeChart');
                if(categoriesTreeChartDom){
                    const treeChart = echarts.init(categoriesTreeChartDom, 'dark');
                    treeChart.setOption({
                        title: {
                            text: '操作提示：单击展开分类，双击进入具体分类页面',
                            textStyle: {
                                fontSize: 12,
                                color: '#999',
                                fontWeight: 'normal'
                            },
                            bottom: 0,
                            left: 'center'
                        },
                        tooltip: {
                            trigger: 'item',
                            triggerOn: 'mousemove'
                        },
                        series: [{
                            type: 'tree',
                            data: [{"name":"Categories","children":[{"name":"uboot","children":[{"name":"other","children":[],"count":12,"path":"uboot/other"},{"name":"子目录","children":[],"count":10,"path":"uboot/子目录"},{"name":"u-boot分类","children":[{"name":"api","children":[],"count":1,"path":"uboot/u-boot分类/api"},{"name":"arch","children":[{"name":"arm","children":[],"count":2,"path":"uboot/u-boot分类/arch/arm"}],"count":3,"path":"uboot/u-boot分类/arch"},{"name":"boot","children":[],"count":4,"path":"uboot/u-boot分类/boot"},{"name":"common","children":[],"count":10,"path":"uboot/u-boot分类/common"},{"name":"cmd","children":[],"count":1,"path":"uboot/u-boot分类/cmd"},{"name":"dm","children":[],"count":15,"path":"uboot/u-boot分类/dm"},{"name":"env","children":[],"count":1,"path":"uboot/u-boot分类/env"},{"name":"fdt","children":[],"count":1,"path":"uboot/u-boot分类/fdt"},{"name":"lib","children":[],"count":4,"path":"uboot/u-boot分类/lib"},{"name":"include","children":[],"count":3,"path":"uboot/u-boot分类/include"},{"name":"test","children":[],"count":1,"path":"uboot/u-boot分类/test"}],"count":44,"path":"uboot/u-boot分类"}],"count":68,"path":"uboot"},{"name":"rt-thread","children":[{"name":"其他资料","children":[{"name":"fatfs","children":[],"count":1,"path":"rt-thread/其他资料/fatfs"}],"count":1,"path":"rt-thread/其他资料"}],"count":44,"path":"rt-thread"},{"name":"linux","children":[{"name":"fs","children":[],"count":37,"path":"linux/fs"},{"name":"lib","children":[],"count":19,"path":"linux/lib"},{"name":"mm","children":[],"count":19,"path":"linux/mm"},{"name":"kernel","children":[{"name":"time","children":[],"count":10,"path":"linux/kernel/time"},{"name":"irq","children":[],"count":5,"path":"linux/kernel/irq"},{"name":"rcu","children":[],"count":3,"path":"linux/kernel/rcu"},{"name":"lock","children":[],"count":7,"path":"linux/kernel/lock"},{"name":"sched","children":[],"count":7,"path":"linux/kernel/sched"}],"count":61,"path":"linux/kernel"},{"name":"other","children":[],"count":17,"path":"linux/other"},{"name":"scripts","children":[],"count":2,"path":"linux/scripts"},{"name":"security","children":[],"count":1,"path":"linux/security"},{"name":"include","children":[],"count":10,"path":"linux/include"},{"name":"block","children":[],"count":5,"path":"linux/block"},{"name":"drivers","children":[{"name":"clk","children":[],"count":2,"path":"linux/drivers/clk"},{"name":"base","children":[],"count":14,"path":"linux/drivers/base"},{"name":"tty","children":[],"count":2,"path":"linux/drivers/tty"}],"count":39,"path":"linux/drivers"},{"name":"arch","children":[{"name":"arm","children":[],"count":10,"path":"linux/arch/arm"}],"count":10,"path":"linux/arch"}],"count":227,"path":"linux"},{"name":"hpatch","children":[{"name":"SA-IS","children":[],"count":1,"path":"hpatch/SA-IS"},{"name":"libdivsufsort","children":[],"count":3,"path":"hpatch/libdivsufsort"}],"count":10,"path":"hpatch"},{"name":"杂谈","children":[],"count":8,"path":"杂谈"},{"name":"MCU","children":[],"count":23,"path":"MCU"},{"name":"git","children":[],"count":6,"path":"git"},{"name":"LoraWan","children":[{"name":"LoRaWAN标准","children":[{"name":"LoRaWAN-Specification_ZH_CN","children":[{"name":"LoRaWAN-Specification_ZH_CN-190102","children":[{"name":"chapter","children":[],"count":20,"path":"LoraWan/LoRaWAN标准/LoRaWAN-Specification_ZH_CN/LoRaWAN-Specification_ZH_CN-190102/chapter"}],"count":22,"path":"LoraWan/LoRaWAN标准/LoRaWAN-Specification_ZH_CN/LoRaWAN-Specification_ZH_CN-190102"}],"count":22,"path":"LoraWan/LoRaWAN标准/LoRaWAN-Specification_ZH_CN"}],"count":22,"path":"LoraWan/LoRaWAN标准"}],"count":23,"path":"LoraWan"},{"name":"freertos","children":[],"count":1,"path":"freertos"},{"name":"tmc5160","children":[],"count":1,"path":"tmc5160"}],"count":0,"path":""}],
                            initialTreeDepth: -1,
                            top: '5%',
                            bottom: '10%',
                            left: '0%',
                            right: '0%',
                            symbolSize: 15,
                            layout: 'orthogonal',
                            orient: 'TB',
                            itemStyle: {
                                color: '#91CC75',
                                borderColor: '#73C0DE'
                            },
                            label: {
                                position: 'bottom',
                                verticalAlign: 'middle',
                                align: 'center',
                                fontSize: 14,
                                distance: 28,
                                formatter: function(params) {
                                    return params.data.name + (params.data.count ? ' (' + params.data.count + ')' : '');
                                }
                            },
                            leaves: {
                                label: {
                                    position: 'top',
                                    verticalAlign: 'middle',
                                    align: 'center'
                                }
                            },
                            emphasis: {
                                focus: 'descendant'
                            },
                            expandAndCollapse: true
                        }]
                    });

                    treeChart.on('dblclick', function (params) {
                        if (params.data && params.data.path) {
                            window.location.href = '/categories/' + params.data.path;
                        }
                    });
                }
            });
        </script>
    
    <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"react":{"opacity":0.7},"log":false});</script></body></html>