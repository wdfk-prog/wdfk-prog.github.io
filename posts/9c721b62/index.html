<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>USB | wdfk-prog的个人博客</title><meta name="author" content="Liya Huang"><meta name="copyright" content="Liya Huang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="USBUSB2.0枚举与配置 设备被连接到 USB 端口上，并得到检测。 集线器通过监控端口的电压来检测设备。集线器的 D+线和 D-线上带有下拉电阻，根据设备的速度，D+或 D-线上会带有上拉电阻。通过监控这些线上的电压变换，集线器检测设备是否得到连接。 这部分具体IAD描述符的参考&lt;&lt;iadclasscode_r10.pdf&gt;&gt; 2节 IAD Use Model Exa">
<meta property="og:type" content="article">
<meta property="og:title" content="USB">
<meta property="og:url" content="https://wdfk-prog.space/posts/9c721b62/index.html">
<meta property="og:site_name" content="wdfk-prog的个人博客">
<meta property="og:description" content="USBUSB2.0枚举与配置 设备被连接到 USB 端口上，并得到检测。 集线器通过监控端口的电压来检测设备。集线器的 D+线和 D-线上带有下拉电阻，根据设备的速度，D+或 D-线上会带有上拉电阻。通过监控这些线上的电压变换，集线器检测设备是否得到连接。 这部分具体IAD描述符的参考&lt;&lt;iadclasscode_r10.pdf&gt;&gt; 2节 IAD Use Model Exa">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wdfk-prog.space/images/covers/06.jpg">
<meta property="article:published_time" content="2025-10-03T01:44:51.000Z">
<meta property="article:modified_time" content="2025-10-03T09:23:27.926Z">
<meta property="article:author" content="Liya Huang">
<meta property="article:tag" content="rt-thread">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wdfk-prog.space/images/covers/06.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "USB",
  "url": "https://wdfk-prog.space/posts/9c721b62/",
  "image": "https://wdfk-prog.space/images/covers/06.jpg",
  "datePublished": "2025-10-03T01:44:51.000Z",
  "dateModified": "2025-10-03T09:23:27.926Z",
  "author": [
    {
      "@type": "Person",
      "name": "Liya Huang",
      "url": "https://github.com/wdfk-prog"
    }
  ]
}</script><link rel="shortcut icon" href="/images/favicon.png"><link rel="canonical" href="https://wdfk-prog.space/posts/9c721b62/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//static.cloudflareinsights.com"/><link rel="preconnect" href="//www.clarity.ms"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxxxxx"/><meta name="baidu-site-verification" content="xxxxxxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-3978542742563797',
  enable_page_level_ads: 'true'
});</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?3c49dd4913ab43efb1bfc8d12b1cded9";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-PF2CVP2PL4"></script><script>window.dataLayer = window.dataLayer || []
function gtag(){dataLayer.push(arguments)}
gtag('js', new Date())
gtag('config', 'G-PF2CVP2PL4')
btf.addGlobalFn('pjaxComplete', () => {
  gtag('config', 'G-PF2CVP2PL4', {'page_path': window.location.pathname})
}, 'google_analytics')
</script><script defer="defer" data-pjax="data-pjax" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;17ff914b5e28493597b7dc19f3356022&quot;}"></script><script>(function(c,l,a,r,i,t,y){
    c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
    t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
    y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
})(window, document, "clarity", "script", "tkaenn1tjv");
</script><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
"https://www.googletagmanager.com/gtm.js?id="+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-MF3J339H');
btf.addGlobalFn('pjaxComplete', () => {
  dataLayer.push({'event': 'pjaxComplete', 'page_title': document.title, 'page_location': location.href, 'page_path': window.location.pathname})
}, 'google_tag_manager')</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":false,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'USB',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.0.0"><link rel="alternate" href="/atom.xml" title="wdfk-prog的个人博客" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (true) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(/images/subtle-texture.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/avatar.png" onerror="this.onerror=null;this.src='/images/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">417</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">49</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">53</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book-open"></i><span> 页面</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fas fa-quote-left"></i><span> 说说</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 示例</span></a></li></ul></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/songs/"><i class="fa-fw fas fa-music"></i><span> 歌曲</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/images/covers/06.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/my-logo.png" alt="Logo"><span class="site-name">wdfk-prog的个人博客</span></a><a class="nav-page-title" href="/"><span class="site-name">USB</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book-open"></i><span> 页面</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fas fa-quote-left"></i><span> 说说</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 示例</span></a></li></ul></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/songs/"><i class="fa-fw fas fa-music"></i><span> 歌曲</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">USB<a class="post-edit-link" href="null_posts/rt-thread/USB.md" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-10-03T01:44:51.000Z" title="发表于 2025-10-03 09:44:51">2025-10-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-03T09:23:27.926Z" title="更新于 2025-10-03 17:23:27">2025-10-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/rt-thread/">rt-thread</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">21.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>102分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/9c721b62/#post-comment"><span class="gitalk-comment-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;已经过了&quot;,&quot;messageNext&quot;:&quot;自上次更新以来，文章的内容可能已经过时&quot;,&quot;postUpdate&quot;:&quot;2025-10-03 17:23:27&quot;}" hidden></div><h1 id="USB"><a href="#USB" class="headerlink" title="USB"></a>USB</h1><h2 id="USB2-0"><a href="#USB2-0" class="headerlink" title="USB2.0"></a>USB2.0</h2><h3 id="枚举与配置"><a href="#枚举与配置" class="headerlink" title="枚举与配置"></a>枚举与配置</h3><ul>
<li>设备被连接到 USB 端口上，并得到检测。</li>
<li>集线器通过监控端口的电压来检测设备。集线器的 D+线和 D-线上带有下拉电阻，根据设备的速度，D+或 D-线上会带有上拉电阻。通过监控这些线上的电压变换，集线器检测设备是否得到连接。</li>
<li>这部分具体IAD描述符的参考&lt;&lt;iadclasscode_r10.pdf&gt;&gt; 2节 IAD Use Model Example</li>
</ul>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/42%20USB.assets/image-20240815170518414.png" alt="image-20240815170518414"></p>
<ul>
<li>具体枚举配置过程,wireshark抓包不够准确,可以通过打印日志查看</li>
<li>方向分为设备到主机和主机到设备;意思是收到请求后执行的方向</li>
</ul>
<ol>
<li>请求类型:Standard Device Request 方向:设备到主机 请求:GET_DESCRIPTOR <ul>
<li>wValue <ul>
<li>描述符类型 :1 (设备描述符) </li>
<li>描述符索引: 0 (第一个描述符)</li>
</ul>
</li>
<li>wIndex字段为字符串描述符指定语言ID</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[80 06 00 01 00 00 12 00]</span><br><span class="line">[23:29:12 571]Setup: bmRequestType 0x80, bRequest 0x06, wValue 0x0100, wIndex 0x0000, wLength 0x0040</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>回复设备描述符18字节,返回的是IAD描述符<ul>
<li>bLength: 0x12 </li>
<li>bDescriptorType: 0x01 (设备描述符)</li>
<li>bcdUSB: 0x0200 (USB2.0)</li>
<li>bDeviceClass: 0xef (Miscellaneous Device Class)</li>
<li>bDeviceSubClass: 0x02 (Common Class Subclass)</li>
<li>bDeviceProtocol: 0x01 (Interface Association Descriptor)</li>
<li>bMaxPacketSize0: 0x40 (64 bytes)</li>
<li>idVendor: 0xffff (供应商 ID)</li>
<li>idProduct: 0xffff (产品 ID)</li>
<li>bcdDevice 0x0100 (设备版本号)</li>
<li>iManufacturer: 0x01 (制造商字符串描述符索引)</li>
<li>iProduct: 0x02 (产品字符串描述符索引)</li>
<li>iSerialNumber: 0x03 (序列号字符串描述符索引)</li>
<li>bNumConfigurations: 0x01 (配置数量)</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[12 01 00 02 ef 02 01 40 ff ff ff ff 00 01 01 02 03 01]</span><br><span class="line">[23:29:12 573]EP0 send 18 bytes, 0 remained</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>请求类型:Standard Device Request 方向:主机到设备 请求:SET_ADDRESS<ul>
<li>wValue: 0x001d (地址为29)</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[23:29:12 631]Setup: bmRequestType 0x00, bRequest 0x05, wValue 0x001d, wIndex 0x0000, wLength 0x0000</span><br><span class="line">[23:29:12 635]EP0 send 0 bytes, 0 remained</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>请求类型:Standard Device Request 方向:设备到主机 请求:GET_DESCRIPTOR<ul>
<li>wValue <ul>
<li>描述符类型 :1 (设备描述符) </li>
<li>描述符索引: 0 (第一个描述符)</li>
</ul>
</li>
<li>wIndex字段为字符串描述符指定语言ID</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[23:29:12 650]Setup: bmRequestType 0x80, bRequest 0x06, wValue 0x0100, wIndex 0x0000, wLength 0x0012</span><br><span class="line">[23:29:12 653]EP0 send 18 bytes, 0 remained</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>请求类型:Standard Device Request 方向:设备到主机 请求:GET_DESCRIPTOR<ul>
<li>wValue <ul>
<li>描述符类型 :2 (配置描述符)</li>
<li>描述符索引: 0 (第一个描述符)</li>
</ul>
</li>
<li>wIndex字段为字符串描述符指定语言ID</li>
<li>wLength: 0x004b (75 bytes)</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[80 06 00 02 00 00 4b 00]</span><br><span class="line">[23:29:12 670]Setup: bmRequestType 0x80, bRequest 0x06, wValue 0x0200, wIndex 0x0000, wLength 0x004b</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>回复描述符75字节<ol>
<li>配置描述符</li>
</ol>
<ul>
<li>bLength: 0x09</li>
<li>bDescriptorType: 0x02 (配置描述符)</li>
<li>wTotalLength: 0x004b (配置描述符及其子描述符的总长度)</li>
<li>bNumInterfaces: 0x01 (接口数量)</li>
<li>bConfigurationValue: 0x01 (配置值)</li>
<li>bmAttributes: 0x80 (配置属性)<ul>
<li>Bit 6: Self-powered 0:总线供电</li>
<li>Bit 5: Remote Wakeup 0:不支持远程唤醒</li>
</ul>
</li>
<li>bMaxPower: 0x32 (最大功率 单位2mA) 100mA</li>
</ul>
<ol start="2">
<li>接口描述符</li>
</ol>
<ul>
<li>bLength: 0x08</li>
<li>bDescriptorType: 0x0b (接口描述符)</li>
<li>bInterfaceNumber: 0x00 (接口号)</li>
<li>bInterfaceCount: 0x02 (接口数量)</li>
<li>bFunctionClass: 0x02 (Communication Device Class)</li>
<li>bFunctionSubClass: 0x02 (Abstract Control Model)</li>
<li>bFunctionProtocol: 0x01 (ITU-T V.250)</li>
<li>iFunction: 0x00 (接口描述符索引)</li>
</ul>
<ol start="3">
<li>接口描述符</li>
</ol>
<ul>
<li>bLength: 0x09</li>
<li>bDescriptorType: 0x04 (接口描述符)</li>
<li>bInterfaceNumber: 0x00 (接口号)</li>
<li>bAlternateSetting: 0x00 (备用设置)</li>
<li>bNumEndpoints: 0x01 (端点数量)</li>
<li>bInterfaceClass: 0x02 (Communication Device Class)</li>
<li>bInterfaceSubClass: 0x02 (Abstract Control Model)</li>
<li>bInterfaceProtocol: 0x01 (ITU-T V.250)</li>
<li>iInterface: 0x02 (接口描述符索引)</li>
</ul>
<ol start="4">
<li>COMMUNICATION DESCRIPTOR</li>
</ol>
<ul>
<li>bLength: 0x05</li>
<li>bDescriptorType: 0x24 (CS_INTERFACE)</li>
<li>bDescriptorSubtype: 0x00 (Header Functional Descriptor)</li>
<li>bcdCDC: 0x0110 (CDC version 1.10)</li>
</ul>
<ol start="5">
<li>COMMUNICATION DESCRIPTOR</li>
</ol>
<ul>
<li>bLength: 0x05</li>
<li>bDescriptorType: 0x24 (CS_INTERFACE)</li>
<li>bDescriptorSubtype: 0x01 (Call Management Functional Descriptor)</li>
<li>bmCapabilities: 0x00<ul>
<li>Call Management over Data Class Interface: Not supported</li>
<li>Call Management over Communication Class Interface: Not supported</li>
</ul>
</li>
<li>bDataInterface: 0x01 (Data Class Interface)</li>
</ul>
<ol start="6">
<li>COMMUNICATION DESCRIPTOR</li>
</ol>
<ul>
<li>bLength: 0x04</li>
<li>bDescriptorType: 0x24 (CS_INTERFACE)</li>
<li>bDescriptorSubtype: 0x02 (Abstract Control Management Functional Descriptor)</li>
<li>bmCapabilities: 0x02<ul>
<li>Comm Features Combinations: Not supported</li>
<li>Line Coding and Serial State: Supported</li>
<li>Send Break: Not supported</li>
<li>Network Connection: Not supported</li>
</ul>
</li>
</ul>
<ol start="7">
<li>COMMUNICATION DESCRIPTOR</li>
</ol>
<ul>
<li>bLength: 0x05</li>
<li>bDescriptorType: 0x24 (CS_INTERFACE)</li>
<li>bDescriptorSubtype: 0x06 (Union Functional Descriptor)</li>
<li>bControlInterface: 0x00 (Control Class Interface)</li>
<li>bSubordinateInterface0: 0x01 (Data Class Interface)</li>
</ul>
<ol start="8">
<li>ENDPOINT DESCRIPTOR</li>
</ol>
<ul>
<li>bLength: 0x07</li>
<li>bDescriptorType: 0x05 (ENDPOINT)</li>
<li>bEndpointAddress: 0x83 (Endpoint 3 IN)<ul>
<li>Direction: IN</li>
<li>Number: 3</li>
</ul>
</li>
<li>bmAttributes: 0x03 (Transfer type: Interrupt)<ul>
<li>Transactions per microframe: 1 (0)</li>
</ul>
</li>
<li>wMaxPacketSize: 0x0008 (8 bytes)</li>
<li>bInterval: 0x00 (Polling interval in (micro) frames)</li>
</ul>
<ol start="9">
<li>INTERFACE DESCRIPTOR</li>
</ol>
<ul>
<li>bLength: 0x09</li>
<li>bDescriptorType: 0x04 (INTERFACE)</li>
<li>bInterfaceNumber: 0x01 (Interface 1)</li>
<li>bAlternateSetting: 0x00 (Alternate setting 0)</li>
<li>bNumEndpoints: 0x02 (2 endpoints)</li>
<li>bInterfaceClass: 0x0a (Data Interface Class)</li>
<li>bInterfaceSubClass: 0x00 (No specific subclass)</li>
<li>bInterfaceProtocol: 0x00 (No specific protocol)</li>
<li>iInterface: 0x00 (No string descriptor)</li>
</ul>
<ol start="10">
<li>ENDPOINT DESCRIPTOR</li>
</ol>
<ul>
<li>bLength: 0x07</li>
<li>bDescriptorType: 0x05 (ENDPOINT)</li>
<li>bEndpointAddress: 0x02 (Endpoint 2 OUT)<ul>
<li>Direction: OUT</li>
<li>Number: 2</li>
</ul>
</li>
<li>bmAttributes: 0x02 (Transfer type: Bulk)<ul>
<li>Transactions per microframe: 1 (0)</li>
</ul>
</li>
<li>wMaxPacketSize: 0x0040 (64 bytes)</li>
<li>bInterval: 0x00 (Polling interval in (micro) frames)</li>
</ul>
<ol start="11">
<li>ENDPOINT DESCRIPTOR</li>
</ol>
<ul>
<li>bLength: 0x07</li>
<li>bDescriptorType: 0x05 (ENDPOINT)</li>
<li>bEndpointAddress: 0x81 (Endpoint 1 IN)<ul>
<li>Direction: IN</li>
<li>Number: 1</li>
</ul>
</li>
<li>bmAttributes: 0x02 (Transfer type: Bulk)<ul>
<li>Transactions per microframe: 1 (0)</li>
</ul>
</li>
<li>wMaxPacketSize: 0x0040 (64 bytes)</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[09 02 4b 00 02 01 00 80 32]</span><br><span class="line">[08 0b 00 02 02 02 01 00]</span><br><span class="line">[09 04 00 00 01 02 02 01 02]</span><br><span class="line">[05 24 00 10 01]</span><br><span class="line">[05 24 01 00 01]</span><br><span class="line">[04 24 02 02]</span><br><span class="line">[05 24 06 00 01]</span><br><span class="line">[07 05 83 03 08 00 0a]</span><br><span class="line">[09 04 01 00 02 0a 00 00 00]</span><br><span class="line">[07 05 02 02 40 00 00]</span><br><span class="line">[07 05 81 02 40 00 00]</span><br><span class="line">[23:29:12 673]EP0 send 64 bytes, 11 remained</span><br><span class="line">[23:29:12 673]EP0 send 11 bytes, 0 remained</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>请求类型:Standard Device Request 方向:设备到主机 请求:GET_DESCRIPTOR<ul>
<li>wValue <ul>
<li>描述符类型 :3 (字符串描述符) </li>
<li>描述符索引: 3 (第3个描述符)</li>
</ul>
</li>
<li>wIndex字段为字符串描述符指定语言ID 0x0409 (英文)</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[80 06 02 03 09 04 26 00]</span><br><span class="line">[23:29:12 685]Setup: bmRequestType 0x80, bRequest 0x06, wValue 0x0303, wIndex 0x0409, wLength 0x00ff</span><br></pre></td></tr></table></figure>

<ul>
<li>回复字符串描述符22字节<ul>
<li>bLength: 0x16</li>
<li>bDescriptorType: 0x03 (字符串描述符)</li>
<li>bString: “2022123456”</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[16 03 32 00 32 00 32 00 31 00 32 00 33 00 34 00 35 00 36 00]</span><br><span class="line">[23:29:12 685]EP0 send 22 bytes, 0 remained</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>请求类型:Standard Device Request 方向:设备到主机 请求:GET_DESCRIPTOR<ul>
<li>wValue <ul>
<li>描述符类型 :3 (字符串描述符) </li>
<li>描述符索引: 0 (第0个描述符)</li>
</ul>
</li>
<li>wIndex字段为字符串描述符指定语言ID 0x0000</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[23:29:12 695]Setup: bmRequestType 0x80, bRequest 0x06, wValue 0x0300, wIndex 0x0000, wLength 0x00ff</span><br></pre></td></tr></table></figure>

<ul>
<li>回复字符串描述符4字节<ul>
<li>bLength: 0x04</li>
<li>bDescriptorType: 0x03 (字符串描述符)</li>
<li>bString: 0x0409 (英文)</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[04 03 09 04]</span><br><span class="line">[23:29:12 697]EP0 send 4 bytes, 0 remained</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>请求类型:Standard Device Request 方向:设备到主机 请求:GET_DESCRIPTOR<ul>
<li>wValue <ul>
<li>描述符类型 :3 (字符串描述符) </li>
<li>描述符索引: 2 (第2个描述符)</li>
</ul>
</li>
<li>wIndex字段为字符串描述符指定语言ID 0x0409 (英文)</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[23:29:12 706]Setup: bmRequestType 0x80, bRequest 0x06, wValue 0x0302, wIndex 0x0409, wLength 0x00ff</span><br></pre></td></tr></table></figure>

<ul>
<li>回复字符串描述符38字节<ul>
<li>bLength: 0x26</li>
<li>bDescriptorType: 0x03 (字符串描述符)</li>
<li>bString: “CherryUSB CDC DEMO”</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[26 03 43 00 68 00 65 00 72 00 72 00 79 00 55 00 53 00 42 00 20 00 43 00 44 00 43 00 20 00 44 00 45 00 4d 00 4f 00]</span><br><span class="line">[23:29:12 706]EP0 send 38 bytes, 0 remained</span><br></pre></td></tr></table></figure>

<ol start="10">
<li>请求类型:Standard Device Request 方向:设备到主机 请求:GET_DESCRIPTOR<ul>
<li>wValue <ul>
<li>描述符类型 :06 (设备限定描述符)</li>
<li>描述符索引: 0 (第0个描述符)</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>没有该描述符,回复STALL</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[23:29:12 719]Setup: bmRequestType 0x80, bRequest 0x06, wValue 0x0600, wIndex 0x0000, wLength 0x000a</span><br></pre></td></tr></table></figure>

<ol start="11">
<li>请求类型:Standard Device Request 方向:设备到主机 请求:SET_CONFIGURATION<ul>
<li>wValue: 0x0001 (配置为1)</li>
</ul>
</li>
</ol>
<ul>
<li>配置对应端点,回复配置状态<ol>
<li>配置0x03端点方向为OUT,类型为中断,最大包大小为8</li>
<li>配置0x02端点方向为OUT,类型为批量,最大包大小为64</li>
<li>配置0x01端点方向为IN,类型为批量,最大包大小为64</li>
</ol>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[23:29:12 773]Setup: bmRequestType 0x00, bRequest 0x09, wValue 0x0001, wIndex 0x0000, wLength 0x0000</span><br><span class="line">[23:29:12 782]Open ep:0x83 type:3 mps:8</span><br><span class="line">[23:29:12 782]Open ep:0x02 type:2 mps:64</span><br><span class="line">[23:29:12 790]Open ep:0x81 type:2 mps:64</span><br><span class="line">[23:29:12 790]EP0 send 0 bytes, 0 remained</span><br></pre></td></tr></table></figure>

<ol start="12">
<li>请求类型: Class Interface Request 方向:设备到主机 请求:GET_LINE_CODING<ul>
<li>wValue: 0x0000</li>
<li>wIndex: 0x0000</li>
<li>wLength: 0x0007</li>
<li>bRequest 0x21</li>
</ul>
</li>
</ol>
<ul>
<li>回复波特率:2000000,停止位:1,校验位:0,数据位:8</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[a1 21 00 00 00 00 07 00]</span><br><span class="line">[23:29:12 845]Setup: bmRequestType 0xa1, bRequest 0x21, wValue 0x0000, wIndex 0x0000, wLength 0x0007</span><br><span class="line">[23:29:12 849]CDC Class request: bRequest 0x21</span><br><span class="line">[23:29:12 852]Get intf:0 linecoding 2000000 0 0 8</span><br><span class="line">[80 84 1e 00 00 00 08]</span><br><span class="line">[23:29:12 855]EP0 send 7 bytes, 0 remained</span><br></pre></td></tr></table></figure>

<ol start="13">
<li>请求类型: Class Interface Request 方向:设备到主机 请求:SET_CONTROL_LINE_STATE<br>- wValue: 0x0000<br>- wIndex: 0x0000<br>- wLength: 0x0007<br>- bRequest 0x20</li>
</ol>
<ul>
<li>设置DTR和RTS</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[21 22 00 00 00 00 00 00]</span><br><span class="line">[23:29:12 877]Setup: bmRequestType 0x21, bRequest 0x22, wValue 0x0000, wIndex 0x0000, wLength 0x0000</span><br><span class="line">[23:29:12 880]CDC Class request: bRequest 0x22</span><br><span class="line">[23:29:12 885]Set intf:0 DTR 0x0,RTS 0x0</span><br><span class="line">[23:29:12 887]EP0 send 0 bytes, 0 remained</span><br></pre></td></tr></table></figure>

<ol start="14">
<li>请求类型: Class Interface Request 方向:主机到设备 请求:SET_LINE_CODING<ul>
<li>wValue: 0x0000</li>
<li>wIndex: 0x0000</li>
<li>wLength: 0x0007</li>
<li>bRequest 0x20</li>
</ul>
</li>
</ol>
<ul>
<li>执行接收,配置波特率:2000000,停止位:1,校验位:0,数据位:8</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[23:29:12 897]Setup: bmRequestType 0x21, bRequest 0x20, wValue 0x0000, wIndex 0x0000, wLength 0x0007</span><br><span class="line">[23:29:12 901]Start reading 7 bytes from ep0</span><br><span class="line">[80 84 1e 00 00 00 08]</span><br><span class="line">[23:29:12 903]EP0 recv 7 bytes, 0 remained</span><br><span class="line">[23:29:12 912]CDC Class request: bRequest 0x20</span><br><span class="line">[23:29:12 912]Set intf:0 linecoding &lt;2000000 8 N 1&gt;</span><br><span class="line">[23:29:12 914]EP0 send 0 bytes, 0 remained</span><br></pre></td></tr></table></figure>

<ol start="15">
<li>请求类型: Class Interface Request 方向:主机到设备 请求:SET_CONTROL_LINE_STATE<ul>
<li>wValue: 0x0002</li>
<li>wIndex: 0x0000</li>
<li>wLength: 0x0000</li>
<li>bRequest 0x22</li>
</ul>
</li>
</ol>
<ul>
<li>设置DTR和RTS(串口助手开启关闭串口发送此命令,MCU可通过该命令实现同步开启输出或关闭)<ul>
<li>DTR:0</li>
<li>RTS:1</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[23:29:18 841] [I/USB] Setup: bmRequestType 0x21, bRequest 0x22, wValue 0x0002, wIndex 0x0000, wLength 0x0000</span><br><span class="line">[23:29:18 846] [D/USB] CDC Class request: bRequest 0x22</span><br><span class="line">[23:29:18 849] [D/USB] Set intf:0 DTR 0x0,RTS 0x1</span><br><span class="line">[23:29:18 853] [D/USB] EP0 send 0 bytes, 0 remained</span><br></pre></td></tr></table></figure>

<h3 id="Endpoint"><a href="#Endpoint" class="headerlink" title="Endpoint"></a>Endpoint</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Standard Endpoint Descriptor */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_endpoint_descriptor</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> bLength;          <span class="comment">/* Descriptor size in bytes = 7 */</span></span><br><span class="line">    <span class="type">uint8_t</span> bDescriptorType;  <span class="comment">/* ENDPOINT descriptor type = 5 */</span></span><br><span class="line">    <span class="type">uint8_t</span> bEndpointAddress; <span class="comment">/* Endpoint # 0 - 15 | IN/OUT */</span></span><br><span class="line">    <span class="type">uint8_t</span> bmAttributes;     <span class="comment">/* Transfer type */</span></span><br><span class="line">    <span class="type">uint16_t</span> wMaxPacketSize;  <span class="comment">/* Bits 10:0 = max. packet size */</span></span><br><span class="line">    <span class="type">uint8_t</span> bInterval;        <span class="comment">/* Polling interval in (micro) frames */</span></span><br><span class="line">&#125; __PACKED;</span><br></pre></td></tr></table></figure>

<ul>
<li>bLength: 描述符长度 7 字节</li>
<li>bDescriptorType: 描述符类型 5(端点描述符)</li>
<li>bEndpointAddress: 8位,低7位为端点号,最高位为方向,0表示OUT,1表示IN</li>
<li>bmAttributes: 属性</li>
</ul>
<p>位1 . .0:传输类型:00 &#x3D;控制;01 &#x3D;同步;10 &#x3D;批量;11 &#x3D;中断<br>如果不是等时端点，第5位…2为预留值，必须设置为0。如果是等时的，则定义如下:<br>位3 . .2:同步类型:00 &#x3D;不同步;01 &#x3D;异步;10 &#x3D;自适应;11 &#x3D;同步<br>Bits 5..4:使用类型:00 &#x3D;数据端点;01 &#x3D;反馈端点;10 &#x3D;隐式反馈数据端点;11 &#x3D;保留<br>所有其他的位被保留，必须重置为零。保留位必须被主机忽略。</p>
<ul>
<li><p>wMaxPacketSize: 最大包大小<br>对于所有端点，第10位…0指定最大数据包大小(以字节为单位)。</p>
</li>
<li><p>bInterval: 传输间隔<br>数据传输轮询端点的时间间隔。<br>对于全速&#x2F;低速中断端点，该字段的取值范围是1 ~ 255。</p>
</li>
</ul>
<h3 id="Device-Requests"><a href="#Device-Requests" class="headerlink" title="Device Requests"></a>Device Requests</h3><ul>
<li>所有USB设备在设备的默认控制管道上响应来自主机的请求。这些请求是使用控制传输发出的。请求和请求的参数在安装包中发送到设备。主机负责建立表9-2所示字段中传递的值。每个安装包有8个字节</li>
</ul>
<table>
<thead>
<tr>
<th>偏移</th>
<th>字段</th>
<th>大小</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>bmRequestType</td>
<td>1</td>
<td>Bitmap</td>
<td>D7:数据传输方向<br/>      0 &#x3D;主机到设备1 &#x3D;设备到主机<br/>D6……5:类型<br/>      0 &#x3D;标准<br/>      1 &#x3D;类别<br/>      2 &#x3D;供应商<br/>      3 &#x3D;保留<br/>D4……0:接收方<br/>0 &#x3D;设备<br/>1 &#x3D;接口<br/>2 &#x3D;终端<br/>3 &#x3D;其他<br/>4…31 &#x3D;保留</td>
</tr>
<tr>
<td>1</td>
<td>bRequest</td>
<td>1</td>
<td>Value</td>
<td>具体要求(参见表9-3)</td>
</tr>
<tr>
<td>2</td>
<td>wValue</td>
<td>2</td>
<td>Value</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>wIndex</td>
<td>2</td>
<td>Index or Offset</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>wLength</td>
<td>2</td>
<td>Count</td>
<td>如果有数据阶段，要传输的字节数</td>
</tr>
</tbody></table>
<ul>
<li>标准设备请求</li>
</ul>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/42%20USB.assets/image-20240813175153704.png" alt="image-20240813175153704"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/42%20USB.assets/image-20240815104039529.png" alt="image-20240815104039529"></p>
<h3 id="描述符"><a href="#描述符" class="headerlink" title="描述符"></a>描述符</h3><h4 id="标准设备描述符"><a href="#标准设备描述符" class="headerlink" title="标准设备描述符"></a>标准设备描述符</h4><ul>
<li>参考&lt;&lt;USB2.0.pdf&gt;&gt; 9.6.1节</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Standard Device Descriptor </span></span><br><span class="line"><span class="comment"> * @bcdUSB: USB 版本号</span></span><br><span class="line"><span class="comment"> * @bDeviceClass: 设备类代码</span></span><br><span class="line"><span class="comment"> * @bDeviceSubClass: 设备子类代码</span></span><br><span class="line"><span class="comment"> * @bDeviceProtocol: 设备协议代码</span></span><br><span class="line"><span class="comment"> * @bMaxPacketSize0: 最大包大小 8/16/32/64 bytes 0x40 = 64</span></span><br><span class="line"><span class="comment"> * @idVendor: 供应商 ID</span></span><br><span class="line"><span class="comment"> * @idProduct: 产品 ID</span></span><br><span class="line"><span class="comment"> * @bcdDevice: 设备版本号</span></span><br><span class="line"><span class="comment"> * @bNumConfigurations: 配置数量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USB_DEVICE_DESCRIPTOR_INIT(bcdUSB, bDeviceClass, bDeviceSubClass, bDeviceProtocol, idVendor, idProduct, bcdDevice, bNumConfigurations) \</span></span><br><span class="line"><span class="meta">    0x12,                       <span class="comment">/* bLength */</span>                                                                                              \</span></span><br><span class="line"><span class="meta">    USB_DESCRIPTOR_TYPE_DEVICE, <span class="comment">/* bDescriptorType */</span>                                                                                      \</span></span><br><span class="line"><span class="meta">    WBVAL(bcdUSB),              <span class="comment">/* bcdUSB */</span>                                                                                               \</span></span><br><span class="line"><span class="meta">    bDeviceClass,               <span class="comment">/* bDeviceClass */</span>                                                                                         \</span></span><br><span class="line"><span class="meta">    bDeviceSubClass,            <span class="comment">/* bDeviceSubClass */</span>                                                                                      \</span></span><br><span class="line"><span class="meta">    bDeviceProtocol,            <span class="comment">/* bDeviceProtocol */</span>                                                                                      \</span></span><br><span class="line"><span class="meta">    0x40,                       <span class="comment">/* bMaxPacketSize */</span>                                                                                       \</span></span><br><span class="line"><span class="meta">    WBVAL(idVendor),            <span class="comment">/* idVendor */</span>                                                                                             \</span></span><br><span class="line"><span class="meta">    WBVAL(idProduct),           <span class="comment">/* idProduct */</span>                                                                                            \</span></span><br><span class="line"><span class="meta">    WBVAL(bcdDevice),           <span class="comment">/* bcdDevice */</span>                                                                                            \</span></span><br><span class="line"><span class="meta">    USB_STRING_MFC_INDEX,       <span class="comment">/* iManufacturer */</span>                                                                                        \</span></span><br><span class="line"><span class="meta">    USB_STRING_PRODUCT_INDEX,   <span class="comment">/* iProduct */</span>                                                                                             \</span></span><br><span class="line"><span class="meta">    USB_STRING_SERIAL_INDEX,    <span class="comment">/* iSerial */</span>                                                                                              \</span></span><br><span class="line"><span class="meta">    bNumConfigurations          <span class="comment">/* bNumConfigurations */</span></span></span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/42%20USB.assets/image-20240815155536119.png" alt="image-20240815155536119"></p>
<h4 id="标准配置描述符"><a href="#标准配置描述符" class="headerlink" title="标准配置描述符"></a>标准配置描述符</h4><ul>
<li><code>bConfigurationValue</code> 字段指示设备固件中定义的配置编号。客户端驱动程序使用该数字值来选择活动配置。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    * @wTotalLength: 配置描述符及其子描述符的总长度</span></span><br><span class="line"><span class="comment">    * @bNumInterfaces: 接口数量</span></span><br><span class="line"><span class="comment">    * @bConfigurationValue: 配置值</span></span><br><span class="line"><span class="comment">    * @bmAttributes: 配置属性</span></span><br><span class="line"><span class="comment">        * Bit 7: Reserved (set to one)</span></span><br><span class="line"><span class="comment">        * Bit 6: Self-powered 1:设备自供电 0:总线供电</span></span><br><span class="line"><span class="comment">        * Bit 5: Remote Wakeup 1:支持远程唤醒 0:不支持远程唤醒</span></span><br><span class="line"><span class="comment">        * Bits 4..0: Reserved (reset to zero)</span></span><br><span class="line"><span class="comment">    * @bMaxPower: 最大功率 单位2mA</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USB_CONFIG_DESCRIPTOR_INIT(wTotalLength, bNumInterfaces, bConfigurationValue, bmAttributes, bMaxPower) \</span></span><br><span class="line"><span class="meta">    0x09,                              <span class="comment">/* bLength */</span>                                                       \</span></span><br><span class="line"><span class="meta">    USB_DESCRIPTOR_TYPE_CONFIGURATION, <span class="comment">/* bDescriptorType */</span>                                               \</span></span><br><span class="line"><span class="meta">    WBVAL(wTotalLength),               <span class="comment">/* wTotalLength */</span>                                                  \</span></span><br><span class="line"><span class="meta">    bNumInterfaces,                    <span class="comment">/* bNumInterfaces */</span>                                                \</span></span><br><span class="line"><span class="meta">    bConfigurationValue,               <span class="comment">/* bConfigurationValue */</span>                                           \</span></span><br><span class="line"><span class="meta">    0x00,                              <span class="comment">/* iConfiguration */</span>                                                \</span></span><br><span class="line"><span class="meta">    bmAttributes,                      <span class="comment">/* bmAttributes */</span>                                                  \</span></span><br><span class="line"><span class="meta">    USB_CONFIG_P</span></span><br></pre></td></tr></table></figure>

<h4 id="IAD描述符"><a href="#IAD描述符" class="headerlink" title="IAD描述符"></a>IAD描述符</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    * @bFirstInterface: 第一个接口号</span></span><br><span class="line"><span class="comment">    * @bInterfaceCount: 接口数量</span></span><br><span class="line"><span class="comment">    * @bFunctionClass: 设备类代码</span></span><br><span class="line"><span class="comment">    * @bFunctionSubClass: 设备子类代码</span></span><br><span class="line"><span class="comment">    * @bFunctionProtocol: 设备协议代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USB_IAD_INIT(bFirstInterface, bInterfaceCount, bFunctionClass, bFunctionSubClass, bFunctionProtocol) \</span></span><br><span class="line"><span class="meta">    0x08,                                      <span class="comment">/* bLength */</span>                                             \</span></span><br><span class="line"><span class="meta">    USB_DESCRIPTOR_TYPE_INTERFACE_ASSOCIATION, <span class="comment">/* bDescriptorType */</span>                                     \</span></span><br><span class="line"><span class="meta">    bFirstInterface,                           <span class="comment">/* bFirstInterface */</span>                                     \</span></span><br><span class="line"><span class="meta">    bInterfaceCount,                           <span class="comment">/* bInterfaceCount */</span>                                     \</span></span><br><span class="line"><span class="meta">    bFunctionClass,                            <span class="comment">/* bFunctionClass */</span>                                      \</span></span><br><span class="line"><span class="meta">    bFunctionSubClass,                         <span class="comment">/* bFunctionSubClass */</span>                                   \</span></span><br><span class="line"><span class="meta">    bFunctionProtocol,                         <span class="comment">/* bFunctionProtocol */</span>                                   \</span></span><br><span class="line"><span class="meta">    0x00                                       <span class="comment">/* iFunction */</span></span></span><br></pre></td></tr></table></figure>

<h4 id="标准接口描述符"><a href="#标准接口描述符" class="headerlink" title="标准接口描述符"></a>标准接口描述符</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @bInterfaceNumber: 接口号 从0开始</span></span><br><span class="line"><span class="comment">* @bAlternateSetting: 备用设置 用于为先前字段中标识的接口选择此备用设置</span></span><br><span class="line"><span class="comment">* @bNumEndpoints: 端点数量 此接口使用的端点数(不包括端点0)。如果该值为零，则该接口只使用默认控制管道。</span></span><br><span class="line"><span class="comment">* @bInterfaceClass: 设备类代码</span></span><br><span class="line"><span class="comment">* @bInterfaceSubClass: 设备子类代码</span></span><br><span class="line"><span class="comment">* @bInterfaceProtocol: 设备协议代码</span></span><br><span class="line"><span class="comment">* @iInterface: 接口描述符索引</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USB_INTERFACE_DESCRIPTOR_INIT(bInterfaceNumber, bAlternateSetting, bNumEndpoints,                  \</span></span><br><span class="line"><span class="meta">                                      bInterfaceClass, bInterfaceSubClass, bInterfaceProtocol, iInterface) \</span></span><br><span class="line"><span class="meta">    0x09,                          <span class="comment">/* bLength */</span>                                                       \</span></span><br><span class="line"><span class="meta">    USB_DESCRIPTOR_TYPE_INTERFACE, <span class="comment">/* bDescriptorType */</span>                                               \</span></span><br><span class="line"><span class="meta">    bInterfaceNumber,              <span class="comment">/* bInterfaceNumber */</span>                                              \</span></span><br><span class="line"><span class="meta">    bAlternateSetting,             <span class="comment">/* bAlternateSetting */</span>                                             \</span></span><br><span class="line"><span class="meta">    bNumEndpoints,                 <span class="comment">/* bNumEndpoints */</span>                                                 \</span></span><br><span class="line"><span class="meta">    bInterfaceClass,               <span class="comment">/* bInterfaceClass */</span>                                               \</span></span><br><span class="line"><span class="meta">    bInterfaceSubClass,            <span class="comment">/* bInterfaceSubClass */</span>                                            \</span></span><br><span class="line"><span class="meta">    bInterfaceProtocol,            <span class="comment">/* bInterfaceProtocol */</span>                                            \</span></span><br><span class="line"><span class="meta">    iInterface                     <span class="comment">/* iInterface */</span></span></span><br></pre></td></tr></table></figure>

<h4 id="标准端点描述符"><a href="#标准端点描述符" class="headerlink" title="标准端点描述符"></a>标准端点描述符</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> USB_ENDPOINT_DESCRIPTOR_INIT(bEndpointAddress, bmAttributes, wMaxPacketSize, bInterval) \</span></span><br><span class="line"><span class="meta">    0x07,                         <span class="comment">/* bLength */</span>                                             \</span></span><br><span class="line"><span class="meta">    USB_DESCRIPTOR_TYPE_ENDPOINT, <span class="comment">/* bDescriptorType */</span>                                     \</span></span><br><span class="line"><span class="meta">    bEndpointAddress,             <span class="comment">/* bEndpointAddress */</span>                                    \</span></span><br><span class="line"><span class="meta">    bmAttributes,                 <span class="comment">/* bmAttributes */</span>                                        \</span></span><br><span class="line"><span class="meta">    WBVAL(wMaxPacketSize),        <span class="comment">/* wMaxPacketSize */</span>                                      \</span></span><br><span class="line"><span class="meta">    bInterval                     <span class="comment">/* bInterval */</span></span></span><br></pre></td></tr></table></figure>

<h4 id="字符串描述符"><a href="#字符串描述符" class="headerlink" title="字符串描述符"></a>字符串描述符</h4><ul>
<li>字符串描述符是可选的。如前所述，如果设备不支持字符串描述符，则必须将设备、配置和接口描述符中对字符串描述符的所有引用重置为零。</li>
<li>字符串描述符使用由统一码标准定义的统一码编码,所有语言的字符串索引为零返回一个字符串描述符，该描述符包含设备支持的双字节LANGID代码数组。USB设备可以省略所有的字符串描述符。省略所有字符串描述符的USB设备必须不返回LANGID代码数组。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> USB_LANGID_INIT(id)                           \</span></span><br><span class="line"><span class="meta">    0x04,                           <span class="comment">/* bLength */</span>     \</span></span><br><span class="line"><span class="meta">    USB_DESCRIPTOR_TYPE_STRING, <span class="comment">/* bDescriptorType */</span> \</span></span><br><span class="line"><span class="meta">    WBVAL(id)                   <span class="comment">/* wLangID0 */</span></span></span><br></pre></td></tr></table></figure>

<h1 id="cherryUSB"><a href="#cherryUSB" class="headerlink" title="cherryUSB"></a>cherryUSB</h1><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><ul>
<li>USB_MEM_ALIGNX: 用于指定内存对齐方式,用<code>CONFIG_USB_ALIGN_SIZE</code>配置,默认4字节对齐</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> USB_MEM_ALIGNX __attribute__((aligned(CONFIG_USB_ALIGN_SIZE)))</span></span><br></pre></td></tr></table></figure>

<ul>
<li>USB_NOCACHE_RAM_SECTION: 用于指定数据存储在无缓存RAM中,用于DMA传输</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* attribute data into no cache ram */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USB_NOCACHE_RAM_SECTION __attribute__((section(<span class="string">&quot;.noncacheable&quot;</span>)))</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>CONFIG_USBDEV_ADVANCE_DESC</code>: <code>usbd_desc_register</code>当前 API 仅支持一种速度，如果需要更高级的速度切换功能，请开启 CONFIG_USBDEV_ADVANCE_DESC，并且包含了下面所有描述符注册功能</li>
</ul>
<h1 id="dwc2"><a href="#dwc2" class="headerlink" title="dwc2"></a>dwc2</h1><h2 id="usb-dc-init"><a href="#usb-dc-init" class="headerlink" title="usb_dc_init"></a>usb_dc_init</h2><ul>
<li>初始化 usb device controller 寄存器，设置 usb 引脚、时钟、中断等等</li>
</ul>
<ol>
<li>软断开</li>
</ol>
<ul>
<li>供电状态可借助软断开功能通过软件退出。将设备控制寄存器中的软断开位（OTG_DCTL中的 SDIS 位）置 1 即可移除 DP 上拉电阻，此时尽管没有从主机端口实际拔出 USB 电缆， 但主机端仍会发生设备断开检测中断.</li>
</ul>
<ol start="2">
<li>关闭全局中断</li>
<li>B会话有效覆盖使能</li>
</ol>
<ul>
<li>由 OTG_HS 模块控制的 DP&#x2F;DM 集成上拉电阻和下拉电阻，具体使能哪种电阻取决于设备的当前角色。作为外设使用时，只要检测到 VBUS 为有效电平（B 会话有效），立即使能 DP 上拉电阻，以告知全速设备的连接。</li>
<li>VBUS 输入检测到 B 会话有效电压，就会使 USB 设备进入供电状态（请参见 USB2.0 第 9.1 部分）。</li>
<li>如果检测到 VBUS 降至 B 会话有效电压以下（例如，因电源干扰或主机端口关闭引发），OTG_HS 将自动断 开连接并生成检测到会话结束中断（OTG_GOTGINT 中的 SEDET 位），指示 OTG_HS 已 退出供电状态。</li>
</ul>
<ol start="4">
<li>全速串行收发器选择<br>0：USB 2.0 外部 ULPI 高速 PHY。<br>1：USB 1.1 全速串行收发器。</li>
<li>复位</li>
<li>强制设备模式</li>
</ol>
<ul>
<li>向该位写入 1 时，可将模块强制为设备模式，而无需考虑 OTG_ID 输入引脚。</li>
<li>0：正常模式1：强制设备模式</li>
<li>将强制位置 1 后，应用程序必须等待至少 25 ms 后更改方可生效。</li>
</ul>
<ol start="7">
<li>重启 PHY 时钟</li>
<li>设备速度配置</li>
</ol>
<ul>
<li>指示应用程序要求模块进行枚举所采用的速度，或应用程序支持的最大速度。但是，实际总线速度只有在完成 chirp 序列后才能确定，同时此速度基于与模块连接的 USB 主机的速度。</li>
<li>00：高速01：使用 HS 进行全速通信;10：保留;11：使用内置 FS PHY 进行全速通信</li>
</ul>
<ol start="9">
<li>清除中断标志</li>
<li>配置fifo</li>
</ol>
<ul>
<li>0X10刷新所有发送FIFO</li>
<li>通常建议在重新配置 FIFO 时进行刷新。还建议在设备端点禁止期间进行 FIFO 刷新。应用程序必须等待模块将此位清零，才能执行任意操作。该位需要八个时钟来清零（使用较慢的phy_clk 或 hclk 时钟）。</li>
<li>应用程序可使用此位刷新整个 Rx FIFO，但必须首先确保模块当前未在处理事务。只有在确认模块当前未对 Rx FIFO 执行读写操作后，应用程序方可对此位执行写操作。应用程序必须等到此位清零后，方可执行其它操作。通常需要等待 8 个时钟周期（以 PHY 或<br>AHB 时钟中最慢的为准）。</li>
</ul>
<ol start="11">
<li>使能中断,关闭软断开</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">usb_dc_init</span><span class="params">(<span class="type">uint8_t</span> busid)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;g_dwc2_udc, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> dwc2_udc));</span><br><span class="line"></span><br><span class="line">    usb_dc_low_level_init();    <span class="comment">// 初始化 usb 设备控制器</span></span><br><span class="line"></span><br><span class="line">    USB_OTG_DEV-&gt;DCTL |= USB_OTG_DCTL_SDIS;         <span class="comment">//软件断开USB连接</span></span><br><span class="line">    USB_OTG_GLB-&gt;GAHBCFG &amp;= ~USB_OTG_GAHBCFG_GINT;  <span class="comment">//关闭全局中断</span></span><br><span class="line">    <span class="comment">// STM32 cfg usb</span></span><br><span class="line">    <span class="comment">/* B-peripheral session valid override enable */</span></span><br><span class="line">    USB_OTG_GLB-&gt;GOTGCTL |= USB_OTG_GOTGCTL_BVALOEN;    <span class="comment">// 使能VBUS检查</span></span><br><span class="line">    USB_OTG_GLB-&gt;GOTGCTL |= USB_OTG_GOTGCTL_BVALOVAL;</span><br><span class="line">    <span class="comment">/* Select FS Embedded PHY */</span></span><br><span class="line">    USB_OTG_GLB-&gt;GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;     <span class="comment">// 选择USB2.0全速PHY</span></span><br><span class="line">    <span class="comment">/* Reset after a PHY select */</span></span><br><span class="line">    ret = dwc2_reset();</span><br><span class="line">    <span class="comment">/* Force Device Mode*/</span></span><br><span class="line">    dwc2_set_mode(USB_OTG_MODE_DEVICE);</span><br><span class="line">    <span class="comment">/* Restart the Phy Clock */</span></span><br><span class="line">    USB_OTG_PCGCCTL = <span class="number">0U</span>;</span><br><span class="line">    <span class="comment">/* Device speed configuration */</span></span><br><span class="line">    USB_OTG_DEV-&gt;DCFG |= USB_OTG_SPEED_HIGH_IN_FULL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">    ret = dwc2_flush_txfifo(<span class="number">0x10U</span>); <span class="comment">//刷新所有发送FIFO</span></span><br><span class="line">    ret = dwc2_flush_rxfifo();</span><br><span class="line"></span><br><span class="line">    USB_OTG_GLB-&gt;GAHBCFG |= USB_OTG_GAHBCFG_GINT;</span><br><span class="line">    USB_OTG_DEV-&gt;DCTL &amp;= ~USB_OTG_DCTL_SDIS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="usb-dc-low-level-init"><a href="#usb-dc-low-level-init" class="headerlink" title="usb_dc_low_level_init"></a>usb_dc_low_level_init</h2><ul>
<li>stm32: cubemx 生成的代码copy msp_init既可</li>
</ul>
<ol>
<li>初始化USB时钟</li>
<li>初始化USB引脚</li>
<li>初始化USB中断</li>
</ol>
<h2 id="USBD-IRQHandler"><a href="#USBD-IRQHandler" class="headerlink" title="USBD_IRQHandler"></a>USBD_IRQHandler</h2><ul>
<li>要将 rc_w1 类型中断状态位清零，应用程序必须向该位写入 1。</li>
</ul>
<h3 id="USB复位-USB-OTG-GINTSTS-USBRST"><a href="#USB复位-USB-OTG-GINTSTS-USBRST" class="headerlink" title="USB复位 USB_OTG_GINTSTS_USBRST"></a>USB复位 USB_OTG_GINTSTS_USBRST</h3><ol>
<li>清除USB复位中断标志</li>
<li>刷新所有FIFO</li>
<li>使能0端点,发送NACK;禁用非0端点,发送NACK</li>
<li>解除0端点中断屏蔽</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">USB_OTG_GLB-&gt;GINTSTS |= USB_OTG_GINTSTS_USBRST; <span class="comment">//清除USB复位中断标志</span></span><br><span class="line">USB_OTG_DEV-&gt;DCTL &amp;= ~USB_OTG_DCTL_RWUSIG;      <span class="comment">//清除远程唤醒信号</span></span><br><span class="line"><span class="comment">//刷新所有FIFO</span></span><br><span class="line">dwc2_flush_txfifo(<span class="number">0x10U</span>);</span><br><span class="line">dwc2_flush_rxfifo();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">uint8_t</span> i = <span class="number">0U</span>; i &lt; CONFIG_USBDEV_EP_NUM; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0U</span>) &#123;  <span class="comment">//使能0端点,发送ACK</span></span><br><span class="line">        USB_OTG_INEP(i)-&gt;DIEPCTL = USB_OTG_DIEPCTL_SNAK;</span><br><span class="line">        USB_OTG_OUTEP(i)-&gt;DOEPCTL = USB_OTG_DOEPCTL_SNAK;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">//禁用非0端点,发送NACK</span></span><br><span class="line">        <span class="keyword">if</span> (USB_OTG_INEP(i)-&gt;DIEPCTL &amp; USB_OTG_DIEPCTL_EPENA) &#123;</span><br><span class="line">            USB_OTG_INEP(i)-&gt;DIEPCTL = (USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            USB_OTG_INEP(i)-&gt;DIEPCTL = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (USB_OTG_OUTEP(i)-&gt;DOEPCTL &amp; USB_OTG_DOEPCTL_EPENA) &#123;</span><br><span class="line">            USB_OTG_OUTEP(i)-&gt;DOEPCTL = (USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            USB_OTG_OUTEP(i)-&gt;DOEPCTL = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    USB_OTG_INEP(i)-&gt;DIEPTSIZ = <span class="number">0U</span>;         <span class="comment">//清除发送端点传输大小</span></span><br><span class="line">    USB_OTG_INEP(i)-&gt;DIEPINT = <span class="number">0xFBFFU</span>;     <span class="comment">//清除发送端点中断标志</span></span><br><span class="line">    USB_OTG_OUTEP(i)-&gt;DOEPTSIZ = <span class="number">0U</span>;        <span class="comment">//清除接收端点传输大小</span></span><br><span class="line">    USB_OTG_OUTEP(i)-&gt;DOEPINT = <span class="number">0xFBFFU</span>;    <span class="comment">//清除接收端点中断标志</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">USB_OTG_DEV-&gt;DAINTMSK |= <span class="number">0x10001U</span>;          <span class="comment">//解除0端点中断屏蔽</span></span><br><span class="line"></span><br><span class="line">USB_OTG_DEV-&gt;DOEPMSK = USB_OTG_DOEPMSK_STUPM |  <span class="comment">//OUT端点使能SETUP阶段完成中断</span></span><br><span class="line">                        USB_OTG_DOEPMSK_XFRCM;  <span class="comment">//OUT端点使能传输完成中断</span></span><br><span class="line"></span><br><span class="line">USB_OTG_DEV-&gt;DIEPMSK = USB_OTG_DIEPMSK_XFRCM;   <span class="comment">//IN端点使能传输完成中断</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;g_dwc2_udc, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> dwc2_udc));</span><br><span class="line">usbd_event_reset_handler(<span class="number">0</span>);        <span class="comment">//USB复位事件处理</span></span><br><span class="line"><span class="comment">/* Start reading setup */</span></span><br><span class="line">dwc2_ep0_start_read_setup((<span class="type">uint8_t</span> *)&amp;g_dwc2_udc.setup);</span><br></pre></td></tr></table></figure>

<h3 id="USB-OUT端点中断-USB-OTG-GINTSTS-OEPINT"><a href="#USB-OUT端点中断-USB-OTG-GINTSTS-OEPINT" class="headerlink" title="USB OUT端点中断 USB_OTG_GINTSTS_OEPINT"></a>USB OUT端点中断 USB_OTG_GINTSTS_OEPINT</h3><ol>
<li>接收到OUT0端点中断</li>
</ol>
<ul>
<li>xfer_len &#x3D; 0,没接收到,再次接收;<code>dwc2_ep0_start_read_setup</code></li>
<li><code>usbd_event_ep_out_complete_handler</code></li>
</ul>
<ol start="2">
<li>接收其他OUT端点中断</li>
</ol>
<ul>
<li>执行<code>usbd_event_ep_out_complete_handler</code>处理接收完成事件</li>
</ul>
<ol start="3">
<li>接收到setup完成中断 <code>USB_OTG_DOEPINT_STUP</code></li>
</ol>
<ul>
<li><code>usbd_event_ep0_setup_complete_handler</code></li>
<li>STUP：SETUP 阶段完成 (SETUP phase done):仅适用于控制 OUT 端点。指示控制端点的 SETUP 阶段已完成，当前控制传输中不再接收到连续的 SETUP 数据包。在此中断上，应用程序可以对接收到的 SETUP 数据包进行解码。</li>
</ul>
<ol start="4">
<li>setup流程</li>
</ol>
<ul>
<li>初始化完成触发RESET中断执行<code>dwc2_ep0_start_read_setup</code></li>
<li>DMA接收或<code>USB_OTG_GINTSTS_RXFLVL</code>中断触发接收完成,执行<code>dwc2_ep_read((uint8_t *)&amp;g_dwc2_udc.setup, read_count);</code>完成SETUP包接收</li>
<li>主机发送SETUP包,触发SETUP中断,执行<code>usbd_event_ep0_setup_complete_handler</code></li>
<li>接收完成触发XFRC中断,执行<code>usbd_event_ep_out_complete_handler</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">ep_idx = <span class="number">0</span>;</span><br><span class="line">ep_intr = dwc2_get_outeps_intstatus();</span><br><span class="line"><span class="keyword">while</span> (ep_intr != <span class="number">0U</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((ep_intr &amp; <span class="number">0x1U</span>) != <span class="number">0U</span>) &#123;                       <span class="comment">//获取是哪个端点产生的中断</span></span><br><span class="line">        epint = dwc2_get_outep_intstatus(ep_idx);       <span class="comment">//获取端点中断状态</span></span><br><span class="line">        <span class="type">uint32_t</span> DoepintReg = USB_OTG_OUTEP(ep_idx)-&gt;DOEPINT;</span><br><span class="line">        USB_OTG_OUTEP(ep_idx)-&gt;DOEPINT = DoepintReg;    <span class="comment">//清除中断标志</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((epint &amp; USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ep_idx == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g_dwc2_udc.out_ep[ep_idx].xfer_len == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">/* Out status, start reading setup */</span></span><br><span class="line">                    dwc2_ep0_start_read_setup((<span class="type">uint8_t</span> *)&amp;g_dwc2_udc.setup);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    g_dwc2_udc.out_ep[ep_idx].actual_xfer_len = g_dwc2_udc.out_ep[ep_idx].xfer_len - ((USB_OTG_OUTEP(ep_idx)-&gt;DOEPTSIZ) &amp; USB_OTG_DOEPTSIZ_XFRSIZ);</span><br><span class="line">                    g_dwc2_udc.out_ep[ep_idx].xfer_len = <span class="number">0</span>;</span><br><span class="line">                    usbd_event_ep_out_complete_handler(<span class="number">0</span>, <span class="number">0x00</span>, g_dwc2_udc.out_ep[ep_idx].actual_xfer_len);  <span class="comment">//执行usbd_event_ep0_out_complete_handler</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                g_dwc2_udc.out_ep[ep_idx].actual_xfer_len = g_dwc2_udc.out_ep[ep_idx].xfer_len - ((USB_OTG_OUTEP(ep_idx)-&gt;DOEPTSIZ) &amp; USB_OTG_DOEPTSIZ_XFRSIZ);</span><br><span class="line">                g_dwc2_udc.out_ep[ep_idx].xfer_len = <span class="number">0</span>;</span><br><span class="line">                usbd_event_ep_out_complete_handler(<span class="number">0</span>, ep_idx, g_dwc2_udc.out_ep[ep_idx].actual_xfer_len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((epint &amp; USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP) &#123;</span><br><span class="line">            usbd_event_ep0_setup_complete_handler(<span class="number">0</span>, (<span class="type">uint8_t</span> *)&amp;g_dwc2_udc.setup);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ep_intr &gt;&gt;= <span class="number">1U</span>;</span><br><span class="line">    ep_idx++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="USB-RxFIFO-nonempty-中断-USB-OTG-GINTSTS-RXFLVL"><a href="#USB-RxFIFO-nonempty-中断-USB-OTG-GINTSTS-RXFLVL" class="headerlink" title="USB RxFIFO nonempty 中断 USB_OTG_GINTSTS_RXFLVL"></a>USB RxFIFO nonempty 中断 USB_OTG_GINTSTS_RXFLVL</h3><ol>
<li>屏蔽接收中断</li>
<li>是数据包,传入<code>xfer_buf</code></li>
<li>是SETUP包,传入<code>g_dwc2_udc.setup</code></li>
<li>解除接收中断屏蔽</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">USB_MASK_INTERRUPT(USB_OTG_GLB, USB_OTG_GINTSTS_RXFLVL);</span><br><span class="line"></span><br><span class="line">temp = USB_OTG_GLB-&gt;GRXSTSP;</span><br><span class="line">ep_idx = temp &amp; USB_OTG_GRXSTSP_EPNUM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (((temp &amp; USB_OTG_GRXSTSP_PKTSTS) &gt;&gt; USB_OTG_GRXSTSP_PKTSTS_Pos) == STS_DATA_UPDT) &#123;</span><br><span class="line">    <span class="comment">//读取数据包</span></span><br><span class="line">    read_count = (temp &amp; USB_OTG_GRXSTSP_BCNT) &gt;&gt; <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (read_count != <span class="number">0</span>) &#123;</span><br><span class="line">        dwc2_ep_read(g_dwc2_udc.out_ep[ep_idx].xfer_buf, read_count);</span><br><span class="line">        g_dwc2_udc.out_ep[ep_idx].xfer_buf += read_count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (((temp &amp; USB_OTG_GRXSTSP_PKTSTS) &gt;&gt; USB_OTG_GRXSTSP_PKTSTS_Pos) == STS_SETUP_UPDT) &#123;</span><br><span class="line">    <span class="comment">//读取SETUP包</span></span><br><span class="line">    read_count = (temp &amp; USB_OTG_GRXSTSP_BCNT) &gt;&gt; <span class="number">4</span>;</span><br><span class="line">    dwc2_ep_read((<span class="type">uint8_t</span> *)&amp;g_dwc2_udc.setup, read_count);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line">USB_UNMASK_INTERRUPT(USB_OTG_GLB, USB_OTG_GINTSTS_RXFLVL);</span><br></pre></td></tr></table></figure>

<h3 id="USB-IN端点中断-USB-OTG-GINTSTS-IEPINT"><a href="#USB-IN端点中断-USB-OTG-GINTSTS-IEPINT" class="headerlink" title="USB IN端点中断 USB_OTG_GINTSTS_IEPINT"></a>USB IN端点中断 USB_OTG_GINTSTS_IEPINT</h3><ol>
<li>USB_OTG_DIEPINT_TXFE 触发,执行<code>dwc2_tx_fifo_empty_procecss</code></li>
<li>USB_OTG_DIEPINT_XFRC 触发,执行<code>usbd_event_ep_in_complete_handler</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (ep_intr != <span class="number">0U</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((ep_intr &amp; <span class="number">0x1U</span>) != <span class="number">0U</span>) &#123;</span><br><span class="line">        epint = dwc2_get_inep_intstatus(ep_idx);</span><br><span class="line">        <span class="type">uint32_t</span> DiepintReg = USB_OTG_INEP(ep_idx)-&gt;DIEPINT;</span><br><span class="line">        USB_OTG_INEP(ep_idx)-&gt;DIEPINT = DiepintReg;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((epint &amp; USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ep_idx == <span class="number">0</span>) &#123;</span><br><span class="line">                g_dwc2_udc.in_ep[ep_idx].actual_xfer_len = g_dwc2_udc.in_ep[ep_idx].xfer_len - ((USB_OTG_INEP(ep_idx)-&gt;DIEPTSIZ) &amp; USB_OTG_DIEPTSIZ_XFRSIZ);</span><br><span class="line">                g_dwc2_udc.in_ep[ep_idx].xfer_len = <span class="number">0</span>;</span><br><span class="line">                usbd_event_ep_in_complete_handler(<span class="number">0</span>, <span class="number">0x80</span>, g_dwc2_udc.in_ep[ep_idx].actual_xfer_len);   <span class="comment">//执行usbd_event_ep0_in_complete_handler</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (g_dwc2_udc.setup.wLength &amp;&amp; ((g_dwc2_udc.setup.bmRequestType &amp; USB_REQUEST_DIR_MASK) == USB_REQUEST_DIR_OUT)) &#123;</span><br><span class="line">                    <span class="comment">/* In status, start reading setup */</span></span><br><span class="line">                    dwc2_ep0_start_read_setup((<span class="type">uint8_t</span> *)&amp;g_dwc2_udc.setup);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (g_dwc2_udc.setup.wLength == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">/* In status, start reading setup */</span></span><br><span class="line">                    dwc2_ep0_start_read_setup((<span class="type">uint8_t</span> *)&amp;g_dwc2_udc.setup);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                g_dwc2_udc.in_ep[ep_idx].actual_xfer_len = g_dwc2_udc.in_ep[ep_idx].xfer_len - ((USB_OTG_INEP(ep_idx)-&gt;DIEPTSIZ) &amp; USB_OTG_DIEPTSIZ_XFRSIZ);</span><br><span class="line">                g_dwc2_udc.in_ep[ep_idx].xfer_len = <span class="number">0</span>;</span><br><span class="line">                usbd_event_ep_in_complete_handler(<span class="number">0</span>, ep_idx | <span class="number">0x80</span>, g_dwc2_udc.in_ep[ep_idx].actual_xfer_len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((epint &amp; USB_OTG_DIEPINT_TXFE) == USB_OTG_DIEPINT_TXFE) &#123;</span><br><span class="line">            dwc2_tx_fifo_empty_procecss(ep_idx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ep_intr &gt;&gt;= <span class="number">1U</span>;</span><br><span class="line">    ep_idx++;</span><br></pre></td></tr></table></figure>

<h2 id="usbd-ep-open"><a href="#usbd-ep-open" class="headerlink" title="usbd_ep_open"></a>usbd_ep_open</h2><ul>
<li>USBAEP：USB 活动端点 (USB active endpoint)<br>指示此端点在当前配置和接口中是否激活。检测到 USB 复位后，模块会为所有端点（端点0 除外）将此位清零。接收到 SetConfiguration 和 SetInterface 命令后，应用程序必须相应地对端点寄存器进行编程并将此位置 1。</li>
<li>SNPM：监听模式 (Snoop mode)<br>此位用于将端点配置为监听模式。在监听模式下，模块不会在将 OUT 数据包传输到应用存储区前检查其是否正确。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">usbd_ep_open</span><span class="params">(<span class="type">uint8_t</span> busid, <span class="type">const</span> <span class="keyword">struct</span> usb_endpoint_descriptor *ep)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> ep_idx = USB_EP_GET_IDX(ep-&gt;bEndpointAddress);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ep_idx &gt; (CONFIG_USBDEV_EP_NUM - <span class="number">1</span>)) &#123;</span><br><span class="line">        USB_LOG_ERR(<span class="string">&quot;Ep addr %02x overflow\r\n&quot;</span>, ep-&gt;bEndpointAddress);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (USB_EP_DIR_IS_OUT(ep-&gt;bEndpointAddress)) &#123;</span><br><span class="line">        g_dwc2_udc.out_ep[ep_idx].ep_mps = USB_GET_MAXPACKETSIZE(ep-&gt;wMaxPacketSize);</span><br><span class="line">        g_dwc2_udc.out_ep[ep_idx].ep_type = USB_GET_ENDPOINT_TYPE(ep-&gt;bmAttributes);</span><br><span class="line"></span><br><span class="line">        USB_OTG_DEV-&gt;DAINTMSK |= USB_OTG_DAINTMSK_OEPM &amp; (<span class="type">uint32_t</span>)(<span class="number">1UL</span> &lt;&lt; (<span class="number">16</span> + ep_idx));  <span class="comment">//解除端点中断屏蔽</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((USB_OTG_OUTEP(ep_idx)-&gt;DOEPCTL &amp; USB_OTG_DOEPCTL_USBAEP) == <span class="number">0</span>) &#123;   <span class="comment">//未激活此端点</span></span><br><span class="line">            USB_OTG_OUTEP(ep_idx)-&gt;DOEPCTL |= (USB_GET_MAXPACKETSIZE(ep-&gt;wMaxPacketSize) &amp; USB_OTG_DOEPCTL_MPSIZ) |</span><br><span class="line">                                              ((<span class="type">uint32_t</span>)USB_GET_ENDPOINT_TYPE(ep-&gt;bmAttributes) &lt;&lt; <span class="number">18</span>) |</span><br><span class="line">                                              USB_OTG_DIEPCTL_SD0PID_SEVNFRM |  <span class="comment">//配置监听模式</span></span><br><span class="line">                                              USB_OTG_DOEPCTL_USBAEP;   <span class="comment">//激活此端点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">uint16_t</span> fifo_size;</span><br><span class="line">        <span class="keyword">if</span> (ep_idx == <span class="number">0</span>) &#123;</span><br><span class="line">            fifo_size = (USB_OTG_GLB-&gt;DIEPTXF0_HNPTXFSIZ &gt;&gt; <span class="number">16</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fifo_size = (USB_OTG_GLB-&gt;DIEPTXF[ep_idx - <span class="number">1U</span>] &gt;&gt; <span class="number">16</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((fifo_size * <span class="number">4</span>) &lt; USB_GET_MAXPACKETSIZE(ep-&gt;wMaxPacketSize)) &#123;</span><br><span class="line">            USB_LOG_ERR(<span class="string">&quot;Ep addr %02x fifo overflow\r\n&quot;</span>, ep-&gt;bEndpointAddress);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        g_dwc2_udc.in_ep[ep_idx].ep_mps = USB_GET_MAXPACKETSIZE(ep-&gt;wMaxPacketSize);</span><br><span class="line">        g_dwc2_udc.in_ep[ep_idx].ep_type = USB_GET_ENDPOINT_TYPE(ep-&gt;bmAttributes);</span><br><span class="line"></span><br><span class="line">        USB_OTG_DEV-&gt;DAINTMSK |= USB_OTG_DAINTMSK_IEPM &amp; (<span class="type">uint32_t</span>)(<span class="number">1UL</span> &lt;&lt; ep_idx);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((USB_OTG_INEP(ep_idx)-&gt;DIEPCTL &amp; USB_OTG_DIEPCTL_USBAEP) == <span class="number">0</span>) &#123;</span><br><span class="line">            USB_OTG_INEP(ep_idx)-&gt;DIEPCTL |= (USB_GET_MAXPACKETSIZE(ep-&gt;wMaxPacketSize) &amp; USB_OTG_DIEPCTL_MPSIZ) |</span><br><span class="line">                                             ((<span class="type">uint32_t</span>)USB_GET_ENDPOINT_TYPE(ep-&gt;bmAttributes) &lt;&lt; <span class="number">18</span>) | (ep_idx &lt;&lt; <span class="number">22</span>) |</span><br><span class="line">                                             USB_OTG_DIEPCTL_SD0PID_SEVNFRM |</span><br><span class="line">                                             USB_OTG_DIEPCTL_USBAEP;</span><br><span class="line">        &#125;</span><br><span class="line">        dwc2_flush_txfifo(ep_idx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="dwc2-ep0-start-read-setup"><a href="#dwc2-ep0-start-read-setup" class="headerlink" title="dwc2_ep0_start_read_setup"></a>dwc2_ep0_start_read_setup</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">dwc2_ep0_start_read_setup</span><span class="params">(<span class="type">uint8_t</span> *psetup)</span></span><br><span class="line">&#123;</span><br><span class="line">    USB_OTG_OUTEP(<span class="number">0U</span>)-&gt;DOEPTSIZ = <span class="number">0U</span>;</span><br><span class="line">    USB_OTG_OUTEP(<span class="number">0U</span>)-&gt;DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT &amp; (<span class="number">1U</span> &lt;&lt; <span class="number">19</span>));  <span class="comment">//包数量</span></span><br><span class="line">    USB_OTG_OUTEP(<span class="number">0U</span>)-&gt;DOEPTSIZ |= (<span class="number">3U</span> * <span class="number">8U</span>);   <span class="comment">//包大小</span></span><br><span class="line">    USB_OTG_OUTEP(<span class="number">0U</span>)-&gt;DOEPTSIZ |= USB_OTG_DOEPTSIZ_STUPCNT;    <span class="comment">//SETUP包</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_USB_DWC2_DMA_ENABLE</span></span><br><span class="line">    USB_OTG_OUTEP(<span class="number">0U</span>)-&gt;DOEPDMA = (<span class="type">uint32_t</span>)psetup;</span><br><span class="line">    <span class="comment">/* EP enable */</span></span><br><span class="line">    USB_OTG_OUTEP(<span class="number">0U</span>)-&gt;DOEPCTL |= USB_OTG_DOEPCTL_EPENA | USB_OTG_DOEPCTL_USBAEP;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="usbd-event-ep0-setup-complete-handler"><a href="#usbd-event-ep0-setup-complete-handler" class="headerlink" title="usbd_event_ep0_setup_complete_handler"></a>usbd_event_ep0_setup_complete_handler</h2><ol>
<li>复制SETUP包</li>
<li>判断缓存长度是否满足接收要求</li>
<li>设置数据缓存</li>
<li>通过安装的处理程序处理请求,具有数据阶段的请求,继续读取数据</li>
<li>执行请求处理程序</li>
<li>检查发送长度并设置</li>
<li>复制数据到ep0_data_buf</li>
<li>发送数据或状态到主机</li>
<li>设置 zlp_flag 的目的是为了在这种情况下发送一个零长度包,让主机需要知道传输已经完成。</li>
</ol>
<ul>
<li><p>例外:情况</p>
<ol>
<li><code>SET_CONFIGURATION</code>请求执行后,返回长度为0,则发送0长度包,将<code>req_data</code>设置为<code>ep0_data_buf</code>发送</li>
</ol>
</li>
<li><p>例如<br>收到<code>80 06 00 01 00 00 12 00</code>,执行<code>usbd_get_descriptor</code>函数,发送设备描述符</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">usbd_event_ep0_setup_complete_handler</span><span class="params">(<span class="type">uint8_t</span> busid, <span class="type">uint8_t</span> *psetup)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usb_setup_packet</span> *<span class="title">setup</span> =</span> &amp;g_usbd_core[busid].setup;</span><br><span class="line">    <span class="type">uint8_t</span> *buf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//复制SETUP包</span></span><br><span class="line">    <span class="comment">// 判断缓存长度是否满足接收要求</span></span><br><span class="line"></span><br><span class="line">    g_usbd_core[busid].ep0_data_buf = g_usbd_core[busid].req_data;  <span class="comment">//设置数据缓存</span></span><br><span class="line">    g_usbd_core[busid].ep0_data_buf_residue = setup-&gt;wLength;</span><br><span class="line">    g_usbd_core[busid].ep0_data_buf_len = setup-&gt;wLength;</span><br><span class="line">    g_usbd_core[busid].zlp_flag = <span class="literal">false</span>;</span><br><span class="line">    buf = g_usbd_core[busid].ep0_data_buf;  <span class="comment">//设置数据缓存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过安装的处理程序处理请求,具有数据阶段的请求,继续读取数据</span></span><br><span class="line">    <span class="keyword">if</span> (setup-&gt;wLength &amp;&amp; ((setup-&gt;bmRequestType &amp; USB_REQUEST_DIR_MASK) == USB_REQUEST_DIR_OUT)) &#123;</span><br><span class="line">        USB_LOG_DBG(<span class="string">&quot;Start reading %d bytes from ep0\r\n&quot;</span>, setup-&gt;wLength);</span><br><span class="line">        usbd_ep_start_read(busid, USB_CONTROL_OUT_EP0, g_usbd_core[busid].ep0_data_buf, setup-&gt;wLength);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行请求处理程序</span></span><br><span class="line">    <span class="keyword">if</span> (!usbd_setup_request_handler(busid, setup, &amp;buf, &amp;g_usbd_core[busid].ep0_data_buf_len)) &#123;</span><br><span class="line">        usbd_ep_set_stall(busid, USB_CONTROL_IN_EP0);   <span class="comment">//请求处理失败,设置端点STALL</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查发送长度并设置</span></span><br><span class="line">    <span class="comment">//如果buf数据与请求的数据不一致,复制数据到ep0_data_buf</span></span><br><span class="line">    <span class="keyword">if</span> (buf != g_usbd_core[busid].ep0_data_buf) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(g_usbd_core[busid].ep0_data_buf, buf, g_usbd_core[busid].ep0_data_buf_residue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Send data or status to host */</span></span><br><span class="line">    usbd_ep_start_write(busid, USB_CONTROL_IN_EP0, g_usbd_core[busid].ep0_data_buf, g_usbd_core[busid].ep0_data_buf_residue);</span><br><span class="line">    <span class="comment">// 设置 zlp_flag 的目的是为了在这种情况下发送一个零长度包,让主机需要知道传输已经完成。</span></span><br><span class="line">    <span class="keyword">if</span> ((setup-&gt;wLength &gt; g_usbd_core[busid].ep0_data_buf_len) &amp;&amp; (!(g_usbd_core[busid].ep0_data_buf_len % USB_CTRL_EP_MPS))) &#123;</span><br><span class="line">        g_usbd_core[busid].zlp_flag = <span class="literal">true</span>;</span><br><span class="line">        USB_LOG_DBG(<span class="string">&quot;EP0 Set zlp\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="usbd-ep-start-read"><a href="#usbd-ep-start-read" class="headerlink" title="usbd_ep_start_read"></a>usbd_ep_start_read</h2><ol>
<li>确保数据地址是4字节对齐</li>
<li>数据长度为0</li>
</ol>
<ul>
<li>数据长度为0,设置数据包数量为1,传输大小为端点最大包大小,使能端点</li>
</ul>
<ol start="3">
<li>端点0</li>
</ol>
<ul>
<li>端点0,数据长度大于端点最大包大小,设置数据长度为端点最大包大小,数据长度小于端点最大包大小,设置数据长度为数据长度</li>
</ul>
<ol start="4">
<li>其他端点</li>
</ol>
<ul>
<li>允许多次传输,计算数据包数量,设置数据包数量,传输大小为数据长度</li>
</ul>
<ol start="5">
<li>中断中执行数据接收,或者DMA自动接收</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">usbd_ep_start_read</span><span class="params">(<span class="type">uint8_t</span> busid, <span class="type">const</span> <span class="type">uint8_t</span> ep, <span class="type">uint8_t</span> *data, <span class="type">uint32_t</span> data_len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> ep_idx = USB_EP_GET_IDX(ep);</span><br><span class="line">    <span class="type">uint32_t</span> pktcnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (((<span class="type">uint32_t</span>)data) &amp; <span class="number">0x03</span>) &#123;  <span class="comment">//确保数据地址是4字节对齐</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data_len == <span class="number">0</span>) &#123;    <span class="comment">//数据长度为0</span></span><br><span class="line">        USB_OTG_OUTEP(ep_idx)-&gt;DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT &amp; (<span class="number">1</span> &lt;&lt; <span class="number">19</span>));</span><br><span class="line">        USB_OTG_OUTEP(ep_idx)-&gt;DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ &amp; g_dwc2_udc.out_ep[ep_idx].ep_mps);</span><br><span class="line">        USB_OTG_OUTEP(ep_idx)-&gt;DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ep_idx == <span class="number">0</span>) &#123;  <span class="comment">//端点0</span></span><br><span class="line">        <span class="keyword">if</span> (data_len &gt; g_dwc2_udc.out_ep[ep_idx].ep_mps) &#123;  <span class="comment">//不允许多次传输</span></span><br><span class="line">            data_len = g_dwc2_udc.out_ep[ep_idx].ep_mps;</span><br><span class="line">        &#125;</span><br><span class="line">        g_dwc2_udc.out_ep[ep_idx].xfer_len = data_len;</span><br><span class="line">        USB_OTG_OUTEP(ep_idx)-&gt;DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT &amp; (<span class="number">1U</span> &lt;&lt; <span class="number">19</span>));</span><br><span class="line">        USB_OTG_OUTEP(ep_idx)-&gt;DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ &amp; data_len);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">//其他端点 允许多次传输</span></span><br><span class="line">        pktcnt = (<span class="type">uint16_t</span>)((data_len + g_dwc2_udc.out_ep[ep_idx].ep_mps - <span class="number">1U</span>) / g_dwc2_udc.out_ep[ep_idx].ep_mps);</span><br><span class="line"></span><br><span class="line">        USB_OTG_OUTEP(ep_idx)-&gt;DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT &amp; (pktcnt &lt;&lt; <span class="number">19</span>));</span><br><span class="line">        USB_OTG_OUTEP(ep_idx)-&gt;DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ &amp; data_len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使能接收</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="usbd-ep-set-stall"><a href="#usbd-ep-set-stall" class="headerlink" title="usbd_ep_set_stall"></a>usbd_ep_set_stall</h3><ul>
<li>停止端点传输,设置端点STALL</li>
</ul>
<h2 id="usbd-ep-start-write"><a href="#usbd-ep-start-write" class="headerlink" title="usbd_ep_start_write"></a>usbd_ep_start_write</h2><ul>
<li><p>同read类似</p>
</li>
<li><p>数据为<code>USB_ENDPOINT_TYPE_ISOCHRONOUS</code>,执行额外操作</p>
</li>
<li><p>数据长度为0,设置数据包数量为1,传输大小为端点最大包大小,使能端点</p>
</li>
</ul>
<h2 id="dwc2-tx-fifo-empty-procecss"><a href="#dwc2-tx-fifo-empty-procecss" class="headerlink" title="dwc2_tx_fifo_empty_procecss"></a>dwc2_tx_fifo_empty_procecss</h2><ul>
<li>发送数据到端点FIFO</li>
</ul>
<h2 id="usbd-event-ep0-in-complete-handler"><a href="#usbd-event-ep0-in-complete-handler" class="headerlink" title="usbd_event_ep0_in_complete_handler"></a>usbd_event_ep0_in_complete_handler</h2><ul>
<li><code>usbd_event_ep0_setup_complete_handler</code>会对<code>ep0_data_buf</code>进行处理,处理完成后,执行<code>usbd_ep_start_write</code>,进而在中断中执行<code>usbd_event_ep0_in_complete_handler</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">usbd_event_ep0_in_complete_handler</span><span class="params">(<span class="type">uint8_t</span> busid, <span class="type">uint8_t</span> ep, <span class="type">uint32_t</span> nbytes)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usb_setup_packet</span> *<span class="title">setup</span> =</span> &amp;g_usbd_core[busid].setup;</span><br><span class="line"></span><br><span class="line">    g_usbd_core[busid].ep0_data_buf += nbytes;</span><br><span class="line">    g_usbd_core[busid].ep0_data_buf_residue -= nbytes;</span><br><span class="line"></span><br><span class="line">    USB_LOG_DBG(<span class="string">&quot;EP0 send %d bytes, %d remained\r\n&quot;</span>, nbytes, g_usbd_core[busid].ep0_data_buf_residue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (g_usbd_core[busid].ep0_data_buf_residue != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* Start sending the remain data */</span></span><br><span class="line">        usbd_ep_start_write(busid, USB_CONTROL_IN_EP0, g_usbd_core[busid].ep0_data_buf, g_usbd_core[busid].ep0_data_buf_residue);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (g_usbd_core[busid].zlp_flag == <span class="literal">true</span>) &#123;</span><br><span class="line">            g_usbd_core[busid].zlp_flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">/* Send zlp to host */</span></span><br><span class="line">            USB_LOG_DBG(<span class="string">&quot;EP0 Send zlp\r\n&quot;</span>);</span><br><span class="line">            usbd_ep_start_write(busid, USB_CONTROL_IN_EP0, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Satisfying three conditions will jump here.</span></span><br><span class="line"><span class="comment">                * 1. send status completely</span></span><br><span class="line"><span class="comment">                * 2. send zlp completely</span></span><br><span class="line"><span class="comment">                * 3. send last data completely.</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">            <span class="keyword">if</span> (setup-&gt;wLength &amp;&amp; ((setup-&gt;bmRequestType &amp; USB_REQUEST_DIR_MASK) == USB_REQUEST_DIR_IN)) &#123;</span><br><span class="line">                <span class="comment">/* if all data has sent completely, start reading out status */</span></span><br><span class="line">                usbd_ep_start_read(busid, USB_CONTROL_OUT_EP0, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="usbd-event-ep-out-complete-handler"><a href="#usbd-event-ep-out-complete-handler" class="headerlink" title="usbd_event_ep_out_complete_handler"></a>usbd_event_ep_out_complete_handler</h2><ul>
<li>同<code>usbd_event_ep0_in_complete_handler</code>流程</li>
</ul>
<h2 id="usbd-set-address"><a href="#usbd-set-address" class="headerlink" title="usbd_set_address"></a>usbd_set_address</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">usbd_set_address</span><span class="params">(<span class="type">uint8_t</span> busid, <span class="type">const</span> <span class="type">uint8_t</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    USB_OTG_DEV-&gt;DCFG &amp;= ~(USB_OTG_DCFG_DAD);</span><br><span class="line">    USB_OTG_DEV-&gt;DCFG |= ((<span class="type">uint32_t</span>)addr &lt;&lt; <span class="number">4</span>) &amp; USB_OTG_DCFG_DAD;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="device"><a href="#device" class="headerlink" title="device"></a>device</h1><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/42%20USB.assets/usbdev.svg" alt="_images&#x2F;usbdev.svg"></p>
<h2 id="core"><a href="#core" class="headerlink" title="core"></a>core</h2><h3 id="usbd-desc-register"><a href="#usbd-desc-register" class="headerlink" title="usbd_desc_register"></a>usbd_desc_register</h3><ul>
<li>注册描述符</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">usbd_desc_register</span><span class="params">(<span class="type">uint8_t</span> busid, <span class="type">const</span> <span class="type">uint8_t</span> *desc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;g_usbd_core[busid], <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> usbd_core_priv));</span><br><span class="line"></span><br><span class="line">    g_usbd_core[busid].descriptors = desc;  <span class="comment">// 注册描述符</span></span><br><span class="line">    g_usbd_core[busid].intf_offset = <span class="number">0</span>;     <span class="comment">// 接口偏移</span></span><br><span class="line"></span><br><span class="line">    g_usbd_core[busid].tx_msg[<span class="number">0</span>].ep = <span class="number">0x80</span>; <span class="comment">// 发送端点</span></span><br><span class="line">    g_usbd_core[busid].tx_msg[<span class="number">0</span>].cb = usbd_event_ep0_in_complete_handler;   <span class="comment">// 发送完成回调</span></span><br><span class="line">    g_usbd_core[busid].rx_msg[<span class="number">0</span>].ep = <span class="number">0x00</span>; <span class="comment">// 接收端点</span></span><br><span class="line">    g_usbd_core[busid].rx_msg[<span class="number">0</span>].cb = usbd_event_ep0_out_complete_handler;  <span class="comment">// 接收完成回调</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="usbd-add-interface"><a href="#usbd-add-interface" class="headerlink" title="usbd_add_interface"></a>usbd_add_interface</h3><ul>
<li>添加一个接口驱动。 添加顺序必须按照描述符顺序。</li>
<li>intf 接口驱动句柄，通常从不同 class 的 xxx_init_intf 函数获取</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">usbd_add_interface</span><span class="params">(<span class="type">uint8_t</span> busid, <span class="keyword">struct</span> usbd_interface *intf)</span></span><br><span class="line">&#123;</span><br><span class="line">    intf-&gt;intf_num = g_usbd_core[busid].intf_offset;    <span class="comment">// 接口编号</span></span><br><span class="line">    g_usbd_core[busid].intf[g_usbd_core[busid].intf_offset] = intf; <span class="comment">// 接口句柄</span></span><br><span class="line">    g_usbd_core[busid].intf_offset++;   <span class="comment">// 接口偏移</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="usbd-add-endpoint"><a href="#usbd-add-endpoint" class="headerlink" title="usbd_add_endpoint"></a>usbd_add_endpoint</h3><ul>
<li>注册端点地址和回调函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">usbd_add_endpoint</span><span class="params">(<span class="type">uint8_t</span> busid, <span class="keyword">struct</span> usbd_endpoint *ep)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (ep-&gt;ep_addr &amp; <span class="number">0x80</span>) &#123;   <span class="comment">// 发送端点,根据端点地址的最高位判断</span></span><br><span class="line">        g_usbd_core[busid].tx_msg[ep-&gt;ep_addr &amp; <span class="number">0x7f</span>].ep = ep-&gt;ep_addr;</span><br><span class="line">        g_usbd_core[busid].tx_msg[ep-&gt;ep_addr &amp; <span class="number">0x7f</span>].cb = ep-&gt;ep_cb;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 接收端点,根据端点地址的最高位判断</span></span><br><span class="line">        g_usbd_core[busid].rx_msg[ep-&gt;ep_addr &amp; <span class="number">0x7f</span>].ep = ep-&gt;ep_addr;</span><br><span class="line">        g_usbd_core[busid].rx_msg[ep-&gt;ep_addr &amp; <span class="number">0x7f</span>].cb = ep-&gt;ep_cb;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="usbd-initialize"><a href="#usbd-initialize" class="headerlink" title="usbd_initialize"></a>usbd_initialize</h3><ul>
<li>用来初始化 usb device 寄存器配置、usb 时钟、中断等，需要注意，此函数必须在所有列出的 API 最后。 如果使用 os，必须放在线程中执行。</li>
<li>填入 busid 和 USB IP 的 reg base， busid 从 0 开始，不能超过 CONFIG_USBDEV_MAX_BUS</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">usbd_initialize</span><span class="params">(<span class="type">uint8_t</span> busid, <span class="type">uint32_t</span> reg_base, <span class="type">void</span> (*event_handler)(<span class="type">uint8_t</span> busid, <span class="type">uint8_t</span> event))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usbd_bus</span> *<span class="title">bus</span>;</span></span><br><span class="line">    bus = &amp;g_usbdev_bus[busid];</span><br><span class="line">    bus-&gt;reg_base = reg_base;</span><br><span class="line">    g_usbd_core[busid].event_handler = event_handler;</span><br><span class="line"></span><br><span class="line">    ret = usb_dc_init(busid);   <span class="comment">//初始化USB设备寄存器</span></span><br><span class="line">    usbd_class_event_notify_handler(busid, USBD_EVENT_INIT, <span class="literal">NULL</span>);  <span class="comment">//执行接口通知函数</span></span><br><span class="line">    g_usbd_core[busid].event_handler(busid, USBD_EVENT_INIT);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="usbd-class-event-notify-handler"><a href="#usbd-class-event-notify-handler" class="headerlink" title="usbd_class_event_notify_handler"></a>usbd_class_event_notify_handler</h3><ul>
<li>执行接口通知函数:<code>intf-&gt;notify_handler(busid, event, arg);</code></li>
</ul>
<h3 id="usbd-event-reset-handler"><a href="#usbd-event-reset-handler" class="headerlink" title="usbd_event_reset_handler"></a>usbd_event_reset_handler</h3><ol>
<li>设置USB设备地址为0</li>
<li>清空配置</li>
<li>配置IN端点</li>
<li>配置OUT端点</li>
<li>执行接口通知函数</li>
<li>执行事件处理函数</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">usbd_event_reset_handler</span><span class="params">(<span class="type">uint8_t</span> busid)</span></span><br><span class="line">&#123;</span><br><span class="line">    usbd_set_address(busid, <span class="number">0</span>); <span class="comment">//设置USB设备地址为0</span></span><br><span class="line">    g_usbd_core[busid].configuration = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_USBDEV_ADVANCE_DESC</span></span><br><span class="line">    g_usbd_core[busid].speed = USB_SPEED_UNKNOWN;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usb_endpoint_descriptor</span> <span class="title">ep0</span>;</span></span><br><span class="line"></span><br><span class="line">    ep0.bLength = <span class="number">7</span>;</span><br><span class="line">    ep0.bDescriptorType = USB_DESCRIPTOR_TYPE_ENDPOINT;</span><br><span class="line">    ep0.wMaxPacketSize = USB_CTRL_EP_MPS;</span><br><span class="line">    ep0.bmAttributes = USB_ENDPOINT_TYPE_CONTROL;</span><br><span class="line">    ep0.bEndpointAddress = USB_CONTROL_IN_EP0;</span><br><span class="line">    ep0.bInterval = <span class="number">0</span>;</span><br><span class="line">    usbd_ep_open(busid, &amp;ep0);  <span class="comment">//配置IN端点</span></span><br><span class="line"></span><br><span class="line">    ep0.bEndpointAddress = USB_CONTROL_OUT_EP0;</span><br><span class="line">    usbd_ep_open(busid, &amp;ep0);  <span class="comment">//配置OUT端点</span></span><br><span class="line"></span><br><span class="line">    usbd_class_event_notify_handler(busid, USBD_EVENT_RESET, <span class="literal">NULL</span>);</span><br><span class="line">    g_usbd_core[busid].event_handler(busid, USBD_EVENT_RESET);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="usbd-setup-request-handler"><a href="#usbd-setup-request-handler" class="headerlink" title="usbd_setup_request_handler"></a>usbd_setup_request_handler</h3><ul>
<li>处理setup请求</li>
</ul>
<h4 id="USB-REQUEST-STANDARD-0x00-标准请求"><a href="#USB-REQUEST-STANDARD-0x00-标准请求" class="headerlink" title="USB_REQUEST_STANDARD 0x00 标准请求"></a>USB_REQUEST_STANDARD 0x00 标准请求</h4><ul>
<li><code>usbd_standard_request_handler</code></li>
</ul>
<h5 id="USB-REQUEST-RECIPIENT-DEVICE-0x00-设备"><a href="#USB-REQUEST-RECIPIENT-DEVICE-0x00-设备" class="headerlink" title="USB_REQUEST_RECIPIENT_DEVICE 0x00 设备"></a>USB_REQUEST_RECIPIENT_DEVICE 0x00 设备</h5><ul>
<li><code>usbd_std_device_req_handler</code></li>
</ul>
<h6 id="USB-REQUEST-GET-STATUS-0x00-获取设备状态"><a href="#USB-REQUEST-GET-STATUS-0x00-获取设备状态" class="headerlink" title="USB_REQUEST_GET_STATUS 0x00 获取设备状态"></a>USB_REQUEST_GET_STATUS 0x00 获取设备状态</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* bit 0: self-powered */</span></span><br><span class="line"><span class="comment">/* bit 1: remote wakeup */</span></span><br><span class="line">(*data)[<span class="number">0</span>] = <span class="number">0x00</span>;</span><br><span class="line">(*data)[<span class="number">1</span>] = <span class="number">0x00</span>;</span><br><span class="line">*len = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h6 id="USB-REQUEST-CLEAR-FEATURE-0x01-清除设备特性"><a href="#USB-REQUEST-CLEAR-FEATURE-0x01-清除设备特性" class="headerlink" title="USB_REQUEST_CLEAR_FEATURE 0x01 清除设备特性"></a>USB_REQUEST_CLEAR_FEATURE 0x01 清除设备特性</h6><h6 id="USB-REQUEST-SET-FEATURE-0x03-设置设备特性"><a href="#USB-REQUEST-SET-FEATURE-0x03-设置设备特性" class="headerlink" title="USB_REQUEST_SET_FEATURE 0x03 设置设备特性"></a>USB_REQUEST_SET_FEATURE 0x03 设置设备特性</h6><h6 id="USB-REQUEST-SET-ADDRESS-0x05-设置设备地址"><a href="#USB-REQUEST-SET-ADDRESS-0x05-设置设备地址" class="headerlink" title="USB_REQUEST_SET_ADDRESS 0x05 设置设备地址"></a>USB_REQUEST_SET_ADDRESS 0x05 设置设备地址</h6><ul>
<li>调用IP层设置设备地址</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">usbd_set_address(busid, value);</span><br><span class="line">*len = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h6 id="USB-REQUEST-GET-DESCRIPTOR-0x06-获取描述符"><a href="#USB-REQUEST-GET-DESCRIPTOR-0x06-获取描述符" class="headerlink" title="USB_REQUEST_GET_DESCRIPTOR 0x06 获取描述符"></a>USB_REQUEST_GET_DESCRIPTOR 0x06 获取描述符</h6><ul>
<li><p>执行<code>ret = usbd_get_descriptor(busid, value, data, len);</code></p>
</li>
<li><p>例如接收到:<code>80 06 00 01 00 00 12 00</code>,执行<code>usbd_get_descriptor</code>函数,返回设备描述符以及长度</p>
</li>
<li><p>调用<code>usbd_desc_register</code>用于注册描述符</p>
</li>
</ul>
<p>例如<code>usbd_desc_register(busid, cdc_descriptor);</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">usbd_get_descriptor</span><span class="params">(<span class="type">uint8_t</span> busid, <span class="type">uint16_t</span> type_index, <span class="type">uint8_t</span> **data, <span class="type">uint32_t</span> *len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> type = <span class="number">0U</span>;</span><br><span class="line">    <span class="type">uint8_t</span> index = <span class="number">0U</span>;</span><br><span class="line">    <span class="type">uint8_t</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">uint32_t</span> cur_index = <span class="number">0U</span>;</span><br><span class="line">    <span class="type">bool</span> found = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    type = HI_BYTE(type_index);</span><br><span class="line">    index = LO_BYTE(type_index);</span><br><span class="line"></span><br><span class="line">    p = (<span class="type">uint8_t</span> *)g_usbd_core[busid].descriptors;  <span class="comment">//获取描述符</span></span><br><span class="line"></span><br><span class="line">    cur_index = <span class="number">0U</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找描述符</span></span><br><span class="line">    <span class="keyword">while</span> (p[DESC_bLength] != <span class="number">0U</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[DESC_bDescriptorType] == type) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur_index == index) &#123;</span><br><span class="line">                found = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cur_index++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* skip to next descriptor */</span></span><br><span class="line">        p += p[DESC_bLength];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回描述符及长度</span></span><br><span class="line">    <span class="keyword">if</span> (found) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((type == USB_DESCRIPTOR_TYPE_CONFIGURATION) || ((type == USB_DESCRIPTOR_TYPE_OTHER_SPEED))) &#123;</span><br><span class="line">            <span class="comment">/* configuration or other speed descriptor is an</span></span><br><span class="line"><span class="comment">             * exception, length is at offset 2 and 3</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            *len = (p[CONF_DESC_wTotalLength]) |</span><br><span class="line">                   (p[CONF_DESC_wTotalLength + <span class="number">1</span>] &lt;&lt; <span class="number">8</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* normally length is at offset 0 */</span></span><br><span class="line">            *len = p[DESC_bLength];</span><br><span class="line">        &#125;</span><br><span class="line">        *data = p;</span><br><span class="line">        <span class="comment">//memcpy(*data, p, *len);</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* nothing found */</span></span><br><span class="line">        USB_LOG_ERR(<span class="string">&quot;descriptor &lt;type:0x%02x,index:0x%02x&gt; not found!\r\n&quot;</span>, type, index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="USB-REQUEST-SET-DESCRIPTOR-0x07-设置描述符"><a href="#USB-REQUEST-SET-DESCRIPTOR-0x07-设置描述符" class="headerlink" title="USB_REQUEST_SET_DESCRIPTOR 0x07 设置描述符"></a>USB_REQUEST_SET_DESCRIPTOR 0x07 设置描述符</h6><h6 id="USB-REQUEST-GET-CONFIGURATION-0x08-获取配置"><a href="#USB-REQUEST-GET-CONFIGURATION-0x08-获取配置" class="headerlink" title="USB_REQUEST_GET_CONFIGURATION 0x08 获取配置"></a>USB_REQUEST_GET_CONFIGURATION 0x08 获取配置</h6><h6 id="USB-REQUEST-SET-CONFIGURATION-0x09-设置配置"><a href="#USB-REQUEST-SET-CONFIGURATION-0x09-设置配置" class="headerlink" title="USB_REQUEST_SET_CONFIGURATION 0x09 设置配置"></a>USB_REQUEST_SET_CONFIGURATION 0x09 设置配置</h6><ul>
<li><p><code>wValue</code>字段的下一个字节指定所需的配置。此配置值必须为零或与配置描述符中的配置值匹配。如果配置值为零，则设备处于地址状态。保留wValue字段的上一个字节。</p>
</li>
<li><p><code>usbd_set_configuration</code>执行流程</p>
<ol>
<li>遍历全局描述符,找到配置描述符,标记为<code>found</code></li>
<li>找到接口描述符,记录<code>cur_alt_setting</code></li>
<li>找打端点描述符,匹配配置和接口,执行<code>usbd_set_endpoint</code></li>
</ol>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">value &amp;= <span class="number">0xFF</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!usbd_set_configuration(busid, value, <span class="number">0</span>)) &#123;</span><br><span class="line">    ret = <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    g_usbd_core[busid].configuration = value;</span><br><span class="line">    usbd_class_event_notify_handler(busid, USBD_EVENT_CONFIGURED, <span class="literal">NULL</span>);    <span class="comment">//执行接口通知函数</span></span><br><span class="line">    g_usbd_core[busid].event_handler(busid, USBD_EVENT_CONFIGURED);   <span class="comment">//执行事件处理函数</span></span><br><span class="line">&#125;</span><br><span class="line">*len = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>


<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">usbd_set_configuration</span><span class="params">(<span class="type">uint8_t</span> busid, <span class="type">uint8_t</span> config_index, <span class="type">uint8_t</span> alt_setting)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> cur_alt_setting = <span class="number">0xFF</span>;</span><br><span class="line">    <span class="type">uint8_t</span> cur_config = <span class="number">0xFF</span>;</span><br><span class="line">    <span class="type">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span> *p;</span><br><span class="line">    <span class="type">uint32_t</span> desc_len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> current_desc_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    p = (<span class="type">uint8_t</span> *)g_usbd_core[busid].descriptors;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* configure endpoints for this configuration/altsetting */</span></span><br><span class="line">    <span class="keyword">while</span> (p[DESC_bLength] != <span class="number">0U</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (p[DESC_bDescriptorType]) &#123;</span><br><span class="line">            <span class="keyword">case</span> USB_DESCRIPTOR_TYPE_CONFIGURATION:</span><br><span class="line">                <span class="comment">/* remember current configuration index */</span></span><br><span class="line">                cur_config = p[CONF_DESC_bConfigurationValue];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cur_config == config_index) &#123;</span><br><span class="line">                    found = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                    current_desc_len = <span class="number">0</span>;</span><br><span class="line">                    desc_len = (p[CONF_DESC_wTotalLength]) |</span><br><span class="line">                               (p[CONF_DESC_wTotalLength + <span class="number">1</span>] &lt;&lt; <span class="number">8</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> USB_DESCRIPTOR_TYPE_INTERFACE:</span><br><span class="line">                <span class="comment">/* remember current alternate setting */</span></span><br><span class="line">                cur_alt_setting =</span><br><span class="line">                    p[INTF_DESC_bAlternateSetting];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> USB_DESCRIPTOR_TYPE_ENDPOINT:</span><br><span class="line">                <span class="keyword">if</span> ((cur_config != config_index) ||</span><br><span class="line">                    (cur_alt_setting != alt_setting)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                found = usbd_set_endpoint(busid, (<span class="keyword">struct</span> usb_endpoint_descriptor *)p);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* skip to next descriptor */</span></span><br><span class="line">        p += p[DESC_bLength];</span><br><span class="line">        current_desc_len += p[DESC_bLength];</span><br><span class="line">        <span class="keyword">if</span> (current_desc_len &gt;= desc_len &amp;&amp; desc_len) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="USB-REQUEST-GET-INTERFACE-0x0A-获取接口"><a href="#USB-REQUEST-GET-INTERFACE-0x0A-获取接口" class="headerlink" title="USB_REQUEST_GET_INTERFACE 0x0A 获取接口"></a>USB_REQUEST_GET_INTERFACE 0x0A 获取接口</h6><h6 id="USB-REQUEST-SET-INTERFACE-0x0B-设置接口"><a href="#USB-REQUEST-SET-INTERFACE-0x0B-设置接口" class="headerlink" title="USB_REQUEST_SET_INTERFACE 0x0B 设置接口"></a>USB_REQUEST_SET_INTERFACE 0x0B 设置接口</h6><ul>
<li>返回false</li>
</ul>
<h5 id="USB-REQUEST-RECIPIENT-INTERFACE-0x01-接口"><a href="#USB-REQUEST-RECIPIENT-INTERFACE-0x01-接口" class="headerlink" title="USB_REQUEST_RECIPIENT_INTERFACE 0x01 接口"></a>USB_REQUEST_RECIPIENT_INTERFACE 0x01 接口</h5><h5 id="USB-REQUEST-RECIPIENT-ENDPOINT-0x02-端点"><a href="#USB-REQUEST-RECIPIENT-ENDPOINT-0x02-端点" class="headerlink" title="USB_REQUEST_RECIPIENT_ENDPOINT  0x02 端点"></a>USB_REQUEST_RECIPIENT_ENDPOINT  0x02 端点</h5><h4 id="USB-REQUEST-CLASS-0x1-类"><a href="#USB-REQUEST-CLASS-0x1-类" class="headerlink" title="USB_REQUEST_CLASS 0x1 类"></a>USB_REQUEST_CLASS 0x1 类</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (usbd_class_request_handler(busid, setup, data, len) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    USB_LOG_ERR(<span class="string">&quot;class request error\r\n&quot;</span>);</span><br><span class="line">    usbd_print_setup(setup);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="USB-REQUEST-RECIPIENT-INTERFACE-0x01-接口-1"><a href="#USB-REQUEST-RECIPIENT-INTERFACE-0x01-接口-1" class="headerlink" title="USB_REQUEST_RECIPIENT_INTERFACE 0x01 接口"></a>USB_REQUEST_RECIPIENT_INTERFACE 0x01 接口</h5><ul>
<li>匹配对应的接口函数进行执行</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">uint8_t</span> i = <span class="number">0</span>; i &lt; g_usbd_core[busid].intf_offset; i++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usbd_interface</span> *<span class="title">intf</span> =</span> g_usbd_core[busid].intf[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (intf &amp;&amp; intf-&gt;class_interface_handler &amp;&amp; (intf-&gt;intf_num == (setup-&gt;wIndex &amp; <span class="number">0xFF</span>))) &#123;</span><br><span class="line">        <span class="keyword">return</span> intf-&gt;class_interface_handler(busid, setup, data, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="USB-REQUEST-RECIPIENT-ENDPOINT-0x02-端点-1"><a href="#USB-REQUEST-RECIPIENT-ENDPOINT-0x02-端点-1" class="headerlink" title="USB_REQUEST_RECIPIENT_ENDPOINT 0x02 端点"></a>USB_REQUEST_RECIPIENT_ENDPOINT 0x02 端点</h5><h4 id="USB-REQUEST-VENDOR-0x2-厂商"><a href="#USB-REQUEST-VENDOR-0x2-厂商" class="headerlink" title="USB_REQUEST_VENDOR 0x2 厂商"></a>USB_REQUEST_VENDOR 0x2 厂商</h4><h3 id="usbd-set-endpoint"><a href="#usbd-set-endpoint" class="headerlink" title="usbd_set_endpoint"></a>usbd_set_endpoint</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">usbd_set_endpoint</span><span class="params">(<span class="type">uint8_t</span> busid, <span class="type">const</span> <span class="keyword">struct</span> usb_endpoint_descriptor *ep)</span></span><br><span class="line">&#123;</span><br><span class="line">    USB_LOG_DBG(<span class="string">&quot;Open ep:0x%02x type:%u mps:%u\r\n&quot;</span>,</span><br><span class="line">                 ep-&gt;bEndpointAddress,</span><br><span class="line">                 USB_GET_ENDPOINT_TYPE(ep-&gt;bmAttributes),</span><br><span class="line">                 USB_GET_MAXPACKETSIZE(ep-&gt;wMaxPacketSize));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ep-&gt;bEndpointAddress &amp; <span class="number">0x80</span>) &#123;</span><br><span class="line">        g_usbd_core[busid].tx_msg[ep-&gt;bEndpointAddress &amp; <span class="number">0x7f</span>].ep_mps = USB_GET_MAXPACKETSIZE(ep-&gt;wMaxPacketSize);  <span class="comment">//设置发送端点最大包大小</span></span><br><span class="line">        g_usbd_core[busid].tx_msg[ep-&gt;bEndpointAddress &amp; <span class="number">0x7f</span>].ep_mult = USB_GET_MULT(ep-&gt;wMaxPacketSize);          <span class="comment">//设置发送端点多包</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        g_usbd_core[busid].rx_msg[ep-&gt;bEndpointAddress &amp; <span class="number">0x7f</span>].ep_mps = USB_GET_MAXPACKETSIZE(ep-&gt;wMaxPacketSize);  <span class="comment">//设置接收端点最大包大小</span></span><br><span class="line">        g_usbd_core[busid].rx_msg[ep-&gt;bEndpointAddress &amp; <span class="number">0x7f</span>].ep_mult = USB_GET_MULT(ep-&gt;wMaxPacketSize);          <span class="comment">//设置接收端点多包</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> usbd_ep_open(busid, ep) == <span class="number">0</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="CDC-Communication-Device-Class"><a href="#CDC-Communication-Device-Class" class="headerlink" title="CDC (Communication Device Class)"></a>CDC (Communication Device Class)</h2><h3 id="cdc-function"><a href="#cdc-function" class="headerlink" title="cdc function"></a>cdc function</h3><h4 id="usbd-cdc-acm-init-intf"><a href="#usbd-cdc-acm-init-intf" class="headerlink" title="usbd_cdc_acm_init_intf"></a>usbd_cdc_acm_init_intf</h4><ul>
<li>用来初始化 USB CDC ACM 类接口，并实现该接口相关的函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> usbd_interface *<span class="title function_">usbd_cdc_acm_init_intf</span><span class="params">(<span class="type">uint8_t</span> busid, <span class="keyword">struct</span> usbd_interface *intf)</span></span><br><span class="line">&#123;</span><br><span class="line">    intf-&gt;class_interface_handler = cdc_acm_class_interface_request_handler;    <span class="comment">//用来处理 USB CDC ACM 类 Setup 请求</span></span><br><span class="line">    intf-&gt;class_endpoint_handler = <span class="literal">NULL</span>;    <span class="comment">// 用来处理 USB CDC ACM 类端点请求</span></span><br><span class="line">    intf-&gt;vendor_handler = <span class="literal">NULL</span>;    <span class="comment">// 用来处理 USB CDC ACM 厂商特定的 Setup 请求</span></span><br><span class="line">    intf-&gt;notify_handler = <span class="literal">NULL</span>;    <span class="comment">// 用来处理 USB CDC 其他中断回调函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> intf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CDC-ACM-Abstract-Control-Model"><a href="#CDC-ACM-Abstract-Control-Model" class="headerlink" title="CDC-ACM (Abstract Control Model)"></a>CDC-ACM (Abstract Control Model)</h3><ul>
<li>CDC-ACM用于实现虚拟串口,无需安装驱动,系统会自动识别为串口设备;但是CDC-ACM的速度较慢,不适合高速传输,且不支持流控制;即与硬件串口无关</li>
<li>CDC-ACM的虚拟串口,如果是充当Bridge的角色，即上位机发送的数据是需要CDC设备继续下传到第三方设备，此时波特率有意义， 上位机和你的第三方设备的串口波特率必须设置为相同才能正常数据传输</li>
<li>USB CDC虚拟串口实质是USB通信，在电脑端映射成串口，波特率没有实际意义。</li>
<li>另外的实现虚拟串口的方式是VCP(Virtual COM Port),需要安装驱动,但是速度较快,支持流控制;</li>
</ul>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/42USB/1723797941724.png" alt="1723797941724"></p>
<ol start="21">
<li>主机发送<code>GET LINE CODING Request</code> 获取波特率,停止位,校验位等信息</li>
<li>设备返回波特率,停止位,校验位等信息</li>
<li>主机发送<code>SET CONTROL LINE STATE Request</code> 设置DTR和RTS</li>
<li>设备返回ACK</li>
<li>主机发送<code>SET LINE CODING Request</code> 设置波特率,停止位,校验位等信息</li>
<li>设备返回ACK</li>
<li>主机发送<code>GET LINE CODING Request</code> 获取波特率,停止位,校验位等信息</li>
<li>设备返回波特率,停止位,校验位等信息</li>
<li>URB_BULK in -&gt; 45 回应主机请求</li>
<li>URB_INTERRUPT in -&gt; 64 回应主机请求</li>
<li>主机发送<code>SET LINE CODING Request</code> 设置波特率115200</li>
</ol>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><ol>
<li><code>cdc_acm_init</code></li>
</ol>
<p>There are three classes that make up the definition for communications devices: </p>
<ul>
<li>Communications Device Class</li>
<li>Communications Interface Class</li>
<li>Data Interface Class.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!&lt; endpoint address */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CDC_IN_EP  0x81</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CDC_OUT_EP 0x02</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*!&lt; endpoint call back */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usbd_endpoint</span> <span class="title">cdc_out_ep</span> =</span> &#123;</span><br><span class="line">    .ep_addr = CDC_OUT_EP,</span><br><span class="line">    .ep_cb = usbd_cdc_acm_bulk_out</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usbd_endpoint</span> <span class="title">cdc_in_ep</span> =</span> &#123;</span><br><span class="line">    .ep_addr = CDC_IN_EP,</span><br><span class="line">    .ep_cb = usbd_cdc_acm_bulk_in</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cdc_acm_init</span><span class="params">(<span class="type">uint8_t</span> busid, <span class="type">uint32_t</span> reg_base)</span></span><br><span class="line">&#123;</span><br><span class="line">    usbd_desc_register(busid, cdc_descriptor);  <span class="comment">// 注册描述符</span></span><br><span class="line">    <span class="comment">//因为 cdc 有 2 个接口，所以我们需要调用 usbd_add_interface 2 次</span></span><br><span class="line">    usbd_add_interface(busid, usbd_cdc_acm_init_intf(busid, &amp;intf0));   <span class="comment">// 初始化intf0为CDC ACM接口,并添加到接口列表</span></span><br><span class="line">    usbd_add_interface(busid, usbd_cdc_acm_init_intf(busid, &amp;intf1));   <span class="comment">// 初始化intf1为CDC ACM接口,并添加到接口列表</span></span><br><span class="line">    usbd_add_endpoint(busid, &amp;cdc_out_ep);  <span class="comment">// 添加接收端点</span></span><br><span class="line">    usbd_add_endpoint(busid, &amp;cdc_in_ep);   <span class="comment">// 添加发送端点</span></span><br><span class="line">    usbd_initialize(busid, reg_base, usbd_event_handler);   <span class="comment">// 初始化USB设备,并注册事件处理函数,执行接口通知函数`USBD_EVENT_INIT`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="全局描述符"><a href="#全局描述符" class="headerlink" title="全局描述符"></a>全局描述符</h4><ol>
<li>设备描述符:USB2.0,基类为多功能设备类,IAD.(接口关联描述符)</li>
<li>配置描述符:接口数为2,配置值为1,属性为总线供电,最大功率为100mA</li>
<li>CDC ACM 描述符:接口数为2,类为CDC,子类为ACM,协议为V.25ter,最大包大小为64</li>
<li>第一个字符串描述符为厂商描述符, 第二个字符串描述符为产品描述符, 第三个字符串描述符为序列号描述符</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!&lt; global descriptor */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint8_t</span> cdc_descriptor[] = &#123;</span><br><span class="line">    USB_DEVICE_DESCRIPTOR_INIT(USB_2_0, <span class="number">0xEF</span>, <span class="number">0x02</span>, <span class="number">0x01</span>, USBD_VID, USBD_PID, <span class="number">0x0100</span>, <span class="number">0x01</span>),</span><br><span class="line">    USB_CONFIG_DESCRIPTOR_INIT(USB_CONFIG_SIZE, <span class="number">0x02</span>, <span class="number">0x01</span>, USB_CONFIG_BUS_POWERED, USBD_MAX_POWER),</span><br><span class="line">    CDC_ACM_DESCRIPTOR_INIT(<span class="number">0x00</span>, CDC_INT_EP, CDC_OUT_EP, CDC_IN_EP, CDC_MAX_MPS, <span class="number">0x02</span>),</span><br><span class="line">    <span class="comment">///////////////////////////////////////</span></span><br><span class="line">    <span class="comment">/// string0 descriptor</span></span><br><span class="line">    <span class="comment">///////////////////////////////////////</span></span><br><span class="line">    USB_LANGID_INIT(USBD_LANGID_STRING),</span><br><span class="line">    <span class="comment">///////////////////////////////////////</span></span><br><span class="line">    <span class="comment">/// string1 descriptor</span></span><br><span class="line">    <span class="comment">///////////////////////////////////////</span></span><br><span class="line">    <span class="number">0x14</span>,                       <span class="comment">/* bLength */</span></span><br><span class="line">    USB_DESCRIPTOR_TYPE_STRING, <span class="comment">/* bDescriptorType */</span></span><br><span class="line">    <span class="string">&#x27;C&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar0 */</span></span><br><span class="line">    <span class="string">&#x27;h&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar1 */</span></span><br><span class="line">    <span class="string">&#x27;e&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar2 */</span></span><br><span class="line">    <span class="string">&#x27;r&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar3 */</span></span><br><span class="line">    <span class="string">&#x27;r&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar4 */</span></span><br><span class="line">    <span class="string">&#x27;y&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar5 */</span></span><br><span class="line">    <span class="string">&#x27;U&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar6 */</span></span><br><span class="line">    <span class="string">&#x27;S&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar7 */</span></span><br><span class="line">    <span class="string">&#x27;B&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar8 */</span></span><br><span class="line">    <span class="comment">///////////////////////////////////////</span></span><br><span class="line">    <span class="comment">/// string2 descriptor</span></span><br><span class="line">    <span class="comment">///////////////////////////////////////</span></span><br><span class="line">    <span class="number">0x26</span>,                       <span class="comment">/* bLength */</span></span><br><span class="line">    USB_DESCRIPTOR_TYPE_STRING, <span class="comment">/* bDescriptorType */</span></span><br><span class="line">    <span class="string">&#x27;C&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar0 */</span></span><br><span class="line">    <span class="string">&#x27;h&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar1 */</span></span><br><span class="line">    <span class="string">&#x27;e&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar2 */</span></span><br><span class="line">    <span class="string">&#x27;r&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar3 */</span></span><br><span class="line">    <span class="string">&#x27;r&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar4 */</span></span><br><span class="line">    <span class="string">&#x27;y&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar5 */</span></span><br><span class="line">    <span class="string">&#x27;U&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar6 */</span></span><br><span class="line">    <span class="string">&#x27;S&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar7 */</span></span><br><span class="line">    <span class="string">&#x27;B&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar8 */</span></span><br><span class="line">    <span class="string">&#x27; &#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar9 */</span></span><br><span class="line">    <span class="string">&#x27;C&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar10 */</span></span><br><span class="line">    <span class="string">&#x27;D&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar11 */</span></span><br><span class="line">    <span class="string">&#x27;C&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar12 */</span></span><br><span class="line">    <span class="string">&#x27; &#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar13 */</span></span><br><span class="line">    <span class="string">&#x27;D&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar14 */</span></span><br><span class="line">    <span class="string">&#x27;E&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar15 */</span></span><br><span class="line">    <span class="string">&#x27;M&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar16 */</span></span><br><span class="line">    <span class="string">&#x27;O&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar17 */</span></span><br><span class="line">    <span class="comment">///////////////////////////////////////</span></span><br><span class="line">    <span class="comment">/// string3 descriptor</span></span><br><span class="line">    <span class="comment">///////////////////////////////////////</span></span><br><span class="line">    <span class="number">0x16</span>,                       <span class="comment">/* bLength */</span></span><br><span class="line">    USB_DESCRIPTOR_TYPE_STRING, <span class="comment">/* bDescriptorType */</span></span><br><span class="line">    <span class="string">&#x27;2&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar0 */</span></span><br><span class="line">    <span class="string">&#x27;0&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar1 */</span></span><br><span class="line">    <span class="string">&#x27;2&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar2 */</span></span><br><span class="line">    <span class="string">&#x27;2&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar3 */</span></span><br><span class="line">    <span class="string">&#x27;1&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar4 */</span></span><br><span class="line">    <span class="string">&#x27;2&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar5 */</span></span><br><span class="line">    <span class="string">&#x27;3&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar6 */</span></span><br><span class="line">    <span class="string">&#x27;4&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar7 */</span></span><br><span class="line">    <span class="string">&#x27;5&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar8 */</span></span><br><span class="line">    <span class="string">&#x27;6&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar9 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_USB_HS</span></span><br><span class="line">    <span class="comment">///////////////////////////////////////</span></span><br><span class="line">    <span class="comment">/// device qualifier descriptor</span></span><br><span class="line">    <span class="comment">///////////////////////////////////////</span></span><br><span class="line">    <span class="number">0x0a</span>,</span><br><span class="line">    USB_DESCRIPTOR_TYPE_DEVICE_QUALIFIER,</span><br><span class="line">    <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x02</span>,</span><br><span class="line">    <span class="number">0x02</span>,</span><br><span class="line">    <span class="number">0x02</span>,</span><br><span class="line">    <span class="number">0x01</span>,</span><br><span class="line">    <span class="number">0x40</span>,</span><br><span class="line">    <span class="number">0x01</span>,</span><br><span class="line">    <span class="number">0x00</span>,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="number">0x00</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="CDC-ACM-描述符"><a href="#CDC-ACM-描述符" class="headerlink" title="CDC_ACM 描述符"></a>CDC_ACM 描述符</h4><h5 id="描述符举例"><a href="#描述符举例" class="headerlink" title="描述符举例"></a>描述符举例</h5><ol>
<li>IAD描述符</li>
</ol>
<ul>
<li>bFunctionClass: <code>Communications Device Class</code>;参考&lt;&lt;CDC120-20101103-track.pdf&gt;&gt; 4.1</li>
<li>bFunctionSubClass: <code>Abstract Control Model</code> 0X02;参考&lt;&lt;CDC120-20101103-track.pdf&gt;&gt; 4.3</li>
<li>bFunctionProtocol: <code>AT Commands: V.250 etc</code> 0X01;参考&lt;&lt;CDC120-20101103-track.pdf&gt;&gt; 4.4</li>
<li>iFunction: 0x00; 可选的函数名字符串描述符索引。</li>
</ul>
<ol start="2">
<li>接口描述符</li>
</ol>
<ul>
<li>bInterfaceNumber: CDC ACM接口编号 0x00</li>
<li>bAlternateSetting: 0x00; 可选的备用设置号</li>
<li>bNumEndpoints: 0x01; 端点数量</li>
<li>bInterfaceClass: CDC类 0x02</li>
<li>bInterfaceSubClass: ACM接口子类 0x02</li>
<li>bInterfaceProtocol: AT Commands: V.250 etc协议 0x01</li>
<li>iInterface: 接口字符串描述符索引</li>
</ul>
<ol start="3">
<li>CDC功能描述符</li>
</ol>
<ul>
<li>bcdCDC: CDC规范版本号</li>
</ul>
<ol start="4">
<li>Call Management功能描述符</li>
</ol>
<ul>
<li>bmCapabilities:设备仅通过通信类接口发送,设备本身不处理呼叫管理</li>
<li>bDataInterface: (bFirstInterface + 1)  可选用于呼叫管理的数据类接口的接口号。</li>
</ul>
<ol start="5">
<li>抽象控制管理功能描述符</li>
</ol>
<ul>
<li>bmCapabilities: 0x02 <ul>
<li>通信组合功能        不支持</li>
<li>链路请求和状态通知   支持</li>
<li>Send_Break         不支持</li>
<li>网络链接            不支持</li>
</ul>
</li>
</ul>
<ol start="6">
<li>Union功能描述符</li>
</ol>
<ul>
<li>bMasterInterface: 通信或数据类接口的接口号，指定为联合的控制接口;</li>
<li>bSlaveInterface0: 联合中第一个从属接口的接口号</li>
<li>这里来说,<code>CALL_MANAGEMENT</code>为从属接口</li>
</ul>
<ol start="7">
<li>端点描述符</li>
</ol>
<ul>
<li>bEndpointAddress: 端点地址 0x81 (IN端点)</li>
<li>bmAttributes: 0x03 (中断传输)</li>
<li>wMaxPacketSize: 0x08 0x00 (8 bytes)</li>
<li>bInterval: 0x0a (10ms)</li>
</ul>
<ol start="8">
<li>接口描述符</li>
</ol>
<ul>
<li>bInterfaceNumber: CDC ACM接口编号 0x01</li>
<li>bAlternateSetting: 0x00; 可选的备用设置号</li>
<li>bNumEndpoints: 0x02; 端点数量</li>
<li>bInterfaceClass: 数据接口类代码 0X0A</li>
<li>bInterfaceSubClass: 0x00 无 该字段未用于Data Class接口，其值应为00h</li>
<li>bInterfaceProtocol: 0x00 无 不需要特定于类的协议</li>
<li>iInterface: ACM接口字符串描述符索引</li>
</ul>
<ol start="9">
<li>端点描述符</li>
</ol>
<ul>
<li>bEndpointAddress: 端点地址 0x02 (OUT端点)</li>
<li>bmAttributes: 0x02 (块传输)</li>
<li>wMaxPacketSize: 0x40 0x00 (64 bytes)</li>
<li>bInterval: 0x00 (不使用)</li>
</ul>
<ol start="10">
<li>端点描述符</li>
</ol>
<ul>
<li>bEndpointAddress: 端点地址 0x82 (IN端点)</li>
<li>bmAttributes: 0x02 (块传输)</li>
<li>wMaxPacketSize: 0x40 0x00 (64 bytes)</li>
<li>bInterval: 0x00 (不使用)</li>
</ul>
<ol start="11">
<li>字符串描述符</li>
</ol>
<ul>
<li>语言ID描述符</li>
<li>字符串描述符1</li>
<li>字符串描述符2</li>
<li>字符串描述符3</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    *@bFirstInterface: CDC ACM接口编号</span></span><br><span class="line"><span class="comment">    *@int_ep: CDC ACM接口中断端点</span></span><br><span class="line"><span class="comment">    *@out_ep: CDC ACM接口接收端点</span></span><br><span class="line"><span class="comment">    *@in_ep: CDC ACM接口发送端点</span></span><br><span class="line"><span class="comment">    *@wMaxPacketSize: CDC ACM接口最大包大小</span></span><br><span class="line"><span class="comment">    *@str_idx: CDC ACM接口字符串描述符索引</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CDC_ACM_DESCRIPTOR_INIT(bFirstInterface, int_ep, out_ep, in_ep, wMaxPacketSize, str_idx) \</span></span><br><span class="line"><span class="meta">    <span class="comment">/* Interface Associate */</span>                                                                  \</span></span><br><span class="line"><span class="meta">    0x08,                                                  <span class="comment">/* bLength */</span>                       \</span></span><br><span class="line"><span class="meta">    USB_DESCRIPTOR_TYPE_INTERFACE_ASSOCIATION,             <span class="comment">/* bDescriptorType */</span>               \</span></span><br><span class="line"><span class="meta">    bFirstInterface,                                       <span class="comment">/* bFirstInterface */</span>               \</span></span><br><span class="line"><span class="meta">    0x02,                                                  <span class="comment">/* bInterfaceCount */</span>               \</span></span><br><span class="line"><span class="meta">    USB_DEVICE_CLASS_CDC,                                  <span class="comment">/* bFunctionClass */</span>                \</span></span><br><span class="line"><span class="meta">    CDC_ABSTRACT_CONTROL_MODEL,                            <span class="comment">/* bFunctionSubClass */</span>             \</span></span><br><span class="line"><span class="meta">    CDC_COMMON_PROTOCOL_AT_COMMANDS,                       <span class="comment">/* bFunctionProtocol */</span>             \</span></span><br><span class="line"><span class="meta">    0x00,                                                  <span class="comment">/* iFunction */</span>                     \</span></span><br><span class="line"><span class="meta">    0x09,                                                  <span class="comment">/* bLength */</span>                       \</span></span><br><span class="line"><span class="meta">    USB_DESCRIPTOR_TYPE_INTERFACE,                         <span class="comment">/* bDescriptorType */</span>               \</span></span><br><span class="line"><span class="meta">    bFirstInterface,                                       <span class="comment">/* bInterfaceNumber */</span>              \</span></span><br><span class="line"><span class="meta">    0x00,                                                  <span class="comment">/* bAlternateSetting */</span>             \</span></span><br><span class="line"><span class="meta">    0x01,                                                  <span class="comment">/* bNumEndpoints */</span>                 \</span></span><br><span class="line"><span class="meta">    USB_DEVICE_CLASS_CDC,                                  <span class="comment">/* bInterfaceClass */</span>               \</span></span><br><span class="line"><span class="meta">    CDC_ABSTRACT_CONTROL_MODEL,                            <span class="comment">/* bInterfaceSubClass */</span>            \</span></span><br><span class="line"><span class="meta">    CDC_COMMON_PROTOCOL_AT_COMMANDS,                       <span class="comment">/* bInterfaceProtocol */</span>            \</span></span><br><span class="line"><span class="meta">    str_idx,                                               <span class="comment">/* iInterface */</span>                    \</span></span><br><span class="line"><span class="meta">    0x05,                                                  <span class="comment">/* bLength */</span>                       \</span></span><br><span class="line"><span class="meta">    CDC_CS_INTERFACE,                                      <span class="comment">/* bDescriptorType */</span>               \</span></span><br><span class="line"><span class="meta">    CDC_FUNC_DESC_HEADER,                                  <span class="comment">/* bDescriptorSubtype */</span>            \</span></span><br><span class="line"><span class="meta">    WBVAL(CDC_V1_10),                                      <span class="comment">/* bcdCDC */</span>                        \</span></span><br><span class="line"><span class="meta">    0x05,                                                  <span class="comment">/* bLength */</span>                       \</span></span><br><span class="line"><span class="meta">    CDC_CS_INTERFACE,                                      <span class="comment">/* bDescriptorType */</span>               \</span></span><br><span class="line"><span class="meta">    CDC_FUNC_DESC_CALL_MANAGEMENT,                         <span class="comment">/* bDescriptorSubtype */</span>            \</span></span><br><span class="line"><span class="meta">    0x00,                                                  <span class="comment">/* bmCapabilities */</span>                \</span></span><br><span class="line"><span class="meta">    (uint8_t)(bFirstInterface + 1),                        <span class="comment">/* bDataInterface */</span>                \</span></span><br><span class="line"><span class="meta">    0x04,                                                  <span class="comment">/* bLength */</span>                       \</span></span><br><span class="line"><span class="meta">    CDC_CS_INTERFACE,                                      <span class="comment">/* bDescriptorType */</span>               \</span></span><br><span class="line"><span class="meta">    CDC_FUNC_DESC_ABSTRACT_CONTROL_MANAGEMENT,             <span class="comment">/* bDescriptorSubtype */</span>            \</span></span><br><span class="line"><span class="meta">    0x02,                                                  <span class="comment">/* bmCapabilities */</span>                \</span></span><br><span class="line"><span class="meta">    0x05,                                                  <span class="comment">/* bLength */</span>                       \</span></span><br><span class="line"><span class="meta">    CDC_CS_INTERFACE,                                      <span class="comment">/* bDescriptorType */</span>               \</span></span><br><span class="line"><span class="meta">    CDC_FUNC_DESC_UNION,                                   <span class="comment">/* bDescriptorSubtype */</span>            \</span></span><br><span class="line"><span class="meta">    bFirstInterface,                                       <span class="comment">/* bMasterInterface */</span>              \</span></span><br><span class="line"><span class="meta">    (uint8_t)(bFirstInterface + 1),                        <span class="comment">/* bSlaveInterface0 */</span>              \</span></span><br><span class="line"><span class="meta">    0x07,                                                  <span class="comment">/* bLength */</span>                       \</span></span><br><span class="line"><span class="meta">    USB_DESCRIPTOR_TYPE_ENDPOINT,                          <span class="comment">/* bDescriptorType */</span>               \</span></span><br><span class="line"><span class="meta">    int_ep,                                                <span class="comment">/* bEndpointAddress */</span>              \</span></span><br><span class="line"><span class="meta">    0x03,                                                  <span class="comment">/* bmAttributes */</span>                  \</span></span><br><span class="line"><span class="meta">    0x08, 0x00,                                            <span class="comment">/* wMaxPacketSize */</span>                \</span></span><br><span class="line"><span class="meta">    0x0a,                                                  <span class="comment">/* bInterval */</span>                     \</span></span><br><span class="line"><span class="meta">    0x09,                                                  <span class="comment">/* bLength */</span>                       \</span></span><br><span class="line"><span class="meta">    USB_DESCRIPTOR_TYPE_INTERFACE,                         <span class="comment">/* bDescriptorType */</span>               \</span></span><br><span class="line"><span class="meta">    (uint8_t)(bFirstInterface + 1),                        <span class="comment">/* bInterfaceNumber */</span>              \</span></span><br><span class="line"><span class="meta">    0x00,                                                  <span class="comment">/* bAlternateSetting */</span>             \</span></span><br><span class="line"><span class="meta">    0x02,                                                  <span class="comment">/* bNumEndpoints */</span>                 \</span></span><br><span class="line"><span class="meta">    CDC_DATA_INTERFACE_CLASS,                              <span class="comment">/* bInterfaceClass */</span>               \</span></span><br><span class="line"><span class="meta">    0x00,                                                  <span class="comment">/* bInterfaceSubClass */</span>            \</span></span><br><span class="line"><span class="meta">    0x00,                                                  <span class="comment">/* bInterfaceProtocol */</span>            \</span></span><br><span class="line"><span class="meta">    0x00,                                                  <span class="comment">/* iInterface */</span>                    \</span></span><br><span class="line"><span class="meta">    0x07,                                                  <span class="comment">/* bLength */</span>                       \</span></span><br><span class="line"><span class="meta">    USB_DESCRIPTOR_TYPE_ENDPOINT,                          <span class="comment">/* bDescriptorType */</span>               \</span></span><br><span class="line"><span class="meta">    out_ep,                                                <span class="comment">/* bEndpointAddress */</span>              \</span></span><br><span class="line"><span class="meta">    0x02,                                                  <span class="comment">/* bmAttributes */</span>                  \</span></span><br><span class="line"><span class="meta">    WBVAL(wMaxPacketSize),                                 <span class="comment">/* wMaxPacketSize */</span>                \</span></span><br><span class="line"><span class="meta">    0x00,                                                  <span class="comment">/* bInterval */</span>                     \</span></span><br><span class="line"><span class="meta">    0x07,                                                  <span class="comment">/* bLength */</span>                       \</span></span><br><span class="line"><span class="meta">    USB_DESCRIPTOR_TYPE_ENDPOINT,                          <span class="comment">/* bDescriptorType */</span>               \</span></span><br><span class="line"><span class="meta">    in_ep,                                                 <span class="comment">/* bEndpointAddress */</span>              \</span></span><br><span class="line"><span class="meta">    0x02,                                                  <span class="comment">/* bmAttributes */</span>                  \</span></span><br><span class="line"><span class="meta">    WBVAL(wMaxPacketSize),                                 <span class="comment">/* wMaxPacketSize */</span>                \</span></span><br><span class="line"><span class="meta">    0x00                                                   <span class="comment">/* bInterval */</span></span></span><br></pre></td></tr></table></figure>

<h4 id="usbd-event-handler"><a href="#usbd-event-handler" class="headerlink" title="usbd_event_handler"></a>usbd_event_handler</h4><ul>
<li><code>USB_REQUEST_SET_CONFIGURATION</code>执行后,执行<code>g_usbd_core[busid].event_handler(busid, USBD_EVENT_CONFIGURED);</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">usbd_event_handler</span><span class="params">(<span class="type">uint8_t</span> busid, <span class="type">uint8_t</span> event)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (event) &#123;</span><br><span class="line">        <span class="keyword">case</span> USBD_EVENT_RESET:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> USBD_EVENT_CONNECTED:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> USBD_EVENT_DISCONNECTED:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> USBD_EVENT_RESUME:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> USBD_EVENT_SUSPEND:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> USBD_EVENT_CONFIGURED:</span><br><span class="line">            ep_tx_busy_flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">/* setup first out ep read transfer */</span></span><br><span class="line">            usbd_ep_start_read(busid, CDC_OUT_EP, read_buffer, <span class="number">2048</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> USBD_EVENT_SET_REMOTE_WAKEUP:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> USBD_EVENT_CLR_REMOTE_WAKEUP:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="cdc-acm-class-interface-request-handler"><a href="#cdc-acm-class-interface-request-handler" class="headerlink" title="cdc_acm_class_interface_request_handler"></a>cdc_acm_class_interface_request_handler</h4><ul>
<li>主机发送<code>GET LINE CODING Request</code>,即CLASS INTERFACE REQUEST,执行</li>
<li>进而执行此函数</li>
</ul>
<h5 id="CDC-REQUEST-GET-LINE-CODING-0x21-获取线编码"><a href="#CDC-REQUEST-GET-LINE-CODING-0x21-获取线编码" class="headerlink" title="CDC_REQUEST_GET_LINE_CODING 0x21 获取线编码"></a>CDC_REQUEST_GET_LINE_CODING 0x21 获取线编码</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__WEAK <span class="type">void</span> <span class="title function_">usbd_cdc_acm_get_line_coding</span><span class="params">(<span class="type">uint8_t</span> busid, <span class="type">uint8_t</span> intf, <span class="keyword">struct</span> cdc_line_coding *line_coding)</span></span><br><span class="line">&#123;</span><br><span class="line">    line_coding-&gt;dwDTERate = <span class="number">2000000</span>;   <span class="comment">//波特率</span></span><br><span class="line">    line_coding-&gt;bDataBits = <span class="number">8</span>;         <span class="comment">//数据位</span></span><br><span class="line">    line_coding-&gt;bParityType = <span class="number">0</span>;       <span class="comment">//校验位</span></span><br><span class="line">    line_coding-&gt;bCharFormat = <span class="number">0</span>;       <span class="comment">//停止位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="CDC-REQUEST-SET-CONTROL-LINE-STATE-0x22-设置控制线状态"><a href="#CDC-REQUEST-SET-CONTROL-LINE-STATE-0x22-设置控制线状态" class="headerlink" title="CDC_REQUEST_SET_CONTROL_LINE_STATE 0x22 设置控制线状态"></a>CDC_REQUEST_SET_CONTROL_LINE_STATE 0x22 设置控制线状态</h5><ul>
<li>dtr: 数据终端准备好 </li>
<li>rts: 请求发送</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dtr = (setup-&gt;wValue &amp; <span class="number">0x0001</span>);</span><br><span class="line">rts = (setup-&gt;wValue &amp; <span class="number">0x0002</span>);</span><br><span class="line">USB_LOG_DBG(<span class="string">&quot;Set intf:%d DTR 0x%x,RTS 0x%x\r\n&quot;</span>,</span><br><span class="line">            intf_num,</span><br><span class="line">            dtr,</span><br><span class="line">            rts);</span><br><span class="line">usbd_cdc_acm_set_dtr(busid, intf_num, dtr);</span><br><span class="line">usbd_cdc_acm_set_rts(busid, intf_num, rts);</span><br></pre></td></tr></table></figure>

<ul>
<li>例如,通过<code>usbd_cdc_acm_set_dtr</code>来实现串口打开才输出数据功能</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">usbd_cdc_acm_set_dtr</span><span class="params">(<span class="type">uint8_t</span> busid, <span class="type">uint8_t</span> intf, <span class="type">bool</span> dtr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (dtr) &#123;</span><br><span class="line">        dtr_enable = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dtr_enable = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cdc_acm_data_send_with_dtr_test</span><span class="params">(<span class="type">uint8_t</span> busid)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (dtr_enable) &#123;</span><br><span class="line">        ep_tx_busy_flag = <span class="literal">true</span>;</span><br><span class="line">        usbd_ep_start_write(busid, CDC_IN_EP, write_buffer, <span class="number">2048</span>);</span><br><span class="line">        <span class="keyword">while</span> (ep_tx_busy_flag) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="CDC-REQUEST-SET-LINE-CODING-0x20-设置线编码"><a href="#CDC-REQUEST-SET-LINE-CODING-0x20-设置线编码" class="headerlink" title="CDC_REQUEST_SET_LINE_CODING 0x20 设置线编码"></a>CDC_REQUEST_SET_LINE_CODING 0x20 设置线编码</h5><ul>
<li>同上</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memcpy</span>(&amp;line_coding, *data, setup-&gt;wLength);</span><br><span class="line">USB_LOG_DBG(<span class="string">&quot;Set intf:%d linecoding &lt;%d %d %s %s&gt;\r\n&quot;</span>,</span><br><span class="line">            intf_num,</span><br><span class="line">            line_coding.dwDTERate,</span><br><span class="line">            line_coding.bDataBits,</span><br><span class="line">            parity_name[line_coding.bParityType],</span><br><span class="line">            stop_name[line_coding.bCharFormat]);</span><br><span class="line"></span><br><span class="line">usbd_cdc_acm_set_line_coding(busid, intf_num, &amp;line_coding);</span><br></pre></td></tr></table></figure>

<h3 id="Endpoint描述符"><a href="#Endpoint描述符" class="headerlink" title="Endpoint描述符"></a>Endpoint描述符</h3><h4 id="Functional-Descriptors"><a href="#Functional-Descriptors" class="headerlink" title="Functional Descriptors"></a>Functional Descriptors</h4><ul>
<li>参考&lt;&lt;CDC120-20101103-track.pdf&gt;&gt; 5.2.3 Table 11: Functional Descriptor General Format</li>
</ul>
<h5 id="Header-Functional-Descriptor"><a href="#Header-Functional-Descriptor" class="headerlink" title="Header Functional Descriptor"></a>Header Functional Descriptor</h5><ul>
<li>类特定的描述符应该从表11中定义的头开始。bcdCDC字段标识通信设备规范的USB类定义(本规范)的发布，该接口及其描述符符合该规范。</li>
</ul>
<h5 id="Union-Functional-Descriptor"><a href="#Union-Functional-Descriptor" class="headerlink" title="Union Functional Descriptor"></a>Union Functional Descriptor</h5><ul>
<li>联合功能描述符描述了一组接口之间的关系，这些接口可以被认为是一个功能单元。它只能发生在类特定部分描述符。</li>
<li>组中的一个接口被指定为组的主接口或控制接口，并且某些特定于类的消息可以发送到该接口以对整个组起作用。类似地，整个组的通知可以从该接口发送，但适用于整个组的接口。该组中的接口可以包括通信、数据或任何其他有效的USB接口类(包括但不限于音频、HID和监视器)。</li>
</ul>
<h2 id="MSC-Mass-Storage-Class"><a href="#MSC-Mass-Storage-Class" class="headerlink" title="MSC (Mass Storage Class)"></a>MSC (Mass Storage Class)</h2><h3 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h3><h4 id="枚举过程"><a href="#枚举过程" class="headerlink" title="枚举过程"></a>枚举过程</h4><ol>
<li>忽略设备描述符及字符串描述符请求和回应过程</li>
<li>主机发送<code>GET CONFIGURATION Request</code> 获取配置描述符<ul>
<li>配置端点</li>
<li>执行<code>usbd_class_event_notify_handler(busid, USBD_EVENT_CONFIGURED, NULL);</code>,执行<code>msc_storage_notify_handler</code></li>
<li>开始读取CBW,MSC Bulk-Only Command Block Wrapper (CBW),存储至<code>g_usbd_msc[busid].cbw</code></li>
<li><code>stage</code>状态 &#x3D; MSC_READ_CBW;</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[15:58:27] [412][I/USB] Setup: bmRequestType 0x00, bRequest 0x09, wValue 0x0001, wIndex 0x0000, wLength 0x0000</span><br><span class="line">[15:58:27] [412][D/USB] Open ep:0x02 type:2 mps:64</span><br><span class="line">[15:58:27] [412][D/USB] Open ep:0x81 type:2 mps:64</span><br><span class="line">[15:58:27] [412][D/USB] Start reading cbw</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>请求类型: Class Interface Request, 方向主机到设备, 请求:Get Max LUN (GML)<ul>
<li>回复<code>0</code>lun</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[a1 fe 00 00 00 00 01 00]</span><br><span class="line">[15:58:27] [431]USB confi[I/USB] Setup: bmRequestType 0xa1, bRequest 0xfe, wValue 0x0000, wIndex 0x0000, wLength 0x0001</span><br><span class="line">[15:58:27] [431][D/USB] MSC Class request: bRequest 0xfe</span><br><span class="line">[00]</span><br><span class="line">[15:58:27] [431][D/USB] EP0 send 1 bytes, 0 remained</span><br><span class="line">[15:58:27] [447][D/USB] EP0 recv out status</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>主机通过端点2发送CBW, SCSI: Inquiry LUN: 0x00 <ul>
<li>Signature: 0x43425355 签名</li>
<li>Tag: 0x16db9010</li>
<li>Data Transfer Length: 36</li>
<li>flag: 0x80<ul>
<li>target: 0x00</li>
<li>lun: 0x00</li>
<li>CDB Length: 6</li>
</ul>
</li>
<li>CDB: 0x12</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[55 53 42 43 10 90 db 16 24 00 00 00 80 00 06 12 00 00 24 00 00 00 00 00 00 00 00 00 00 00]</span><br><span class="line">[2024/8/17 15:58:27] [448][D/USB] Decode CB:0x12</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>解码SCSI命令,执行<code>SCSI_inquiry</code>,回复设备信息<ul>
<li>外设限定符: 0x00 , 设备类型连接到逻辑单元</li>
<li>设备类型: 0x00 , 直接访问设备(磁盘)</li>
<li>RMB: 0x01 , 可移动介质</li>
<li>Device-type modifier: 0x00 不支持</li>
<li>ISO&#x2F;IEC 646: 0x02 , ASCII</li>
<li>Response data format: 0x01 , ACSI-2</li>
<li>Additional Length: 0x1f , 31 bytes</li>
<li>Vendor ID: “        “</li>
<li>Product ID: “        “</li>
<li>Product Revision: “0.01”</li>
<li>回复长度: 36</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[00 80 02 02 1f 00 00 00 20 20 20 20 20 20 20 20 0 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 30 2e 30 31]</span><br><span class="line">[2024/8/17 15:58:27] [448][D/USB] Send info len:36</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>设备通过端点1发送CSW状态(good),转入<code>MSC_READ_CBW</code>状态<ul>
<li>Signature: 0x53425355</li>
<li>Tag: 0x16db9010</li>
<li>dDataResidue: 0, 预期与实际数据长度差异</li>
<li>Status: 0x00 (Passed[good])</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[55 53 42 53 10 90 db 16 00 00 00 00 00]</span><br><span class="line">[15:58:27] [448] [D/USB] Send csw</span><br><span class="line">[15:58:27] [448]S[D/USB] Start reading cbw</span><br></pre></td></tr></table></figure>

<ol start="7">
<li><p>主机通过端点2发送CBW, SCSI Command: 0x23(READ FORMAT CAPACITIES) LUN:0x00 </p>
<ul>
<li><p>Signature: 0x43425355 签名</p>
</li>
<li><p>Tag: 0x0d89a010</p>
</li>
<li><p>Data Transfer Length: 252</p>
</li>
<li><p>flag: 0x80</p>
<ul>
<li>target: 0x00</li>
<li>lun: 0x00</li>
<li>CDB Length: 10</li>
</ul>
</li>
<li><p>CDB: 0x23 READ FORMAT CAPACITIES</p>
<ul>
<li>LUN: 0x00</li>
<li>Allocation Length: 0xfc &#x3D; 252</li>
</ul>
</li>
<li><p>设备回复容量信息(512字节块,1000块)&#x3D; 512KB</p>
<ul>
<li>Capacity List Length: 8</li>
<li>Number of blocks: 0x000003e8 &#x3D; 1000</li>
<li>Desc Type: 0x02 &#x3D; 可格式化设备</li>
<li>Block Length: 0x200 &#x3D; 512</li>
</ul>
</li>
</ul>
<p> SW状态(GOOD),转入<code>MSC_READ_CBW</code>状态</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[55 53 42 43 10 a0 89 0d fc 00 00 00 80 00 0a 23 00 00 00 00 00 00 00 fc 00 00 00 00 00 00 00]</span><br><span class="line">[15:58:27] [466][D/USB] Decode CB:0x23</span><br><span class="line"></span><br><span class="line">[00 00 00 08 00 00 03 e8 02 00 02 00]</span><br><span class="line">[15:58:27] [466][D/USB] Send info len:12</span><br><span class="line"></span><br><span class="line">[55 53 42 53 10 a0 89 0d f0 00 00 00 00]</span><br><span class="line">[15:58:27] [466][D/USB] Send csw</span><br><span class="line"></span><br><span class="line">[15:58:27] [466][D/USB] Start reading cbw</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>主机通过端点2发送CBW, SCSI Command: 0x25(READ CAPACITY) LUN:0x00 <ul>
<li><p>Signature: 0x43425355 签名</p>
</li>
<li><p>Tag: 0x17db9010</p>
</li>
<li><p>Data Transfer Length: 8</p>
</li>
<li><p>flag: 0x80</p>
<ul>
<li>target: 0x00</li>
<li>lun: 0x00</li>
<li>CDB Length: 10</li>
</ul>
</li>
<li><p>CDB: 0x25 READ CAPACITY</p>
<ul>
<li>LUN: 0x00</li>
<li>RelAdr: 0x00</li>
<li>Logical Block Address: 0x00000000</li>
<li>PMI: 0x00</li>
</ul>
</li>
<li><p>设备回复容量信息(512字节块,1000块)&#x3D; 512KB</p>
<ul>
<li>Last Logical Block Address: 0x000003e7 &#x3D; 999</li>
<li>Block Length: 0x200 &#x3D; 512</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[55 53 42 43 10 d0 0e 17 08 00 00 00 80 00 0a 25 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00]</span><br><span class="line">[15:58:27] [502][D/USB] Decode CB:0x25</span><br><span class="line"></span><br><span class="line">[00 00 03 e7 00 00 02 00]</span><br><span class="line">[15:58:27] [502][D/USB] Send info len:8</span><br><span class="line"></span><br><span class="line">[15:58:27] [550][D/USB] Send csw</span><br><span class="line">[15:58:27] [662][D/USB] Start reading cbw</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>主机通过端点2发送CBW, SCSI Command: 0x1A(MODE SENSE(6)) LUN:0x00<ul>
<li>Signature: 0x43425355 签名</li>
<li>Tag: 0x16db9010</li>
<li>Data Transfer Length: 192</li>
<li>flag: 0x80<ul>
<li>target: 0x00</li>
<li>lun: 0x00</li>
<li>CDB Length: 6</li>
</ul>
</li>
<li>CDB: 0x1A MODE SENSE(6)<ul>
<li>LUN: 0x00</li>
<li>DBD: 0x00</li>
<li>ALLOCATE LENGTH: 192</li>
<li>Control: 0x00</li>
</ul>
</li>
<li>回复设备信息<ul>
<li>Mode Data Length: 0x00</li>
<li>Medium Type: 0x00</li>
<li>Device-Specific Parameter: 0x00</li>
<li>Block Descriptor Length: 0x00</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[55 53 42 43 10 40 ff 16 c0 00 00 00 80 00 06 1a 00 1c 00 c0 00 00 00 00 00 00 00 00 00 00 00]</span><br><span class="line">[15:58:27] [662][D/USB] Decode CB:0x1a</span><br><span class="line"></span><br><span class="line">[03 00 00 00]</span><br><span class="line">[15:58:27] [662][D/USB] Send info len:4</span><br><span class="line">[15:58:27] [662][D/USB] Send csw</span><br><span class="line">[15:58:27] [662][D/USB] Start reading cbw</span><br></pre></td></tr></table></figure>

<ol start="10">
<li>主机通过端点2发送CBW, SCSI Command: 0X28(READ(10)) LUN:0x00<ul>
<li><p>Signature: 0x43425355 签名</p>
</li>
<li><p>Tag: 0X1405b290</p>
</li>
<li><p>Data Transfer Length: 512</p>
</li>
<li><p>flag: 0x80</p>
<ul>
<li>target: 0x00</li>
<li>lun: 0x00</li>
<li>CDB Length: 10</li>
</ul>
</li>
<li><p>CDB: 0x28 READ(10)</p>
<ul>
<li>LUN: 0x00</li>
<li>rdprotect: 0x00</li>
<li>dpo: 0x00</li>
<li>fua: 0x00</li>
<li>rarc: 0x00</li>
<li>Logical Block Address: 0x00000000</li>
<li>Group Number: 0x00</li>
<li>Transfer Length: 1</li>
<li>Control: 0x00</li>
</ul>
</li>
<li><p>回复返回所需LBA地址数据</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[55 53 42 43 90 b2 05 14 00 02 00 00 80 00 0a 28 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00]</span><br><span class="line">[15:58:27] [687][D/USB] Decode CB:0x28</span><br><span class="line">[15:58:27] [687][D/USB] lba: 0x0000 //读取的逻辑块地址</span><br><span class="line">[15:58:27] [687][D/USB] nsectors: 0x01 //读取的扇区数</span><br><span class="line">[15:58:27] [687][D/USB] read lba:0</span><br><span class="line"></span><br><span class="line">[0000   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00]</span><br><span class="line">[0010   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00]</span><br><span class="line">[0020   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00]</span><br><span class="line">[0030   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00]</span><br><span class="line">[0040   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00]</span><br><span class="line">[0050   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00]</span><br><span class="line">[0060   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00]</span><br><span class="line">[0070   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00]</span><br><span class="line">[0080   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00]</span><br><span class="line">[0090   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00]</span><br><span class="line">[00a0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00]</span><br><span class="line">[00b0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00]</span><br><span class="line">[00c0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00]</span><br><span class="line">[00d0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00]</span><br><span class="line">[00e0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00]</span><br><span class="line">[00f0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00]</span><br><span class="line">[0100   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00]</span><br><span class="line">[0110   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00]</span><br><span class="line">[0120   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00]</span><br><span class="line">[0130   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00]</span><br><span class="line">[0140   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00]</span><br><span class="line">[0150   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00]</span><br><span class="line">[0160   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00]</span><br><span class="line">[0170   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00]</span><br><span class="line">[0180   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00]</span><br><span class="line">[0190   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00]</span><br><span class="line">[01a0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00]</span><br><span class="line">[01b0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00]</span><br><span class="line">[01c0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00]</span><br><span class="line">[01d0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00]</span><br><span class="line">[01e0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00]</span><br><span class="line">[01f0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00]</span><br><span class="line"></span><br><span class="line">[15:58:27] [687][D/USB] Send csw</span><br><span class="line">[15:58:27] [687][D/USB] Start reading cbw</span><br></pre></td></tr></table></figure>

<ol start="11">
<li>读取lba:2的数据,读取0~15块数据</li>
</ol>
<ul>
<li>应该是获取MBR分区信息和FAT表信息</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">144 [2024/8/17 15:58:27] [746][D/USB] Decode CB:0x28</span><br><span class="line">145 [2024/8/17 15:58:27] [746][D/USB] lba: 0x0002</span><br><span class="line">146 [2024/8/17 15:58:27] [746][D/USB] nsectors: 0x01</span><br><span class="line">147 [2024/8/17 15:58:27] [757][D/USB] read lba:2</span><br><span class="line"></span><br><span class="line">209 [2024/8/17 15:58:27] [915][D/USB] Decode CB:0x28</span><br><span class="line">210 [2024/8/17 15:58:27] [915][D/USB] lba: 0x0000</span><br><span class="line">211 [2024/8/17 15:58:27] [928][D/USB] nsectors: 0x10</span><br><span class="line">212 [2024/8/17 15:58:27] [928][D/USB] read lba:0</span><br><span class="line">213 [2024/8/17 15:58:27] [928][D/USB] read lba:1</span><br><span class="line">214 [2024/8/17 15:58:27] [928][D/USB] read lba:2</span><br><span class="line">215 [2024/8/17 15:58:27] [928][D/USB] read lba:3</span><br><span class="line">216 [2024/8/17 15:58:27] [939][D/USB] read lba:4</span><br><span class="line">217 [2024/8/17 15:58:27] [939][D/USB] read lba:5</span><br><span class="line">218 [2024/8/17 15:58:27] [939][D/USB] read lba:6</span><br><span class="line">219 [2024/8/17 15:58:27] [939][D/USB] read lba:7</span><br><span class="line">220 [2024/8/17 15:58:27] [953][D/USB] read lba:8</span><br><span class="line">221 [2024/8/17 15:58:27] [953][D/USB] read lba:9</span><br><span class="line">222 [2024/8/17 15:58:27] [953][D/USB] read lba:10</span><br><span class="line">223 [2024/8/17 15:58:27] [953][D/USB] read lba:11</span><br><span class="line">224 [2024/8/17 15:58:27] [953][D/USB] read lba:12</span><br><span class="line">225 [2024/8/17 15:58:27] [965][D/USB] read lba:13</span><br><span class="line">226 [2024/8/17 15:58:27] [965][D/USB] read lba:14</span><br><span class="line">227 [2024/8/17 15:58:27] [965][D/USB] read lba:15</span><br></pre></td></tr></table></figure>

<ol start="12">
<li>主机通过端点2发送CBW, SCSI Command: 0x00(TEST UNIT READY) LUN:0x00<ul>
<li>回复(Test Unit Ready) (Good)</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[55 53 42 43 10 30 50 1d 00 00 00 00 00 00 06 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00]</span><br><span class="line">[2024/8/18 15:24:43] [240][I/USB] Decode CB:0x00</span><br><span class="line">[55 53 42 53 10 30 50 1d 00 00 00 00 00]</span><br></pre></td></tr></table></figure>

<ol start="13">
<li>发送CBW, SCSI Command: 0x1e(PREVENT-ALLOW MEDIUM REMOVAL) LUN:0x00<ul>
<li>Prevent Allow Flags: 0x00 不允许移除</li>
<li>回复(Prevent&#x2F;Allow Medium Removal) (Good)<br>发送CBW, SCSI Command: 0x1e(PREVENT-ALLOW MEDIUM REMOVAL) LUN:0x00</li>
<li>Prevent Allow Flags: 0x01 允许移除</li>
<li>回复(Prevent&#x2F;Allow Medium Removal) (Good)</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[55 53 42 43 60 95 ca 16 00 00 00 00 00 00 06 1e 00 00 00 01 00 00 00 00 00 00 00 00 00 00 00]</span><br><span class="line"> 211 [2024/8/18 15:24:43] [645][I/USB] Decode CB:0x1e</span><br><span class="line"> 212 [2024/8/18 15:24:43] [645][I/USB] Decode CB:0x1e</span><br><span class="line">[55 53 42 43 60 95 ca 16 00 00 00 00 00 00 06 1e 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00]</span><br></pre></td></tr></table></figure>

<h4 id="数据交互过程"><a href="#数据交互过程" class="headerlink" title="数据交互过程"></a>数据交互过程</h4><h5 id="不断读取LBA分区数据-wireshark抓包导致"><a href="#不断读取LBA分区数据-wireshark抓包导致" class="headerlink" title="不断读取LBA分区数据(wireshark抓包导致)"></a>不断读取LBA分区数据(wireshark抓包导致)</h5><ul>
<li>event:2 MSC_DATA_IN事件</li>
<li>?可能是未格式化缘故</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1647 [2024/8/18 15:17:42] [766][I/USB] read lba:64</span><br><span class="line">1648 [2024/8/18 15:17:42] [766][I/USB] event:2</span><br><span class="line">1649 [2024/8/18 15:17:42] [766][I/USB] read lba:65</span><br><span class="line">1650 [2024/8/18 15:17:42] [766][I/USB] event:2</span><br><span class="line">1651 [2024/8/18 15:17:42] [766][I/USB] read lba:66</span><br><span class="line">1652 [2024/8/18 15:17:42] [778][I/USB] event:2</span><br><span class="line">1653 [2024/8/18 15:17:42] [778][I/USB] read lba:67</span><br></pre></td></tr></table></figure>

<h5 id="执行格式化操作"><a href="#执行格式化操作" class="headerlink" title="执行格式化操作"></a>执行格式化操作</h5><ol>
<li>发送CBW, SCSI Command: 0x2a(WRITE(10)) LUN:0X00<ul>
<li>Signature: 0x43425355 签名</li>
<li>Tag: 0X12B1C010</li>
<li>Data Transfer Length: 512</li>
<li>flag: 0x00<ul>
<li>target: 0x00</li>
<li>lun: 0x00</li>
<li>CDB Length: 10</li>
</ul>
</li>
<li>CDB: 0x2a WRITE(10)<ul>
<li>LUN: 0x00</li>
<li>wrprotect: 0x00</li>
<li>dpo: 0x00</li>
<li>fua: 0x00</li>
<li>rarc: 0x00</li>
<li>Logical Block Address: 0x00000000</li>
<li>Group Number: 0x00</li>
<li>Transfer Length: 1</li>
<li>Control: 0x00</li>
</ul>
</li>
</ul>
</li>
<li>对扇区写入数据</li>
<li>设备回复good</li>
<li>主机使用read(10)读取写入扇区数据,确保写入成功</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[55 53 42 43 10 c0 b1 12 00 02 00 00 00 00 0a 2a 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00]</span><br><span class="line">[16:16:11] [896][I/USB] Decode CB:0x2a</span><br><span class="line">[16:16:11] [896][I/USB] lba: 0x0000</span><br><span class="line">[16:16:11] [903][I/USB] nsectors: 0x01</span><br><span class="line">[16:16:11] [903][I/USB] event:1</span><br><span class="line"></span><br><span class="line">// 主机传输写入数据</span><br><span class="line">0000   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">0010   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">0020   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">0030   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">0040   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">0050   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">0060   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">0070   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">0080   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">0090   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">00a0   00 00 00 00 00 00 00 00 00 00 7a 00 68 00 2d 00</span><br><span class="line">00b0   43 00 4e 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>写入末尾扇区数据,回复good,写入全0</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[16:16:11] [903][I/USB] Decode CB:0x2a</span><br><span class="line">[16:16:11] [909][I/USB] lba: 0x03e7</span><br><span class="line">[16:16:11] [909][I/USB] nsectors: 0x01</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>写入LBA2,3个扇区数据;写入LBA5,三个扇区数据</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[2024/8/18 16:16:11] [915][I/USB] Decode CB:0x2a</span><br><span class="line">[2024/8/18 16:16:11] [915][I/USB] lba: 0x0002</span><br><span class="line">[2024/8/18 16:16:11] [915][I/USB] nsectors: 0x03</span><br><span class="line">[2024/8/18 16:16:11] [927][I/USB] Decode CB:0x2a</span><br><span class="line">[2024/8/18 16:16:11] [927][I/USB] lba: 0x0005</span><br><span class="line">[2024/8/18 16:16:11] [935][I/USB] nsectors: 0x03</span><br><span class="line"></span><br><span class="line">0000   f8 ff ff 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>写入LBA8,32个扇区数据;写入全零数据</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[16:16:11] [941][I/USB] Decode CB:0x2a</span><br><span class="line">[16:16:11] [941][I/USB] lba: 0x0008</span><br><span class="line">[16:16:11] [949][I/USB] nsectors: 0x20</span><br></pre></td></tr></table></figure>

<h4 id="数据写入过程-创建文本"><a href="#数据写入过程-创建文本" class="headerlink" title="数据写入过程(创建文本)"></a>数据写入过程(创建文本)</h4><ol>
<li>创建FAT12文件系统,写入MBR数据,对LBA0~1扇区写入数据<ul>
<li>LBA0扇区末尾: 55 aa</li>
<li>引导代码: 位于数据的前446字节，用于启动操作系统。</li>
<li>分区表: 包含四个分区条目，每个条目16字节，总共64字节。每个条目描述一个分区的起始和结束位置、类型等信息。</li>
<li>引导标志: 位于数据的最后两个字节（0x55AA），表示这是一个有效的MBR。</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[16:16:12] [033][I/USB] Decode CB:0x2a</span><br><span class="line">[16:16:12] [033][I/USB] lba: 0x0000</span><br><span class="line">[16:16:12] [046][I/USB] nsectors: 0x02</span><br><span class="line">0000   eb 3c 90 4d 53 44 4f 53 35 2e 30 00 02 01 02 00   .&lt;.MSDOS5.0.....</span><br><span class="line">0010   02 00 02 e8 03 f8 03 00 01 00 01 00 00 00 00 00   ................</span><br><span class="line">0020   00 00 00 00 80 00 29 55 fa e2 ea 4e 4f 20 4e 41   ......)U...NO NA</span><br><span class="line">0030   4d 45 20 20 20 20 46 41 54 31 32 20 20 20 33 c9   ME    FAT12   3.</span><br><span class="line">0040   8e d1 bc f0 7b 8e d9 b8 00 20 8e c0 fc bd 00 7c   ....&#123;.... .....|</span><br><span class="line">0050   38 4e 24 7d 24 8b c1 99 e8 3c 01 72 1c 83 eb 3a   8N$&#125;$....&lt;.r...:</span><br><span class="line">0060   66 a1 1c 7c 26 66 3b 07 26 8a 57 fc 75 06 80 ca   f..|&amp;f;.&amp;.W.u...</span><br><span class="line">0070   02 88 56 02 80 c3 10 73 eb 33 c9 8a 46 10 98 f7   ..V....s.3..F...</span><br><span class="line">0080   66 16 03 46 1c 13 56 1e 03 46 0e 13 d1 8b 76 11   f..F..V..F....v.</span><br><span class="line">0090   60 89 46 fc 89 56 fe b8 20 00 f7 e6 8b 5e 0b 03   `.F..V.. ....^..</span><br><span class="line">00a0   c3 48 f7 f3 01 46 fc 11 4e fe 61 bf 00 00 e8 e6   .H...F..N.a.....</span><br><span class="line">00b0   00 72 39 26 38 2d 74 17 60 b1 0b be a1 7d f3 a6   .r9&amp;8-t.`....&#125;..</span><br><span class="line">00c0   61 74 32 4e 74 09 83 c7 20 3b fb 72 e6 eb dc a0   at2Nt... ;.r....</span><br><span class="line">00d0   fb 7d b4 7d 8b f0 ac 98 40 74 0c 48 74 13 b4 0e   .&#125;.&#125;....@t.Ht...</span><br><span class="line">00e0   bb 07 00 cd 10 eb ef a0 fd 7d eb e6 a0 fc 7d eb   .........&#125;....&#125;.</span><br><span class="line">00f0   e1 cd 16 cd 19 26 8b 55 1a 52 b0 01 bb 00 00 e8   .....&amp;.U.R......</span><br><span class="line">0100   3b 00 72 e8 5b 8a 56 24 be 0b 7c 8b fc c7 46 f0   ;.r.[.V$..|...F.</span><br><span class="line">0110   3d 7d c7 46 f4 29 7d 8c d9 89 4e f2 89 4e f6 c6   =&#125;.F.)&#125;...N..N..</span><br><span class="line">0120   06 96 7d cb ea 03 00 00 20 0f b6 c8 66 8b 46 f8   ..&#125;..... ...f.F.</span><br><span class="line">0130   66 03 46 1c 66 8b d0 66 c1 ea 10 eb 5e 0f b6 c8   f.F.f..f....^...</span><br><span class="line">0140   4a 4a 8a 46 0d 32 e4 f7 e2 03 46 fc 13 56 fe eb   JJ.F.2....F..V..</span><br><span class="line">0150   4a 52 50 06 53 6a 01 6a 10 91 8b 46 18 96 92 33   JRP.Sj.j...F...3</span><br><span class="line">0160   d2 f7 f6 91 f7 f6 42 87 ca f7 76 1a 8a f2 8a e8   ......B...v.....</span><br><span class="line">0170   c0 cc 02 0a cc b8 01 02 80 7e 02 0e 75 04 b4 42   .........~..u..B</span><br><span class="line">0180   8b f4 8a 56 24 cd 13 61 61 72 0b 40 75 01 42 03   ...V$..aar.@u.B.</span><br><span class="line">0190   5e 0b 49 75 06 f8 c3 41 bb 00 00 60 66 6a 00 eb   ^.Iu...A...`fj..</span><br><span class="line">01a0   b0 42 4f 4f 54 4d 47 52 20 20 20 20 0d 0a 52 65   .BOOTMGR    ..Re</span><br><span class="line">01b0   6d 6f 76 65 20 64 69 73 6b 73 20 6f 72 20 6f 74   move disks or ot</span><br><span class="line">01c0   68 65 72 20 6d 65 64 69 61 2e ff 0d 0a 44 69 73   her media....Dis</span><br><span class="line">01d0   6b 20 65 72 72 6f 72 ff 0d 0a 50 72 65 73 73 20   k error...Press </span><br><span class="line">01e0   61 6e 79 20 6b 65 79 20 74 6f 20 72 65 73 74 61   any key to resta</span><br><span class="line">01f0   72 74 0d 0a 00 00 00 00 00 00 00 ac cb d8 55 aa   rt............U.</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>写入根目录数据,对LBA8~16扇区写入数据</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[16:16:12] [068][I/USB] Decode CB:0x2a</span><br><span class="line">[16:16:12] [068][I/USB] lba: 0x0008</span><br><span class="line">[16:16:12] [082][I/USB] nsectors: 0x08</span><br><span class="line"></span><br><span class="line">0000   42 20 00 49 00 6e 00 66 00 6f 00 0f 00 72 72 00   B .I.n.f.o...rr.</span><br><span class="line">0010   6d 00 61 00 74 00 69 00 6f 00 00 00 6e 00 00 00   m.a.t.i.o...n...</span><br><span class="line">0020   01 53 00 79 00 73 00 74 00 65 00 0f 00 72 6d 00   .S.y.s.t.e...rm.</span><br><span class="line">0030   20 00 56 00 6f 00 6c 00 75 00 00 00 6d 00 65 00    .V.o.l.u...m.e.</span><br><span class="line">0040   53 59 53 54 45 4d 7e 31 20 20 20 16 00 06 06 82   SYSTEM~1   .....</span><br><span class="line">0050   12 59 12 59 00 00 07 82 12 59 02 00 00 00 00 00   .Y.Y.....Y......</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>写入数据内容,对LBA28~29扇区写入数据</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[16:16:12] [120][I/USB] Decode CB:0x2a</span><br><span class="line">[16:16:12] [120][I/USB] lba: 0x0028</span><br><span class="line">[16:16:12] [120][I/USB] nsectors: 0x01</span><br><span class="line">写入LAB28扇区数据</span><br><span class="line">0000   1b 00 40 e5 1d 12 83 e6 ff ff 00 00 00 00 09 00   ..@.............</span><br><span class="line">0010   00 01 00 0b 00 02 03 00 02 00 00 2e 20 20 20 20   ............    </span><br><span class="line">0020   20 20 20 20 20 20 10 00 06 06 82 12 59 12 59 00         ......Y.Y.</span><br><span class="line">0030   00 07 82 12 59 02 00 00 00 00 00 2e 2e 20 20 20   ....Y........   </span><br><span class="line">0040   20 20 20 20 20 20 10 00 06 06 82 12 59 12 59 00         ......Y.Y.</span><br><span class="line">0050   00 07 82 12 59 00 00 00 00 00 00 42 74 00 00 00   ....Y......Bt...</span><br><span class="line">0060   ff ff ff ff ff ff 0f 00 ce ff ff ff ff ff ff ff   ................</span><br><span class="line">0070   ff ff ff ff ff 00 00 ff ff ff ff 01 57 00 50 00   ............W.P.</span><br><span class="line">0080   53 00 65 00 74 00 0f 00 ce 74 00 69 00 6e 00 67   S.e.t....t.i.n.g</span><br><span class="line">0090   00 73 00 2e 00 00 00 64 00 61 00 57 50 53 45 54   .s.....d.a.WPSET</span><br><span class="line">00a0   54 7e 31 44 41 54 20 00 0a 06 82 12 59 12 59 00   T~1DAT .....Y.Y.</span><br><span class="line">00b0   00 07 82 12 59 03 00 0c 00 00 00 42 47 00 75 00   ....Y......BG.u.</span><br><span class="line">00c0   69 00 64 00 00 00 0f 00 ff ff ff ff ff ff ff ff   i.d.............</span><br><span class="line">00d0   ff ff ff ff ff 00 00 ff ff ff ff 01 49 00 6e 00   ............I.n.</span><br><span class="line">00e0   64 00 65 00 78 00 0f 00 ff 65 00 72 00 56 00 6f   d.e.x....e.r.V.o</span><br><span class="line">00f0   00 6c 00 75 00 00 00 6d 00 65 00 49 4e 44 45 58   .l.u...m.e.INDEX</span><br><span class="line">0100   45 7e 31 20 20 20 20 00 1a 07 82 12 59 12 59 00   E~1    .....Y.Y.</span><br><span class="line">0110   00 08 82 12 59 04 00 4c 00 00 00 00 00 00 00 00   ....Y..L........</span><br><span class="line"></span><br><span class="line">[16:16:12] [150][I/USB] Decode CB:0x2a</span><br><span class="line">[16:16:12] [150][I/USB] lba: 0x0029</span><br><span class="line">[16:16:12] [150][I/USB] nsectors: 0x01</span><br><span class="line"></span><br><span class="line">0000   1b 00 40 e5 1d 12 83 e6 ff ff 00 00 00 00 09 00   ..@.............</span><br><span class="line">0010   00 01 00 0b 00 02 03 00 02 00 00 0c 00 00 00 31   ...............1</span><br><span class="line">0020   30 eb e4 b1 a8 94 17 00 00 00 00 00 00 00 00 00   0...............</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>写入文件数据,对LBA42扇区写入数据</p>
<ul>
<li>{7A10627C-EB63-4B65-B8F5-3C36782DF3DF}</li>
<li>写入GUID （全局唯一标识符）</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0000   7b 00 37 00 41 00 31 00 30 00 36 00 32 00 37 00   &#123;.7.A.1.0.6.2.7.</span><br><span class="line">0010   43 00 2d 00 45 00 42 00 36 00 33 00 2d 00 34 00   C.-.E.B.6.3.-.4.</span><br><span class="line">0020   42 00 36 00 35 00 2d 00 42 00 38 00 46 00 35 00   B.6.5.-.B.8.F.5.</span><br><span class="line">0030   2d 00 33 00 43 00 33 00 36 00 37 00 38 00 32 00   -.3.C.3.6.7.8.2.</span><br><span class="line">0040   44 00 46 00 33 00 44 00 46 00 7d 00 00 00 00 00   D.F.3.D.F.&#125;.....</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在目录中添加文件索引,对LBA8~16写入数据<ul>
<li>写入文件索引,<code>123.txt</code>文件索引</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127 [2024/8/18 16:16:17] [106][I/USB] Decode CB:0x2a</span><br><span class="line">128 [2024/8/18 16:16:17] [106][I/USB] lba: 0x0008</span><br><span class="line">129 [2024/8/18 16:16:17] [119][I/USB] nsectors: 0x08</span><br><span class="line"></span><br><span class="line">0000   42 20 00 49 00 6e 00 66 00 6f 00 0f 00 72 72 00   B .I.n.f.o...rr.</span><br><span class="line">0010   6d 00 61 00 74 00 69 00 6f 00 00 00 6e 00 00 00   m.a.t.i.o...n...</span><br><span class="line">0020   01 53 00 79 00 73 00 74 00 65 00 0f 00 72 6d 00   .S.y.s.t.e...rm.</span><br><span class="line">0030   20 00 56 00 6f 00 6c 00 75 00 00 00 6d 00 65 00    .V.o.l.u...m.e.</span><br><span class="line">0040   53 59 53 54 45 4d 7e 31 20 20 20 16 00 06 06 82   SYSTEM~1   .....</span><br><span class="line">0050   12 59 12 59 00 00 07 82 12 59 02 00 00 00 00 00   .Y.Y.....Y......</span><br><span class="line">0060   e5 b0 65 fa 5e 20 00 87 65 2c 67 0f 00 d2 87 65   ..e.^ ..e,g....e</span><br><span class="line">0070   63 68 2e 00 74 00 78 00 74 00 00 00 00 00 ff ff   ch..t.x.t.......</span><br><span class="line">0080   e5 c2 bd a8 ce c4 7e 31 54 58 54 20 00 6d 08 82   ......~1TXT .m..</span><br><span class="line">0090   12 59 12 59 00 00 09 82 12 59 00 00 00 00 00 00   .Y.Y.....Y......</span><br><span class="line">00a0   31 32 33 20 20 20 20 20 54 58 54 20 10 6d 08 82   123     TXT .m..</span><br><span class="line">00b0   12 59 12 59 00 00 09 82 12 59 00 00 00 00 00 00   .Y.Y.....Y......</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>在文件扇区写入数据,对LBA43写入数据</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[16:16:21] [708][I/USB] Decode CB:0x2a</span><br><span class="line">[16:16:21] [708][I/USB] lba: 0x002b</span><br><span class="line">[16:16:21] [708][I/USB] nsectors: 0x01</span><br><span class="line"></span><br><span class="line">0000   30 30 30 30 20 20 20 35 35 20 35 33 20 34 32 20   0000   55 53 42 </span><br><span class="line">0010   34 33 20 36 30 20 39 35 20 63 61 20 31 36 20 30   43 60 95 ca 16 0</span><br><span class="line">0020   30 20 30 30 20 30 30 20 30 30 20 30 30 20 30 30   0 00 00 00 00 00</span><br><span class="line">0030   20 30 36 20 31 65 0d 0a 30 30 31 30 20 20 20 30    06 1e..0010   0</span><br><span class="line">0040   30 20 30 30 20 30 30 20 30 31 20 30 30 20 30 30   0 00 00 01 00 00</span><br><span class="line">0050   20 30 30 20 30 30 20 30 30 20 30 30 20 30 30 20    00 00 00 00 00 </span><br><span class="line">0060   30 30 20 30 30 20 30 30 20 30 30 0d 0a 00 00 00   00 00 00 00.....</span><br></pre></td></tr></table></figure>

<h4 id="U盘弹出操作"><a href="#U盘弹出操作" class="headerlink" title="U盘弹出操作"></a>U盘弹出操作</h4><ul>
<li>使用<code>SCSI_CMD_PREVENTMEDIAREMOVAL</code>命令进行交互完成,任务栏弹出使用的命令</li>
<li>使用<code>SCSI_CMD_STARTSTOPUNIT</code>,盘符执行弹出使用</li>
</ul>
<h3 id="msc-function"><a href="#msc-function" class="headerlink" title="msc function"></a>msc function</h3><h4 id="init"><a href="#init" class="headerlink" title="init"></a>init</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">msc_ram_init</span><span class="params">(<span class="type">uint8_t</span> busid, <span class="type">uint32_t</span> reg_base)</span></span><br><span class="line">&#123;</span><br><span class="line">    usbd_desc_register(busid, msc_ram_descriptor);</span><br><span class="line">    usbd_add_interface(busid, usbd_msc_init_intf(busid, &amp;intf0, MSC_OUT_EP, MSC_IN_EP));</span><br><span class="line"></span><br><span class="line">    usbd_initialize(busid, reg_base, usbd_event_handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="usbd-msc-init-intf"><a href="#usbd-msc-init-intf" class="headerlink" title="usbd_msc_init_intf"></a>usbd_msc_init_intf</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> usbd_interface *<span class="title function_">usbd_msc_init_intf</span><span class="params">(<span class="type">uint8_t</span> busid, <span class="keyword">struct</span> usbd_interface *intf, <span class="type">const</span> <span class="type">uint8_t</span> out_ep, <span class="type">const</span> <span class="type">uint8_t</span> in_ep)</span></span><br><span class="line">&#123;</span><br><span class="line">    intf-&gt;class_interface_handler = msc_storage_class_interface_request_handler;</span><br><span class="line">    intf-&gt;class_endpoint_handler = <span class="literal">NULL</span>;</span><br><span class="line">    intf-&gt;vendor_handler = <span class="literal">NULL</span>;</span><br><span class="line">    intf-&gt;notify_handler = msc_storage_notify_handler;</span><br><span class="line"></span><br><span class="line">    mass_ep_data[busid][MSD_OUT_EP_IDX].ep_addr = out_ep;</span><br><span class="line">    mass_ep_data[busid][MSD_OUT_EP_IDX].ep_cb = mass_storage_bulk_out;</span><br><span class="line">    mass_ep_data[busid][MSD_IN_EP_IDX].ep_addr = in_ep;</span><br><span class="line">    mass_ep_data[busid][MSD_IN_EP_IDX].ep_cb = mass_storage_bulk_in;</span><br><span class="line"></span><br><span class="line">    usbd_add_endpoint(busid, &amp;mass_ep_data[busid][MSD_OUT_EP_IDX]);</span><br><span class="line">    usbd_add_endpoint(busid, &amp;mass_ep_data[busid][MSD_IN_EP_IDX]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">uint8_t</span> *)&amp;g_usbd_msc[busid], <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> usbd_msc_priv));</span><br><span class="line"></span><br><span class="line">    usdb_msc_set_max_lun(busid);<span class="comment">//设置最大LUN,定义了 USB 大容量存储类 （MSC） 设备可以支持的最大逻辑单元号 （LUN） 数。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint8_t</span> i = <span class="number">0u</span>; i &lt;= g_usbd_msc[busid].max_lun; i++) &#123;</span><br><span class="line">        usbd_msc_get_cap(busid, i, &amp;g_usbd_msc[busid].scsi_blk_nbr[i], &amp;g_usbd_msc[busid].scsi_blk_size[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (g_usbd_msc[busid].scsi_blk_size[i] &gt; CONFIG_USBDEV_MSC_MAX_BUFSIZE) &#123;</span><br><span class="line">            USB_LOG_ERR(<span class="string">&quot;msc block buffer overflow\r\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> intf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="usbd-msc-get-cap"><a href="#usbd-msc-get-cap" class="headerlink" title="usbd_msc_get_cap"></a>usbd_msc_get_cap</h4><ul>
<li>需要自行实现,以下为示例</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">usbd_msc_get_cap</span><span class="params">(<span class="type">uint8_t</span> busid, <span class="type">uint8_t</span> lun, <span class="type">uint32_t</span> *block_num, <span class="type">uint32_t</span> *block_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    *block_num = <span class="number">1000</span>; <span class="comment">//Pretend having so many buffer,not has actually.</span></span><br><span class="line">    *block_size = BLOCK_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="msc-storage-notify-handler"><a href="#msc-storage-notify-handler" class="headerlink" title="msc_storage_notify_handler"></a>msc_storage_notify_handler</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">msc_storage_notify_handler</span><span class="params">(<span class="type">uint8_t</span> busid, <span class="type">uint8_t</span> event, <span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (event) &#123;</span><br><span class="line">        <span class="keyword">case</span> USBD_EVENT_INIT:</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_USBDEV_MSC_THREAD</span></span><br><span class="line">            g_usbd_msc[busid].usbd_msc_mq = usb_osal_mq_create(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (g_usbd_msc[busid].usbd_msc_mq == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                USB_LOG_ERR(<span class="string">&quot;No memory to alloc for g_usbd_msc[busid].usbd_msc_mq\r\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            g_usbd_msc[busid].usbd_msc_thread = usb_osal_thread_create(<span class="string">&quot;usbd_msc&quot;</span>, CONFIG_USBDEV_MSC_STACKSIZE, CONFIG_USBDEV_MSC_PRIO, usbdev_msc_thread, (<span class="type">void</span> *)busid);</span><br><span class="line">            <span class="keyword">if</span> (g_usbd_msc[busid].usbd_msc_thread == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                USB_LOG_ERR(<span class="string">&quot;No memory to alloc for g_usbd_msc[busid].usbd_msc_thread\r\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> USBD_EVENT_DEINIT:</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_USBDEV_MSC_THREAD</span></span><br><span class="line">            <span class="keyword">if</span> (g_usbd_msc[busid].usbd_msc_mq) &#123;</span><br><span class="line">                usb_osal_mq_delete(g_usbd_msc[busid].usbd_msc_mq);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (g_usbd_msc[busid].usbd_msc_thread) &#123;</span><br><span class="line">                usb_osal_thread_delete(g_usbd_msc[busid].usbd_msc_thread);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> USBD_EVENT_RESET:</span><br><span class="line">            usbd_msc_reset(busid);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> USBD_EVENT_CONFIGURED:</span><br><span class="line">            USB_LOG_DBG(<span class="string">&quot;Start reading cbw\r\n&quot;</span>);</span><br><span class="line">            usbd_ep_start_read(busid, mass_ep_data[busid][MSD_OUT_EP_IDX].ep_addr, (<span class="type">uint8_t</span> *)&amp;g_usbd_msc[busid].cbw, USB_SIZEOF_MSC_CBW);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="mass-storage-bulk-out"><a href="#mass-storage-bulk-out" class="headerlink" title="mass_storage_bulk_out"></a>mass_storage_bulk_out</h4><ul>
<li>out端点回调函数,根据<code>stage</code>状态执行不同操作</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mass_storage_bulk_out</span><span class="params">(<span class="type">uint8_t</span> busid, <span class="type">uint8_t</span> ep, <span class="type">uint32_t</span> nbytes)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (g_usbd_msc[busid].stage) &#123;</span><br><span class="line">        <span class="keyword">case</span> MSC_READ_CBW:</span><br><span class="line">            <span class="keyword">if</span> (SCSI_CBWDecode(busid, nbytes) == <span class="literal">false</span>) &#123;</span><br><span class="line">                USB_LOG_ERR(<span class="string">&quot;Command:0x%02x decode err\r\n&quot;</span>, g_usbd_msc[busid].cbw.CB[<span class="number">0</span>]);</span><br><span class="line">                usbd_msc_bot_abort(busid);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MSC_DATA_OUT:</span><br><span class="line">            <span class="keyword">switch</span> (g_usbd_msc[busid].cbw.CB[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="keyword">case</span> SCSI_CMD_WRITE10:</span><br><span class="line">                <span class="keyword">case</span> SCSI_CMD_WRITE12:</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_USBDEV_MSC_THREAD</span></span><br><span class="line">                    g_usbd_msc[busid].nbytes = nbytes;</span><br><span class="line">                    usb_osal_mq_send(g_usbd_msc[busid].usbd_msc_mq, MSC_DATA_OUT);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">                    <span class="keyword">if</span> (SCSI_processWrite(busid, nbytes) == <span class="literal">false</span>) &#123;</span><br><span class="line">                        usbd_msc_send_csw(busid, CSW_STATUS_CMD_FAILED); <span class="comment">/* send fail status to host,and the host will retry*/</span></span><br><span class="line">                    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="SCSI-CBWDecode"><a href="#SCSI-CBWDecode" class="headerlink" title="SCSI_CBWDecode"></a>SCSI_CBWDecode</h5><ul>
<li>解码CBW,并根据命令执行不同操作</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">SCSI_CBWDecode</span><span class="params">(<span class="type">uint8_t</span> busid, <span class="type">uint32_t</span> nbytes)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> *buf2send = g_usbd_msc[busid].block_buffer;</span><br><span class="line">    <span class="type">uint32_t</span> len2send = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nbytes != <span class="keyword">sizeof</span>(<span class="keyword">struct</span> CBW)) &#123;</span><br><span class="line">        USB_LOG_ERR(<span class="string">&quot;size != sizeof(cbw)\r\n&quot;</span>);</span><br><span class="line">        SCSI_SetSenseData(busid, SCSI_KCQIR_INVALIDCOMMAND);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g_usbd_msc[busid].csw.dTag = g_usbd_msc[busid].cbw.dTag;</span><br><span class="line">    g_usbd_msc[busid].csw.dDataResidue = g_usbd_msc[busid].cbw.dDataLength;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((g_usbd_msc[busid].cbw.dSignature != MSC_CBW_Signature) || (g_usbd_msc[busid].cbw.bCBLength &lt; <span class="number">1</span>) || (g_usbd_msc[busid].cbw.bCBLength &gt; <span class="number">16</span>)) &#123;</span><br><span class="line">        SCSI_SetSenseData(busid, SCSI_KCQIR_INVALIDCOMMAND);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        USB_LOG_DBG(<span class="string">&quot;Decode CB:0x%02x\r\n&quot;</span>, g_usbd_msc[busid].cbw.CB[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">switch</span> (g_usbd_msc[busid].cbw.CB[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                SCSI_SetSenseData(busid, SCSI_KCQIR_INVALIDCOMMAND);</span><br><span class="line">                USB_LOG_WRN(<span class="string">&quot;unsupported cmd:0x%02x\r\n&quot;</span>, g_usbd_msc[busid].cbw.CB[<span class="number">0</span>]);</span><br><span class="line">                ret = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        <span class="keyword">if</span> (g_usbd_msc[busid].stage == MSC_READ_CBW) &#123;</span><br><span class="line">            <span class="keyword">if</span> (len2send) &#123;</span><br><span class="line">                USB_LOG_DBG(<span class="string">&quot;Send info len:%d\r\n&quot;</span>, len2send);</span><br><span class="line">                usbd_msc_send_info(busid, buf2send, len2send);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                usbd_msc_send_csw(busid, CSW_STATUS_CMD_PASSED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="SCSI-CMD-INQUIRY-0x12"><a href="#SCSI-CMD-INQUIRY-0x12" class="headerlink" title="SCSI_CMD_INQUIRY 0x12"></a>SCSI_CMD_INQUIRY 0x12</h6><ul>
<li>copy默认的inquiry信息,并回复</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (g_usbd_msc[busid].cbw.CB[<span class="number">4</span>] &lt; SCSIRESP_INQUIRY_SIZEOF) &#123;</span><br><span class="line">        data_len = g_usbd_msc[busid].cbw.CB[<span class="number">4</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(*data, (<span class="type">uint8_t</span> *)inquiry, data_len);</span><br><span class="line"></span><br><span class="line">*len = data_len;</span><br></pre></td></tr></table></figure>


<h6 id="usbd-msc-send-info"><a href="#usbd-msc-send-info" class="headerlink" title="usbd_msc_send_info"></a>usbd_msc_send_info</h6><ul>
<li>发送信息</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">usbd_msc_send_info</span><span class="params">(<span class="type">uint8_t</span> busid, <span class="type">uint8_t</span> *buffer, <span class="type">uint8_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    size = MIN(size, g_usbd_msc[busid].cbw.dDataLength);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* updating the State Machine , so that we send CSW when this</span></span><br><span class="line"><span class="comment">	 * transfer is complete, ie when we get a bulk in callback</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    g_usbd_msc[busid].stage = MSC_SEND_CSW;</span><br><span class="line"></span><br><span class="line">    usbd_ep_start_write(busid, mass_ep_data[busid][MSD_IN_EP_IDX].ep_addr, buffer, size);</span><br><span class="line"></span><br><span class="line">    g_usbd_msc[busid].csw.dDataResidue -= size;</span><br><span class="line">    g_usbd_msc[busid].csw.bStatus = CSW_STATUS_CMD_PASSED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="mass-storage-bulk-in"><a href="#mass-storage-bulk-in" class="headerlink" title="mass_storage_bulk_in"></a>mass_storage_bulk_in</h4><ul>
<li>in端点回调函数,根据<code>stage</code>状态执行不同操作</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mass_storage_bulk_in</span><span class="params">(<span class="type">uint8_t</span> busid, <span class="type">uint8_t</span> ep, <span class="type">uint32_t</span> nbytes)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (g_usbd_msc[busid].stage) &#123;</span><br><span class="line">        <span class="keyword">case</span> MSC_DATA_IN:</span><br><span class="line">            <span class="keyword">switch</span> (g_usbd_msc[busid].cbw.CB[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="keyword">case</span> SCSI_CMD_READ10:</span><br><span class="line">                <span class="keyword">case</span> SCSI_CMD_READ12:</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_USBDEV_MSC_THREAD</span></span><br><span class="line">                    usb_osal_mq_send(g_usbd_msc[busid].usbd_msc_mq, MSC_DATA_IN);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">                    <span class="keyword">if</span> (SCSI_processRead(busid) == <span class="literal">false</span>) &#123;</span><br><span class="line">                        usbd_msc_send_csw(busid, CSW_STATUS_CMD_FAILED); <span class="comment">/* send fail status to host,and the host will retry*/</span></span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">/*the device has to send a CSW*/</span></span><br><span class="line">        <span class="keyword">case</span> MSC_SEND_CSW:</span><br><span class="line">            usbd_msc_send_csw(busid, CSW_STATUS_CMD_PASSED);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*the host has received the CSW*/</span></span><br><span class="line">        <span class="keyword">case</span> MSC_WAIT_CSW:</span><br><span class="line">            g_usbd_msc[busid].stage = MSC_READ_CBW;</span><br><span class="line">            USB_LOG_DBG(<span class="string">&quot;Start reading cbw\r\n&quot;</span>);</span><br><span class="line">            usbd_ep_start_read(busid, mass_ep_data[busid][MSD_OUT_EP_IDX].ep_addr, (<span class="type">uint8_t</span> *)&amp;g_usbd_msc[busid].cbw, USB_SIZEOF_MSC_CBW);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="MSC-SEND-CSW"><a href="#MSC-SEND-CSW" class="headerlink" title="MSC_SEND_CSW"></a>MSC_SEND_CSW</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usbd_msc_send_csw(busid, CSW_STATUS_CMD_PASSED);</span><br></pre></td></tr></table></figure>

<h4 id="usbd-msc-send-csw"><a href="#usbd-msc-send-csw" class="headerlink" title="usbd_msc_send_csw"></a>usbd_msc_send_csw</h4><ul>
<li>发送CSW,并设置状态为<code>MSC_WAIT_CSW</code>,等待主机发送批量传输</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">usbd_msc_send_csw</span><span class="params">(<span class="type">uint8_t</span> busid, <span class="type">uint8_t</span> CSW_Status)</span></span><br><span class="line">&#123;</span><br><span class="line">    g_usbd_msc[busid].csw.dSignature = MSC_CSW_Signature;</span><br><span class="line">    g_usbd_msc[busid].csw.bStatus = CSW_Status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* updating the State Machine , so that we wait CSW when this</span></span><br><span class="line"><span class="comment">	 * transfer is complete, ie when we get a bulk in callback</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    g_usbd_msc[busid].stage = MSC_WAIT_CSW;</span><br><span class="line"></span><br><span class="line">    USB_LOG_DBG(<span class="string">&quot;Send csw\r\n&quot;</span>);</span><br><span class="line">    usbd_ep_start_write(busid, mass_ep_data[busid][MSD_IN_EP_IDX].ep_addr, (<span class="type">uint8_t</span> *)&amp;g_usbd_msc[busid].csw, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> CSW));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SCSI-processRead"><a href="#SCSI-processRead" class="headerlink" title="SCSI_processRead"></a>SCSI_processRead</h4><ol>
<li>判断最小传输长度</li>
<li>通过<code>usbd_msc_sector_read</code>接口读取数据</li>
<li>更新开始扇区,剩余扇区,数据长度</li>
<li>CBW需要获取扇区数为0,设置状态为<code>MSC_SEND_CSW</code></li>
<li>通过<code>usbd_ep_start_write</code>发送数据</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">SCSI_processRead</span><span class="params">(<span class="type">uint8_t</span> busid)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> transfer_len;</span><br><span class="line"></span><br><span class="line">    USB_LOG_DBG(<span class="string">&quot;read lba:%d\r\n&quot;</span>, g_usbd_msc[busid].start_sector);</span><br><span class="line"></span><br><span class="line">    transfer_len = MIN(g_usbd_msc[busid].nsectors * g_usbd_msc[busid].scsi_blk_size[g_usbd_msc[busid].cbw.bLUN], CONFIG_USBDEV_MSC_MAX_BUFSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (usbd_msc_sector_read(busid, g_usbd_msc[busid].cbw.bLUN, g_usbd_msc[busid].start_sector, g_usbd_msc[busid].block_buffer, transfer_len) != <span class="number">0</span>) &#123;</span><br><span class="line">        SCSI_SetSenseData(busid, SCSI_KCQHE_UREINRESERVEDAREA);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g_usbd_msc[busid].start_sector += (transfer_len / g_usbd_msc[busid].scsi_blk_size[g_usbd_msc[busid].cbw.bLUN]);</span><br><span class="line">    g_usbd_msc[busid].nsectors -= (transfer_len / g_usbd_msc[busid].scsi_blk_size[g_usbd_msc[busid].cbw.bLUN]);</span><br><span class="line">    g_usbd_msc[busid].csw.dDataResidue -= transfer_len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (g_usbd_msc[busid].nsectors == <span class="number">0</span>) &#123;</span><br><span class="line">        g_usbd_msc[busid].stage = MSC_SEND_CSW;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    usbd_ep_start_write(busid, mass_ep_data[busid][MSD_IN_EP_IDX].ep_addr, g_usbd_msc[busid].block_buffer, transfer_len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="usbd-msc-sector-read"><a href="#usbd-msc-sector-read" class="headerlink" title="usbd_msc_sector_read"></a>usbd_msc_sector_read</h4><ul>
<li>需要自行实现,以下为示例</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">usbd_msc_sector_read</span><span class="params">(<span class="type">uint8_t</span> busid, <span class="type">uint8_t</span> lun, <span class="type">uint32_t</span> sector, <span class="type">uint8_t</span> *buffer, <span class="type">uint32_t</span> length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (sector &lt; BLOCK_COUNT)</span><br><span class="line">        <span class="built_in">memcpy</span>(buffer, mass_block[sector].BlockSpace, length);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="usbd-msc-sector-write"><a href="#usbd-msc-sector-write" class="headerlink" title="usbd_msc_sector_write"></a>usbd_msc_sector_write</h3><ul>
<li>需要自行实现,以下为示例</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">usbd_msc_sector_write</span><span class="params">(<span class="type">uint8_t</span> busid, <span class="type">uint8_t</span> lun, <span class="type">uint32_t</span> sector, <span class="type">uint8_t</span> *buffer, <span class="type">uint32_t</span> length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (sector &lt; BLOCK_COUNT)</span><br><span class="line">        <span class="built_in">memcpy</span>(mass_block[sector].BlockSpace, buffer, length);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="msc-ram-descriptor"><a href="#msc-ram-descriptor" class="headerlink" title="msc_ram_descriptor"></a>msc_ram_descriptor</h3><ul>
<li><p>bInterfaceClass : USB_DEVICE_CLASS_MASS_STORAGE 0x08</p>
</li>
<li><p>bInterfaceSubClass : MSC_SUBCLASS_SCSI 0x06</p>
</li>
<li><p>bInterfaceProtocol : MSC_PROTOCOL_BULK_ONLY 0x50</p>
<ul>
<li>USB大容量存储类仅大容量(BBB)传输</li>
</ul>
</li>
<li><p>设置了两个端点,一个接收,一个发送</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MSC_DESCRIPTOR_INIT(bFirstInterface, out_ep, in_ep, wMaxPacketSize, str_idx) \</span></span><br><span class="line"><span class="meta">    <span class="comment">/* Interface */</span>                                              \</span></span><br><span class="line"><span class="meta">    0x09,                          <span class="comment">/* bLength */</span>                 \</span></span><br><span class="line"><span class="meta">    USB_DESCRIPTOR_TYPE_INTERFACE, <span class="comment">/* bDescriptorType */</span>         \</span></span><br><span class="line"><span class="meta">    bFirstInterface,               <span class="comment">/* bInterfaceNumber */</span>        \</span></span><br><span class="line"><span class="meta">    0x00,                          <span class="comment">/* bAlternateSetting */</span>       \</span></span><br><span class="line"><span class="meta">    0x02,                          <span class="comment">/* bNumEndpoints */</span>           \</span></span><br><span class="line"><span class="meta">    USB_DEVICE_CLASS_MASS_STORAGE, <span class="comment">/* bInterfaceClass */</span>         \</span></span><br><span class="line"><span class="meta">    MSC_SUBCLASS_SCSI,             <span class="comment">/* bInterfaceSubClass */</span>      \</span></span><br><span class="line"><span class="meta">    MSC_PROTOCOL_BULK_ONLY,        <span class="comment">/* bInterfaceProtocol */</span>      \</span></span><br><span class="line"><span class="meta">    str_idx,                       <span class="comment">/* iInterface */</span>              \</span></span><br><span class="line"><span class="meta">    0x07,                          <span class="comment">/* bLength */</span>                 \</span></span><br><span class="line"><span class="meta">    USB_DESCRIPTOR_TYPE_ENDPOINT,  <span class="comment">/* bDescriptorType */</span>         \</span></span><br><span class="line"><span class="meta">    out_ep,                        <span class="comment">/* bEndpointAddress */</span>        \</span></span><br><span class="line"><span class="meta">    0x02,                          <span class="comment">/* bmAttributes */</span>            \</span></span><br><span class="line"><span class="meta">    WBVAL(wMaxPacketSize),         <span class="comment">/* wMaxPacketSize */</span>          \</span></span><br><span class="line"><span class="meta">    0x00,                          <span class="comment">/* bInterval */</span>               \</span></span><br><span class="line"><span class="meta">    0x07,                          <span class="comment">/* bLength */</span>                 \</span></span><br><span class="line"><span class="meta">    USB_DESCRIPTOR_TYPE_ENDPOINT,  <span class="comment">/* bDescriptorType */</span>         \</span></span><br><span class="line"><span class="meta">    in_ep,                         <span class="comment">/* bEndpointAddress */</span>        \</span></span><br><span class="line"><span class="meta">    0x02,                          <span class="comment">/* bmAttributes */</span>            \</span></span><br><span class="line"><span class="meta">    WBVAL(wMaxPacketSize),         <span class="comment">/* wMaxPacketSize */</span>          \</span></span><br><span class="line"><span class="meta">    0x00                           <span class="comment">/* bInterval */</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">uint8_t</span> msc_ram_descriptor[] = &#123;</span><br><span class="line">    USB_DEVICE_DESCRIPTOR_INIT(USB_2_0, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, USBD_VID, USBD_PID, <span class="number">0x0200</span>, <span class="number">0x01</span>),</span><br><span class="line">    USB_CONFIG_DESCRIPTOR_INIT(USB_CONFIG_SIZE, <span class="number">0x01</span>, <span class="number">0x01</span>, USB_CONFIG_BUS_POWERED, USBD_MAX_POWER),</span><br><span class="line">    MSC_DESCRIPTOR_INIT(<span class="number">0x00</span>, MSC_OUT_EP, MSC_IN_EP, MSC_MAX_MPS, <span class="number">0x02</span>),</span><br><span class="line">    <span class="comment">///////////////////////////////////////</span></span><br><span class="line">    <span class="comment">/// string0 descriptor</span></span><br><span class="line">    <span class="comment">///////////////////////////////////////</span></span><br><span class="line">    USB_LANGID_INIT(USBD_LANGID_STRING),</span><br><span class="line">    <span class="comment">///////////////////////////////////////</span></span><br><span class="line">    <span class="comment">/// string1 descriptor</span></span><br><span class="line">    <span class="comment">///////////////////////////////////////</span></span><br><span class="line">    <span class="number">0x14</span>,                       <span class="comment">/* bLength */</span></span><br><span class="line">    USB_DESCRIPTOR_TYPE_STRING, <span class="comment">/* bDescriptorType */</span></span><br><span class="line">    <span class="string">&#x27;C&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar0 */</span></span><br><span class="line">    <span class="string">&#x27;h&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar1 */</span></span><br><span class="line">    <span class="string">&#x27;e&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar2 */</span></span><br><span class="line">    <span class="string">&#x27;r&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar3 */</span></span><br><span class="line">    <span class="string">&#x27;r&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar4 */</span></span><br><span class="line">    <span class="string">&#x27;y&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar5 */</span></span><br><span class="line">    <span class="string">&#x27;U&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar6 */</span></span><br><span class="line">    <span class="string">&#x27;S&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar7 */</span></span><br><span class="line">    <span class="string">&#x27;B&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar8 */</span></span><br><span class="line">    <span class="comment">///////////////////////////////////////</span></span><br><span class="line">    <span class="comment">/// string2 descriptor</span></span><br><span class="line">    <span class="comment">///////////////////////////////////////</span></span><br><span class="line">    <span class="number">0x26</span>,                       <span class="comment">/* bLength */</span></span><br><span class="line">    USB_DESCRIPTOR_TYPE_STRING, <span class="comment">/* bDescriptorType */</span></span><br><span class="line">    <span class="string">&#x27;C&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar0 */</span></span><br><span class="line">    <span class="string">&#x27;h&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar1 */</span></span><br><span class="line">    <span class="string">&#x27;e&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar2 */</span></span><br><span class="line">    <span class="string">&#x27;r&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar3 */</span></span><br><span class="line">    <span class="string">&#x27;r&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar4 */</span></span><br><span class="line">    <span class="string">&#x27;y&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar5 */</span></span><br><span class="line">    <span class="string">&#x27;U&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar6 */</span></span><br><span class="line">    <span class="string">&#x27;S&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar7 */</span></span><br><span class="line">    <span class="string">&#x27;B&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar8 */</span></span><br><span class="line">    <span class="string">&#x27; &#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar9 */</span></span><br><span class="line">    <span class="string">&#x27;M&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar10 */</span></span><br><span class="line">    <span class="string">&#x27;S&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar11 */</span></span><br><span class="line">    <span class="string">&#x27;C&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar12 */</span></span><br><span class="line">    <span class="string">&#x27; &#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar13 */</span></span><br><span class="line">    <span class="string">&#x27;D&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar14 */</span></span><br><span class="line">    <span class="string">&#x27;E&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar15 */</span></span><br><span class="line">    <span class="string">&#x27;M&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar16 */</span></span><br><span class="line">    <span class="string">&#x27;O&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar17 */</span></span><br><span class="line">    <span class="comment">///////////////////////////////////////</span></span><br><span class="line">    <span class="comment">/// string3 descriptor</span></span><br><span class="line">    <span class="comment">///////////////////////////////////////</span></span><br><span class="line">    <span class="number">0x16</span>,                       <span class="comment">/* bLength */</span></span><br><span class="line">    USB_DESCRIPTOR_TYPE_STRING, <span class="comment">/* bDescriptorType */</span></span><br><span class="line">    <span class="string">&#x27;2&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar0 */</span></span><br><span class="line">    <span class="string">&#x27;0&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar1 */</span></span><br><span class="line">    <span class="string">&#x27;2&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar2 */</span></span><br><span class="line">    <span class="string">&#x27;2&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar3 */</span></span><br><span class="line">    <span class="string">&#x27;1&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar4 */</span></span><br><span class="line">    <span class="string">&#x27;2&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar5 */</span></span><br><span class="line">    <span class="string">&#x27;3&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar6 */</span></span><br><span class="line">    <span class="string">&#x27;4&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar7 */</span></span><br><span class="line">    <span class="string">&#x27;5&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar8 */</span></span><br><span class="line">    <span class="string">&#x27;6&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar9 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_USB_HS</span></span><br><span class="line">    <span class="comment">///////////////////////////////////////</span></span><br><span class="line">    <span class="comment">/// device qualifier descriptor</span></span><br><span class="line">    <span class="comment">///////////////////////////////////////</span></span><br><span class="line">    <span class="number">0x0a</span>,</span><br><span class="line">    USB_DESCRIPTOR_TYPE_DEVICE_QUALIFIER,</span><br><span class="line">    <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x02</span>,</span><br><span class="line">    <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x40</span>,</span><br><span class="line">    <span class="number">0x01</span>,</span><br><span class="line">    <span class="number">0x00</span>,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="number">0x00</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Mass-Storage-Request-Codes"><a href="#Mass-Storage-Request-Codes" class="headerlink" title="Mass Storage Request Codes"></a>Mass Storage Request Codes</h3><h4 id="Get-Max-LUN-GML-0xFE"><a href="#Get-Max-LUN-GML-0xFE" class="headerlink" title="Get Max LUN (GML) 0xFE"></a>Get Max LUN (GML) 0xFE</h4><ul>
<li>由USB大容量存储类仅限大容量(BBB)传输分配</li>
</ul>
<h3 id="Bulk-Only-Transport-Protocol"><a href="#Bulk-Only-Transport-Protocol" class="headerlink" title="Bulk-Only Transport Protocol"></a>Bulk-Only Transport Protocol</h3><ul>
<li>该规范处理仅批量传输，或者换句话说，仅通过批量端点(不通过中断或控制端点)传输命令、数据和状态。此规范仅使用默认管道清除Bulk端点上的STALL条件，并发出如下所定义的特定于类的请求。本规范不要求使用中断端点。</li>
<li>该规范定义了对共享公共设备特性的逻辑单元的支持。虽然这个特性提供了必要的支持，允许类似的大容量存储设备共享一个通用的USB接口描述符，但它并不打算用于实现接口桥接设备。</li>
</ul>
<h4 id="CBW-Command-Block-Wrapper"><a href="#CBW-Command-Block-Wrapper" class="headerlink" title="CBW (Command Block Wrapper)"></a>CBW (Command Block Wrapper)</h4><ul>
<li>表 5-1 命令块包装器 (Command Block Wrapper)</li>
</ul>
<table>
<thead>
<tr>
<th>字节</th>
<th>字段名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>0-3</td>
<td>dCBWSignature</td>
<td>用于识别此数据包为 CBW 的签名。</td>
</tr>
<tr>
<td>4-7</td>
<td>dCBWTag</td>
<td>主机发送的标签，用于将此 CBW 与相应的 CSW 关联。</td>
</tr>
<tr>
<td>8-11</td>
<td>dCBWDataTransferLength</td>
<td>主机期望在此命令中传输的数据字节数。</td>
</tr>
<tr>
<td>12</td>
<td>bmCBWFlags</td>
<td>指示数据传输方向的标志。</td>
</tr>
<tr>
<td>13</td>
<td>bCBWLUN</td>
<td>与此命令关联的逻辑单元号。</td>
</tr>
<tr>
<td>14</td>
<td>保留</td>
<td>保留 (0)</td>
</tr>
<tr>
<td>15-30</td>
<td>保留</td>
<td>保留 (0)</td>
</tr>
</tbody></table>
<ul>
<li><strong>dCBWSignature</strong>: 此字段包含 <code>43425355h</code>，用于识别传入的 CBW。</li>
<li><strong>dCBWTag</strong>: 用于将 CBW 与相应的 CSW 关联的唯一标识符。<ul>
<li><strong>位 7</strong>: 方向 - 如果 dCBWDataTransferLength 字段为零，设备应忽略此位，否则：<ul>
<li>0 &#x3D; 数据从主机传输到设备（Data-Out）</li>
<li>1 &#x3D; 数据从设备传输到主机（Data-In）</li>
</ul>
</li>
<li><strong>位 6</strong>: 废弃。主机应将此位设置为零。</li>
<li><strong>位 5-0</strong>: 保留 - 主机应将这些位设置为零。</li>
</ul>
<ul>
<li><strong>bmCBWFlags</strong>: 指示设备是否应忽略或遵守 <code>bCBWCBLength</code> 中的值。</li>
</ul>
</li>
<li><strong>dCBWDataTransferLength</strong>: 主机期望在 Bulk-In 或 Bulk-Out 端点（由方向位指示）上传输的数据字节数。如果此字段为零，则设备和主机在 CBW 和相应的 CSW 之间不传输数据，设备应忽略 bmCBWFlags 中的方向位的值。</li>
<li><strong>bCBWLUN</strong>: 对于支持多个 LUN 的设备，主机应在此字段中放置发送命令块的 LUN。否则，主机应将此字段设置为零。</li>
<li><strong>bCBWCBLength</strong>: 此值定义命令块的有效长度。唯一合法的值是 1 到 16（01h 到 10h）。所有其他值均为保留值。</li>
<li><strong>CBWCB</strong>: 设备要执行的命令块。设备应将此字段中的前 <code>bCBWCBLength</code> 字节解释为由 <code>bInterfaceSubClass</code> 标识的命令集定义的命令块。如果设备支持的命令集使用少于 16（10h）字节的命令块，则应首先传输有效字节，从偏移量 15（Fh）开始。设备应忽略 <code>CBWCB</code> 字段中偏移量（15 + <code>bCBWCBLength</code> - 1）之后的内容。</li>
</ul>
<h4 id="SCSI-Command"><a href="#SCSI-Command" class="headerlink" title="SCSI Command"></a>SCSI Command</h4><ul>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.staff.uni-mainz.de/tacke/scsi/SCSI2-08.html">https://www.staff.uni-mainz.de/tacke/scsi/SCSI2-08.html</a></li>
</ul>
<h5 id="SCSI-CMD-INQUIRY-0x12-1"><a href="#SCSI-CMD-INQUIRY-0x12-1" class="headerlink" title="SCSI_CMD_INQUIRY 0x12"></a>SCSI_CMD_INQUIRY 0x12</h5><ul>
<li><p>参考&lt;&lt;usbmassbulk_10.pdf&gt;&gt; 6.4.2 INQUIRY命令</p>
</li>
<li><p>INQUIRY命令(参见表58)请求将有关逻辑单元和SCSI目标设备的信息发送到应用程序客户端。</p>
</li>
<li><p>表 58 INQUIRY 命令</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Byte</th>
<th>Bit 7</th>
<th>Bit 6</th>
<th>Bit 5</th>
<th>Bit 4</th>
<th>Bit 3</th>
<th>Bit 2</th>
<th>Bit 1</th>
<th>Bit 0</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>OPERATION CODE (12h)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>Reserved</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Formerly</td>
<td>EVPD</td>
</tr>
<tr>
<td>2</td>
<td>PAGE CODE</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>3 - 4</td>
<td>ALLOCATION LENGTH</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>CONTROL</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><p><strong>EVPD（启用重要产品数据）位</strong>：设置为 1 时，指定设备服务器应返回由页面代码字段指定的重要产品数据。如果 EVPD 位设置为 0，设备服务器应返回标准 INQUIRY 数据（见 3.6.2）。如果在 EVPD 位设置为 0 时页面代码字段不为零，则命令应以 CHECK CONDITION 状态终止，感知键设置为 ILLEGAL REQUEST，附加感知代码设置为 INVALID FIELD IN CDB。</p>
</li>
<li><p><strong>CMDDT（命令支持数据）位</strong>：此位已被 T10 委员会声明为废弃。然而，它仍然包含在内，因为某些产品可能会实现此功能。有关此位的描述，请参见 SPC-2。如果 EVPD 和 CMDDT 位都为 1，目标应返回 CHECK CONDITION 状态，感知键设置为 ILLEGAL REQUEST，附加感知代码为 Invalid Field in CDB。当 EVPD 位为 1 时，页面或操作码字段指定目标应返回的重要产品数据页面。</p>
</li>
<li><p><strong>ALLOCATION LENGTH</strong>: 如果EVPD设置为0，则分配长度至少为5，这样将返回参数数据(参见3.6.2)中的ADDITIONAL length字段。如果EVPD设置为1，则分配长度应该至少为4，这样就会返回参数数据(参见5.4)中的PAGE length字段。</p>
</li>
<li><p>回复的为:<code>Standard INQUIRY data format</code> 标准INQUIRY数据格式</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> inquiry[SCSIRESP_INQUIRY_SIZEOF] = &#123;</span><br><span class="line">    <span class="comment">/* 36 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* LUN 0 */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Qualifier: 设备类型连接到逻辑单元</span></span><br><span class="line"><span class="comment">     * Device Type:直接存取块设备(如磁盘)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="number">0x00</span>,</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * RMB: 0x80 可移动介质</span></span><br><span class="line"><span class="comment">     * Device-type modifier: 0x00 不支持</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="number">0x80</span>,</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * ANSI-approved version: 设备遵循SCSI的这个版本。本规范保留用于指定ANSI批准后的标准。</span></span><br><span class="line"><span class="comment">    * ECMA 版本: 目标未声明符合 ISO 版本的 SCSI （ISO 9316）</span></span><br><span class="line"><span class="comment">    * ISO 版本: 目标未声明符合 ECMA 版本的 SCSI （ECMA 111）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="number">0x02</span>,</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Response Data Format: 0x02 表示数据应采用本国际标准中规定的格式。 </span></span><br><span class="line"><span class="comment">     * AENC: 处理器设备不支持异步事件通知</span></span><br><span class="line"><span class="comment">     * TrmIOP: 0x00 设备不支持 TERMINATE I/O PROCESS 消息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="number">0x02</span>,</span><br><span class="line">    <span class="comment">// 分配长度</span></span><br><span class="line">    (SCSIRESP_INQUIRY_SIZEOF - <span class="number">5</span>),</span><br><span class="line">    <span class="comment">//reserverd</span></span><br><span class="line">    <span class="number">0x00</span>,</span><br><span class="line">    <span class="comment">//reserverd</span></span><br><span class="line">    <span class="number">0x00</span>,</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * RelAdr: 0x00 设备不支持相对地址</span></span><br><span class="line"><span class="comment">     * WBus32: 0x00 设备不支持32位总线</span></span><br><span class="line"><span class="comment">     * WBus16: 0x00 设备不支持16位总线</span></span><br><span class="line"><span class="comment">     * 如果 Wbus16 和 Wbus32 位的值均为零，则设备仅支持 8 位宽的数据传输。</span></span><br><span class="line"><span class="comment">     * Sync: 0x00 设备不支持同步数据传输</span></span><br><span class="line"><span class="comment">     * Linked: 0x00 设备不支持连接命令</span></span><br><span class="line"><span class="comment">     * CmdQue: 0x00 设备不支持命令队列</span></span><br><span class="line"><span class="comment">     * SftRe: 0x00 设备不支持软重置</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="number">0x00</span>,</span><br><span class="line">    <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="comment">/* 供应商   : 8 bytes */</span></span><br><span class="line">    <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="comment">/* 产品标识 : 16 Bytes */</span></span><br><span class="line">    <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>,</span><br><span class="line">    <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span> <span class="comment">/* 版本号      : 4 Bytes */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(&amp;inquiry[<span class="number">8</span>], CONFIG_USBDEV_MSC_MANUFACTURER_STRING, <span class="built_in">strlen</span>(CONFIG_USBDEV_MSC_MANUFACTURER_STRING));</span><br><span class="line"><span class="built_in">memcpy</span>(&amp;inquiry[<span class="number">16</span>], CONFIG_USBDEV_MSC_PRODUCT_STRING, <span class="built_in">strlen</span>(CONFIG_USBDEV_MSC_PRODUCT_STRING));</span><br><span class="line"><span class="built_in">memcpy</span>(&amp;inquiry[<span class="number">32</span>], CONFIG_USBDEV_MSC_VERSION_STRING, <span class="built_in">strlen</span>(CONFIG_USBDEV_MSC_VERSION_STRING));</span><br></pre></td></tr></table></figure>

<h5 id="SCSI-CMD-READFORMATCAPACITIES-0x23"><a href="#SCSI-CMD-READFORMATCAPACITIES-0x23" class="headerlink" title="SCSI_CMD_READFORMATCAPACITIES 0x23"></a>SCSI_CMD_READFORMATCAPACITIES 0x23</h5><ul>
<li>参见&lt;&lt;usbmass-ufi10.pdf&gt;&gt; 第4节</li>
<li>发送<code>[23 00 00 00 00 00 00 00 fc 00 00 00 00 00 00 00]</code><ul>
<li>CB: 0x23</li>
<li>LUN: 0x00</li>
<li>Allocation Length: 0xfc &#x3D; 252</li>
</ul>
</li>
<li>在收到这个命令块后，UFI设备将容量列表返回给Bulk In端点上的主机。</li>
<li><code>scsi_blk_size</code>和<code>scsi_blk_nbr</code>通过<code>usbd_msc_get_cap</code>获取</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">SCSI_readFormatCapacity</span><span class="params">(<span class="type">uint8_t</span> busid, <span class="type">uint8_t</span> **data, <span class="type">uint32_t</span> *len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> format_capacity[SCSIRESP_READFORMATCAPACITIES_SIZEOF] = &#123;</span><br><span class="line">        <span class="number">0x00</span>,</span><br><span class="line">        <span class="number">0x00</span>,</span><br><span class="line">        <span class="number">0x00</span>,</span><br><span class="line">        <span class="number">0x08</span>, <span class="comment">/* Capacity List Length */</span></span><br><span class="line">        <span class="comment">/*Number of Blocks*/</span></span><br><span class="line">        (<span class="type">uint8_t</span>)((g_usbd_msc[busid].scsi_blk_nbr[g_usbd_msc[busid].cbw.bLUN] &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>),</span><br><span class="line">        (<span class="type">uint8_t</span>)((g_usbd_msc[busid].scsi_blk_nbr[g_usbd_msc[busid].cbw.bLUN] &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>),</span><br><span class="line">        (<span class="type">uint8_t</span>)((g_usbd_msc[busid].scsi_blk_nbr[g_usbd_msc[busid].cbw.bLUN] &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>),</span><br><span class="line">        (<span class="type">uint8_t</span>)((g_usbd_msc[busid].scsi_blk_nbr[g_usbd_msc[busid].cbw.bLUN] &gt;&gt; <span class="number">0</span>) &amp; <span class="number">0xff</span>),</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 01b: Unformatted Media</span></span><br><span class="line"><span class="comment">        * 02b: Formatted Media</span></span><br><span class="line"><span class="comment">        * 03b: No Cartridge in Device</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="number">0x02</span>, <span class="comment">/* Descriptor Code: Formatted Media */</span></span><br><span class="line">        <span class="number">0x00</span>, </span><br><span class="line">        (<span class="type">uint8_t</span>)((g_usbd_msc[busid].scsi_blk_size[g_usbd_msc[busid].cbw.bLUN] &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>),</span><br><span class="line">        (<span class="type">uint8_t</span>)((g_usbd_msc[busid].scsi_blk_size[g_usbd_msc[busid].cbw.bLUN] &gt;&gt; <span class="number">0</span>) &amp; <span class="number">0xff</span>),  <span class="comment">/* Block Length */</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(*data, (<span class="type">uint8_t</span> *)format_capacity, SCSIRESP_READFORMATCAPACITIES_SIZEOF);</span><br><span class="line">    *len = SCSIRESP_READFORMATCAPACITIES_SIZEOF;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="SCSI-CMD-READCAPACITY10-0x25"><a href="#SCSI-CMD-READCAPACITY10-0x25" class="headerlink" title="SCSI_CMD_READCAPACITY10 0x25"></a>SCSI_CMD_READCAPACITY10 0x25</h5><ul>
<li>READ capacity命令允许主机请求当前安装的介质的容量</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">SCSI_readCapacity10</span><span class="params">(<span class="type">uint8_t</span> busid, <span class="type">uint8_t</span> **data, <span class="type">uint32_t</span> *len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (g_usbd_msc[busid].cbw.dDataLength == <span class="number">0U</span>) &#123;</span><br><span class="line">        SCSI_SetSenseData(busid, SCSI_KCQIR_INVALIDCOMMAND);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> capacity10[SCSIRESP_READCAPACITY10_SIZEOF] = &#123;</span><br><span class="line">        (<span class="type">uint8_t</span>)(((g_usbd_msc[busid].scsi_blk_nbr[g_usbd_msc[busid].cbw.bLUN] - <span class="number">1</span>) &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>),</span><br><span class="line">        (<span class="type">uint8_t</span>)(((g_usbd_msc[busid].scsi_blk_nbr[g_usbd_msc[busid].cbw.bLUN] - <span class="number">1</span>) &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>),</span><br><span class="line">        (<span class="type">uint8_t</span>)(((g_usbd_msc[busid].scsi_blk_nbr[g_usbd_msc[busid].cbw.bLUN] - <span class="number">1</span>) &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>),</span><br><span class="line">        (<span class="type">uint8_t</span>)(((g_usbd_msc[busid].scsi_blk_nbr[g_usbd_msc[busid].cbw.bLUN] - <span class="number">1</span>) &gt;&gt; <span class="number">0</span>) &amp; <span class="number">0xff</span>),</span><br><span class="line"></span><br><span class="line">        (<span class="type">uint8_t</span>)((g_usbd_msc[busid].scsi_blk_size[g_usbd_msc[busid].cbw.bLUN] &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>),</span><br><span class="line">        (<span class="type">uint8_t</span>)((g_usbd_msc[busid].scsi_blk_size[g_usbd_msc[busid].cbw.bLUN] &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>),</span><br><span class="line">        (<span class="type">uint8_t</span>)((g_usbd_msc[busid].scsi_blk_size[g_usbd_msc[busid].cbw.bLUN] &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>),</span><br><span class="line">        (<span class="type">uint8_t</span>)((g_usbd_msc[busid].scsi_blk_size[g_usbd_msc[busid].cbw.bLUN] &gt;&gt; <span class="number">0</span>) &amp; <span class="number">0xff</span>),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(*data, (<span class="type">uint8_t</span> *)capacity10, SCSIRESP_READCAPACITY10_SIZEOF);</span><br><span class="line">    *len = SCSIRESP_READCAPACITY10_SIZEOF;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="SCSI-CMD-MODESENSE6-0x1A"><a href="#SCSI-CMD-MODESENSE6-0x1A" class="headerlink" title="SCSI_CMD_MODESENSE6 0x1A"></a>SCSI_CMD_MODESENSE6 0x1A</h5><ul>
<li>MODE SENSE(6)命令为设备服务器向应用程序客户机报告参数提供了一种方法。</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Bit</strong></td>
<td><strong>7</strong></td>
<td><strong>6</strong></td>
<td><strong>5</strong></td>
<td><strong>4</strong></td>
<td><strong>3</strong></td>
<td><strong>2</strong></td>
<td><strong>1</strong></td>
</tr>
<tr>
<td><strong>0</strong></td>
<td>OPERATION CODE (1Ah)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>1</strong></td>
<td></td>
<td>Reserved</td>
<td></td>
<td>DBD</td>
<td></td>
<td>Reserved</td>
<td></td>
</tr>
<tr>
<td><strong>2</strong></td>
<td></td>
<td>PC PAGE CODE</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>3</strong></td>
<td></td>
<td>SUBPAGE CODE</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>4</strong></td>
<td></td>
<td>ALLOCATION LENGTH</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>5</strong></td>
<td></td>
<td>CONTROL</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><strong>DBD（禁用块描述符）位</strong>：如果 DBD 位设置为 1，则设备服务器应返回参数数据，其中不包含块描述符。如果 DBD 位设置为 0，则设备服务器应返回参数数据，其中包含块描述符。</li>
<li><strong>PC（页面控制）字段</strong>：此字段指定设备服务器应返回的参数数据页面。如果 PC 字段为零，则设备服务器应返回当前值。如果 PC 字段为 1，则设备服务器应返回默认值。如果 PC 字段为 2，则设备服务器应返回保存值。如果 PC 字段为 3，则设备服务器应返回更改值。</li>
<li><strong>PAGE CODE 字段</strong>：指定要返回的模式页</li>
<li><strong>SUBPAGE CODE 字段</strong>：指定要返回的模式页的子页</li>
<li><strong>ALLOCATION LENGTH 字段</strong>：此字段指定设备服务器应返回的参数数据的长度（以字节为单位）。如果 ALLOCATION LENGTH 字段为零，则设备服务器应返回参数数据的长度，以便填充主机分配的数据缓冲区。如果 ALLOCATION LENGTH 字段为非零值，则设备服务器应返回参数数据的长度，以便填充主机分配的数据缓冲区，但不得超过 ALLOCATION LENGTH 字段中指定的长度。</li>
<li><strong>CONTROL 字段</strong>：此字段包含用于错误检测和纠正的 CRC 或校验和。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">SCSI_modeSense6</span><span class="params">(<span class="type">uint8_t</span> busid, <span class="type">uint8_t</span> **data, <span class="type">uint32_t</span> *len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> data_len = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (g_usbd_msc[busid].cbw.dDataLength == <span class="number">0U</span>) &#123;</span><br><span class="line">        SCSI_SetSenseData(busid, SCSI_KCQIR_INVALIDCOMMAND);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (g_usbd_msc[busid].cbw.CB[<span class="number">4</span>] &lt; SCSIRESP_MODEPARAMETERHDR6_SIZEOF) &#123;</span><br><span class="line">        data_len = g_usbd_msc[busid].cbw.CB[<span class="number">4</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> sense6[SCSIRESP_MODEPARAMETERHDR6_SIZEOF] = &#123; <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (g_usbd_msc[busid].readonly) &#123;</span><br><span class="line">        sense6[<span class="number">2</span>] = <span class="number">0x80</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(*data, (<span class="type">uint8_t</span> *)sense6, data_len);</span><br><span class="line">    *len = data_len;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="SCSI-CMD-READ10-0x28"><a href="#SCSI-CMD-READ10-0x28" class="headerlink" title="SCSI_CMD_READ10 0x28"></a>SCSI_CMD_READ10 0x28</h5><ul>
<li><p>READ(10)命令(参见表97)请求设备服务器读取指定的逻辑块并将它们传输到data-in缓冲区。读取的每个逻辑块包括用户数据，如果介质已启用保护信息进行格式化，还包括保护信息。传输的每个逻辑块包括用户数据，也可能包括基于RDPROTECT字段和介质格式的保护信息。应该返回最近写入地址逻辑块的数据值</p>
</li>
<li><p>获取传输过来需要读取的LBA和读取的块数,并判断是否超出范围</p>
</li>
<li><p>判断<code>dDataLength</code>是否和<code>nsectors * scsi_blk_size</code>相等</p>
</li>
<li><p>设置<code>stage</code>为<code>MSC_DATA_IN</code>,并发送<code>MSC_DATA_IN</code>消息</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">SCSI_read10</span><span class="params">(<span class="type">uint8_t</span> busid, <span class="type">uint8_t</span> **data, <span class="type">uint32_t</span> *len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (((g_usbd_msc[busid].cbw.bmFlags &amp; <span class="number">0x80U</span>) != <span class="number">0x80U</span>) || (g_usbd_msc[busid].cbw.dDataLength == <span class="number">0U</span>)) &#123;</span><br><span class="line">        SCSI_SetSenseData(busid, SCSI_KCQIR_INVALIDCOMMAND);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g_usbd_msc[busid].start_sector = GET_BE32(&amp;g_usbd_msc[busid].cbw.CB[<span class="number">2</span>]); <span class="comment">/* Logical Block Address of First Block */</span></span><br><span class="line">    USB_LOG_DBG(<span class="string">&quot;lba: 0x%04x\r\n&quot;</span>, g_usbd_msc[busid].start_sector);</span><br><span class="line"></span><br><span class="line">    g_usbd_msc[busid].nsectors = GET_BE16(&amp;g_usbd_msc[busid].cbw.CB[<span class="number">7</span>]); <span class="comment">/* Number of Blocks to transfer */</span></span><br><span class="line">    USB_LOG_DBG(<span class="string">&quot;nsectors: 0x%02x\r\n&quot;</span>, g_usbd_msc[busid].nsectors);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((g_usbd_msc[busid].start_sector + g_usbd_msc[busid].nsectors) &gt; g_usbd_msc[busid].scsi_blk_nbr[g_usbd_msc[busid].cbw.bLUN]) &#123;</span><br><span class="line">        SCSI_SetSenseData(busid, SCSI_KCQIR_LBAOUTOFRANGE);</span><br><span class="line">        USB_LOG_ERR(<span class="string">&quot;LBA out of range\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (g_usbd_msc[busid].cbw.dDataLength != (g_usbd_msc[busid].nsectors * g_usbd_msc[busid].scsi_blk_size[g_usbd_msc[busid].cbw.bLUN])) &#123;</span><br><span class="line">        USB_LOG_ERR(<span class="string">&quot;scsi_blk_len does not match with dDataLength\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    g_usbd_msc[busid].stage = MSC_DATA_IN;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_USBDEV_MSC_THREAD)</span></span><br><span class="line">    usb_osal_mq_send(g_usbd_msc[busid].usbd_msc_mq, MSC_DATA_IN);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(CONFIG_USBDEV_MSC_POLLING)</span></span><br><span class="line">    chry_ringbuffer_write_byte(&amp;g_usbd_msc[busid].msc_rb, MSC_DATA_IN);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> SCSI_processRead(busid);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="SCSI-CMD-TESTUNITREADY-0x00"><a href="#SCSI-CMD-TESTUNITREADY-0x00" class="headerlink" title="SCSI_CMD_TESTUNITREADY 0x00"></a>SCSI_CMD_TESTUNITREADY 0x00</h5><ul>
<li>TEST UNIT READY命令(参见表202)提供了一种检查逻辑单元是否就绪的方法。这不是要求自测。如果逻辑单元能够接受适当的介质访问命令而不返回CHECK CONDITION状态，则该命令应返回GOOD状态。如果逻辑单元无法运行或处于需要应用程序客户端操作(例如，START unit命令)使逻辑单元准备就绪的状态，则该命令应以CHECK CONDITION状态终止，并将感测键设置为NOT ready。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">SCSI_testUnitReady</span><span class="params">(<span class="type">uint8_t</span> busid, <span class="type">uint8_t</span> **data, <span class="type">uint32_t</span> *len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (g_usbd_msc[busid].cbw.dDataLength != <span class="number">0U</span>) &#123;</span><br><span class="line">        SCSI_SetSenseData(busid, SCSI_KCQIR_INVALIDCOMMAND);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *data = <span class="literal">NULL</span>;</span><br><span class="line">    *len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="SCSI-CMD-PREVENTMEDIAREMOVAL-0x1E"><a href="#SCSI-CMD-PREVENTMEDIAREMOVAL-0x1E" class="headerlink" title="SCSI_CMD_PREVENTMEDIAREMOVAL 0x1E"></a>SCSI_CMD_PREVENTMEDIAREMOVAL 0x1E</h5><ul>
<li>这个命令告诉UFI设备启用或禁用删除逻辑单元中的介质</li>
</ul>
<table>
<thead>
<tr>
<th>字节</th>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody><tr>
<td><strong>0</strong></td>
<td>操作码 (4Eh)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>1</strong></td>
<td>逻辑单元号</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>保留</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>保留</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>4</strong></td>
<td>保留</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Prevent</td>
</tr>
<tr>
<td><strong>5</strong></td>
<td>保留</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>6</strong></td>
<td>保留</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>7</strong></td>
<td>保留</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>8</strong></td>
<td>保留</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>9</strong></td>
<td>保留</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>10</strong></td>
<td>保留</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>11</strong></td>
<td>保留</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>Prevent: 0x01 防止介质删除 0x00 允许介质删除</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">SCSI_preventAllowMediaRemoval</span><span class="params">(<span class="type">uint8_t</span> busid, <span class="type">uint8_t</span> **data, <span class="type">uint32_t</span> *len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (g_usbd_msc[busid].cbw.dDataLength != <span class="number">0U</span>) &#123;</span><br><span class="line">        SCSI_SetSenseData(busid, SCSI_KCQIR_INVALIDCOMMAND);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (g_usbd_msc[busid].cbw.CB[<span class="number">4</span>] == <span class="number">0U</span>) &#123;</span><br><span class="line">        <span class="comment">//SCSI_MEDIUM_UNLOCKED;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//SCSI_MEDIUM_LOCKED;</span></span><br><span class="line">    &#125;</span><br><span class="line">    *data = <span class="literal">NULL</span>;</span><br><span class="line">    *len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="WRITE-10-0x2a"><a href="#WRITE-10-0x2a" class="headerlink" title="WRITE(10) 0x2a"></a>WRITE(10) 0x2a</h5><ul>
<li>WRITE(10)命令请求UFI设备将主机传输的数据写入介质</li>
</ul>
<table>
<thead>
<tr>
<th>字节</th>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody><tr>
<td><strong>0</strong></td>
<td>操作码 (2Ah)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>1</strong></td>
<td>逻辑单元号</td>
<td>DPO</td>
<td>FUA</td>
<td>保留</td>
<td>RelAdr</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>(MSB)</td>
<td>逻辑块地址</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>逻辑块地址</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>4</strong></td>
<td>逻辑块地址</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>5</strong></td>
<td>逻辑块地址</td>
<td>(LSB)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>6</strong></td>
<td>保留</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>7</strong></td>
<td>传输长度 (MSB)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>8</strong></td>
<td>传输长度 (LSB)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>9</strong></td>
<td>保留</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>10</strong></td>
<td>保留</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>11</strong></td>
<td>保留</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><p>逻辑块地址:该字段指定写操作开始的逻辑块。</p>
</li>
<li><p>传输长度:传输长度字段指定要传输的连续数据逻辑块的数量。传输长度为0表示不传输逻辑块。此情况不应视为错误，也不应写入任何数据。任何其他值表示需要传输的逻辑块的数量</p>
</li>
<li><p>主机将要写入的数据发送到Bulk Output端点上的UFI设备。传输的字节数应该是传输长度乘以逻辑块大小。如果WRITE命令成功完成，则UFI设备将感测数据设置为NO sense。否则，设备应将感测数据设置为第5节所列的适当值。如果WRITE命令因为USB位填充错误或CRC错误而被终止，UFI设备应该将感测数据设置为USB to HOST SYSTEM INTERFACE FAILURE。注意:即使发生了写错误，介质也可能被改变了。对于跨越磁盘的多个物理磁道的命令块尤其如此。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 获取传输过来需要写入的LBA和写入的块数,并判断是否超出范围</span></span><br><span class="line"><span class="comment">    2. 判断`dDataLength`是否和`nsectors * scsi_blk_size`相等</span></span><br><span class="line"><span class="comment">    3. 设置`stage`为`MSC_DATA_OUT`,并发送`MSC_DATA_OUT`消息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">SCSI_write10</span><span class="params">(<span class="type">uint8_t</span> busid, <span class="type">uint8_t</span> **data, <span class="type">uint32_t</span> *len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> data_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    g_usbd_msc[busid].start_sector = GET_BE32(&amp;g_usbd_msc[busid].cbw.CB[<span class="number">2</span>]); <span class="comment">/* Logical Block Address of First Block */</span></span><br><span class="line">    USB_LOG_INFO(<span class="string">&quot;lba: 0x%04x\r\n&quot;</span>, g_usbd_msc[busid].start_sector);</span><br><span class="line"></span><br><span class="line">    g_usbd_msc[busid].nsectors = GET_BE16(&amp;g_usbd_msc[busid].cbw.CB[<span class="number">7</span>]); <span class="comment">/* Number of Blocks to transfer */</span></span><br><span class="line">    USB_LOG_INFO(<span class="string">&quot;nsectors: 0x%02x\r\n&quot;</span>, g_usbd_msc[busid].nsectors);</span><br><span class="line"></span><br><span class="line">    data_len = g_usbd_msc[busid].nsectors * g_usbd_msc[busid].scsi_blk_size[g_usbd_msc[busid].cbw.bLUN];</span><br><span class="line">    <span class="keyword">if</span> ((g_usbd_msc[busid].start_sector + g_usbd_msc[busid].nsectors) &gt; g_usbd_msc[busid].scsi_blk_nbr[g_usbd_msc[busid].cbw.bLUN]) &#123;</span><br><span class="line">        USB_LOG_ERR(<span class="string">&quot;LBA out of range\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (g_usbd_msc[busid].cbw.dDataLength != data_len) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    g_usbd_msc[busid].stage = MSC_DATA_OUT;</span><br><span class="line">    data_len = MIN(data_len, CONFIG_USBDEV_MSC_MAX_BUFSIZE);</span><br><span class="line">    usbd_ep_start_read(busid, mass_ep_data[busid][MSD_OUT_EP_IDX].ep_addr, g_usbd_msc[busid].block_buffer, data_len);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Command-Status-Wrapper-CSW"><a href="#Command-Status-Wrapper-CSW" class="headerlink" title="Command Status Wrapper (CSW)"></a>Command Status Wrapper (CSW)</h4><ul>
<li>表 5.3 - 命令块状态值</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>00h</td>
<td>命令通过（“good status”）</td>
</tr>
<tr>
<td>01h</td>
<td>命令失败</td>
</tr>
<tr>
<td>02h</td>
<td>阶段错误</td>
</tr>
<tr>
<td>03和04号</td>
<td>预留（Obsolete）</td>
</tr>
<tr>
<td>05到FF号</td>
<td>预留</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** MSC Bulk-Only Command Status Wrapper (CSW) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CSW</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> dSignature;   <span class="comment">/* &#x27;USBS&#x27; = 0x53425355 */</span></span><br><span class="line">    <span class="type">uint32_t</span> dTag;         <span class="comment">/* Same tag as original command */</span></span><br><span class="line">    <span class="type">uint32_t</span> dDataResidue; <span class="comment">/* Amount not transferred */</span></span><br><span class="line">    <span class="type">uint8_t</span> bStatus;       <span class="comment">/* Status of transfer */</span></span><br><span class="line">&#125; __PACKED;</span><br></pre></td></tr></table></figure>

<h2 id="HID-Human-Interface-Device"><a href="#HID-Human-Interface-Device" class="headerlink" title="HID (Human Interface Device)"></a>HID (Human Interface Device)</h2><h3 id="抓包-1"><a href="#抓包-1" class="headerlink" title="抓包"></a>抓包</h3><h3 id="描述符-1"><a href="#描述符-1" class="headerlink" title="描述符"></a>描述符</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint8_t</span> hid_descriptor[] = &#123;</span><br><span class="line">    USB_DEVICE_DESCRIPTOR_INIT(USB_2_0, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, USBD_VID, USBD_PID, <span class="number">0x0002</span>, <span class="number">0x01</span>),</span><br><span class="line">    USB_CONFIG_DESCRIPTOR_INIT(USB_HID_CONFIG_DESC_SIZ, <span class="number">0x01</span>, <span class="number">0x01</span>, USB_CONFIG_BUS_POWERED, USBD_MAX_POWER),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/************** Descriptor of Joystick Mouse interface ****************/</span></span><br><span class="line">    <span class="comment">/* 09 */</span></span><br><span class="line">    <span class="number">0x09</span>,                          <span class="comment">/* bLength: Interface Descriptor size */</span></span><br><span class="line">    USB_DESCRIPTOR_TYPE_INTERFACE, <span class="comment">/* bDescriptorType: Interface descriptor type */</span></span><br><span class="line">    <span class="number">0x00</span>,                          <span class="comment">/* bInterfaceNumber: Number of Interface */</span></span><br><span class="line">    <span class="number">0x00</span>,                          <span class="comment">/* bAlternateSetting: Alternate setting */</span></span><br><span class="line">    <span class="number">0x01</span>,                          <span class="comment">/* bNumEndpoints */</span></span><br><span class="line">    <span class="number">0x03</span>,                          <span class="comment">/* bInterfaceClass: HID */</span></span><br><span class="line">    <span class="number">0x01</span>,                          <span class="comment">/* bInterfaceSubClass : 1=BOOT, 0=no boot */</span></span><br><span class="line">    <span class="number">0x01</span>,                          <span class="comment">/* nInterfaceProtocol : 0=none, 1=keyboard, 2=mouse */</span></span><br><span class="line">    <span class="number">0</span>,                             <span class="comment">/* iInterface: Index of string descriptor */</span></span><br><span class="line">    <span class="comment">/******************** Descriptor of Joystick Mouse HID ********************/</span></span><br><span class="line">    <span class="comment">/* 18 */</span></span><br><span class="line">    <span class="number">0x09</span>,                    <span class="comment">/* bLength: HID Descriptor size */</span></span><br><span class="line">    HID_DESCRIPTOR_TYPE_HID, <span class="comment">/* bDescriptorType: HID */</span></span><br><span class="line">    <span class="number">0x11</span>,                    <span class="comment">/* bcdHID: HID Class Spec release number */</span></span><br><span class="line">    <span class="number">0x01</span>,</span><br><span class="line">    <span class="number">0x00</span>,                          <span class="comment">/* bCountryCode: Hardware target country */</span></span><br><span class="line">    <span class="number">0x01</span>,                          <span class="comment">/* bNumDescriptors: Number of HID class descriptors to follow */</span></span><br><span class="line">    <span class="number">0x22</span>,                          <span class="comment">/* bDescriptorType */</span></span><br><span class="line">    HID_KEYBOARD_REPORT_DESC_SIZE, <span class="comment">/* wItemLength: Total length of Report descriptor */</span></span><br><span class="line">    <span class="number">0x00</span>,</span><br><span class="line">    <span class="comment">/******************** Descriptor of Mouse endpoint ********************/</span></span><br><span class="line">    <span class="comment">/* 27 */</span></span><br><span class="line">    <span class="number">0x07</span>,                         <span class="comment">/* bLength: Endpoint Descriptor size */</span></span><br><span class="line">    USB_DESCRIPTOR_TYPE_ENDPOINT, <span class="comment">/* bDescriptorType: */</span></span><br><span class="line">    HID_INT_EP,                   <span class="comment">/* bEndpointAddress: Endpoint Address (IN) */</span></span><br><span class="line">    <span class="number">0x03</span>,                         <span class="comment">/* bmAttributes: Interrupt endpoint */</span></span><br><span class="line">    HID_INT_EP_SIZE,              <span class="comment">/* wMaxPacketSize: 4 Byte max */</span></span><br><span class="line">    <span class="number">0x00</span>,</span><br><span class="line">    HID_INT_EP_INTERVAL, <span class="comment">/* bInterval: Polling Interval */</span></span><br><span class="line">    <span class="comment">/* 34 */</span></span><br><span class="line">    <span class="comment">///////////////////////////////////////</span></span><br><span class="line">    <span class="comment">/// string0 descriptor</span></span><br><span class="line">    <span class="comment">///////////////////////////////////////</span></span><br><span class="line">    USB_LANGID_INIT(USBD_LANGID_STRING),</span><br><span class="line">    <span class="comment">///////////////////////////////////////</span></span><br><span class="line">    <span class="comment">/// string1 descriptor</span></span><br><span class="line">    <span class="comment">///////////////////////////////////////</span></span><br><span class="line">    <span class="number">0x14</span>,                       <span class="comment">/* bLength */</span></span><br><span class="line">    USB_DESCRIPTOR_TYPE_STRING, <span class="comment">/* bDescriptorType */</span></span><br><span class="line">    <span class="string">&#x27;C&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar0 */</span></span><br><span class="line">    <span class="string">&#x27;h&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar1 */</span></span><br><span class="line">    <span class="string">&#x27;e&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar2 */</span></span><br><span class="line">    <span class="string">&#x27;r&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar3 */</span></span><br><span class="line">    <span class="string">&#x27;r&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar4 */</span></span><br><span class="line">    <span class="string">&#x27;y&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar5 */</span></span><br><span class="line">    <span class="string">&#x27;U&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar6 */</span></span><br><span class="line">    <span class="string">&#x27;S&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar7 */</span></span><br><span class="line">    <span class="string">&#x27;B&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar8 */</span></span><br><span class="line">    <span class="comment">///////////////////////////////////////</span></span><br><span class="line">    <span class="comment">/// string2 descriptor</span></span><br><span class="line">    <span class="comment">///////////////////////////////////////</span></span><br><span class="line">    <span class="number">0x26</span>,                       <span class="comment">/* bLength */</span></span><br><span class="line">    USB_DESCRIPTOR_TYPE_STRING, <span class="comment">/* bDescriptorType */</span></span><br><span class="line">    <span class="string">&#x27;C&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar0 */</span></span><br><span class="line">    <span class="string">&#x27;h&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar1 */</span></span><br><span class="line">    <span class="string">&#x27;e&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar2 */</span></span><br><span class="line">    <span class="string">&#x27;r&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar3 */</span></span><br><span class="line">    <span class="string">&#x27;r&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar4 */</span></span><br><span class="line">    <span class="string">&#x27;y&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar5 */</span></span><br><span class="line">    <span class="string">&#x27;U&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar6 */</span></span><br><span class="line">    <span class="string">&#x27;S&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar7 */</span></span><br><span class="line">    <span class="string">&#x27;B&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar8 */</span></span><br><span class="line">    <span class="string">&#x27; &#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar9 */</span></span><br><span class="line">    <span class="string">&#x27;H&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar10 */</span></span><br><span class="line">    <span class="string">&#x27;I&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar11 */</span></span><br><span class="line">    <span class="string">&#x27;D&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar12 */</span></span><br><span class="line">    <span class="string">&#x27; &#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar13 */</span></span><br><span class="line">    <span class="string">&#x27;D&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar14 */</span></span><br><span class="line">    <span class="string">&#x27;E&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar15 */</span></span><br><span class="line">    <span class="string">&#x27;M&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar16 */</span></span><br><span class="line">    <span class="string">&#x27;O&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar17 */</span></span><br><span class="line">    <span class="comment">///////////////////////////////////////</span></span><br><span class="line">    <span class="comment">/// string3 descriptor</span></span><br><span class="line">    <span class="comment">///////////////////////////////////////</span></span><br><span class="line">    <span class="number">0x16</span>,                       <span class="comment">/* bLength */</span></span><br><span class="line">    USB_DESCRIPTOR_TYPE_STRING, <span class="comment">/* bDescriptorType */</span></span><br><span class="line">    <span class="string">&#x27;2&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar0 */</span></span><br><span class="line">    <span class="string">&#x27;0&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar1 */</span></span><br><span class="line">    <span class="string">&#x27;2&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar2 */</span></span><br><span class="line">    <span class="string">&#x27;2&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar3 */</span></span><br><span class="line">    <span class="string">&#x27;1&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar4 */</span></span><br><span class="line">    <span class="string">&#x27;2&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar5 */</span></span><br><span class="line">    <span class="string">&#x27;3&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar6 */</span></span><br><span class="line">    <span class="string">&#x27;4&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar7 */</span></span><br><span class="line">    <span class="string">&#x27;5&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar8 */</span></span><br><span class="line">    <span class="string">&#x27;6&#x27;</span>, <span class="number">0x00</span>,                  <span class="comment">/* wcChar9 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_USB_HS</span></span><br><span class="line">    <span class="comment">///////////////////////////////////////</span></span><br><span class="line">    <span class="comment">/// device qualifier descriptor</span></span><br><span class="line">    <span class="comment">///////////////////////////////////////</span></span><br><span class="line">    <span class="number">0x0a</span>,</span><br><span class="line">    USB_DESCRIPTOR_TYPE_DEVICE_QUALIFIER,</span><br><span class="line">    <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x02</span>,</span><br><span class="line">    <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x40</span>,</span><br><span class="line">    <span class="number">0x01</span>,</span><br><span class="line">    <span class="number">0x00</span>,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="number">0x00</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/wdfk-prog">Liya Huang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://wdfk-prog.space/posts/9c721b62/">https://wdfk-prog.space/posts/9c721b62/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://wdfk-prog.space" target="_blank">wdfk-prog的个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/rt-thread/">rt-thread</a></div><div class="post-share"><div class="social-share" data-image="/images/covers/06.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/images/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/images/alipay.png" target="_blank"><img class="post-qr-code-img" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/alipay.png" alt="支付寶"/></a><div class="post-qr-code-desc">支付寶</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/79c94d14/" title="I2C驱动"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/10.jpg" onerror="onerror=null;src='/images/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">I2C驱动</div></div><div class="info-2"><div class="info-item-1">I2C驱动 https://www.i2c-bus.org/i2c-primer/termination-versus-capacitance/  硬件电路 I2C 总线使用 SDA 和 SCL 传输数据和时钟。首先要意识到：SDA 和 SCL 是开漏（在 TTL 世界中也称为开集），也就是说 I2C 主设备和从设备只能将这些线路驱动为低电平或保持开路。如果没有 I2C 设备将其拉低，终端电阻Rp 会将线路拉高至 Vcc。这允许同时操作多个 I2C 主设备（如果它们具有**多主设备功能）或拉伸（从设备可以通过按住 SCL 来减慢通信速度）等功能。 终端电阻 Rp 与线路电容 Cp 一起影响 SDA 和 SCL 上信号的时间行为。虽然 I2C 设备使用开漏驱动器或 FET 拉低线路（通常可以驱动至少约 10mA 或更多），但上拉电阻 Rp 负责将信号恢复到高电平。Rp 通常在 1 kΩ 至 10 kΩ 之间，导致典型的上拉电流约为 1 mA 或更小。这就是 I2C 信号具有锯齿状外观的原因。事实上，每个“齿”在上升沿显示线路的充电特性，在下降沿显示放电特性。  SDA（上）和 SC...</div></div></div></a><a class="pagination-related" href="/posts/8bf91915/" title="fal"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/02.jpg" onerror="onerror=null;src='/images/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">fal</div></div><div class="info-2"><div class="info-item-1">fal flash抽象层-FAL_FLASH_DEV_TABLE设备表挂载不同flash设备 -FAL_PART_TABLE分区表对同一个flash挂载不同分区 -blocks 对不同颗粒度的flash进行分块 初始化 执行 fal_init  -FAL_FLASH_DEV_TABLE注册flash设备  fal_flash_init   遍历注册表信息,执行flash初始化,与block分割   fal_partition_init   使用ROM保存分区表,每次查询并挂钩 FAL_PART_TABLE分区表 使用FLASH保存分区表,仅需读取 加载分区表,读取分区信息 检查flash设备是否都存在  注册设备 注册块设备, 或字符串设备,或MTD nor设备  1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162struct rt_mtd_nor_device&#123;    struct rt_d...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/fa99c9bd/" title="fatfs"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/04.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-03</div><div class="info-item-2">fatfs</div></div><div class="info-2"><div class="info-item-1">fatfs 因此应用程序应尽可能以大块的形式写入数据。理想的写入块大小和对齐方式是扇区大小，簇大小最好。当然，应用程序和存储设备之间的所有层都必须考虑多扇区写入，但大多数开源存储卡驱动程序都缺乏这一点。不要将多扇区写入请求拆分为单扇区写入事务，否则写入吞吐量会变差。 努力实现扇区对齐的读&#x2F;写访问可以消除缓冲数据传输，从而提高读&#x2F;写性能。除此之外，在 tiny 配置下，缓存的 FAT 数据不会被文件数据传输刷新，因此它可以以较小的内存占用实现与非 tiny 配置相同的性能。 如果由于意外故障（例如突然断电、错误移除介质和不可恢复的磁盘错误）而中断对 FAT 卷的写入操作，则卷上的 FAT 结构可能会被破坏。为了最大限度地降低数据丢失的风险，可以通过最小化以写入模式打开文件的时间或使用f_sync函数来最小化临界区 FatFs 模块不支持对文件的重复打开的读写冲突控制。仅当对文件的每种打开方式都是读取模式时才允许重复打开。始终禁止对文件进行一次或多次写入模式的重复打开，并且打开的文件不得重命名或删除。违反这些规则可能会导致数据冲突。  文件系统操作mkfs 格式化...</div></div></div></a><a class="pagination-related" href="/posts/afef3039/" title="CAN驱动"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/06.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-03</div><div class="info-item-2">CAN驱动</div></div><div class="info-2"><div class="info-item-1">CAN驱动CAN驱动框架CAN初始化-rt_hw_can_register注册CAN设备,并初始化互斥量 -rt_timer_init初始化CAN定时器,注册定时器回调函数 cantimeout 初始化&amp;&amp;配置 RT_CAN_CMD_SET_PRIV  123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960if (can-&gt;config.privmode)            &#123;                for (i = 0;  i &lt; can-&gt;config.sndboxnumber; i++)                &#123;                    level = rt_hw_interrupt_disable();                    if(rt_list_isempty(&amp;tx_fifo-&gt;buff...</div></div></div></a><a class="pagination-related" href="/posts/386931f6/" title="PM电源管理"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/05.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-03</div><div class="info-item-2">PM电源管理</div></div><div class="info-2"><div class="info-item-1">PM电源管理初始化drv_pm_hw_init -&gt; rt_system_pm_init 1234567891011121314/* initialize timer mask */timer_mask = 1UL &lt;&lt; PM_SLEEP_MODE_DEEP;/* when system power on, set default sleep modes */pm-&gt;modes[pm-&gt;sleep_mode] = 1;pm-&gt;module_status[PM_POWER_ID].req_status = 1;pm-&gt;run_mode   = RT_PM_DEFAULT_RUN_MODE;  pm设备注册12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/** * Register a...</div></div></div></a><a class="pagination-related" href="/posts/fdf8ebd7/" title="FINSH模块"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/04.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-03</div><div class="info-item-2">FINSH模块</div></div><div class="info-2"><div class="info-item-1">FINSH模块MSH初始化 根据链接脚本指明FINSH使用内存空间 _syscall_table_begin _syscall_table_end的地址  FSymtab段1234. = ALIGN(4);__fsymtab_start = .;KEEP(*(FSymTab))__fsymtab_end = .;   __fsymtab_start和 __fsymtab_end用于指明finsh使用内存 FSymTab用于存放所有注册命令的结构体 struct finsh_syscall,包括命令名称,命令选项,命令描述,命令函数执行地址信息  宏12345678910111213141516171819202122232425262728293031/** * @ingroup msh * * This macro exports a command to module shell. * * @param command is the name of the command. * @param desc is the description of the command, wh...</div></div></div></a><a class="pagination-related" href="/posts/dc9314c3/" title="DFS"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/09.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-03</div><div class="info-item-2">DFS</div></div><div class="info-2"><div class="info-item-1">DFS 虚拟文件系统https://www.rt-thread.org/document/site/#/rt-thread-version/rt-thread-standard/programming-manual/filesystem/filesystem 123456789101112131415161718FatFS 是专为小型嵌入式设备开发的一个兼容微软 FAT 格式的文件系统，采用 ANSI C 编写，具有良好的硬件无关性以及可移植性，是 RT-Thread 中最常用的文件系统类型。传统型的 RomFS 文件系统是一种简单的、紧凑的、只读的文件系统，不支持动态擦写保存，按顺序存放数据，因而支持应用程序以 XIP(execute In Place，片内运行) 方式运行，在系统运行时, 节省 RAM 空间。Jffs2 文件系统是一种日志闪存文件系统。主要用于 NOR 型闪存，基于 MTD 驱动层，特点是：可读写的、支持数据压缩的、基于哈希表的日志型文件系统，并提供了崩溃 / 掉电安全保护，提供写平衡支持等。DevFS 即设备文件系统，在 RT-Thread 操作系统中开启该...</div></div></div></a><a class="pagination-related" href="/posts/6e6a3ae8/" title="ARM指针寄存器"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/07.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-03</div><div class="info-item-2">ARM指针寄存器</div></div><div class="info-2"><div class="info-item-1">ARM指针寄存器 https://blog.csdn.net/zhuguanlin121/article/details/120883025  -堆栈指针r13 SP：每一种异常模式都有其自己独立的r13，它通常指向异常模式所专用的堆栈，也就是说五种异常模式、非异常模式（用户模式和系统模式），都有各自独立的堆栈，用不同的堆栈指针来索引。这样当ARM进入异常模式的时候，程序就可以把一般通用寄存器压入堆栈，返回时再出栈，保证了各种模式下程序的状态的完整性。 栈顶指针（Stack Pointer）是寄存器页的核心，用以指向系统栈的栈顶位置，某些情况下也可以作为通用寄存器来使用，例如，在 ARM Cortex M 内核中，SP 可以作为 R13 来使用。由于栈是函数式语言的核心，在操作系统中 SP 的地位举足轻重，以 RT-Thread 为例，每个用户任务都有独享的栈，任务的切换几乎就是栈的切换，也就是栈顶指针的切换，我们可以毫不夸张的说：栈顶指针就是每个任务的生命线。 -连接寄存器r14 LR：每种模式下r14都有自身版组，它有两个特殊功能。 （1）保存子程序返回地址。使用BL或BLX...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/avatar.png" onerror="this.onerror=null;this.src='/images/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Liya Huang</div><div class="author-info-description">WORK-LIFE BALANCE</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">417</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">49</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">53</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/wdfk-prog"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/wdfk-prog" rel="external nofollow noreferrer" target="_blank" title="GitHub"><i class="fab fa-github" style="color: #181717;"></i></a><a class="social-icon" href="https://wdfk-prog.blog.csdn.net/" rel="external nofollow noreferrer" target="_blank" title="CSDN"><i class="fas fa-blog" style="color: #FC5531;"></i></a><a class="social-icon" href="mailto:1425075683@qq.com" rel="external nofollow noreferrer" target="_blank" title="E-mail"><i class="fas fa-envelope" style="color: #4A4A4A;"></i></a><a class="social-icon" href="/images/wechat-qrcode.jpg" target="_blank" title="微信公众号"><i class="fab fa-weixin" style="color: #07C160;"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss" style="color: #EE802F;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎光临！有任何问题或想法，欢迎在文章下留言交流，或者通过 <a href='/about/'>关于页面</a> 联系我。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#USB"><span class="toc-number">1.</span> <span class="toc-text">USB</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#USB2-0"><span class="toc-number">1.1.</span> <span class="toc-text">USB2.0</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E4%B8%8E%E9%85%8D%E7%BD%AE"><span class="toc-number">1.1.1.</span> <span class="toc-text">枚举与配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Endpoint"><span class="toc-number">1.1.2.</span> <span class="toc-text">Endpoint</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Device-Requests"><span class="toc-number">1.1.3.</span> <span class="toc-text">Device Requests</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">1.1.4.</span> <span class="toc-text">描述符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E8%AE%BE%E5%A4%87%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">标准设备描述符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E9%85%8D%E7%BD%AE%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">标准配置描述符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IAD%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">IAD描述符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E6%8E%A5%E5%8F%A3%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">1.1.4.4.</span> <span class="toc-text">标准接口描述符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E7%AB%AF%E7%82%B9%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">1.1.4.5.</span> <span class="toc-text">标准端点描述符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">1.1.4.6.</span> <span class="toc-text">字符串描述符</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cherryUSB"><span class="toc-number">2.</span> <span class="toc-text">cherryUSB</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%82%E9%A1%B9"><span class="toc-number">2.1.</span> <span class="toc-text">杂项</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#dwc2"><span class="toc-number">3.</span> <span class="toc-text">dwc2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#usb-dc-init"><span class="toc-number">3.1.</span> <span class="toc-text">usb_dc_init</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#usb-dc-low-level-init"><span class="toc-number">3.2.</span> <span class="toc-text">usb_dc_low_level_init</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#USBD-IRQHandler"><span class="toc-number">3.3.</span> <span class="toc-text">USBD_IRQHandler</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#USB%E5%A4%8D%E4%BD%8D-USB-OTG-GINTSTS-USBRST"><span class="toc-number">3.3.1.</span> <span class="toc-text">USB复位 USB_OTG_GINTSTS_USBRST</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#USB-OUT%E7%AB%AF%E7%82%B9%E4%B8%AD%E6%96%AD-USB-OTG-GINTSTS-OEPINT"><span class="toc-number">3.3.2.</span> <span class="toc-text">USB OUT端点中断 USB_OTG_GINTSTS_OEPINT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#USB-RxFIFO-nonempty-%E4%B8%AD%E6%96%AD-USB-OTG-GINTSTS-RXFLVL"><span class="toc-number">3.3.3.</span> <span class="toc-text">USB RxFIFO nonempty 中断 USB_OTG_GINTSTS_RXFLVL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#USB-IN%E7%AB%AF%E7%82%B9%E4%B8%AD%E6%96%AD-USB-OTG-GINTSTS-IEPINT"><span class="toc-number">3.3.4.</span> <span class="toc-text">USB IN端点中断 USB_OTG_GINTSTS_IEPINT</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#usbd-ep-open"><span class="toc-number">3.4.</span> <span class="toc-text">usbd_ep_open</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dwc2-ep0-start-read-setup"><span class="toc-number">3.5.</span> <span class="toc-text">dwc2_ep0_start_read_setup</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#usbd-event-ep0-setup-complete-handler"><span class="toc-number">3.6.</span> <span class="toc-text">usbd_event_ep0_setup_complete_handler</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#usbd-ep-start-read"><span class="toc-number">3.7.</span> <span class="toc-text">usbd_ep_start_read</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#usbd-ep-set-stall"><span class="toc-number">3.7.1.</span> <span class="toc-text">usbd_ep_set_stall</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#usbd-ep-start-write"><span class="toc-number">3.8.</span> <span class="toc-text">usbd_ep_start_write</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dwc2-tx-fifo-empty-procecss"><span class="toc-number">3.9.</span> <span class="toc-text">dwc2_tx_fifo_empty_procecss</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#usbd-event-ep0-in-complete-handler"><span class="toc-number">3.10.</span> <span class="toc-text">usbd_event_ep0_in_complete_handler</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#usbd-event-ep-out-complete-handler"><span class="toc-number">3.11.</span> <span class="toc-text">usbd_event_ep_out_complete_handler</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#usbd-set-address"><span class="toc-number">3.12.</span> <span class="toc-text">usbd_set_address</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#device"><span class="toc-number">4.</span> <span class="toc-text">device</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#core"><span class="toc-number">4.1.</span> <span class="toc-text">core</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#usbd-desc-register"><span class="toc-number">4.1.1.</span> <span class="toc-text">usbd_desc_register</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#usbd-add-interface"><span class="toc-number">4.1.2.</span> <span class="toc-text">usbd_add_interface</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#usbd-add-endpoint"><span class="toc-number">4.1.3.</span> <span class="toc-text">usbd_add_endpoint</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#usbd-initialize"><span class="toc-number">4.1.4.</span> <span class="toc-text">usbd_initialize</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#usbd-class-event-notify-handler"><span class="toc-number">4.1.5.</span> <span class="toc-text">usbd_class_event_notify_handler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#usbd-event-reset-handler"><span class="toc-number">4.1.6.</span> <span class="toc-text">usbd_event_reset_handler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#usbd-setup-request-handler"><span class="toc-number">4.1.7.</span> <span class="toc-text">usbd_setup_request_handler</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#USB-REQUEST-STANDARD-0x00-%E6%A0%87%E5%87%86%E8%AF%B7%E6%B1%82"><span class="toc-number">4.1.7.1.</span> <span class="toc-text">USB_REQUEST_STANDARD 0x00 标准请求</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#USB-REQUEST-RECIPIENT-DEVICE-0x00-%E8%AE%BE%E5%A4%87"><span class="toc-number">4.1.7.1.1.</span> <span class="toc-text">USB_REQUEST_RECIPIENT_DEVICE 0x00 设备</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#USB-REQUEST-GET-STATUS-0x00-%E8%8E%B7%E5%8F%96%E8%AE%BE%E5%A4%87%E7%8A%B6%E6%80%81"><span class="toc-number">4.1.7.1.1.1.</span> <span class="toc-text">USB_REQUEST_GET_STATUS 0x00 获取设备状态</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#USB-REQUEST-CLEAR-FEATURE-0x01-%E6%B8%85%E9%99%A4%E8%AE%BE%E5%A4%87%E7%89%B9%E6%80%A7"><span class="toc-number">4.1.7.1.1.2.</span> <span class="toc-text">USB_REQUEST_CLEAR_FEATURE 0x01 清除设备特性</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#USB-REQUEST-SET-FEATURE-0x03-%E8%AE%BE%E7%BD%AE%E8%AE%BE%E5%A4%87%E7%89%B9%E6%80%A7"><span class="toc-number">4.1.7.1.1.3.</span> <span class="toc-text">USB_REQUEST_SET_FEATURE 0x03 设置设备特性</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#USB-REQUEST-SET-ADDRESS-0x05-%E8%AE%BE%E7%BD%AE%E8%AE%BE%E5%A4%87%E5%9C%B0%E5%9D%80"><span class="toc-number">4.1.7.1.1.4.</span> <span class="toc-text">USB_REQUEST_SET_ADDRESS 0x05 设置设备地址</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#USB-REQUEST-GET-DESCRIPTOR-0x06-%E8%8E%B7%E5%8F%96%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">4.1.7.1.1.5.</span> <span class="toc-text">USB_REQUEST_GET_DESCRIPTOR 0x06 获取描述符</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#USB-REQUEST-SET-DESCRIPTOR-0x07-%E8%AE%BE%E7%BD%AE%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">4.1.7.1.1.6.</span> <span class="toc-text">USB_REQUEST_SET_DESCRIPTOR 0x07 设置描述符</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#USB-REQUEST-GET-CONFIGURATION-0x08-%E8%8E%B7%E5%8F%96%E9%85%8D%E7%BD%AE"><span class="toc-number">4.1.7.1.1.7.</span> <span class="toc-text">USB_REQUEST_GET_CONFIGURATION 0x08 获取配置</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#USB-REQUEST-SET-CONFIGURATION-0x09-%E8%AE%BE%E7%BD%AE%E9%85%8D%E7%BD%AE"><span class="toc-number">4.1.7.1.1.8.</span> <span class="toc-text">USB_REQUEST_SET_CONFIGURATION 0x09 设置配置</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#USB-REQUEST-GET-INTERFACE-0x0A-%E8%8E%B7%E5%8F%96%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.1.7.1.1.9.</span> <span class="toc-text">USB_REQUEST_GET_INTERFACE 0x0A 获取接口</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#USB-REQUEST-SET-INTERFACE-0x0B-%E8%AE%BE%E7%BD%AE%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.1.7.1.1.10.</span> <span class="toc-text">USB_REQUEST_SET_INTERFACE 0x0B 设置接口</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#USB-REQUEST-RECIPIENT-INTERFACE-0x01-%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.1.7.1.2.</span> <span class="toc-text">USB_REQUEST_RECIPIENT_INTERFACE 0x01 接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#USB-REQUEST-RECIPIENT-ENDPOINT-0x02-%E7%AB%AF%E7%82%B9"><span class="toc-number">4.1.7.1.3.</span> <span class="toc-text">USB_REQUEST_RECIPIENT_ENDPOINT  0x02 端点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#USB-REQUEST-CLASS-0x1-%E7%B1%BB"><span class="toc-number">4.1.7.2.</span> <span class="toc-text">USB_REQUEST_CLASS 0x1 类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#USB-REQUEST-RECIPIENT-INTERFACE-0x01-%E6%8E%A5%E5%8F%A3-1"><span class="toc-number">4.1.7.2.1.</span> <span class="toc-text">USB_REQUEST_RECIPIENT_INTERFACE 0x01 接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#USB-REQUEST-RECIPIENT-ENDPOINT-0x02-%E7%AB%AF%E7%82%B9-1"><span class="toc-number">4.1.7.2.2.</span> <span class="toc-text">USB_REQUEST_RECIPIENT_ENDPOINT 0x02 端点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#USB-REQUEST-VENDOR-0x2-%E5%8E%82%E5%95%86"><span class="toc-number">4.1.7.3.</span> <span class="toc-text">USB_REQUEST_VENDOR 0x2 厂商</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#usbd-set-endpoint"><span class="toc-number">4.1.8.</span> <span class="toc-text">usbd_set_endpoint</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CDC-Communication-Device-Class"><span class="toc-number">4.2.</span> <span class="toc-text">CDC (Communication Device Class)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cdc-function"><span class="toc-number">4.2.1.</span> <span class="toc-text">cdc function</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#usbd-cdc-acm-init-intf"><span class="toc-number">4.2.1.1.</span> <span class="toc-text">usbd_cdc_acm_init_intf</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CDC-ACM-Abstract-Control-Model"><span class="toc-number">4.2.2.</span> <span class="toc-text">CDC-ACM (Abstract Control Model)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">4.2.2.1.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">4.2.2.2.</span> <span class="toc-text">全局描述符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CDC-ACM-%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">4.2.2.3.</span> <span class="toc-text">CDC_ACM 描述符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%BE%E4%BE%8B"><span class="toc-number">4.2.2.3.1.</span> <span class="toc-text">描述符举例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#usbd-event-handler"><span class="toc-number">4.2.2.4.</span> <span class="toc-text">usbd_event_handler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cdc-acm-class-interface-request-handler"><span class="toc-number">4.2.2.5.</span> <span class="toc-text">cdc_acm_class_interface_request_handler</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#CDC-REQUEST-GET-LINE-CODING-0x21-%E8%8E%B7%E5%8F%96%E7%BA%BF%E7%BC%96%E7%A0%81"><span class="toc-number">4.2.2.5.1.</span> <span class="toc-text">CDC_REQUEST_GET_LINE_CODING 0x21 获取线编码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CDC-REQUEST-SET-CONTROL-LINE-STATE-0x22-%E8%AE%BE%E7%BD%AE%E6%8E%A7%E5%88%B6%E7%BA%BF%E7%8A%B6%E6%80%81"><span class="toc-number">4.2.2.5.2.</span> <span class="toc-text">CDC_REQUEST_SET_CONTROL_LINE_STATE 0x22 设置控制线状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CDC-REQUEST-SET-LINE-CODING-0x20-%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%BC%96%E7%A0%81"><span class="toc-number">4.2.2.5.3.</span> <span class="toc-text">CDC_REQUEST_SET_LINE_CODING 0x20 设置线编码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Endpoint%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">4.2.3.</span> <span class="toc-text">Endpoint描述符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Functional-Descriptors"><span class="toc-number">4.2.3.1.</span> <span class="toc-text">Functional Descriptors</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Header-Functional-Descriptor"><span class="toc-number">4.2.3.1.1.</span> <span class="toc-text">Header Functional Descriptor</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Union-Functional-Descriptor"><span class="toc-number">4.2.3.1.2.</span> <span class="toc-text">Union Functional Descriptor</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MSC-Mass-Storage-Class"><span class="toc-number">4.3.</span> <span class="toc-text">MSC (Mass Storage Class)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%93%E5%8C%85"><span class="toc-number">4.3.1.</span> <span class="toc-text">抓包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E8%BF%87%E7%A8%8B"><span class="toc-number">4.3.1.1.</span> <span class="toc-text">枚举过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B"><span class="toc-number">4.3.1.2.</span> <span class="toc-text">数据交互过程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E6%96%AD%E8%AF%BB%E5%8F%96LBA%E5%88%86%E5%8C%BA%E6%95%B0%E6%8D%AE-wireshark%E6%8A%93%E5%8C%85%E5%AF%BC%E8%87%B4"><span class="toc-number">4.3.1.2.1.</span> <span class="toc-text">不断读取LBA分区数据(wireshark抓包导致)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%93%8D%E4%BD%9C"><span class="toc-number">4.3.1.2.2.</span> <span class="toc-text">执行格式化操作</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5%E8%BF%87%E7%A8%8B-%E5%88%9B%E5%BB%BA%E6%96%87%E6%9C%AC"><span class="toc-number">4.3.1.3.</span> <span class="toc-text">数据写入过程(创建文本)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#U%E7%9B%98%E5%BC%B9%E5%87%BA%E6%93%8D%E4%BD%9C"><span class="toc-number">4.3.1.4.</span> <span class="toc-text">U盘弹出操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#msc-function"><span class="toc-number">4.3.2.</span> <span class="toc-text">msc function</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#init"><span class="toc-number">4.3.2.1.</span> <span class="toc-text">init</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#usbd-msc-init-intf"><span class="toc-number">4.3.2.2.</span> <span class="toc-text">usbd_msc_init_intf</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#usbd-msc-get-cap"><span class="toc-number">4.3.2.3.</span> <span class="toc-text">usbd_msc_get_cap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#msc-storage-notify-handler"><span class="toc-number">4.3.2.4.</span> <span class="toc-text">msc_storage_notify_handler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mass-storage-bulk-out"><span class="toc-number">4.3.2.5.</span> <span class="toc-text">mass_storage_bulk_out</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#SCSI-CBWDecode"><span class="toc-number">4.3.2.5.1.</span> <span class="toc-text">SCSI_CBWDecode</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#SCSI-CMD-INQUIRY-0x12"><span class="toc-number">4.3.2.5.1.1.</span> <span class="toc-text">SCSI_CMD_INQUIRY 0x12</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#usbd-msc-send-info"><span class="toc-number">4.3.2.5.1.2.</span> <span class="toc-text">usbd_msc_send_info</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mass-storage-bulk-in"><span class="toc-number">4.3.2.6.</span> <span class="toc-text">mass_storage_bulk_in</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#MSC-SEND-CSW"><span class="toc-number">4.3.2.6.1.</span> <span class="toc-text">MSC_SEND_CSW</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#usbd-msc-send-csw"><span class="toc-number">4.3.2.7.</span> <span class="toc-text">usbd_msc_send_csw</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SCSI-processRead"><span class="toc-number">4.3.2.8.</span> <span class="toc-text">SCSI_processRead</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#usbd-msc-sector-read"><span class="toc-number">4.3.2.9.</span> <span class="toc-text">usbd_msc_sector_read</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#usbd-msc-sector-write"><span class="toc-number">4.3.3.</span> <span class="toc-text">usbd_msc_sector_write</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#msc-ram-descriptor"><span class="toc-number">4.3.4.</span> <span class="toc-text">msc_ram_descriptor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mass-Storage-Request-Codes"><span class="toc-number">4.3.5.</span> <span class="toc-text">Mass Storage Request Codes</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Get-Max-LUN-GML-0xFE"><span class="toc-number">4.3.5.1.</span> <span class="toc-text">Get Max LUN (GML) 0xFE</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bulk-Only-Transport-Protocol"><span class="toc-number">4.3.6.</span> <span class="toc-text">Bulk-Only Transport Protocol</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CBW-Command-Block-Wrapper"><span class="toc-number">4.3.6.1.</span> <span class="toc-text">CBW (Command Block Wrapper)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SCSI-Command"><span class="toc-number">4.3.6.2.</span> <span class="toc-text">SCSI Command</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#SCSI-CMD-INQUIRY-0x12-1"><span class="toc-number">4.3.6.2.1.</span> <span class="toc-text">SCSI_CMD_INQUIRY 0x12</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SCSI-CMD-READFORMATCAPACITIES-0x23"><span class="toc-number">4.3.6.2.2.</span> <span class="toc-text">SCSI_CMD_READFORMATCAPACITIES 0x23</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SCSI-CMD-READCAPACITY10-0x25"><span class="toc-number">4.3.6.2.3.</span> <span class="toc-text">SCSI_CMD_READCAPACITY10 0x25</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SCSI-CMD-MODESENSE6-0x1A"><span class="toc-number">4.3.6.2.4.</span> <span class="toc-text">SCSI_CMD_MODESENSE6 0x1A</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SCSI-CMD-READ10-0x28"><span class="toc-number">4.3.6.2.5.</span> <span class="toc-text">SCSI_CMD_READ10 0x28</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SCSI-CMD-TESTUNITREADY-0x00"><span class="toc-number">4.3.6.2.6.</span> <span class="toc-text">SCSI_CMD_TESTUNITREADY 0x00</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SCSI-CMD-PREVENTMEDIAREMOVAL-0x1E"><span class="toc-number">4.3.6.2.7.</span> <span class="toc-text">SCSI_CMD_PREVENTMEDIAREMOVAL 0x1E</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#WRITE-10-0x2a"><span class="toc-number">4.3.6.2.8.</span> <span class="toc-text">WRITE(10) 0x2a</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Command-Status-Wrapper-CSW"><span class="toc-number">4.3.6.3.</span> <span class="toc-text">Command Status Wrapper (CSW)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HID-Human-Interface-Device"><span class="toc-number">4.4.</span> <span class="toc-text">HID (Human Interface Device)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%93%E5%8C%85-1"><span class="toc-number">4.4.1.</span> <span class="toc-text">抓包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%E7%AC%A6-1"><span class="toc-number">4.4.2.</span> <span class="toc-text">描述符</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/48974a1a/" title="mq-deadline"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/08.jpg" onerror="this.onerror=null;this.src='/images/404.jpg'" alt="mq-deadline"/></a><div class="content"><a class="title" href="/posts/48974a1a/" title="mq-deadline">mq-deadline</a><time datetime="2025-10-10T09:35:34.893Z" title="更新于 2025-10-10 17:35:34">2025-10-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/44c8f818/" title="list"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/10.jpg" onerror="this.onerror=null;this.src='/images/404.jpg'" alt="list"/></a><div class="content"><a class="title" href="/posts/44c8f818/" title="list">list</a><time datetime="2025-10-10T08:51:23.325Z" title="更新于 2025-10-10 16:51:23">2025-10-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/447af9b5/" title="genhd"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/09.jpg" onerror="this.onerror=null;this.src='/images/404.jpg'" alt="genhd"/></a><div class="content"><a class="title" href="/posts/447af9b5/" title="genhd">genhd</a><time datetime="2025-10-10T08:50:59.612Z" title="更新于 2025-10-10 16:50:59">2025-10-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/ed4b199f/" title="class"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/01.jpg" onerror="this.onerror=null;this.src='/images/404.jpg'" alt="class"/></a><div class="content"><a class="title" href="/posts/ed4b199f/" title="class">class</a><time datetime="2025-10-10T08:38:03.324Z" title="更新于 2025-10-10 16:38:03">2025-10-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/aa511041/" title="blk-core"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/07.jpg" onerror="this.onerror=null;this.src='/images/404.jpg'" alt="blk-core"/></a><div class="content"><a class="title" href="/posts/aa511041/" title="blk-core">blk-core</a><time datetime="2025-10-10T08:15:30.737Z" title="更新于 2025-10-10 16:15:30">2025-10-10</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/images/covers/06.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">文档</div><div class="footer-flex-content"><a href="/categories/linux/" target="_blank" title="🚀 linux">🚀 linux</a><a href="/categories/rt-thread/" target="_blank" title="📑 rt-thread">📑 rt-thread</a><a href="/categories/uboot/" target="_blank" title="📌 uboot">📌 uboot</a><a href="/categories/LoraWan/" target="_blank" title="⚔️ LoraWan">⚔️ LoraWan</a><a href="/categories/hpatch/" target="_blank" title="❓ hpatch">❓ hpatch</a><a href="/categories/git/" target="_blank" title="⚡️ git">⚡️ git</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/gallery/" target="_blank" title="图库">图库</a><a href="/messageboard/" target="_blank" title="留言板">留言板</a><a href="/shuoshuo/" target="_blank" title="说说">说说</a><a href="/link/" target="_blank" title="示例">示例</a><a href="/link/" target="_blank" title="友链">友链</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">框架</div><div class="footer-flex-content"><a href="https://hexo.io/zh-cn/" rel="external nofollow noreferrer" target="_blank" title="Hexo">Hexo</a><a href="https://butterfly.js.org/" rel="external nofollow noreferrer" target="_blank" title="Butterfly">Butterfly</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">贊助</div><div class="footer-flex-content"><div><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/alipay.png" alt='wdfk_prog' width='100px' height='100px'></div></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Liya Huang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo 8.0.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.1</a></span></div><div class="footer_custom_text">你好，欢迎来到我的 <a href="/about/">数字花园</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天" style="display:none"><i class="fas fa-message"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script><script>(() => {
  const abcjsInit = () => {
    const abcjsFn = () => {
      setTimeout(() => {
        const sheets = document.querySelectorAll(".abc-music-sheet")
        for (let i = 0; i < sheets.length; i++) {
          const ele = sheets[i]
          if (ele.children.length > 0) continue

          // Parse parameters from data-params attribute
          let params = {}
          const dp = ele.getAttribute("data-params")
          if (dp) {
            try {
              params = JSON.parse(dp)
            } catch (e) {
              console.error("Failed to parse data-params:", e)
            }
          }

          // Merge parsed parameters with the responsive option
          // Ensures params content appears before responsive
          const options = { ...params, responsive: "resize" }

          // Render the music score using ABCJS.renderAbc
          ABCJS.renderAbc(ele, ele.innerHTML, options)
        }
      }, 100)
    }

    if (typeof ABCJS === "object") {
      abcjsFn()
    } else {
      btf.getScript("https://cdn.jsdelivr.net/npm/abcjs/dist/abcjs-basic-min.min.js").then(abcjsFn)
    }
  }

  if (window.pjax) {
    abcjsInit()
  } else {
    window.addEventListener("load", abcjsInit)
  }

  btf.addGlobalFn("encrypt", abcjsInit, "abcjs")
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: 'Ov23livBmwx65h3XIdfT',
      clientSecret: '9f23bdaa2ea11322f9f405d77bcdc27166077a7d',
      repo: 'wdfk-prog.github.io',
      owner: 'wdfk-prog',
      admin: ['wdfk-prog'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || '79e39c7621804360ace8f5d6232eae91'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script>window.newestComments = {
  changeContent: content => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<code>.*?<\/code>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g, "") // remove html tag

    if (content.length > 150) {
      content = content.substring(0, 150) + '...'
    }
    return content
  },

  generateHtml: (array, ele) => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class="aside-list-item">'

        if (true && array[i].avatar) {
          const imgAttr = 'data-lazy-src'
          const lazyloadNative = ''
          result += `<a href="${array[i].url}" class="thumbnail"><img ${imgAttr}="${array[i].avatar}" alt="${array[i].nick}" ${lazyloadNative}></a>`
        }

        result += `<div class="content">
        <a class="comment" href="${array[i].url}" title="${array[i].content}">${array[i].content}</a>
        <div class="name"><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '暂无评论'
    }

    ele.innerHTML = result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh(ele)
  },

  newestCommentInit: (name, getComment) => {
    const $dom = document.querySelector('#card-newest-comments .aside-list')
    if ($dom) {
      const data = btf.saveToLocal.get(name)
      if (data) {
        newestComments.generateHtml(JSON.parse(data), $dom)
      } else {
        getComment($dom)
      }
    }
  },

  run: (name, getComment) => {
    newestComments.newestCommentInit(name, getComment)
    btf.addGlobalFn('pjaxComplete', () => newestComments.newestCommentInit(name, getComment), name)
  }
}</script><script>window.addEventListener('load', () => {
  const keyName = 'github-newest-comments'
  const { changeContent, generateHtml, run } = window.newestComments

  const findTrueUrl = (array, ele) => {
    Promise.all(array.map(item =>
      fetch(item.url).then(resp => resp.json()).then(data => {
        let urlArray = data.body ? data.body.match(/(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?/ig) : []
        if (!Array.isArray(urlArray) || urlArray.length === 0) {
          urlArray = [`${data.html_url}`]
        }
        if (data.user.login === 'utterances-bot') {
          return urlArray.pop()
        } else {
          return urlArray.shift()
        }
      })
    )).then(res => {
        array = array.map((i,index)=> {
          return {
            ...i,
            url: res[index]
          }
        })

        btf.saveToLocal.set(keyName, JSON.stringify(array), 10/(60*24))
        generateHtml(array, ele)
    });
  }

  const getComment = ele => {
    fetch('https://api.github.com/repos/wdfk-prog/wdfk-prog.github.io/issues/comments?sort=updated&direction=desc&per_page=6&page=1',{
      "headers": {
        Accept: 'application/vnd.github.v3.html+json'
      }
    })
      .then(response => response.json())
      .then(data => {
        const githubArray = data.map(item => {
          return {
            'avatar': item.user.avatar_url,
            'content': changeContent(item.body_html || item.body),
            'nick': item.user.login,
            'url': item.issue_url,
            'date': item.updated_at
          }
        })
        findTrueUrl(githubArray, ele)
      }).catch(e => {
        console.error(e)
        ele.textContent= "无法获取评论，请确认相关配置是否正确"
      })
  }
  run(keyName, getComment)
})</script><div class="aplayer no-destroy" data-id="60198" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="false" data-volume="0.5"></div><script>
  var titleTime, OriginTitile = document.title;
  document.addEventListener("visibilitychange", function() {
    if (document.hidden) {
      titleTime = setTimeout(function() {
        document.title = "w(ﾟДﾟ)w 不要走！再看看嘛！";
      }, 300);
    } else {
      document.title = "♪(^∇^*)欢迎回来！" + OriginTitile;
      titleTime = setTimeout(function() {
        document.title = OriginTitile;
      }, 2000);
    }
  });
</script>
<script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script>(() => {
  window.ChatraID = '5cPWcnA8HKGzg5hoc'
  window.Chatra = window.Chatra || function() {
    (window.Chatra.q = window.Chatra.q || []).push(arguments)
  }

  btf.getScript('https://call.chatra.io/chatra.js').then(() => {
    const isChatBtn = true
    const isChatHideShow = true

    if (isChatBtn) {
      const close = () => {
        Chatra('minimizeWidget')
        Chatra('hide')
      }

      const open = () => {
        Chatra('openChat', true)
        Chatra('show')
      }

      window.ChatraSetup = { startHidden: true }
    
      window.chatBtnFn = () => document.getElementById('chatra').classList.contains('chatra--expanded') ? close() : open()

      document.getElementById('chat-btn').style.display = 'block'
    } else if (isChatHideShow) {
      window.chatBtn = {
        hide: () => Chatra('hide'),
        show: () => Chatra('show')
      }
    }
  })
})()</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: true,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      true
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-MF3J339H" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript></div><script src="https://cdn.jsdelivr.net/npm/echarts@5.5.1/dist/echarts.min.js"></script>
        
        <script>
            document.addEventListener("DOMContentLoaded", function() {
                const heatmapChartDom = document.getElementById('heatmapChart');
                if(heatmapChartDom){
                    const heatmapChart = echarts.init(heatmapChartDom, 'dark');
                    const cellSize = [18, 18];
                    
                    const groupByYear = (data) => {
                        const result = {};
                        data.forEach(([date, value]) => {
                            const [year] = date.split('-').map(Number);
                            if (!result[year]) {
                                result[year] = [];
                            }
                            result[year].push([date, value]);
                        });
                        return result;
                    };
                    
                    const groupedData = groupByYear([["2025-10-03",392],["2025-10-04",5],["2025-10-06",9],["2025-10-07",8],["2025-10-10",3]]);
                    const years = Object.keys(groupedData).reverse();
                    
                    var initYear = parseInt(heatmapChartDom.getAttribute('year')) || new Date().getFullYear();
                    const minYear = years[years.length - 1];
                    const maxYear = years[0];
                    if (initYear < minYear || initYear > maxYear) {
                        initYear = maxYear;
                    }
                    console.log('[hexo-graph]generateHeatmapChart|initYear:', initYear, 'minYear:', minYear, 'maxYear:', maxYear);
                    
                    heatmapChart.setOption({
                        grid: {},
                        tooltip: { 
                            position: 'top', 
                            formatter: params => `${params.value[0]}: ${params.value[1]} Articles` 
                        },
                        calendar: { 
                            top: '10%',
                            left: 'left', 
                            right: '8%',
                            range: initYear,
                            cellSize: cellSize, 
                            splitLine: { lineStyle: { color: '#E0E0E0', width: 1 } }, 
                            itemStyle: { borderWidth: 1, borderColor: '#E0E0E0' }, 
                            dayLabel: { show: false },
                            monthLabel: { show: true },
                            yearLabel: { show: false },
                        },
                        visualMap: { 
                            show: true,
                            right: '8%',
                            bottom: '5%',
                            type: 'piecewise',
                            orient: 'horizontal',
                            text: ['More', 'Less'],
                            min: 0,
                            max: Math.max(...groupedData[initYear].map(item => item[1])),
                            inRange: { color: ["#ACE7AE","#69C16D","#549F57"] }
                        },
                        legend: {
                            type: 'scroll',
                            icon: 'none',
                            data: years,
                            orient: 'vertical',
                            top: '5%',
                            right: 'right',
                            itemWidth: 20,
                            itemHeight: 20,
                            itemGap: 10,
                            pageIconSize: 10,
                            pageTextStyle: { fontSize: 14 },
                            selectedMode: 'single',
                        },
                        series: years.map(year => ({
                            type: 'heatmap',
                            coordinateSystem: 'calendar',
                            data: groupedData[year],
                            name: year,
                            emphasis: {
                                disabled: true,
                            },
                            silent: year !== initYear,
                        })),
                    });
                    
                    // init selected year
                    heatmapChart.dispatchAction({
                        type: 'legendSelect',
                        name: initYear,
                    });
                    
                    heatmapChart.on('legendselectchanged', function(params) {
                        console.log('[hexo-graph]generateHeatmapChart|legendselectchanged:', params);
                        const selectedYear = Object.keys(params.selected).find(key => params.selected[key]);
                        if (selectedYear && groupedData[selectedYear]) {
                            heatmapChart.setOption({
                                calendar: {
                                    range: selectedYear,
                                },
                                visualMap: {
                                    max: Math.max(...groupedData[selectedYear].map(item => item[1])),
                                },
                                series: years.map(year => ({
                                    type: 'heatmap',
                                    coordinateSystem: 'calendar',
                                    data: groupedData[year],
                                    name: year,
                                    emphasis: {
                                        disabled: true,
                                    },
                                    silent: year !== selectedYear,
                                })),
                            });
                        }
                    });
                    
                    heatmapChart.on('click', function (params) {
                        if (params.componentType === 'series') {
                            const [year, month] = params.value[0].split('-');
                            window.location.href = '/archives/' + year + '/' + month;
                        }
                    });
                }
            });
        </script>
    
        
        <script>
            document.addEventListener("DOMContentLoaded", function() {
                const monthlyChartDom = document.getElementById('monthlyChart');
                if(monthlyChartDom){
                    const monthlyChart = echarts.init(monthlyChartDom, 'dark');
                    monthlyChart.setOption({
                        xAxis: { 
                            type: 'category', 
                            data: ["2025-10"], 
                            axisLabel: { fontSize: 14, fontWeight: 'bold', fontFamily: 'Microsoft YaHei, SimSun, serif' }
                        },
                        yAxis: { type: 'value', splitLine: { lineStyle: { type: 'dashed', color: '#ccc' } } },
                        series: [{
                            name: 'Articles',
                            type: 'line',
                            data: [417],
                            smooth: true,
                            lineStyle: { color: '#5470C6', width: 2 },
                            itemStyle: { color: '#5470C6' },
                            areaStyle: { color: 'rgba(84, 112, 198, 0.4)' },
                            symbolSize: 10,
                            label: {
                                show: true,
                                position: 'top',
                                formatter: params => params.value,
                                fontSize: 14,
                                color: '#000',
                                fontWeight: 'bold',
                                fontFamily: 'Microsoft YaHei, SimSun, serif'
                            }
                        }]
                    });

                    monthlyChart.on('click', function (params) {
                        const [year, month] = params.name.split('-');
                        window.location.href = '/archives/' + year + '/' + month;
                    });
                }
            })
        </script>
    
        
        <script>
            document.addEventListener("DOMContentLoaded", function() {
                const tagsChartDom = document.getElementById('tagsChart');
                if(tagsChartDom){
                    const tagsChart = echarts.init(tagsChartDom, 'dark');
                    tagsChart.setOption({
                        tooltip: { trigger: 'item', formatter: '{b}: {c} ({d}%)' },
                        series: [{
                            type: 'pie',
                            radius: '60%',
                            data: [{"name":"linux","value":230},{"name":"uboot","value":68},{"name":"kernel","value":61},{"name":"rt-thread","value":44},{"name":"u-boot分类","value":44},{"name":"drivers","value":39},{"name":"fs","value":37},{"name":"other","value":28}],
                            label: {
                                position: 'outside',
                                formatter: '{b} {c} ({d}%)',
                                fontSize: 14,
                                fontWeight: 'bold',
                                fontFamily: 'Microsoft YaHei, SimSun, serif'
                            },
                            color: ["#5470C6","#91CC75","#FAC858","#EE6666","#73C0DE","#3BA272","#FC8452","#9A60B4"],
                            labelLine: { show: true }
                        }],
                        legend: {
                            bottom: '0',
                            left: 'center',
                            data: [{"name":"linux","value":230},{"name":"uboot","value":68},{"name":"kernel","value":61},{"name":"rt-thread","value":44},{"name":"u-boot分类","value":44},{"name":"drivers","value":39},{"name":"fs","value":37},{"name":"other","value":28}].map(tag => tag.name),
                            textStyle: { fontSize: 14, fontWeight: 'bold', fontFamily: 'Microsoft YaHei, SimSun, serif' }
                        }
                    });

                    tagsChart.on('click', function (params) {
                        window.location.href = '/tags/' + params.name;
                    });
                }
            })
        </script>
    
        
        <script>
            document.addEventListener("DOMContentLoaded", function() {
                const categoriesChartDom = document.getElementById('categoriesChart');
                if(categoriesChartDom){
                    const categoriesChart = echarts.init(categoriesChartDom, 'dark');
                    categoriesChart.setOption({
                        xAxis: { type: 'value', splitLine: { lineStyle: { type: 'dashed', color: '#ccc' } } },
                        yAxis: { 
                            type: 'category', 
                            data: [{"name":"linux","value":230},{"name":"uboot","value":68},{"name":"kernel","value":61},{"name":"rt-thread","value":44},{"name":"u-boot分类","value":44}].map(category => category.name).reverse(), 
                            axisLabel: { fontSize: 14, fontWeight: 'bold', fontFamily: 'Microsoft YaHei, SimSun, serif' }
                        },
                        series: [{
                            name: 'Category Count',
                            type: 'bar',
                            data: [{"name":"linux","value":230},{"name":"uboot","value":68},{"name":"kernel","value":61},{"name":"rt-thread","value":44},{"name":"u-boot分类","value":44}].map(category => category.value).reverse(),
                            label: {
                                show: true,
                                position: 'right',
                                formatter: params => params.value,
                                fontSize: 14,
                                color: '#000',
                                fontWeight: 'bold',
                                fontFamily: 'Microsoft YaHei, SimSun, serif'
                            },
                            itemStyle: {
                                color: new echarts.graphic.LinearGradient(0, 0, 1, 0, [
                                    { offset: 0, color: '#91CC75' },
                                    { offset: 1, color: '#73C0DE' }
                                ])
                            }
                        }]
                    });

                    categoriesChart.on('click', function (params) {
                        window.location.href = '/categories/' + params.name;
                    });
                }
            });
        </script>
    
        
        <script>
            document.addEventListener("DOMContentLoaded", function() {
                const categoriesTreeChartDom = document.getElementById('categoriesTreeChart');
                if(categoriesTreeChartDom){
                    const treeChart = echarts.init(categoriesTreeChartDom, 'dark');
                    treeChart.setOption({
                        title: {
                            text: '操作提示：单击展开分类，双击进入具体分类页面',
                            textStyle: {
                                fontSize: 12,
                                color: '#999',
                                fontWeight: 'normal'
                            },
                            bottom: 0,
                            left: 'center'
                        },
                        tooltip: {
                            trigger: 'item',
                            triggerOn: 'mousemove'
                        },
                        series: [{
                            type: 'tree',
                            data: [{"name":"Categories","children":[{"name":"git","children":[],"count":6,"path":"git"},{"name":"hpatch","children":[{"name":"libdivsufsort","children":[],"count":3,"path":"hpatch/libdivsufsort"},{"name":"SA-IS","children":[],"count":1,"path":"hpatch/SA-IS"}],"count":10,"path":"hpatch"},{"name":"LoraWan","children":[{"name":"LoRaWAN标准","children":[{"name":"LoRaWAN-Specification_ZH_CN","children":[{"name":"LoRaWAN-Specification_ZH_CN-190102","children":[{"name":"chapter","children":[],"count":20,"path":"LoraWan/LoRaWAN标准/LoRaWAN-Specification_ZH_CN/LoRaWAN-Specification_ZH_CN-190102/chapter"}],"count":22,"path":"LoraWan/LoRaWAN标准/LoRaWAN-Specification_ZH_CN/LoRaWAN-Specification_ZH_CN-190102"}],"count":22,"path":"LoraWan/LoRaWAN标准/LoRaWAN-Specification_ZH_CN"}],"count":22,"path":"LoraWan/LoRaWAN标准"}],"count":23,"path":"LoraWan"},{"name":"MCU","children":[],"count":23,"path":"MCU"},{"name":"linux","children":[{"name":"block","children":[],"count":8,"path":"linux/block"},{"name":"include","children":[],"count":10,"path":"linux/include"},{"name":"fs","children":[],"count":37,"path":"linux/fs"},{"name":"drivers","children":[{"name":"base","children":[],"count":14,"path":"linux/drivers/base"},{"name":"tty","children":[],"count":2,"path":"linux/drivers/tty"},{"name":"clk","children":[],"count":2,"path":"linux/drivers/clk"}],"count":39,"path":"linux/drivers"},{"name":"kernel","children":[{"name":"rcu","children":[],"count":3,"path":"linux/kernel/rcu"},{"name":"lock","children":[],"count":7,"path":"linux/kernel/lock"},{"name":"irq","children":[],"count":5,"path":"linux/kernel/irq"},{"name":"sched","children":[],"count":7,"path":"linux/kernel/sched"},{"name":"time","children":[],"count":10,"path":"linux/kernel/time"}],"count":61,"path":"linux/kernel"},{"name":"lib","children":[],"count":19,"path":"linux/lib"},{"name":"security","children":[],"count":1,"path":"linux/security"},{"name":"scripts","children":[],"count":2,"path":"linux/scripts"},{"name":"other","children":[],"count":17,"path":"linux/other"},{"name":"mm","children":[],"count":19,"path":"linux/mm"},{"name":"arch","children":[{"name":"arm","children":[],"count":10,"path":"linux/arch/arm"}],"count":10,"path":"linux/arch"}],"count":230,"path":"linux"},{"name":"tmc5160","children":[],"count":1,"path":"tmc5160"},{"name":"rt-thread","children":[{"name":"其他资料","children":[{"name":"fatfs","children":[],"count":1,"path":"rt-thread/其他资料/fatfs"}],"count":1,"path":"rt-thread/其他资料"}],"count":44,"path":"rt-thread"},{"name":"uboot","children":[{"name":"other","children":[],"count":12,"path":"uboot/other"},{"name":"子目录","children":[],"count":10,"path":"uboot/子目录"},{"name":"u-boot分类","children":[{"name":"arch","children":[{"name":"arm","children":[],"count":2,"path":"uboot/u-boot分类/arch/arm"}],"count":3,"path":"uboot/u-boot分类/arch"},{"name":"boot","children":[],"count":4,"path":"uboot/u-boot分类/boot"},{"name":"api","children":[],"count":1,"path":"uboot/u-boot分类/api"},{"name":"common","children":[],"count":10,"path":"uboot/u-boot分类/common"},{"name":"cmd","children":[],"count":1,"path":"uboot/u-boot分类/cmd"},{"name":"dm","children":[],"count":15,"path":"uboot/u-boot分类/dm"},{"name":"env","children":[],"count":1,"path":"uboot/u-boot分类/env"},{"name":"lib","children":[],"count":4,"path":"uboot/u-boot分类/lib"},{"name":"include","children":[],"count":3,"path":"uboot/u-boot分类/include"},{"name":"fdt","children":[],"count":1,"path":"uboot/u-boot分类/fdt"},{"name":"test","children":[],"count":1,"path":"uboot/u-boot分类/test"}],"count":44,"path":"uboot/u-boot分类"}],"count":68,"path":"uboot"},{"name":"杂谈","children":[],"count":8,"path":"杂谈"},{"name":"freertos","children":[],"count":1,"path":"freertos"}],"count":0,"path":""}],
                            initialTreeDepth: -1,
                            top: '5%',
                            bottom: '10%',
                            left: '0%',
                            right: '0%',
                            symbolSize: 15,
                            layout: 'orthogonal',
                            orient: 'TB',
                            itemStyle: {
                                color: '#91CC75',
                                borderColor: '#73C0DE'
                            },
                            label: {
                                position: 'bottom',
                                verticalAlign: 'middle',
                                align: 'center',
                                fontSize: 14,
                                distance: 28,
                                formatter: function(params) {
                                    return params.data.name + (params.data.count ? ' (' + params.data.count + ')' : '');
                                }
                            },
                            leaves: {
                                label: {
                                    position: 'top',
                                    verticalAlign: 'middle',
                                    align: 'center'
                                }
                            },
                            emphasis: {
                                focus: 'descendant'
                            },
                            expandAndCollapse: true
                        }]
                    });

                    treeChart.on('dblclick', function (params) {
                        if (params.data && params.data.path) {
                            window.location.href = '/categories/' + params.data.path;
                        }
                    });
                }
            });
        </script>
    
    <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"react":{"opacity":0.7},"log":false});</script></body></html>