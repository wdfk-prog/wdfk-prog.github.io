<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>binfmt_script | wdfk-prog的个人博客</title><meta name="author" content="Liya Huang"><meta name="copyright" content="Liya Huang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[TOC] include&#x2F;uapi&#x2F;linux&#x2F;elf.hElf32_Ehdr (内核中通常用 struct elfhdr): ELF文件头结构体这个结构体是ELF文件格式的“封面”和“目录”，它必须位于任何一个ELF文件的最开头。加载器（如内核）通过读取并解析这个结构体，来了解如何处理文件的其余部分。 1234567891011121314151617181920">
<meta property="og:type" content="article">
<meta property="og:title" content="binfmt_script">
<meta property="og:url" content="https://wdfk-prog.space/posts/f793f059/index.html">
<meta property="og:site_name" content="wdfk-prog的个人博客">
<meta property="og:description" content="[TOC] include&#x2F;uapi&#x2F;linux&#x2F;elf.hElf32_Ehdr (内核中通常用 struct elfhdr): ELF文件头结构体这个结构体是ELF文件格式的“封面”和“目录”，它必须位于任何一个ELF文件的最开头。加载器（如内核）通过读取并解析这个结构体，来了解如何处理文件的其余部分。 1234567891011121314151617181920">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wdfk-prog.space/images/covers/05.jpg">
<meta property="article:published_time" content="2025-10-03T01:01:49.000Z">
<meta property="article:modified_time" content="2025-10-03T09:23:28.360Z">
<meta property="article:author" content="Liya Huang">
<meta property="article:tag" content="fs">
<meta property="article:tag" content="linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wdfk-prog.space/images/covers/05.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "binfmt_script",
  "url": "https://wdfk-prog.space/posts/f793f059/",
  "image": "https://wdfk-prog.space/images/covers/05.jpg",
  "datePublished": "2025-10-03T01:01:49.000Z",
  "dateModified": "2025-10-03T09:23:28.360Z",
  "author": [
    {
      "@type": "Person",
      "name": "Liya Huang",
      "url": "https://github.com/wdfk-prog"
    }
  ]
}</script><link rel="shortcut icon" href="/images/favicon.png"><link rel="canonical" href="https://wdfk-prog.space/posts/f793f059/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//static.cloudflareinsights.com"/><link rel="preconnect" href="//www.clarity.ms"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxxxxx"/><meta name="baidu-site-verification" content="xxxxxxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-3978542742563797',
  enable_page_level_ads: 'true'
});</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?3c49dd4913ab43efb1bfc8d12b1cded9";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-PF2CVP2PL4"></script><script>window.dataLayer = window.dataLayer || []
function gtag(){dataLayer.push(arguments)}
gtag('js', new Date())
gtag('config', 'G-PF2CVP2PL4')
btf.addGlobalFn('pjaxComplete', () => {
  gtag('config', 'G-PF2CVP2PL4', {'page_path': window.location.pathname})
}, 'google_analytics')
</script><script defer="defer" data-pjax="data-pjax" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;17ff914b5e28493597b7dc19f3356022&quot;}"></script><script>(function(c,l,a,r,i,t,y){
    c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
    t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
    y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
})(window, document, "clarity", "script", "tkaenn1tjv");
</script><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
"https://www.googletagmanager.com/gtm.js?id="+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-MF3J339H');
btf.addGlobalFn('pjaxComplete', () => {
  dataLayer.push({'event': 'pjaxComplete', 'page_title': document.title, 'page_location': location.href, 'page_path': window.location.pathname})
}, 'google_tag_manager')</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":false,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'binfmt_script',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.0.0"><link rel="alternate" href="/atom.xml" title="wdfk-prog的个人博客" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (true) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(/images/subtle-texture.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/avatar.png" onerror="this.onerror=null;this.src='/images/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">417</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">49</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">53</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book-open"></i><span> 页面</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fas fa-quote-left"></i><span> 说说</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 示例</span></a></li></ul></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/songs/"><i class="fa-fw fas fa-music"></i><span> 歌曲</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/images/covers/05.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/my-logo.png" alt="Logo"><span class="site-name">wdfk-prog的个人博客</span></a><a class="nav-page-title" href="/"><span class="site-name">binfmt_script</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book-open"></i><span> 页面</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fas fa-quote-left"></i><span> 说说</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 示例</span></a></li></ul></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/songs/"><i class="fa-fw fas fa-music"></i><span> 歌曲</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">binfmt_script<a class="post-edit-link" href="null_posts/linux/fs/binfmt_script.md" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-10-03T01:01:49.000Z" title="发表于 2025-10-03 09:01:49">2025-10-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-03T09:23:28.360Z" title="更新于 2025-10-03 17:23:28">2025-10-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/linux/">linux</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/linux/fs/">fs</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">21.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>81分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/f793f059/#post-comment"><span class="gitalk-comment-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;已经过了&quot;,&quot;messageNext&quot;:&quot;自上次更新以来，文章的内容可能已经过时&quot;,&quot;postUpdate&quot;:&quot;2025-10-03 17:23:28&quot;}" hidden></div><p>[TOC]</p>
<h1 id="include-uapi-linux-elf-h"><a href="#include-uapi-linux-elf-h" class="headerlink" title="include&#x2F;uapi&#x2F;linux&#x2F;elf.h"></a>include&#x2F;uapi&#x2F;linux&#x2F;elf.h</h1><h3 id="Elf32-Ehdr-内核中通常用-struct-elfhdr-ELF文件头结构体"><a href="#Elf32-Ehdr-内核中通常用-struct-elfhdr-ELF文件头结构体" class="headerlink" title="Elf32_Ehdr (内核中通常用 struct elfhdr): ELF文件头结构体"></a><code>Elf32_Ehdr</code> (内核中通常用 <code>struct elfhdr</code>): ELF文件头结构体</h3><p>这个结构体是ELF文件格式的“封面”和“目录”，它<strong>必须</strong>位于任何一个ELF文件的最开头。加载器（如内核）通过读取并解析这个结构体，来了解如何处理文件的其余部分。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这是32位ELF文件头的标准定义. </span></span><br><span class="line"><span class="comment"> * 内核代码中通常会用 Elf32_Addr, Elf32_Half 等类型来保证在不同架构下的大小是固定的.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf32_hdr</span> &#123;</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * e_ident: 一个16字节的数组, 用于识别文件. 它包含了多个子字段.</span></span><br><span class="line"><span class="comment">   *   - e_ident[EI_MAG0..EI_MAG3]: 存放着 &#x27;0x7F&#x27;, &#x27;E&#x27;, &#x27;L&#x27;, &#x27;F&#x27; 这个魔数(Magic Number).</span></span><br><span class="line"><span class="comment">   *   - e_ident[EI_CLASS]:      指定文件是32位(ELFCLASS32)还是64位(ELFCLASS64).</span></span><br><span class="line"><span class="comment">   *   - e_ident[EI_DATA]:       指定字节序是大端(ELFDATA2MSB)还是小端(ELFDATA2LSB).</span></span><br><span class="line"><span class="comment">   *   - e_ident[EI_VERSION]:    ELF头的版本, 通常为 EV_CURRENT.</span></span><br><span class="line"><span class="comment">   *   - e_ident[EI_OSABI]:      指定文件所遵循的操作系统ABI, 例如 ELFOSABI_LINUX 或 ELFOSABI_ARM_FDPIC.</span></span><br><span class="line"><span class="comment">   *   - ... 其他字节通常被填充为0.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>	e_ident[EI_NIDENT];</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * e_type: ELF文件的类型. 这是区分可执行文件、共享库和目标文件的关键字段.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Elf32_Half	e_type;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * e_machine: 目标CPU架构. </span></span><br><span class="line"><span class="comment">   * 例如, EM_ARM 表示为ARM架构编译, EM_386 表示为x86架构编译.</span></span><br><span class="line"><span class="comment">   * 内核通过此字段判断该文件能否在当前硬件上运行.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Elf32_Half	e_machine;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * e_version: ELF格式的版本. 通常为1.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Elf32_Word	e_version;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * e_entry: 程序的入口点地址. </span></span><br><span class="line"><span class="comment">   * 当内核加载完程序后, CPU的程序计数器(PC)将跳转到这个地址开始执行.</span></span><br><span class="line"><span class="comment">   * 对于FDPIC程序, 这个地址是相对于代码段基地址的偏移.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Elf32_Addr	e_entry;  <span class="comment">/* Entry point */</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * e_phoff: 程序头表(Program Header Table)在文件中的偏移量(以字节为单位).</span></span><br><span class="line"><span class="comment">   * 内核根据这个值去文件中找到加载指令表.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Elf32_Off	e_phoff;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * e_shoff: 段头表(Section Header Table)在文件中的偏移量.</span></span><br><span class="line"><span class="comment">   * 段头表主要用于链接和调试, 在程序执行时非必需, 内核加载器通常不关心它.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Elf32_Off	e_shoff;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * e_flags: 特定于架构的标志.</span></span><br><span class="line"><span class="comment">   * 例如, 在ARM上, 它可以用来指示文件是否使用了硬件浮点单元等信息.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Elf32_Word	e_flags;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * e_ehsize: ELF头自身的大小(以字节为单位).</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Elf32_Half	e_ehsize;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * e_phentsize: 程序头表中每个表项的大小(以字节为单位).</span></span><br><span class="line"><span class="comment">   * 内核用它来验证文件格式的兼容性.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Elf32_Half	e_phentsize;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * e_phnum: 程序头表中的表项数量.</span></span><br><span class="line"><span class="comment">   * 内核用它和e_phentsize来计算整个程序头表的总大小.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Elf32_Half	e_phnum;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * e_shentsize: 段头表中每个表项的大小.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Elf32_Half	e_shentsize;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * e_shnum: 段头表中的表项数量.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Elf32_Half	e_shnum;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * e_shstrndx: 段头表字符串表在段头表中的索引.</span></span><br><span class="line"><span class="comment">   * 用于获取段的名称.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Elf32_Half	e_shstrndx;</span><br><span class="line">&#125; Elf32_Ehdr;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义了 e_type 字段可能取值的常量. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ET_NONE   0       <span class="comment">/* 未知类型 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ET_REL    1       <span class="comment">/* 可重定位文件 (.o 文件) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ET_EXEC   2       <span class="comment">/* 可执行文件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ET_DYN    3       <span class="comment">/* 共享目标文件 (.so 文件) 或 位置无关可执行文件(PIE) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ET_CORE   4       <span class="comment">/* 核心转储文件 (Core dump) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ET_LOPROC 0xff00  <span class="comment">/* 特定于处理器的类型范围开始 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ET_HIPROC 0xffff  <span class="comment">/* 特定于处理器的类型范围结束 */</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义了 e_ident 数组中各个字节的索引值, 它们代表了不同的信息字段.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EI_MAG0		0		<span class="comment">/* e_ident[] 索引: 魔数第0字节 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EI_MAG1		1		<span class="comment">/* e_ident[] 索引: 魔数第1字节 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EI_MAG2		2		<span class="comment">/* e_ident[] 索引: 魔数第2字节 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EI_MAG3		3		<span class="comment">/* e_ident[] 索引: 魔数第3字节 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EI_CLASS	4		<span class="comment">/* e_ident[] 索引: 文件类别 (32位/64位) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EI_DATA		5		<span class="comment">/* e_ident[] 索引: 数据编码 (字节序) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EI_VERSION	6		<span class="comment">/* e_ident[] 索引: ELF 版本 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EI_OSABI	7		<span class="comment">/* e_ident[] 索引: 操作系统/ABI 标识 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EI_PAD		8		<span class="comment">/* e_ident[] 索引: 填充字节的开始, 此后的字节未使用, 必须为0 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义了魔数(Magic Number)的各个字节的具体值.</span></span><br><span class="line"><span class="comment"> * 内核通过比较文件的前四个字节与这些值来确认它是否是ELF文件.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ELFMAG0		0x7f		<span class="comment">/* 魔数第0字节的值 (ASCII的DEL字符) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ELFMAG1		<span class="string">&#x27;E&#x27;</span>		    <span class="comment">/* 魔数第1字节的值 (&#x27;E&#x27;的ASCII码) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ELFMAG2		<span class="string">&#x27;L&#x27;</span>		    <span class="comment">/* 魔数第2字节的值 (&#x27;L&#x27;的ASCII码) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ELFMAG3		<span class="string">&#x27;F&#x27;</span>		    <span class="comment">/* 魔数第3字节的值 (&#x27;F&#x27;的ASCII码) */</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将整个魔数定义为一个字符串字面量.</span></span><br><span class="line"><span class="comment"> * &quot;\177&quot; 是 0x7f 的八进制表示法.</span></span><br><span class="line"><span class="comment"> * 这个宏在内核代码中非常常用, 例如 memcmp(hdr-&gt;e_ident, ELFMAG, SELFMAG).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ELFMAG		<span class="string">&quot;\177ELF&quot;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义魔数的长度, 即4个字节.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SELFMAG		4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义了 e_ident[EI_CLASS] 字段的可能取值, 用于表示文件的&quot;位数&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ELFCLASSNONE	0		<span class="comment">/* 无效类别 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ELFCLASS32	1		<span class="comment">/* 32位目标文件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ELFCLASS64	2		<span class="comment">/* 64位目标文件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ELFCLASSNUM	3		<span class="comment">/* 合法类别的数量 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义了 e_ident[EI_DATA] 字段的可能取值, 用于表示数据的字节序(Endianness).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFDATANONE	0		<span class="comment">/* 无效的数据编码 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFDATA2LSB	1		<span class="comment">/* 小端序(Least Significant Byte first). 像x86, ARM(大部分模式下)都是小端. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFDATA2MSB	2		<span class="comment">/* 大端序(Most Significant Byte first). 像MIPS, PowerPC可以是大端. */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义了 e_version 和 e_ident[EI_VERSION] 字段的可能取值.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_NONE		0		<span class="comment">/* 无效版本 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_CURRENT	1		<span class="comment">/* 当前版本. 几乎所有的ELF文件都使用这个值. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_NUM		2		<span class="comment">/* 合法版本的数量 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义了 e_ident[EI_OSABI] 字段的可能取值, 用于标识文件所遵循的操作系统或ABI规范.</span></span><br><span class="line"><span class="comment"> * 这对于区分不同Unix变体或特殊ABI下的二进制文件很有用.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFOSABI_NONE	0       <span class="comment">/* 未指定或与UNIX System V ABI兼容(通常是默认值) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFOSABI_LINUX	3       <span class="comment">/* 专门为Linux编译, 可能使用了Linux特有的特性 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这是一个预处理宏, 用于为当前编译的内核设置一个默认的OSABI.</span></span><br><span class="line"><span class="comment"> * 如果在编译内核时没有明确定义 ELF_OSABI,</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ELF_OSABI</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 那么就将它默认定义为 ELFOSABI_NONE.</span></span><br><span class="line"><span class="comment"> * 这确保了内核自身在处理某些内部事务时有一个默认的OSABI值可用.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELF_OSABI ELFOSABI_NONE</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="程序头表项类型-p-type"><a href="#程序头表项类型-p-type" class="headerlink" title="程序头表项类型 (p_type)"></a>程序头表项类型 (<code>p_type</code>)</h3><p>ELF文件的程序头表是一个数组，数组中的每个元素（一个<code>elf_phdr</code>结构体）都描述了文件中的一个“段”以及如何处理它。<code>p_type</code>字段就是用来指明这个段的类型的。加载器（内核）会遍历这个表，并根据<code>p_type</code>的值来采取不同的行动。</p>
<p>下面是对这些宏的逐一、详细解释：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这些常量用于表示存储在镜像头文件中的段类型 (Segment Types).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 类型: 空段 (NULL).</span></span><br><span class="line"><span class="comment"> * 作用: 表示这是一个未使用的或无效的程序头表项. 加载器会完全忽略这个表项.</span></span><br><span class="line"><span class="comment"> * 它也经常作为数组的哨兵或占位符.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_NULL    0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 类型: 可加载段 (LOAD).</span></span><br><span class="line"><span class="comment"> * 作用: 这是最重要的类型. 它指示加载器将文件中的某一部分内容加载(或映射)到内存中.</span></span><br><span class="line"><span class="comment"> * 一个典型的可执行文件至少有两个PT_LOAD段: 一个用于代码(.text, 只读可执行),</span></span><br><span class="line"><span class="comment"> * 另一个用于数据(.data/.bss, 可读可写). &#x27;elf_fdpic_map_file&#x27;函数的核心工作就是处理这些段.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_LOAD    1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 类型: 动态链接信息 (DYNAMIC).</span></span><br><span class="line"><span class="comment"> * 作用: 这个段包含了一系列用于动态链接的键值对信息, 例如需要链接哪些共享库、</span></span><br><span class="line"><span class="comment"> * 符号重定位表在哪里等等. 用户空间的动态链接器(如ld.so)会读取这个段来完成链接工作.</span></span><br><span class="line"><span class="comment"> * 内核加载器会找到这个段并将其地址通过辅助向量传递给动态链接器.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_DYNAMIC 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 类型: 解释器 (INTERP).</span></span><br><span class="line"><span class="comment"> * 作用: 这个段只包含一个简单的、以NULL结尾的字符串, 即程序所需的动态链接器的路径</span></span><br><span class="line"><span class="comment"> * (例如, &quot;/lib/ld-uClibc.so.1&quot;). 当内核加载器发现这个段时, 它就知道不能直接运行当前程序,</span></span><br><span class="line"><span class="comment"> * 而是需要先加载并运行这个段中指定的解释器.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_INTERP  3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 类型: 附加说明 (NOTE).</span></span><br><span class="line"><span class="comment"> * 作用: 包含一些附加的、特定于供应商或系统的信息. 例如, GNU工具链用它来存储</span></span><br><span class="line"><span class="comment"> * 构建ID (build-id), 以唯一标识一个二进制文件. coredump文件也用它来存储进程信息.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_NOTE    4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 类型: 共享库 (SHLIB).</span></span><br><span class="line"><span class="comment"> * 作用: 这个类型是保留的, 但在现代系统中已不再使用.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_SHLIB   5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 类型: 程序头表 (PHDR).</span></span><br><span class="line"><span class="comment"> * 作用: 这个段描述了程序头表本身在文件中的位置和大小. </span></span><br><span class="line"><span class="comment"> * 这使得动态链接器可以找到并解析程序头表, 而无需依赖ELF头.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_PHDR    6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 类型: 线程局部存储 (Thread Local Storage).</span></span><br><span class="line"><span class="comment"> * 作用: 这个段描述了与线程局部存储(TLS)相关的模板. 当创建新线程时,</span></span><br><span class="line"><span class="comment"> * 系统会使用这个模板为每个线程分配私有的TLS数据区.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_TLS     7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 类型: 操作系统特定范围的开始 (OS-specific).</span></span><br><span class="line"><span class="comment"> * 作用: 定义了一个范围, 从这个值开始, 用于操作系统特定的段类型.</span></span><br><span class="line"><span class="comment"> * 这允许不同的操作系统(如Linux, BSD)定义自己独有的段类型而不会发生冲突.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_LOOS    0x60000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 类型: 操作系统特定范围的结束 (OS-specific).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_HIOS    0x6fffffff</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 类型: 处理器特定范围的开始.</span></span><br><span class="line"><span class="comment"> * 作用: 定义了一个范围, 用于特定CPU架构的段类型.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_LOPROC  0x70000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 类型: 处理器特定范围的结束.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_HIPROC  0x7fffffff</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 以下是GNU扩展的、在操作系统特定范围(PT_LOOS)内的段类型.</span></span><br><span class="line"><span class="comment"> * 它们是Linux生态中非常常见的段.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 类型: GNU异常处理帧 (GNU Exception Handler Frame).</span></span><br><span class="line"><span class="comment"> * (PT_LOOS + 0x474e550) 中的&#x27;0x474e550&#x27;实际上是&quot;GNU&quot;的ASCII码在特定字节序下的表现.</span></span><br><span class="line"><span class="comment"> * 作用: 这个段指向一个用于C++等语言异常处理(try/catch)的栈回溯(unwinding)信息表.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_GNU_EH_FRAME	(PT_LOOS + 0x474e550)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 类型: GNU栈 (GNU STACK).</span></span><br><span class="line"><span class="comment"> * 作用: 这个段本身不包含任何数据, 它的标志位(p_flags)被用来向操作系统传达</span></span><br><span class="line"><span class="comment"> * 这个程序希望它的栈是可执行的还是不可执行的. </span></span><br><span class="line"><span class="comment"> * 这是实现栈不可执行(NX bit)安全策略的关键. &#x27;elf_fdpic_fetch_phdrs&#x27;会解析这个段.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_GNU_STACK	(PT_LOOS + 0x474e551)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 类型: GNU只读重定位 (GNU Read-Only Relocations).</span></span><br><span class="line"><span class="comment"> * 作用: 这是一个安全增强特性. 它将一些在加载后就不再需要修改的动态链接数据</span></span><br><span class="line"><span class="comment"> * (如全局偏移表GOT的一部分)所在的内存区域标记为只读.</span></span><br><span class="line"><span class="comment"> * 这可以防止某些类型的攻击, 如GOT覆写攻击.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_GNU_RELRO	(PT_LOOS + 0x474e552)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 类型: GNU属性 (GNU PROPERTY).</span></span><br><span class="line"><span class="comment"> * 作用: 一个较新的段类型, 用于向系统传递更丰富的二进制文件属性,</span></span><br><span class="line"><span class="comment"> * 例如它是否使用了ARM的BTI(Branch Target Identification)或PAC(Pointer Authentication)等安全特性.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_GNU_PROPERTY	(PT_LOOS + 0x474e553)</span></span><br></pre></td></tr></table></figure>

<h1 id="fs-binfmt-script-c"><a href="#fs-binfmt-script-c" class="headerlink" title="fs&#x2F;binfmt_script.c"></a>fs&#x2F;binfmt_script.c</h1><p><code>#!</code> 机制的本质是把执行权委托给另一个程序。下面我们来深入了解这些常见的“受委托者”以及它们各自的特长。</p>
<h3 id="1-bin-sh-与-bin-bash-Bourne-Shell-和-Bourne-Again-Shell"><a href="#1-bin-sh-与-bin-bash-Bourne-Shell-和-Bourne-Again-Shell" class="headerlink" title="1. /bin/sh 与 /bin/bash (Bourne Shell 和 Bourne-Again Shell)"></a>1. <code>/bin/sh</code> 与 <code>/bin/bash</code> (Bourne Shell 和 Bourne-Again Shell)</h3><ul>
<li><p><strong>脚本作用</strong>:<br>这是Linux&#x2F;Unix世界中最基础、最核心的“胶水语言”。它的主要作用是<strong>自动化执行一系列命令</strong>，管理文件系统，控制进程，以及配置系统环境。<code>sh</code>是遵循POSIX标准的最小集，保证了极高的可移植性；<code>bash</code>是<code>sh</code>的超集，提供了更多便利的功能，如命令历史、更强大的数组、更复杂的条件判断等。</p>
</li>
<li><p><strong>使用场景</strong>:<br>它们是嵌入式Linux系统中无可替代的工具。</p>
<ul>
<li><strong>系统启动脚本</strong>: 几乎所有的初始化脚本（位于<code>/etc/init.d/</code>或被<code>systemd</code>调用的脚本）都是shell脚本。它们负责挂载文件系统、配置网络、启动后台服务（守护进程）等。</li>
<li><strong>任务自动化 (Cron Jobs)</strong>: 定时执行的任务，如夜间日志清理、数据备份、系统状态检查等，通常都由shell脚本完成。</li>
<li><strong>设备管理</strong>: 编写一个简单的脚本来配置GPIO、设置串口参数或重启一个外设驱动。</li>
<li><strong>简单的应用程序启动器</strong>: 编写一个包装脚本，在运行主程序前设置好必要的环境变量或检查依赖项。</li>
</ul>
</li>
<li><p><strong>示例</strong> (<code>/usr/local/bin/start_myapp</code>):</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 脚本功能：一个健壮的应用程序启动器</span></span><br><span class="line"></span><br><span class="line">APP_BIN=<span class="string">&quot;/opt/myapp/my_application&quot;</span></span><br><span class="line">PID_FILE=<span class="string">&quot;/var/run/myapp.pid&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查应用程序二进制文件是否存在且可执行</span></span><br><span class="line"><span class="keyword">if</span> [ ! -x <span class="string">&quot;<span class="variable">$APP_BIN</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;错误: 应用程序 &#x27;<span class="variable">$APP_BIN</span>&#x27; 不存在或不可执行。&quot;</span></span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;正在启动 my_application...&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在后台启动应用程序，并将它的进程ID(PID)写入文件</span></span><br><span class="line"><span class="comment"># &gt; /dev/null 2&gt;&amp;1 将所有输出重定向到空设备，实现静默运行</span></span><br><span class="line"><span class="variable">$APP_BIN</span> &gt; /dev/null 2&gt;&amp;1 &amp;</span><br><span class="line"><span class="built_in">echo</span> $! &gt; <span class="variable">$PID_FILE</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;my_application 已启动, PID 为: <span class="subst">$(cat $PID_FILE)</span>&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-usr-bin-python3-Python-3"><a href="#2-usr-bin-python3-Python-3" class="headerlink" title="2. /usr/bin/python3 (Python 3)"></a>2. <code>/usr/bin/python3</code> (Python 3)</h3><ul>
<li><p><strong>脚本作用</strong>:<br>Python是一种高级、通用的编程语言，以其清晰的语法和强大的标准库而闻名。与Shell脚本相比，它更适合处理<strong>复杂的逻辑、数据结构、网络通信和算法</strong>。</p>
</li>
<li><p><strong>使用场景</strong>:</p>
<ul>
<li><strong>数据采集与处理</strong>: 从传感器（如I2C、SPI接口的温湿度传感器）读取数据，进行解析、计算，然后存储到文件或数据库中。</li>
<li><strong>轻量级Web服务器</strong>: 使用Flask或Bottle等微型框架，在STM32H750上运行一个Web服务，提供一个用于设备监控和远程控制的API接口或Web页面。</li>
<li><strong>网络客户端</strong>: 主动连接到远程服务器，通过HTTP&#x2F;HTTPS上传数据，或通过MQTT协议与物联网平台通信。</li>
<li><strong>替代复杂的Shell脚本</strong>: 当一个自动化任务的逻辑变得非常复杂，需要用到字典、列表、类等高级数据结构时，用Python实现会比用Shell更清晰、更易于维护。</li>
</ul>
</li>
<li><p><strong>示例</strong> (<code>/opt/sensors/log_temp.py</code>):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 脚本功能：模拟从传感器读取温度并记录到日志文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> random <span class="comment"># 用于模拟传感器数据</span></span><br><span class="line"></span><br><span class="line">LOG_FILE = <span class="string">&quot;/var/log/temperature.log&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_temperature</span>():</span><br><span class="line">    <span class="comment"># 在真实场景中, 这里会是与硬件交互的代码 (例如, 通过 spidev 或 smbus2)</span></span><br><span class="line">    <span class="comment"># 我们用一个随机数来模拟</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">20.0</span> + random.uniform(-<span class="number">2.0</span>, <span class="number">2.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        temp = get_temperature()</span><br><span class="line">        timestamp = datetime.datetime.now().isoformat()</span><br><span class="line">        log_entry = <span class="string">f&quot;<span class="subst">&#123;timestamp&#125;</span> - Temperature: <span class="subst">&#123;temp:<span class="number">.2</span>f&#125;</span> C\n&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(LOG_FILE, <span class="string">&quot;a&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(log_entry)</span><br><span class="line">            </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;成功记录温度: <span class="subst">&#123;temp:<span class="number">.2</span>f&#125;</span> C&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="comment"># 简单的错误处理</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;错误: 无法记录温度 - <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-usr-bin-perl-Perl"><a href="#3-usr-bin-perl-Perl" class="headerlink" title="3. /usr/bin/perl (Perl)"></a>3. <code>/usr/bin/perl</code> (Perl)</h3><ul>
<li><p><strong>脚本作用</strong>:<br>Perl被誉为“文本处理的瑞士军刀”。它是一种非常强大的脚本语言，尤其擅长<strong>正则表达式和字符串操作</strong>。虽然近年来Python的使用更为广泛，但在系统管理和日志分析领域，Perl依然宝刀不老。</p>
</li>
<li><p><strong>使用场景</strong>:</p>
<ul>
<li><strong>日志分析</strong>: 实时监控或离线分析系统日志（如 <code>dmesg</code>, <code>/var/log/messages</code>）, 从大量文本中提取出特定的错误模式或关键信息。</li>
<li><strong>配置文件解析与生成</strong>: 读取复杂的、非标准格式的配置文件，解析其内容，并根据需要生成新的配置文件。</li>
<li><strong>报告生成</strong>: 从各种系统命令的输出中抓取数据，并将其格式化为人类可读的报告。</li>
</ul>
</li>
<li><p><strong>示例</strong> (<code>/usr/local/bin/parse_auth_log</code>):</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/perl</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 脚本功能：从auth.log文件中提取所有失败的SSH登录尝试</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> strict;</span><br><span class="line"><span class="keyword">use</span> warnings;</span><br><span class="line"></span><br><span class="line"><span class="keyword">my</span> <span class="variable">$log_file</span> = <span class="string">&#x27;/var/log/auth.log&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span>(<span class="keyword">my</span> <span class="variable">$fh</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="variable">$log_file</span>) <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">&quot;无法打开 <span class="variable">$log_file</span>: <span class="variable">$!</span>&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;检测到失败的SSH登录尝试:\n&quot;</span>;</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;--------------------------\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">my</span> <span class="variable">$line</span> = &lt;<span class="variable">$fh</span>&gt;) &#123;</span><br><span class="line">    <span class="comment"># 使用正则表达式匹配包含 &quot;Failed password for&quot; 的行</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$line</span> =~ <span class="regexp">/Failed password for (\S+) from (\S+)/</span>) &#123;</span><br><span class="line">        <span class="keyword">my</span> <span class="variable">$user</span> = <span class="variable">$1</span>;</span><br><span class="line">        <span class="keyword">my</span> <span class="variable">$ip</span> = <span class="variable">$2</span>;</span><br><span class="line">        <span class="keyword">print</span> <span class="string">&quot;用户: <span class="variable">$user</span>, 来源IP: <span class="variable">$ip</span>\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">close</span>(<span class="variable">$fh</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-usr-bin-awk-f"><a href="#4-usr-bin-awk-f" class="headerlink" title="4. /usr/bin/awk -f"></a>4. <code>/usr/bin/awk -f</code></h3><ul>
<li><p><strong>脚本作用</strong>:<br>AWK是一种优秀的<strong>面向列的文本处理工具</strong>。它逐行读取文本，并能自动将每一行按分隔符（默认为空格）拆分成多个字段（<code>$1</code>, <code>$2</code>, <code>$3</code>…）。它非常适合从格式规整的文本数据中提取信息、进行计算和重新格式化输出。<code>-f</code>标志告诉<code>awk</code>命令，执行逻辑的脚本就写在当前文件中。</p>
</li>
<li><p><strong>使用场景</strong>:</p>
<ul>
<li><strong>处理命令输出</strong>: 对<code>ls -l</code>, <code>ps aux</code>, <code>df -h</code>等命令的输出进行二次处理，只提取你关心的列。</li>
<li><strong>数据汇总</strong>: 计算文件中某一列的总和、平均值等。</li>
<li><strong>格式转换</strong>: 将一种格式的文本文件（如空格分隔）转换为另一种格式（如CSV逗号分隔）。</li>
</ul>
</li>
<li><p><strong>示例</strong> (<code>/usr/local/bin/disk_usage_report.awk</code>):</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/awk -f</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 脚本功能：处理&#x27;df -h&#x27;的输出，只显示使用率超过80%的文件系统</span></span><br><span class="line"><span class="comment"># 使用方法: df -h | /usr/local/bin/disk_usage_report.awk</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># BEGIN块在处理任何输入行之前执行一次, 用于打印表头</span></span><br><span class="line"><span class="keyword">BEGIN</span> &#123;</span><br><span class="line">    print <span class="string">&quot;高使用率的文件系统 (&gt;80%):&quot;</span></span><br><span class="line">    print <span class="string">&quot;文件系统\t\t已用%&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个模式块对每一行都执行</span></span><br><span class="line"><span class="comment"># NR &gt; 1 表示跳过第一行(表头)</span></span><br><span class="line"><span class="comment"># $5 ~ /%/ 表示只处理第五列包含&#x27;%&#x27;符号的行</span></span><br><span class="line">NR &gt; <span class="number">1</span> &amp;&amp; <span class="variable">$5</span> ~ <span class="regexp">/%/</span> &#123;</span><br><span class="line">    <span class="comment"># gsub函数用于替换, 这里去掉第五列的&#x27;%&#x27;符号, 以便进行数值比较</span></span><br><span class="line">    gsub(<span class="regexp">/%/</span>, <span class="string">&quot;&quot;</span>, <span class="variable">$5</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果第五列(使用率)大于80</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$5</span> &gt; <span class="number">80</span>) &#123;</span><br><span class="line">        <span class="comment"># 打印第一列(文件系统名称)和第五列(使用率)</span></span><br><span class="line">        printf <span class="string">&quot;%-20s\t%s%%\n&quot;</span>, <span class="variable">$1</span>, <span class="variable">$5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># END块在所有输入行处理完毕后执行一次</span></span><br><span class="line"><span class="keyword">END</span> &#123;</span><br><span class="line">    print <span class="string">&quot;检查完毕.&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-usr-bin-env-的巧妙用法"><a href="#5-usr-bin-env-的巧妙用法" class="headerlink" title="5. #!/usr/bin/env 的巧妙用法"></a>5. <code>#!/usr/bin/env</code> 的巧妙用法</h3><p>这不是一个解释器, 而是<strong>一个寻找解释器的工具</strong>。<code>env</code>是一个标准的系统程序, 它的作用是在当前用户的<code>PATH</code>环境变量所指定的目录列表中, 查找并执行一个程序。</p>
<ul>
<li><p><strong>问题</strong>: 如果你在脚本中硬编码 <code>#!/usr/bin/python3</code>, 但在另一台机器上, Python被安装在了 <code>/usr/local/bin/python3</code>。那么这个脚本在那台机器上就会因为找不到解释器而执行失败。</p>
</li>
<li><p><strong>解决方案</strong>: 使用 <code>#!/usr/bin/env python3</code></p>
</li>
<li><p><strong>工作流程</strong>:</p>
<ol>
<li>内核看到 <code>#!</code> 行, 它执行 <code>/usr/bin/env</code> 程序。</li>
<li>内核将 <code>python3</code> 和脚本路径 <code>/home/user/test.py</code> 作为参数传递给 <code>env</code>。</li>
<li><code>env</code> 程序启动, 它看到第一个参数是 <code>python3</code>。</li>
<li><code>env</code> 开始在 <code>PATH</code> 环境变量（如<code>/usr/local/bin:/usr/bin:/bin</code>）的所有目录中依次搜索一个名为 <code>python3</code> 的可执行文件。</li>
<li>一旦找到（比如在<code>/usr/bin/python3</code>）, <code>env</code> 就会执行它, 并将脚本路径传递给它。</li>
</ol>
</li>
<li><p><strong>优点</strong>: <strong>极大地提高了脚本的可移植性</strong>。它不关心解释器到底安装在哪里, 只要它存在于用户的<code>PATH</code>中, 脚本就能正确执行。这在使用Python虚拟环境（<code>venv</code>）时尤其重要, 因为虚拟环境会修改<code>PATH</code>, 使得<code>python3</code>指向环境内部的解释器。</p>
</li>
</ul>
<h2 id="Shebang-支持哪些脚本"><a href="#Shebang-支持哪些脚本" class="headerlink" title="#! (Shebang) 支持哪些脚本?"></a><code>#!</code> (Shebang) 支持哪些脚本?</h2><p>这是一个非常好的问题, 也是一个常见的误区。<strong>内核的 <code>#!</code> 机制本身不关心、也不识别任何特定的脚本语言（如Shell, Python, Perl等）。</strong></p>
<p>它的机制是完全通用的, 其原理是：<strong>“不要执行这个文件, 而是去执行 <code>#!</code> 后面指定的那一个程序, 并把这个脚本文件的路径作为参数传给它。”</strong></p>
<p>因此, <strong><code>#!</code> 支持任何已经安装了解释器的脚本语言</strong>。只要系统中存在一个可以接收脚本文件路径作为参数并执行其内容的可执行程序, 你就可以在 <code>#!</code> 后面使用它。</p>
<p><strong>常见的解释器包括：</strong></p>
<ul>
<li><code>/bin/sh</code> (标准的Bourne Shell)</li>
<li><code>/bin/bash</code> (更强大的Bash Shell)</li>
<li><code>/usr/bin/python</code> 或 <code>/usr/bin/python3</code></li>
<li><code>/usr/bin/perl</code></li>
<li><code>/usr/bin/awk -f</code></li>
<li><code>/usr/bin/node</code> (用于Node.js脚本)</li>
</ul>
<p>甚至一些不常见的程序也可以, 比如 <code>#!/usr/bin/env</code> 就是一个巧妙的用法, 它会利用 <code>env</code> 程序在用户的<code>PATH</code>环境变量中去查找真正的解释器（如 <code>python</code>）, 增加了脚本的可移植性。</p>
<hr>
<h3 id="工作流程示例"><a href="#工作流程示例" class="headerlink" title="工作流程示例"></a>工作流程示例</h3><p>下面我们通过两个具体的例子, 详细追踪 <code>load_script</code> 函数是如何工作的。</p>
<h4 id="示例1-一个简单的Shell脚本"><a href="#示例1-一个简单的Shell脚本" class="headerlink" title="示例1: 一个简单的Shell脚本"></a>示例1: 一个简单的Shell脚本</h4><p><strong>场景</strong>: 用户在命令行执行一个带参数的shell脚本。</p>
<ol>
<li><p><strong>脚本文件内容</strong> (<code>/home/user/test.sh</code>):</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello from script! You gave me the argument: <span class="variable">$1</span>&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>用户执行的命令</strong>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home/user/test.sh my_arg</span><br></pre></td></tr></table></figure></li>
<li><p><strong>内核 <code>load_script</code> 函数介入前的状态</strong>:</p>
<ul>
<li><code>bprm-&gt;filename</code>: “&#x2F;home&#x2F;user&#x2F;test.sh”</li>
<li><code>bprm-&gt;argc</code>: 2</li>
<li>内核看到的初始参数列表 (<code>argv</code>):<ul>
<li><code>argv[0]</code>: <code>/home/user/test.sh</code></li>
<li><code>argv[1]</code>: <code>my_arg</code></li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>load_script</code> 函数执行步骤详解</strong>:</p>
<ul>
<li><strong>行31</strong>: <code>(bprm-&gt;buf[0] != &#39;#&#39;) || (bprm-&gt;buf[1] != &#39;!&#39;)</code> 判断为 <code>false</code>, 因为文件以 <code>#!</code> 开头, 匹配成功。</li>
<li><strong>行39-57</strong>: 解析 <code>#!</code> 行。<ul>
<li><code>i_name</code> 被设置为指向字符串 <code>/bin/sh</code>。</li>
<li><code>i_arg</code> 为 <code>NULL</code>, 因为 <code>/bin/sh</code> 后面没有其他内容。</li>
</ul>
</li>
<li><strong>行80</strong>: <code>retval = remove_arg_zero(bprm);</code><ul>
<li>移除原始的 <code>argv[0]</code>, 即 “&#x2F;home&#x2F;user&#x2F;test.sh”。</li>
<li><code>bprm-&gt;argc</code> 变为 1。</li>
</ul>
</li>
<li><strong>行83-86</strong>: <code>retval = copy_string_kernel(bprm-&gt;interp, bprm);</code><ul>
<li>将原始文件名 “&#x2F;home&#x2F;user&#x2F;test.sh” 作为<strong>新的参数</strong>压入。</li>
<li><code>bprm-&gt;argc</code> 变为 2。</li>
<li>参数列表现在逻辑上是: (<code>my_arg</code>, <code>/home/user/test.sh</code>)</li>
</ul>
</li>
<li><strong>行89-95</strong>: <code>if (i_arg)</code> 判断为 <code>false</code>, 跳过。</li>
<li><strong>行96-99</strong>: <code>retval = copy_string_kernel(i_name, bprm);</code><ul>
<li>将解释器名 “&#x2F;bin&#x2F;sh” 作为<strong>新的参数</strong>压入。</li>
<li><code>bprm-&gt;argc</code> 变为 3。</li>
<li>参数列表现在逻辑上是: (<code>/bin/sh</code>, <code>/home/user/test.sh</code>, <code>my_arg</code>)</li>
</ul>
</li>
<li><strong>行100-103</strong>: <code>retval = bprm_change_interp(i_name, bprm);</code><ul>
<li>将 <code>bprm-&gt;interp</code> 从 “&#x2F;home&#x2F;user&#x2F;test.sh” 更改为 “&#x2F;bin&#x2F;sh”。</li>
</ul>
</li>
<li><strong>行108-111</strong>: <code>file = open_exec(i_name);</code><ul>
<li>内核尝试打开 <code>/bin/sh</code> 这个文件以供执行。</li>
</ul>
</li>
<li><strong>行113</strong>: <code>bprm-&gt;interpreter = file;</code><ul>
<li>将 <code>bprm</code> 结构体中要执行的程序文件对象, 设置为刚刚打开的 <code>/bin/sh</code>。</li>
</ul>
</li>
<li><strong>行115</strong>: <code>return 0;</code> 函数成功返回。</li>
</ul>
</li>
<li><p><strong>最终结果</strong>:</p>
<ul>
<li><code>load_script</code> 函数修改了 <code>bprm</code> 结构, 告诉内核的 <code>execve</code> 流程：“不要执行原来的脚本了, 请执行 <code>/bin/sh</code> 这个程序”。</li>
<li>内核最终执行的命令是: <code>/bin/sh /home/user/test.sh my_arg</code></li>
<li><code>/bin/sh</code> 解释器启动后, 看到它的第一个参数是 <code>/home/user/test.sh</code>, 于是它打开这个文件, 读取并执行里面的指令。第二个参数 <code>my_arg</code> 则成为脚本内部的 <code>$1</code>。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="示例2-行带有参数"><a href="#示例2-行带有参数" class="headerlink" title="示例2: #! 行带有参数"></a>示例2: <code>#!</code> 行带有参数</h4><p><strong>场景</strong>: 一个python脚本, 在 <code>#!</code> 行上就为解释器提供了一个参数。</p>
<ol>
<li><p><strong>脚本文件内容</strong> (<code>/home/user/test.py</code>):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3 -u</span></span><br><span class="line"><span class="comment"># The -u flag forces unbuffered output for stdout and stderr</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Script running&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Argv is:&quot;</span>, sys.argv)</span><br></pre></td></tr></table></figure></li>
<li><p><strong>用户执行的命令</strong>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home/user/test.py</span><br></pre></td></tr></table></figure></li>
<li><p><strong>内核 <code>load_script</code> 函数介入前的状态</strong>:</p>
<ul>
<li><code>bprm-&gt;filename</code>: “&#x2F;home&#x2F;user&#x2F;test.py”</li>
<li><code>bprm-&gt;argc</code>: 1</li>
<li>内核看到的初始参数列表 (<code>argv</code>):<ul>
<li><code>argv[0]</code>: <code>/home/user/test.py</code></li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>load_script</code> 函数执行步骤详解</strong>:</p>
<ul>
<li><strong>行31</strong>: 匹配 <code>#!</code> 成功。</li>
<li><strong>行39-57</strong>: 解析 <code>#!</code> 行。<ul>
<li><code>i_name</code> 被设置为指向字符串 <code>/usr/bin/python3</code>。</li>
<li><code>i_sep</code> 指向 <code>python3</code> 和 <code>-u</code> 之间的空格。</li>
<li><code>i_arg</code> 被设置为指向字符串 <code>-u</code>。</li>
</ul>
</li>
<li><strong>行80</strong>: <code>retval = remove_arg_zero(bprm);</code><ul>
<li>移除原始的 <code>argv[0]</code>, 即 “&#x2F;home&#x2F;user&#x2F;test.py”。</li>
<li><code>bprm-&gt;argc</code> 变为 0。</li>
</ul>
</li>
<li><strong>行83-86</strong>: <code>retval = copy_string_kernel(bprm-&gt;interp, bprm);</code><ul>
<li>将 “&#x2F;home&#x2F;user&#x2F;test.py” 作为新参数压入。</li>
<li><code>bprm-&gt;argc</code> 变为 1。</li>
<li>参数列表逻辑上是: (<code>/home/user/test.py</code>)</li>
</ul>
</li>
<li><strong>行89-95</strong>: <code>if (i_arg)</code> 判断为 <code>true</code>。<ul>
<li><code>retval = copy_string_kernel(i_arg, bprm);</code> 将 <code>-u</code> 作为新参数压入。</li>
<li><code>bprm-&gt;argc</code> 变为 2。</li>
<li>参数列表逻辑上是: (<code>-u</code>, <code>/home/user/test.py</code>)</li>
</ul>
</li>
<li><strong>行96-99</strong>: <code>retval = copy_string_kernel(i_name, bprm);</code><ul>
<li>将 “&#x2F;usr&#x2F;bin&#x2F;python3” 作为新参数压入。</li>
<li><code>bprm-&gt;argc</code> 变为 3。</li>
<li>参数列表逻辑上是: (<code>/usr/bin/python3</code>, <code>-u</code>, <code>/home/user/test.py</code>)</li>
</ul>
</li>
<li>后续步骤同示例1, <code>bprm-&gt;interp</code> 被改为 <code>/usr/bin/python3</code>, 并被成功打开。</li>
</ul>
</li>
<li><p><strong>最终结果</strong>:</p>
<ul>
<li>内核最终执行的命令是: <code>/usr/bin/python3 -u /home/user/test.py</code></li>
<li>这样, <code>-u</code> 这个参数就成功地从脚本的 <code>#!</code> 行传递给了 <code>python3</code> 解释器。</li>
</ul>
</li>
</ol>
<p>希望这两个详细的例子能帮助您彻底理解 <code>load_script</code> 的工作原理和 <code>#!</code> 机制的强大之处。</p>
<h2 id="binfmt-script-c-内核脚本执行支持"><a href="#binfmt-script-c-内核脚本执行支持" class="headerlink" title="binfmt_script.c: 内核脚本执行支持"></a>binfmt_script.c: 内核脚本执行支持</h2><p>此文件的作用是实现一个内核级的二进制格式（binfmt）处理器, 专门用于识别并处理以 <code>#!</code> (Shebang) 开头的脚本文件。当用户尝试执行一个脚本时, 内核通过此文件中实现的 <code>load_script</code> 函数, 解析脚本的第一行, 找出指定的解释器（如<code>/bin/sh</code>）, 然后加载并运行该解释器来执行脚本内容。这个机制是所有现代Linux&#x2F;Unix系统能够原生执行shell脚本、Python脚本等的基础。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 一个内联辅助函数, 用于判断一个字符是否是空格或制表符. */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">spacetab</span><span class="params">(<span class="type">char</span> c)</span> &#123; <span class="keyword">return</span> c == <span class="string">&#x27; &#x27;</span> || c == <span class="string">&#x27;\t&#x27;</span>; &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 一个内联辅助函数, 用于从指定范围 [first, last] 内查找并返回第一个非空格/制表符的字符的指针.</span></span><br><span class="line"><span class="comment"> * 如果找不到, 返回 NULL.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="type">char</span> *<span class="title function_">next_non_spacetab</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *first, <span class="type">const</span> <span class="type">char</span> *last)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (; first &lt;= last; first++)</span><br><span class="line">		<span class="keyword">if</span> (!spacetab(*first))</span><br><span class="line">			<span class="keyword">return</span> first;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 一个内联辅助函数, 用于从指定范围 [first, last] 内查找并返回第一个终止符(空格/制表符/字符串结束符)的指针.</span></span><br><span class="line"><span class="comment"> * 如果找不到, 返回 NULL.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="type">char</span> *<span class="title function_">next_terminator</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *first, <span class="type">const</span> <span class="type">char</span> *last)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (; first &lt;= last; first++)</span><br><span class="line">		<span class="keyword">if</span> (spacetab(*first) || !*first)</span><br><span class="line">			<span class="keyword">return</span> first;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * load_script: 二进制格式处理器的核心函数.</span></span><br><span class="line"><span class="comment"> * 当内核认为一个文件可能是脚本时, 会调用此函数.</span></span><br><span class="line"><span class="comment"> * @bprm: 指向 linux_binprm 结构体的指针, 它包含了要执行的文件的信息,</span></span><br><span class="line"><span class="comment"> *        如文件的前128字节(bprm-&gt;buf), 参数列表等.</span></span><br><span class="line"><span class="comment"> * @return: 成功时返回0, 失败时返回负值的错误码.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">load_script</span><span class="params">(<span class="keyword">struct</span> linux_binprm *bprm)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * i_name: 指向解释器名称的指针.</span></span><br><span class="line"><span class="comment">	 * i_sep: 指向解释器名称和参数之间分隔符的指针.</span></span><br><span class="line"><span class="comment">	 * i_arg: 指向解释器参数的指针.</span></span><br><span class="line"><span class="comment">	 * i_end: 指向&#x27;#!&#x27;行有效内容末尾的指针.</span></span><br><span class="line"><span class="comment">	 * buf_end: 指向bprm-&gt;buf缓冲区末尾的指针, 用于防止越界.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *i_name, *i_sep, *i_arg, *i_end, *buf_end;</span><br><span class="line">	<span class="comment">/* file: 指向解释器可执行文件的文件对象. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">	<span class="comment">/* retval: 用于存储函数调用的返回值. */</span></span><br><span class="line">	<span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 检查文件的起始两个字节是否为&#x27;#!&#x27;. 如果不是, 则这不是一个脚本文件, 我们不处理. */</span></span><br><span class="line">	<span class="comment">/* 返回 -ENOEXEC 告知内核尝试下一个二进制格式处理器. */</span></span><br><span class="line">	<span class="keyword">if</span> ((bprm-&gt;buf[<span class="number">0</span>] != <span class="string">&#x27;#&#x27;</span>) || (bprm-&gt;buf[<span class="number">1</span>] != <span class="string">&#x27;!&#x27;</span>))</span><br><span class="line">		<span class="keyword">return</span> -ENOEXEC;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 下面的代码块负责解析&#x27;#!&#x27;行, 将其分解为解释器路径和可选的参数字符串.</span></span><br><span class="line"><span class="comment">	 * 必须小心处理, 因为bprm-&gt;buf中的内容不保证是以NUL(空字符)结尾的.</span></span><br><span class="line"><span class="comment">	 * 我们不希望执行一个被截断的解释器路径, 所以我们要么找到一个换行符(说明行是完整的),</span></span><br><span class="line"><span class="comment">	 * 要么在解释器路径后找到一个空格/制表符/NUL. 参数被截断是可以接受的.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/* 计算出bprm-&gt;buf缓冲区的末尾地址, 用于边界检查. */</span></span><br><span class="line">	buf_end = bprm-&gt;buf + <span class="keyword">sizeof</span>(bprm-&gt;buf) - <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/* 在缓冲区中查找第一个换行符&#x27;\n&#x27;, 它标志着&#x27;#!&#x27;行的结束. */</span></span><br><span class="line">	i_end = strnchr(bprm-&gt;buf, <span class="keyword">sizeof</span>(bprm-&gt;buf), <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">	<span class="comment">/* 如果没有找到换行符, 说明&#x27;#!&#x27;行可能因为文件太小而被截断了. */</span></span><br><span class="line">	<span class="keyword">if</span> (!i_end) &#123;</span><br><span class="line">		<span class="comment">/* 从&#x27;#!&#x27;之后开始查找第一个非空格/制表符的字符. */</span></span><br><span class="line">		i_end = next_non_spacetab(bprm-&gt;buf + <span class="number">2</span>, buf_end);</span><br><span class="line">		<span class="comment">/* 如果整个缓冲区都是空格/制表符, 这是一个无效的脚本. */</span></span><br><span class="line">		<span class="keyword">if</span> (!i_end)</span><br><span class="line">			<span class="keyword">return</span> -ENOEXEC; </span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 如果在找到的第一个非空字符之后, 再也找不到任何空格/制表符/NUL,</span></span><br><span class="line"><span class="comment">		 * 我们必须假设解释器的路径被截断了, 这是一个不安全的情况.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!next_terminator(i_end, buf_end))</span><br><span class="line">			<span class="keyword">return</span> -ENOEXEC;</span><br><span class="line">		<span class="comment">/* 如果没有换行符, 我们将行的末尾视为缓冲区的末尾. */</span></span><br><span class="line">		i_end = buf_end;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 从后向前, 修剪掉行末尾的所有空格或制表符. */</span></span><br><span class="line">	<span class="keyword">while</span> (spacetab(i_end[<span class="number">-1</span>]))</span><br><span class="line">		i_end--;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 跳过&#x27;#!&#x27;后面可能存在的前导空格/制表符, 找到解释器名称的起始位置. */</span></span><br><span class="line">	i_name = next_non_spacetab(bprm-&gt;buf+<span class="number">2</span>, i_end);</span><br><span class="line">	<span class="comment">/* 如果没有找到解释器名称 (例如, &#x27;#! &#x27;后面全是空格), 则返回错误. */</span></span><br><span class="line">	<span class="keyword">if</span> (!i_name || (i_name == i_end))</span><br><span class="line">		<span class="keyword">return</span> -ENOEXEC; </span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 检查是否存在可选的参数. */</span></span><br><span class="line">	i_arg = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">/* 查找解释器名称后面的第一个终止符 (空格/制表符/NUL). */</span></span><br><span class="line">	i_sep = next_terminator(i_name, i_end);</span><br><span class="line">	<span class="comment">/* 如果找到了一个非NUL的终止符, 说明后面可能有参数. */</span></span><br><span class="line">	<span class="keyword">if</span> (i_sep &amp;&amp; (*i_sep != <span class="string">&#x27;\0&#x27;</span>))</span><br><span class="line">		<span class="comment">/* 在这个终止符之后, 查找下一个非空格/制表符的字符, 那就是参数的开始. */</span></span><br><span class="line">		i_arg = next_non_spacetab(i_sep, i_end);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 如果脚本文件名在exec之后将变得不可访问(例如, 它是一个指向将要被关闭的文件描述符的路径),</span></span><br><span class="line"><span class="comment">	 * 那么现在就放弃执行. 因为我们假定解释器自己也需要读取这个脚本文件.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (bprm-&gt;interp_flags &amp; BINPRM_FLAGS_PATH_INACCESSIBLE)</span><br><span class="line">		<span class="keyword">return</span> -ENOENT;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 我们已经解析出了解释器名称和(可选的)参数.</span></span><br><span class="line"><span class="comment">	 * 现在我们需要重新组织bprm中的参数列表, 以便执行解释器.</span></span><br><span class="line"><span class="comment">	 * 新的参数列表将是:</span></span><br><span class="line"><span class="comment">	 *   argv[0]: 解释器名称 (例如, &quot;/bin/sh&quot;)</span></span><br><span class="line"><span class="comment">	 *   argv[1]: (可选的)&#x27;#!&#x27;行中的参数</span></span><br><span class="line"><span class="comment">	 *   argv[2]: 脚本文件的路径 (它替换了旧的argv[0])</span></span><br><span class="line"><span class="comment">	 *   ...:    原始的其他参数</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 这个过程是反向操作的, 因为用户空间参数是以栈的形式存储的.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/* 移除原始的argv[0] (即脚本文件的名称). */</span></span><br><span class="line">	retval = remove_arg_zero(bprm);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line">	<span class="comment">/* 将原始的脚本文件名(bprm-&gt;interp)作为最后一个参数压入. */</span></span><br><span class="line">	retval = copy_string_kernel(bprm-&gt;interp, bprm);</span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line">	bprm-&gt;argc++;</span><br><span class="line">	<span class="comment">/* 在i_end位置写入NUL, 确保从bprm-&gt;buf中复制字符串时能正确终止. */</span></span><br><span class="line">	*((<span class="type">char</span> *)i_end) = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	<span class="comment">/* 如果存在&#x27;#!&#x27;行中的参数. */</span></span><br><span class="line">	<span class="keyword">if</span> (i_arg) &#123;</span><br><span class="line">		<span class="comment">/* 在解释器和参数的分隔符处写入NUL, 将它们分开. */</span></span><br><span class="line">		*((<span class="type">char</span> *)i_sep) = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">		<span class="comment">/* 将&#x27;#!&#x27;行中的参数压入参数列表. */</span></span><br><span class="line">		retval = copy_string_kernel(i_arg, bprm);</span><br><span class="line">		<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> retval;</span><br><span class="line">		bprm-&gt;argc++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 将解释器名称压入参数列表, 它将成为新的argv[0]. */</span></span><br><span class="line">	retval = copy_string_kernel(i_name, bprm);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line">	bprm-&gt;argc++;</span><br><span class="line">	<span class="comment">/* 更改bprm中的解释器字段, 以记录新的解释器路径. */</span></span><br><span class="line">	retval = bprm_change_interp(i_name, bprm);</span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 现在用解释器的路径来重新开始执行流程.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/* 调用 open_exec 尝试打开解释器的可执行文件. */</span></span><br><span class="line">	file = open_exec(i_name);</span><br><span class="line">	<span class="comment">/* 检查文件打开是否成功. IS_ERR宏用于判断返回的指针是否是错误码. */</span></span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(file))</span><br><span class="line">		<span class="comment">/* PTR_ERR宏从指针中提取出负值的错误码. */</span></span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(file);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 将打开的解释器文件对象存入bprm-&gt;interpreter. */</span></span><br><span class="line">	bprm-&gt;interpreter = file;</span><br><span class="line">	<span class="comment">/* 返回0表示成功, 内核的execve流程将继续, 但这次加载的是bprm-&gt;interpreter指向的文件. */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义一个静态的 &#x27;linux_binfmt&#x27; 结构体实例, 名为 script_format.</span></span><br><span class="line"><span class="comment"> * 它将&#x27;#!&#x27;脚本这种&quot;格式&quot;与它的加载函数&#x27;load_script&#x27;绑定在一起.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">linux_binfmt</span> <span class="title">script_format</span> =</span> &#123;</span><br><span class="line">	.module		= THIS_MODULE,</span><br><span class="line">	.load_binary	= load_script,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * init_script_binfmt: 内核模块的初始化函数.</span></span><br><span class="line"><span class="comment"> * __init 属性表示此函数仅在内核启动时执行.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">init_script_binfmt</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 调用 register_binfmt 将 script_format 注册到内核的二进制格式处理器列表中. */</span></span><br><span class="line">	register_binfmt(&amp;script_format);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * exit_script_binfmt: 内核模块的退出函数.</span></span><br><span class="line"><span class="comment"> * __exit 属性表示此函数仅在模块卸载时执行.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">exit_script_binfmt</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 调用 unregister_binfmt 从内核列表中注销 script_format 处理器. */</span></span><br><span class="line">	unregister_binfmt(&amp;script_format);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将 init_script_binfmt 注册为核心初始化调用, 确保在系统启动早期被执行. */</span></span><br><span class="line">core_initcall(init_script_binfmt);</span><br><span class="line"><span class="comment">/* 将 exit_script_binfmt 注册为模块卸载时的退出函数. */</span></span><br><span class="line">module_exit(exit_script_binfmt);</span><br><span class="line"><span class="comment">/* 模块的描述信息, 可通过 modinfo 工具查看. */</span></span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Kernel support for scripts starting with #!&quot;</span>);</span><br><span class="line"><span class="comment">/* 模块的许可证. */</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="fs-binfmt-elf-fdpic-c"><a href="#fs-binfmt-elf-fdpic-c" class="headerlink" title="fs&#x2F;binfmt_elf_fdpic.c"></a>fs&#x2F;binfmt_elf_fdpic.c</h1><h2 id="ELF-FDPIC-Binary-Format-Support-在无MMU系统上实现多进程"><a href="#ELF-FDPIC-Binary-Format-Support-在无MMU系统上实现多进程" class="headerlink" title="ELF FDPIC Binary Format Support: 在无MMU系统上实现多进程"></a>ELF FDPIC Binary Format Support: 在无MMU系统上实现多进程</h2><p>此代码片段的作用是为Linux内核注册一个<strong>二进制格式处理器（binfmt）</strong>，专门用于加载和执行一种特殊类型的ELF（Executable and Linkable Format）文件，即 <strong>FDPIC（Function-Descriptor Position-Independent Code）</strong> 格式的可执行文件。</p>
<p>这个功能对于在<strong>没有内存管理单元（MMU）<strong>的微控制器（如STM32H750）上运行一个功能完整的、支持多进程的Linux系统（通常称为uClinux）是</strong>绝对核心和必需的</strong>。</p>
<h3 id="FDPIC的原理与在STM32H750上的关键作用"><a href="#FDPIC的原理与在STM32H750上的关键作用" class="headerlink" title="FDPIC的原理与在STM32H750上的关键作用"></a>FDPIC的原理与在STM32H750上的关键作用</h3><ol>
<li><p><strong>无MMU系统面临的挑战</strong>:<br>在一个标准的、有MMU的系统上，当您运行两个相同的程序实例（例如，两个<code>httpd</code>进程）时，MMU会为每个进程创建一个独立的虚拟地址空间。这意味着，虽然它们共享同一份物理代码（<code>.text</code>段），但每个进程都有自己私有的、位于相同虚拟地址的数据段（<code>.data</code>和<code>.bss</code>）。它们可以自由地修改自己的全局变量，而不会影响到对方。</p>
<p>在没有MMU的STM32H750上，<strong>地址就是物理地址</strong>。如果两个进程直接加载同一个普通ELF文件，它们将共享同一份物理代码<strong>和</strong>同一份物理数据段。如果一个进程修改了一个全局变量，这个修改会立即对另一个进程可见，这将导致灾难性的后果和系统崩溃。</p>
</li>
<li><p><strong>FDPIC的解决方案</strong>:<br>FDPIC是一种为解决这个问题而设计的、精巧的编译和加载方案。</p>
<ul>
<li><strong>编译</strong>: 编译器会生成一种特殊的位置无关代码。在这种代码中，对全局变量或静态变量的访问<strong>不是</strong>通过绝对地址，而是通过一个<strong>基地址寄存器</strong>加上一个偏移量来进行的。</li>
<li><strong>加载 (<code>load_elf_fdpic_binary</code>)</strong>: 当<code>load_elf_fdpic_binary</code>函数加载一个FDPIC程序时，它会：<ul>
<li>将程序的代码段（<code>.text</code>）加载到内存中。<strong>这份代码段只会被加载一次，并由所有运行该程序的进程共享</strong>。</li>
<li>对于<strong>每一个</strong>要创建的新进程，加载器都会在内存中<strong>分配一套全新的、私有的</strong>数据段（<code>.data</code>）和BSS段（<code>.bss</code>）。</li>
<li>在创建进程和进行上下文切换时，内核会负责将这个进程<strong>私有数据段的基地址</strong>加载到那个专用的基地址寄存器中。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>最终效果</strong>:<br>当CPU执行共享的代码时，无论它访问哪个全局变量，实际上都是通过“基地址寄存器（指向私有数据区） + 偏移量”来找到正确的位置。这样，进程A的指令访问的是A的数据区，进程B的指令访问的是B的数据区，它们之间完美隔离，互不干扰。<strong>FDPIC巧妙地用软件和编译器约定，模拟出了MMU对数据段的隔离效果</strong>。</p>
</li>
</ol>
<p>因此，<code>binfmt_elf_fdpic</code>是使真正的多任务处理在像STM32H750这样的高性能MCU上成为可能的基石。</p>
<hr>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义一个静态的 &#x27;linux_binfmt&#x27; 结构体实例, 名为 elf_fdpic_format.</span></span><br><span class="line"><span class="comment"> * 这个结构体向内核注册了一个处理 FDPIC ELF 格式二进制文件的处理器.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">linux_binfmt</span> <span class="title">elf_fdpic_format</span> =</span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * .module: 指向当前模块的指针 (THIS_MODULE).</span></span><br><span class="line"><span class="comment">	 * 用于管理模块的引用计数, 确保在处理器还在使用时, 模块不会被卸载.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	.module		= THIS_MODULE,</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * .load_binary: 一个函数指针, 指向加载此格式二进制文件的核心函数.</span></span><br><span class="line"><span class="comment">	 * 当内核识别出一个文件是 FDPIC ELF 格式时, 就会调用 load_elf_fdpic_binary.</span></span><br><span class="line"><span class="comment">	 * 这个函数会执行我们上面描述的加载逻辑: 加载共享的代码段, 并为新进程分配私有的数据段.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	.load_binary	= load_elf_fdpic_binary,</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 仅当内核配置了CONFIG_ELF_CORE (支持生成ELF格式的crash dump)时, 才编译以下部分.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ELF_CORE</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * .core_dump: 一个函数指针, 指向当此格式的程序崩溃时, 用于生成核心转储(core dump)文件的函数.</span></span><br><span class="line"><span class="comment">	 * 这对于事后调试非常重要.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	.core_dump	= elf_fdpic_core_dump,</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * .min_coredump: 指定生成核心转储所需的最小文件大小.</span></span><br><span class="line"><span class="comment">	 * 通常设置为一个页的大小 (ELF_EXEC_PAGESIZE).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	.min_coredump	= ELF_EXEC_PAGESIZE,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * init_elf_fdpic_binfmt: 内核模块的初始化函数.</span></span><br><span class="line"><span class="comment"> * 标记为 __init, 表示它仅在内核启动期间执行.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">init_elf_fdpic_binfmt</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 调用 register_binfmt, 将我们定义的 elf_fdpic_format 处理器注册到内核的二进制格式处理器列表中.</span></span><br><span class="line"><span class="comment">	 * 从此, 内核在执行 execve 系统调用时, 就会考虑 FDPIC ELF 这种格式.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	register_binfmt(&amp;elf_fdpic_format);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * exit_elf_fdpic_binfmt: 内核模块的退出函数.</span></span><br><span class="line"><span class="comment"> * 标记为 __exit, 表示它仅在模块卸载时执行.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">exit_elf_fdpic_binfmt</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 调用 unregister_binfmt, 从内核列表中注销 elf_fdpic_format 处理器.</span></span><br><span class="line"><span class="comment">	 * 这是注册操作的反向过程, 用于安全地移除该功能.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	unregister_binfmt(&amp;elf_fdpic_format);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用 core_initcall() 将 init_elf_fdpic_binfmt 注册为一个核心初始化调用.</span></span><br><span class="line"><span class="comment"> * 这确保了对 FDPIC ELF 格式的支持在系统启动的早期阶段就已经可用,</span></span><br><span class="line"><span class="comment"> * 以便系统能够执行用这种格式编译的用户空间程序.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">core_initcall(init_elf_fdpic_binfmt);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用 module_exit() 宏指定当模块被卸载时要调用的退出函数.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">module_exit(exit_elf_fdpic_binfmt);</span><br></pre></td></tr></table></figure>

<h2 id="is-elf-验证一个文件是否为可执行的ELF文件"><a href="#is-elf-验证一个文件是否为可执行的ELF文件" class="headerlink" title="is_elf: 验证一个文件是否为可执行的ELF文件"></a>is_elf: 验证一个文件是否为可执行的ELF文件</h2><p>此函数是一个<strong>验证函数</strong>，它的核心作用是根据ELF文件格式规范，对一个文件的头部信息进行一系列快速检查，以判断该文件<strong>是否是一个当前系统可以理解并尝试执行的ELF二进制文件</strong>。它像是一个门卫，只有通过了它所有检查的文件，才会被内核的ELF加载器进一步处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * is_elf: 检查一个文件是否是当前系统可以处理的有效ELF文件.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @hdr:  指向从文件头部读出的 elfhdr 结构体的指针.</span></span><br><span class="line"><span class="comment"> * @file: 指向该文件的 &#x27;struct file&#x27; 对象的指针.</span></span><br><span class="line"><span class="comment"> * @return: 如果是有效的、可处理的ELF文件, 返回1 (true); 否则返回0 (false).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">is_elf</span><span class="params">(<span class="keyword">struct</span> elfhdr *hdr, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 第1步: 检查魔数 (Magic Number). 这是最首要、最关键的检查.</span></span><br><span class="line"><span class="comment">	 * memcmp: 是一个内存比较函数, 它比较两块内存区域的内容.</span></span><br><span class="line"><span class="comment">	 * hdr-&gt;e_ident: 这是ELF头中一个16字节的数组, 其前4个字节包含了魔数.</span></span><br><span class="line"><span class="comment">	 * ELFMAG: 是一个宏, 定义了标准的ELF魔数 &#123;&#x27;\x7f&#x27;, &#x27;E&#x27;, &#x27;L&#x27;, &#x27;F&#x27;&#125;.</span></span><br><span class="line"><span class="comment">	 * SELFMAG: 是一个宏, 定义了魔数的长度 (4).</span></span><br><span class="line"><span class="comment">	 * 这行代码的意思是: &quot;比较文件头的前4个字节是否与标准的ELF魔数完全相同&quot;.</span></span><br><span class="line"><span class="comment">	 * 如果不相同 (memcmp返回值不为0), 说明这不是一个ELF文件.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">memcmp</span>(hdr-&gt;e_ident, ELFMAG, SELFMAG) != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* 立即返回false. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 第2步: 检查文件类型.</span></span><br><span class="line"><span class="comment">	 * hdr-&gt;e_type: 这个字段描述了ELF文件的类型.</span></span><br><span class="line"><span class="comment">	 * ET_EXEC: 表示这是一个可执行文件.</span></span><br><span class="line"><span class="comment">	 * ET_DYN: 表示这是一个共享目标文件, 在现代Linux中, 它也用于位置无关可执行文件(PIE).</span></span><br><span class="line"><span class="comment">	 * 在STM32H750的uClinux上, 几乎所有的可执行文件都是 ET_DYN 类型的PIE/FDPIC文件.</span></span><br><span class="line"><span class="comment">	 * 这行代码的意思是: &quot;我们只尝试加载可执行文件或PIE, 不加载.o之类的目标文件&quot;.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (hdr-&gt;e_type != ET_EXEC &amp;&amp; hdr-&gt;e_type != ET_DYN)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* 如果类型不匹配, 返回false. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 第3步: 检查目标架构.</span></span><br><span class="line"><span class="comment">	 * 调用 elf_check_arch 辅助函数. 这个函数会检查ELF头中的 e_machine 字段.</span></span><br><span class="line"><span class="comment">	 * e_machine 字段记录了这个文件是为哪种CPU架构编译的.</span></span><br><span class="line"><span class="comment">	 * elf_check_arch 会判断这个架构是否与当前系统正在运行的CPU架构(例如, ARM)相匹配.</span></span><br><span class="line"><span class="comment">	 * 你不能在ARM架构的STM32H750上运行一个为x86编译的程序.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!elf_check_arch(hdr))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* 如果架构不匹配, 返回false. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 第4步: 检查文件系统是否支持内存映射(mmap).</span></span><br><span class="line"><span class="comment">	 * file-&gt;f_op: 指向与该文件所在文件系统相关的文件操作函数表.</span></span><br><span class="line"><span class="comment">	 * file-&gt;f_op-&gt;mmap: 是这个函数表中的一个函数指针. mmap是加载ELF文件的核心操作,</span></span><br><span class="line"><span class="comment">	 *                   它将文件的代码段和数据段映射到内存中.</span></span><br><span class="line"><span class="comment">	 * 这行代码的意思是: &quot;如果这个文件所在的文件系统(例如一个特殊的虚拟文件系统)</span></span><br><span class="line"><span class="comment">	 *                   根本不支持mmap操作, 那么我们就无法加载它&quot;.</span></span><br><span class="line"><span class="comment">	 * 在STM32H750上, 存放可执行文件的文件系统 (如FAT32, JFFS2, Ext4等) 都会支持mmap.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!file-&gt;f_op-&gt;mmap)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* 如果不支持mmap, 返回false. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 如果以上所有检查都通过了, 说明这是一个当前系统可以尝试加载的ELF文件.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>; <span class="comment">/* 返回true. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="elf-fdpic-fetch-phdrs-读取并解析ELF程序头表"><a href="#elf-fdpic-fetch-phdrs-读取并解析ELF程序头表" class="headerlink" title="elf_fdpic_fetch_phdrs: 读取并解析ELF程序头表"></a>elf_fdpic_fetch_phdrs: 读取并解析ELF程序头表</h2><p>此函数是FDPIC ELF加载器中的一个关键步骤。它的核心作用是根据ELF头中提供的信息，从可执行文件中<strong>读取整个程序头表（Program Header Table）<strong>到内核内存中，并对表中的特定项进行初步解析，以获取重要信息，如</strong>请求的栈大小和栈的可执行权限</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * read the program headers table into memory</span></span><br><span class="line"><span class="comment"> * 将程序头表读入内存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @params: 指向 elf_fdpic_params 结构体的指针, 函数将把读取和解析的结果存入其中.</span></span><br><span class="line"><span class="comment"> * @file:   指向要读取的ELF文件的 &#x27;struct file&#x27; 对象.</span></span><br><span class="line"><span class="comment"> * @return: 成功时返回0, 失败时返回负值的错误码.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">elf_fdpic_fetch_phdrs</span><span class="params">(<span class="keyword">struct</span> elf_fdpic_params *params,</span></span><br><span class="line"><span class="params">				 <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * phdr: 一个指针, 用于在读取的程序头表中进行遍历.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">elf_phdr</span> *<span class="title">phdr</span>;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * size: 用于存储整个程序头表所需的总字节数.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * retval: 用于存储函数调用的返回值.</span></span><br><span class="line"><span class="comment">	 * loop: 用于循环的计数器.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> retval, loop;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * pos: 文件读取的偏移量.</span></span><br><span class="line"><span class="comment">	 * 从ELF头中的 e_phoff 字段获取程序头表的起始位置在文件中的偏移量.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">loff_t</span> pos = params-&gt;hdr.e_phoff;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 安全性检查 1: 检查ELF头中记录的每个程序头表项的大小(e_phentsize)</span></span><br><span class="line"><span class="comment">	 * 是否与内核定义的 &#x27;struct elf_phdr&#x27; 大小完全一致.</span></span><br><span class="line"><span class="comment">	 * 如果不一致, 说明文件格式有误或与内核不兼容.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (params-&gt;hdr.e_phentsize != <span class="keyword">sizeof</span>(<span class="keyword">struct</span> elf_phdr))</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM; <span class="comment">/* 返回错误. -ENOMEM在这里实际上意味着格式不兼容. */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 安全性检查 2: 检查程序头表的总数(e_phnum)是否过大.</span></span><br><span class="line"><span class="comment">	 * 65536U 是一个合理的上限值, 防止因文件中一个畸大的数值而导致内核分配过多内存.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (params-&gt;hdr.e_phnum &gt; <span class="number">65536U</span> / <span class="keyword">sizeof</span>(<span class="keyword">struct</span> elf_phdr))</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 计算读取整个程序头表所需的总内存大小.</span></span><br><span class="line"><span class="comment">	 * 总大小 = 表项数量 * 每个表项的大小.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	size = params-&gt;hdr.e_phnum * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> elf_phdr);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 使用 kmalloc 为程序头表分配内核内存.</span></span><br><span class="line"><span class="comment">	 * GFP_KERNEL 是标准的内核内存分配标志.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	params-&gt;phdrs = kmalloc(size, GFP_KERNEL);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 检查内存是否分配成功.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!params-&gt;phdrs)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM; <span class="comment">/* 如果失败, 返回内存不足错误. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 调用 kernel_read, 从文件的指定位置(pos)读取整个程序头表(大小为size)到新分配的内存中.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	retval = kernel_read(file, params-&gt;phdrs, size, &amp;pos);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 检查读取操作的结果. unlikely() 是一个编译器优化提示.</span></span><br><span class="line"><span class="comment">	 * 必须确保实际读取的字节数与期望的完全一致.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(retval != size))</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 如果不一致, 如果 retval &lt; 0, 说明发生了I/O错误, 直接返回该错误码.</span></span><br><span class="line"><span class="comment">		 * 否则 (retval &gt;= 0 但 &lt; size), 说明文件被意外截断, 返回 -ENOEXEC (无效的执行格式).</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">return</span> retval &lt; <span class="number">0</span> ? retval : -ENOEXEC;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 遍历刚刚读入的程序头表, 以确定此二进制文件请求的栈属性.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/* phdr 指针指向程序头表的起始位置. */</span></span><br><span class="line">	phdr = params-&gt;phdrs;</span><br><span class="line">	<span class="comment">/* 遍历所有表项. */</span></span><br><span class="line">	<span class="keyword">for</span> (loop = <span class="number">0</span>; loop &lt; params-&gt;hdr.e_phnum; loop++, phdr++) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 检查当前表项的类型是否是 PT_GNU_STACK.</span></span><br><span class="line"><span class="comment">		 * 这是一个由GNU工具链添加的特殊段, 专门用来向操作系统传达栈的属性.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (phdr-&gt;p_type != PT_GNU_STACK)</span><br><span class="line">			<span class="keyword">continue</span>; <span class="comment">/* 如果不是, 继续检查下一个表项. */</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 如果找到了 PT_GNU_STACK 段, 检查其 p_flags 字段.</span></span><br><span class="line"><span class="comment">		 * PF_X 标志位代表&quot;可执行&quot;(eXecutable).</span></span><br><span class="line"><span class="comment">		 * 如果 PF_X 被设置, 说明程序请求一个可执行的栈.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (phdr-&gt;p_flags &amp; PF_X)</span><br><span class="line">			<span class="comment">/* 在 params-&gt;flags 中记录下这个请求. */</span></span><br><span class="line">			params-&gt;flags |= ELF_FDPIC_FLAG_EXEC_STACK;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="comment">/* 否则, 记录下栈是不可执行的. */</span></span><br><span class="line">			params-&gt;flags |= ELF_FDPIC_FLAG_NOEXEC_STACK;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * PT_GNU_STACK 段的 p_memsz 字段通常被用来建议一个默认的栈大小.</span></span><br><span class="line"><span class="comment">		 * 将这个值存入 params-&gt;stack_size.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		params-&gt;stack_size = phdr-&gt;p_memsz;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 按照规范, 一个ELF文件中最多只有一个 PT_GNU_STACK 段.</span></span><br><span class="line"><span class="comment">		 * 既然已经找到了, 就可以提前结束循环.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 所有操作成功, 返回0.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="elf-fdpic-map-file-constdisp-on-uclinux-在uClinux上映射固定位移的文件"><a href="#elf-fdpic-map-file-constdisp-on-uclinux-在uClinux上映射固定位移的文件" class="headerlink" title="elf_fdpic_map_file_constdisp_on_uclinux: 在uClinux上映射固定位移的文件"></a>elf_fdpic_map_file_constdisp_on_uclinux: 在uClinux上映射固定位移的文件</h2><p>此函数专门用于处理那些其内部段（segment）之间需要保持固定相对位置的FDPIC ELF文件。它的核心策略是：<strong>一次性地分配一块足够大的、连续的物理内存块，然后像“贴图”一样，将文件中的各个<code>PT_LOAD</code>段精确地复制到这块大内存的不同偏移处。</strong> 这块大内存就成为了新进程的代码和私有数据区。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * map a file with constant displacement under uClinux</span></span><br><span class="line"><span class="comment"> * 在uClinux下映射一个具有固定位移的文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @params: 指向 elf_fdpic_params 结构体的指针.</span></span><br><span class="line"><span class="comment"> * @file:   指向要加载的文件的 file 对象.</span></span><br><span class="line"><span class="comment"> * @mm:     指向当前进程的内存描述符 (mm_struct) 的指针.</span></span><br><span class="line"><span class="comment"> * @return: 成功时返回0, 失败时返回负值的错误码.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">elf_fdpic_map_file_constdisp_on_uclinux</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="keyword">struct</span> elf_fdpic_params *params,</span></span><br><span class="line"><span class="params">	<span class="keyword">struct</span> file *file,</span></span><br><span class="line"><span class="params">	<span class="keyword">struct</span> mm_struct *mm)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * seg:   用于填充加载映射表(loadmap)中段信息的指针.</span></span><br><span class="line"><span class="comment">	 * phdr:  用于遍历程序头表的指针.</span></span><br><span class="line"><span class="comment">	 * load_addr: 期望的加载地址.</span></span><br><span class="line"><span class="comment">	 * base:  所有LOAD段中最小的虚拟地址(vaddr).</span></span><br><span class="line"><span class="comment">	 * top:   所有LOAD段中最大的虚拟地址 + 大小.</span></span><br><span class="line"><span class="comment">	 * maddr: 分配到的大块连续物理内存的起始地址.</span></span><br><span class="line"><span class="comment">	 * loop, ret: 循环计数器和返回值.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">elf_fdpic_loadseg</span> *<span class="title">seg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">elf_phdr</span> *<span class="title">phdr</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> load_addr, base = ULONG_MAX, top = <span class="number">0</span>, maddr = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> loop, ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 从参数结构体中获取期望的加载地址和加载映射表的指针.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	load_addr = params-&gt;load_addr;</span><br><span class="line">	seg = params-&gt;loadmap-&gt;segs;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 第一步: 扫描程序头表, 计算出需要分配的连续内存块的总大小.</span></span><br><span class="line"><span class="comment">	 * 这个大小由所有PT_LOAD段所覆盖的虚拟地址范围决定.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	phdr = params-&gt;phdrs;</span><br><span class="line">	<span class="keyword">for</span> (loop = <span class="number">0</span>; loop &lt; params-&gt;hdr.e_phnum; loop++, phdr++) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 我们只关心需要被加载到内存的段.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (params-&gt;phdrs[loop].p_type != PT_LOAD)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 寻找所有LOAD段中最小的虚拟地址, 作为整个内存块的虚拟基地址.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (base &gt; phdr-&gt;p_vaddr)</span><br><span class="line">			base = phdr-&gt;p_vaddr;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 寻找所有LOAD段覆盖范围的最高点, 作为整个内存块的虚拟顶地址.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (top &lt; phdr-&gt;p_vaddr + phdr-&gt;p_memsz)</span><br><span class="line">			top = phdr-&gt;p_vaddr + phdr-&gt;p_memsz;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 第二步: 根据计算出的总大小 (top - base), 分配一块大的、匿名的、连续的物理内存.</span></span><br><span class="line"><span class="comment">	 * vm_mmap 在无MMU系统上是一个物理内存分配器.</span></span><br><span class="line"><span class="comment">	 * @ NULL, load_addr: 提示期望的加载地址.</span></span><br><span class="line"><span class="comment">	 * @ top - base:      要分配的总大小.</span></span><br><span class="line"><span class="comment">	 * @ PROT_...|PROT_EXEC: 请求的内存权限为可读、可写、可执行.</span></span><br><span class="line"><span class="comment">	 * @ MAP_PRIVATE:     这是一个私有映射, 对内存的修改不会写回文件.</span></span><br><span class="line"><span class="comment">	 * @ 0:               文件偏移量, 对于匿名映射为0.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	maddr = vm_mmap(<span class="literal">NULL</span>, load_addr, top - base,</span><br><span class="line">			PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 检查内存分配是否成功. IS_ERR_VALUE 用于判断一个无符号长整型是否是一个错误码.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (IS_ERR_VALUE(maddr))</span><br><span class="line">		<span class="keyword">return</span> (<span class="type">int</span>) maddr; <span class="comment">/* 如果失败, 返回错误码. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 这行代码用于共享库的加载, 如果有多个库, 确保它们被加载到不同的地址.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (load_addr != <span class="number">0</span>)</span><br><span class="line">		load_addr += PAGE_ALIGN(top - base);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 第三步: 再次遍历程序头表, 将每个PT_LOAD段的内容复制到大内存块(maddr)中对应的位置.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	phdr = params-&gt;phdrs;</span><br><span class="line">	<span class="keyword">for</span> (loop = <span class="number">0</span>; loop &lt; params-&gt;hdr.e_phnum; loop++, phdr++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (params-&gt;phdrs[loop].p_type != PT_LOAD)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 关键计算: 确定当前段在物理内存块(maddr)中的最终位置.</span></span><br><span class="line"><span class="comment">		 * 物理地址 = 物理基地址 + (段的虚拟地址 - 虚拟基地址).</span></span><br><span class="line"><span class="comment">		 * 这保证了所有段在物理内存中的相对位移和它们在虚拟地址空间中的完全一致.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		seg-&gt;addr = maddr + (phdr-&gt;p_vaddr - base);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 填充加载映射表(loadmap)的当前表项.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		seg-&gt;p_vaddr = phdr-&gt;p_vaddr;</span><br><span class="line">		seg-&gt;p_memsz = phdr-&gt;p_memsz;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 调用 read_code, 从文件中读取段的内容(大小为p_filesz)到计算出的物理地址(seg-&gt;addr).</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		ret = read_code(file, seg-&gt;addr, phdr-&gt;p_offset,</span><br><span class="line">				       phdr-&gt;p_filesz);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) <span class="comment">/* 如果读取失败, 返回错误. */</span></span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 如果当前段包含了文件的开头(p_offset == 0), 那么ELF头也被加载进来了.</span></span><br><span class="line"><span class="comment">		 * 记录下这个地址, 动态链接器可能需要它.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (phdr-&gt;p_offset == <span class="number">0</span>)</span><br><span class="line">			params-&gt;elfhdr_addr = seg-&gt;addr;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 处理 .bss 段: 如果段在内存中的大小(p_memsz)大于在文件中的大小(p_filesz),</span></span><br><span class="line"><span class="comment">		 * 那么多出来的部分就是未初始化的全局变量(.bss).</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (phdr-&gt;p_filesz &lt; phdr-&gt;p_memsz) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * 调用 clear_user 将这部分内存区域清零, 这是C语言规范所要求的.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (clear_user((<span class="type">void</span> *) (seg-&gt;addr + phdr-&gt;p_filesz),</span><br><span class="line">				       phdr-&gt;p_memsz - phdr-&gt;p_filesz))</span><br><span class="line">				<span class="keyword">return</span> -EFAULT; <span class="comment">/* 如果清零失败, 返回错误. */</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 如果mm不为NULL(即正在加载主可执行文件), 更新进程内存描述符中的代码段和数据段范围.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (mm) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * 如果段是可执行的(PF_X), 它就是代码段.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (phdr-&gt;p_flags &amp; PF_X) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!mm-&gt;start_code) &#123; <span class="comment">/* 只记录第一个代码段的范围. */</span></span><br><span class="line">					mm-&gt;start_code = seg-&gt;addr;</span><br><span class="line">					mm-&gt;end_code = seg-&gt;addr +</span><br><span class="line">						phdr-&gt;p_memsz;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mm-&gt;start_data) &#123; <span class="comment">/* 否则, 它是数据段. */</span></span><br><span class="line">				mm-&gt;start_data = seg-&gt;addr;</span><br><span class="line">				mm-&gt;end_data = seg-&gt;addr + phdr-&gt;p_memsz;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 移动到加载映射表的下一个表项, 准备填充下一个LOAD段的信息.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		seg++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 所有段都成功加载, 返回0.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="elf-fdpic-map-file-by-direct-mmap-逐个映射PT-LOAD段"><a href="#elf-fdpic-map-file-by-direct-mmap-逐个映射PT-LOAD段" class="headerlink" title="elf_fdpic_map_file_by_direct_mmap: 逐个映射PT_LOAD段"></a>elf_fdpic_map_file_by_direct_mmap: 逐个映射<code>PT_LOAD</code>段</h2><p>此函数的核心策略是遍历程序头表，并为每一个 <code>PT_LOAD</code> 类型的段单独调用<code>vm_mmap</code>。这种方法更加灵活，因为它不要求所有段都被加载到一块连续的物理内存中。</p>
<p>在这种模式下：</p>
<ul>
<li><strong>独立分配</strong>: 内核会为代码段分配一块物理内存，为数据段分配<strong>另一块</strong>（可能不相邻的）物理内存。</li>
<li><strong><code>vm_mmap</code>的行为</strong>: 在无MMU系统上，<code>vm_mmap</code>从文件中映射内存的行为简化为：<ol>
<li>调用物理内存分配器（如<code>kmalloc</code>）分配一块大小合适的、<strong>私有的</strong>物理内存。</li>
<li>调用文件系统的<code>read</code>操作，将文件中的数据复制到这块新分配的物理内存中。</li>
</ol>
</li>
<li><strong>FDPIC的魔力</strong>: 即使代码段和数据段被加载到了物理上不相邻的内存区域，FDPIC机制依然能正常工作。因为对全局变量的访问是通过“基地址寄存器（指向私有数据段） + 偏移量”来完成的，这个基地址寄存器的值是在程序加载时根据数据段的实际物理位置确定的。所以无论数据段在哪里，程序总能找到它。</li>
</ul>
<p>这种方式的缺点是可能会产生更多的内存碎片，并且无法保证段之间的固定相对位置，但优点是为链接器和加载器提供了更大的灵活性。</p>
<hr>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * map a binary by direct mmap() of the individual PT_LOAD segments</span></span><br><span class="line"><span class="comment"> * 通过对单个PT_LOAD段直接进行mmap()来映射一个二进制文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @params: 指向 elf_fdpic_params 结构体的指针.</span></span><br><span class="line"><span class="comment"> * @file:   指向要加载的文件的 file 对象.</span></span><br><span class="line"><span class="comment"> * @mm:     指向当前进程的内存描述符 (mm_struct) 的指针.</span></span><br><span class="line"><span class="comment"> * @return: 成功时返回0, 失败时返回负值的错误码.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">elf_fdpic_map_file_by_direct_mmap</span><span class="params">(<span class="keyword">struct</span> elf_fdpic_params *params,</span></span><br><span class="line"><span class="params">					     <span class="keyword">struct</span> file *file,</span></span><br><span class="line"><span class="params">					     <span class="keyword">struct</span> mm_struct *mm)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * seg:   用于填充加载映射表(loadmap)中段信息的指针.</span></span><br><span class="line"><span class="comment">	 * phdr:  用于遍历程序头表的指针.</span></span><br><span class="line"><span class="comment">	 * load_addr: 期望的加载基地址.</span></span><br><span class="line"><span class="comment">	 * delta_vaddr: 用于计算固定位移模式下的地址偏移.</span></span><br><span class="line"><span class="comment">	 * loop:  循环计数器.</span></span><br><span class="line"><span class="comment">	 * dvset: 一个标志, 用于标记delta_vaddr是否已被设置.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">elf_fdpic_loadseg</span> *<span class="title">seg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">elf_phdr</span> *<span class="title">phdr</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> load_addr, delta_vaddr;</span><br><span class="line">	<span class="type">int</span> loop, dvset;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 初始化变量.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	load_addr = params-&gt;load_addr;</span><br><span class="line">	delta_vaddr = <span class="number">0</span>;</span><br><span class="line">	dvset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 指针指向加载映射表的第一个段.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	seg = params-&gt;loadmap-&gt;segs;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 核心部分: 遍历程序头表, 对每个PT_LOAD段分别进行处理.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	phdr = params-&gt;phdrs;</span><br><span class="line">	<span class="keyword">for</span> (loop = <span class="number">0</span>; loop &lt; params-&gt;hdr.e_phnum; loop++, phdr++) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * maddr: 将要映射到的内存地址.</span></span><br><span class="line"><span class="comment">		 * disp:  段的虚拟地址(vaddr)相对于页边界的偏移.</span></span><br><span class="line"><span class="comment">		 * excess: .bss段的大小.</span></span><br><span class="line"><span class="comment">		 * prot:  内存保护标志 (读/写/执行).</span></span><br><span class="line"><span class="comment">		 * flags: mmap的标志.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> maddr, disp, excess;</span><br><span class="line">		<span class="type">int</span> prot = <span class="number">0</span>, flags;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 我们只关心需要被加载到内存的PT_LOAD段.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (phdr-&gt;p_type != PT_LOAD)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 内核调试打印: 显示当前正在处理的LOAD段的虚拟地址、文件偏移、文件大小和内存大小. */</span></span><br><span class="line">		kdebug(<span class="string">&quot;[LOAD] va=%lx of=%lx fs=%lx ms=%lx&quot;</span>,</span><br><span class="line">		       (<span class="type">unsigned</span> <span class="type">long</span>) phdr-&gt;p_vaddr,</span><br><span class="line">		       (<span class="type">unsigned</span> <span class="type">long</span>) phdr-&gt;p_offset,</span><br><span class="line">		       (<span class="type">unsigned</span> <span class="type">long</span>) phdr-&gt;p_filesz,</span><br><span class="line">		       (<span class="type">unsigned</span> <span class="type">long</span>) phdr-&gt;p_memsz);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 根据程序头中的p_flags, 确定内存的保护属性.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (phdr-&gt;p_flags &amp; PF_R) prot |= PROT_READ;</span><br><span class="line">		<span class="keyword">if</span> (phdr-&gt;p_flags &amp; PF_W) prot |= PROT_WRITE;</span><br><span class="line">		<span class="keyword">if</span> (phdr-&gt;p_flags &amp; PF_X) prot |= PROT_EXEC;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 默认的mmap标志为私有映射.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		flags = MAP_PRIVATE;</span><br><span class="line">		maddr = <span class="number">0</span>; <span class="comment">/* 默认让内核自动选择加载地址. */</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 根据FDPIC的排列方式标志, 调整mmap的参数.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">switch</span> (params-&gt;flags &amp; ELF_FDPIC_FLAG_ARRANGEMENT) &#123;</span><br><span class="line">		<span class="keyword">case</span> ELF_FDPIC_FLAG_INDEPENDENT:</span><br><span class="line">			<span class="comment">/* PT_LOAD段可独立重定位. 无需特殊操作. */</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> ELF_FDPIC_FLAG_HONOURVADDR:</span><br><span class="line">			<span class="comment">/* 必须遵守指定的虚拟地址. */</span></span><br><span class="line">			maddr = phdr-&gt;p_vaddr; <span class="comment">/* 将期望地址设置为vaddr. */</span></span><br><span class="line">			flags |= MAP_FIXED;  <span class="comment">/* 使用 MAP_FIXED 强制映射到该地址. */</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> ELF_FDPIC_FLAG_CONSTDISP:</span><br><span class="line">			<span class="comment">/* 固定位移模式. */</span></span><br><span class="line">			<span class="keyword">if</span> (!dvset) &#123; <span class="comment">/* 如果是第一个LOAD段 */</span></span><br><span class="line">				maddr = load_addr; <span class="comment">/* 使用传入的基地址. */</span></span><br><span class="line">				delta_vaddr = phdr-&gt;p_vaddr; <span class="comment">/* 记录第一个段的虚拟地址作为基准. */</span></span><br><span class="line">				dvset = <span class="number">1</span>; <span class="comment">/* 设置标志. */</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123; <span class="comment">/* 对于后续的段 */</span></span><br><span class="line">				<span class="comment">/* 计算期望地址, 保持与第一个段的相对位移不变. */</span></span><br><span class="line">				maddr = load_addr + phdr-&gt;p_vaddr - delta_vaddr;</span><br><span class="line">				flags |= MAP_FIXED;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> ELF_FDPIC_FLAG_CONTIGUOUS:</span><br><span class="line">			<span class="comment">/* 连续模式, 地址将在后面计算. */</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			BUG(); <span class="comment">/* 不应该出现其他情况. */</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 将期望的映射地址按页对齐.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		maddr &amp;= PAGE_MASK;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 调用 vm_mmap 来执行实际的内存映射.</span></span><br><span class="line"><span class="comment">		 * disp: 计算段的vaddr没有对齐到页边界的部分, 这部分也要包含在映射中.</span></span><br><span class="line"><span class="comment">		 * phdr-&gt;p_offset - disp: 调整文件偏移, 以匹配对齐后的内存地址.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		disp = phdr-&gt;p_vaddr &amp; ~PAGE_MASK;</span><br><span class="line">		maddr = vm_mmap(file, maddr, phdr-&gt;p_memsz + disp, prot, flags,</span><br><span class="line">				phdr-&gt;p_offset - disp);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 内核调试打印: 显示mmap的详细参数和返回值. */</span></span><br><span class="line">		kdebug(<span class="string">&quot;mmap[%d] &lt;file&gt; sz=%llx pr=%x fl=%x of=%llx --&gt; %08lx&quot;</span>,</span><br><span class="line">		       loop, (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) phdr-&gt;p_memsz + disp,</span><br><span class="line">		       prot, flags, (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) phdr-&gt;p_offset - disp,</span><br><span class="line">		       maddr);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 检查mmap是否失败. */</span></span><br><span class="line">		<span class="keyword">if</span> (IS_ERR_VALUE(maddr))</span><br><span class="line">			<span class="keyword">return</span> (<span class="type">int</span>) maddr;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 如果是连续模式, 更新下一个段的期望加载地址. */</span></span><br><span class="line">		<span class="keyword">if</span> ((params-&gt;flags &amp; ELF_FDPIC_FLAG_ARRANGEMENT) ==</span><br><span class="line">		    ELF_FDPIC_FLAG_CONTIGUOUS)</span><br><span class="line">			load_addr += PAGE_ALIGN(phdr-&gt;p_memsz + disp);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 填充加载映射表(loadmap)的当前项.</span></span><br><span class="line"><span class="comment">		 * seg-&gt;addr 是段在内存中的真正起始地址 (maddr + disp).</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		seg-&gt;addr = maddr + disp;</span><br><span class="line">		seg-&gt;p_vaddr = phdr-&gt;p_vaddr;</span><br><span class="line">		seg-&gt;p_memsz = phdr-&gt;p_memsz;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 如果当前段包含了ELF头, 记录其在内存中的地址. */</span></span><br><span class="line">		<span class="keyword">if</span> (phdr-&gt;p_offset == <span class="number">0</span>)</span><br><span class="line">			params-&gt;elfhdr_addr = seg-&gt;addr;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 清理页内偏移(disp)产生的、在段内容开始之前的&quot;空隙&quot;.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (prot &amp; PROT_WRITE &amp;&amp; disp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			kdebug(<span class="string">&quot;clear[%d] ad=%lx sz=%lx&quot;</span>, loop, maddr, disp);</span><br><span class="line">			<span class="keyword">if</span> (clear_user((<span class="type">void</span> __user *) maddr, disp))</span><br><span class="line">				<span class="keyword">return</span> -EFAULT;</span><br><span class="line">			maddr += disp;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 清理 .bss 段 (内存大小 &gt; 文件大小的部分).</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		excess = phdr-&gt;p_memsz - phdr-&gt;p_filesz;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MMU</span></span><br><span class="line">		<span class="comment">/* 在有MMU的系统上, .bss段的处理比较复杂, 因为它可能跨越页,</span></span><br><span class="line"><span class="comment">		 * 并且需要为超出文件映射范围的部分创建匿名的、清零的内存页. */</span></span><br><span class="line">		<span class="comment">// ... (MMU特定处理逻辑)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		<span class="comment">/* 在无MMU系统上, 因为整个段都在一块连续的物理内存中, 处理很简单. */</span></span><br><span class="line">		<span class="keyword">if</span> (excess &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			kdebug(<span class="string">&quot;clear[%d] ad=%llx sz=%lx&quot;</span>, loop,</span><br><span class="line">			       (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) maddr + phdr-&gt;p_filesz,</span><br><span class="line">			       excess);</span><br><span class="line">			<span class="comment">/* 直接调用clear_user将这部分内存清零. */</span></span><br><span class="line">			<span class="keyword">if</span> (clear_user((<span class="type">void</span> *) maddr + phdr-&gt;p_filesz, excess))</span><br><span class="line">				<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 更新进程内存描述符中的代码段和数据段范围.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (mm) &#123;</span><br><span class="line">			<span class="keyword">if</span> (phdr-&gt;p_flags &amp; PF_X) &#123; <span class="comment">/* 可执行段是代码 */</span></span><br><span class="line">				<span class="keyword">if</span> (!mm-&gt;start_code) &#123;</span><br><span class="line">					mm-&gt;start_code = maddr;</span><br><span class="line">					mm-&gt;end_code = maddr + phdr-&gt;p_memsz;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123; <span class="comment">/* 否则是数据 */</span></span><br><span class="line">				<span class="keyword">if</span> (!mm-&gt;start_data) &#123;</span><br><span class="line">					mm-&gt;start_data = maddr;</span><br><span class="line">					mm-&gt;end_data = maddr + phdr-&gt;p_memsz;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 移动到加载映射表的下一个表项.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		seg++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 所有段都成功加载, 返回0.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="elf-fdpic-map-file-将FDPIC程序映射到内存"><a href="#elf-fdpic-map-file-将FDPIC程序映射到内存" class="headerlink" title="elf_fdpic_map_file: 将FDPIC程序映射到内存"></a>elf_fdpic_map_file: 将FDPIC程序映射到内存</h2><p>此函数的核心职责是：根据程序头表（<code>phdrs</code>）的指示，为所有需要加载的段（<code>PT_LOAD</code>）在物理内存中分配空间，并将文件中的相应内容复制进去。它会创建一个<strong>加载映射表（loadmap）</strong>，详细记录每个段被加载到了哪个物理地址，并将这个映射表提供给后续步骤和用户空间的动态链接器使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * load the appropriate binary image (executable or interpreter) into memory</span></span><br><span class="line"><span class="comment"> * 将合适二进制镜像(可执行文件或解释器)加载到内存中</span></span><br><span class="line"><span class="comment"> * - we assume no MMU is available</span></span><br><span class="line"><span class="comment"> *   我们假定没有MMU可用 (这是uClinux FDPIC加载器的核心思想)</span></span><br><span class="line"><span class="comment"> * - if no other PIC bits are set in params-&gt;hdr-&gt;e_flags</span></span><br><span class="line"><span class="comment"> *   - we assume that the LOADable segments in the binary are independently relocatable</span></span><br><span class="line"><span class="comment"> *     我们假定二进制文件中的可加载(LOADable)段是可独立重定位的</span></span><br><span class="line"><span class="comment"> *   - we assume R/O executable segments are shareable</span></span><br><span class="line"><span class="comment"> *     我们假定只读的可执行段是可共享的</span></span><br><span class="line"><span class="comment"> * - else</span></span><br><span class="line"><span class="comment"> *   - we assume the loadable parts of the image to require fixed displacement</span></span><br><span class="line"><span class="comment"> *     我们假定镜像的可加载部分需要固定的位移</span></span><br><span class="line"><span class="comment"> *   - the image is not shareable</span></span><br><span class="line"><span class="comment"> *     镜像是不可共享的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @params: 指向 elf_fdpic_params 结构体的指针, 包含了ELF文件的所有解析信息.</span></span><br><span class="line"><span class="comment"> * @file:   指向要加载的文件的 file 对象.</span></span><br><span class="line"><span class="comment"> * @mm:     指向当前进程的内存描述符 (mm_struct) 的指针.</span></span><br><span class="line"><span class="comment"> * @what:   一个描述性字符串 (&quot;executable&quot; 或 &quot;interpreter&quot;), 用于调试打印.</span></span><br><span class="line"><span class="comment"> * @return: 成功时返回0, 失败时返回负值的错误码.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">elf_fdpic_map_file</span><span class="params">(<span class="keyword">struct</span> elf_fdpic_params *params,</span></span><br><span class="line"><span class="params">			      <span class="keyword">struct</span> file *file,</span></span><br><span class="line"><span class="params">			      <span class="keyword">struct</span> mm_struct *mm,</span></span><br><span class="line"><span class="params">			      <span class="type">const</span> <span class="type">char</span> *what)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * loadmap: 指向将要创建的FDPIC加载映射表的指针.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">elf_fdpic_loadmap</span> *<span class="title">loadmap</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MMU</span></span><br><span class="line">	<span class="comment">/* 在有MMU的系统上, 这些变量用于内存段的合并优化. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">elf_fdpic_loadseg</span> *<span class="title">mseg</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> load_addr;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * seg:   用于遍历加载映射表中各个段的指针.</span></span><br><span class="line"><span class="comment">	 * phdr:  用于遍历程序头表的指针.</span></span><br><span class="line"><span class="comment">	 * nloads:记录文件中PT_LOAD段的总数.</span></span><br><span class="line"><span class="comment">	 * tmp:   一个临时变量.</span></span><br><span class="line"><span class="comment">	 * stop:  用于地址范围计算的临时变量.</span></span><br><span class="line"><span class="comment">	 * loop:  用于循环的计数器.</span></span><br><span class="line"><span class="comment">	 * ret:   用于存储函数调用的返回值.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">elf_fdpic_loadseg</span> *<span class="title">seg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">elf_phdr</span> *<span class="title">phdr</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> nloads, tmp;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> stop;</span><br><span class="line">	<span class="type">int</span> loop, ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 第一步: 统计文件中PT_LOAD段的数量, 以便为加载映射表分配大小刚好的内存.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	nloads = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">/* 遍历程序头表. */</span></span><br><span class="line">	<span class="keyword">for</span> (loop = <span class="number">0</span>; loop &lt; params-&gt;hdr.e_phnum; loop++)</span><br><span class="line">		<span class="comment">/* 如果一个程序头项的类型是PT_LOAD, 计数器加1. */</span></span><br><span class="line">		<span class="keyword">if</span> (params-&gt;phdrs[loop].p_type == PT_LOAD)</span><br><span class="line">			nloads++;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果一个可执行文件没有任何PT_LOAD段, 这是一个无效的文件. */</span></span><br><span class="line">	<span class="keyword">if</span> (nloads == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -ELIBBAD; <span class="comment">/* 返回库格式错误. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 使用 kzalloc 分配加载映射表(loadmap)所需的内存.</span></span><br><span class="line"><span class="comment">	 * struct_size 是一个宏, 用于计算一个包含柔性数组成员的结构体的总大小.</span></span><br><span class="line"><span class="comment">	 * 这里它计算 &#x27;struct elf_fdpic_loadmap&#x27; 头部加上 &#x27;nloads&#x27; 个 &#x27;elf_fdpic_loadseg&#x27; 元素所需的总字节数.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	loadmap = kzalloc(struct_size(loadmap, segs, nloads), GFP_KERNEL);</span><br><span class="line">	<span class="comment">/* 检查内存分配是否成功. */</span></span><br><span class="line">	<span class="keyword">if</span> (!loadmap)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 将新创建的loadmap与params关联起来. */</span></span><br><span class="line">	params-&gt;loadmap = loadmap;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化loadmap的版本号和段的数量. */</span></span><br><span class="line">	loadmap-&gt;version = ELF_FDPIC_LOADMAP_VERSION;</span><br><span class="line">	loadmap-&gt;nsegs = nloads;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 第二步: 根据FDPIC的排列方式标志, 调用不同的映射函数将文件段加载到内存.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">switch</span> (params-&gt;flags &amp; ELF_FDPIC_FLAG_ARRANGEMENT) &#123;</span><br><span class="line">	<span class="comment">/* 如果ELF文件要求其各段之间保持固定位移或需要连续加载. */</span></span><br><span class="line">	<span class="keyword">case</span> ELF_FDPIC_FLAG_CONSTDISP:</span><br><span class="line">	<span class="keyword">case</span> ELF_FDPIC_FLAG_CONTIGUOUS:</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 在无MMU的uClinux上, 这是最常见也是最关键的路径.</span></span><br><span class="line"><span class="comment">		 * 调用一个专门的函数, 它会一次性地分配一块足够大的连续物理内存,</span></span><br><span class="line"><span class="comment">		 * 然后根据程序头表, 将文件的各个段(代码、数据)精确地复制到这块大内存的不同偏移处.</span></span><br><span class="line"><span class="comment">		 * 这个函数是实现FDPIC数据段隔离的核心.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		ret = elf_fdpic_map_file_constdisp_on_uclinux(params, file, mm);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* 对于其他情况 (如段可独立重定位). */</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 调用另一个映射函数. 在无MMU系统上, 这通常意味着为每个段独立分配物理内存.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		ret = elf_fdpic_map_file_by_direct_mmap(params, file, mm);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 第三步: 在所有段都加载完毕后, 计算一些关键地址的最终物理位置.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/* 映射程序的入口点地址. */</span></span><br><span class="line">	<span class="keyword">if</span> (params-&gt;hdr.e_entry) &#123; <span class="comment">/* 如果ELF头中指定了入口点 */</span></span><br><span class="line">		seg = loadmap-&gt;segs; <span class="comment">/* 指针指向加载映射表的第一个段. */</span></span><br><span class="line">		<span class="comment">/* 遍历加载映射表中的所有段. */</span></span><br><span class="line">		<span class="keyword">for</span> (loop = loadmap-&gt;nsegs; loop &gt; <span class="number">0</span>; loop--, seg++) &#123;</span><br><span class="line">			<span class="comment">/* 检查入口点的虚拟地址(e_entry)是否落在当前段的虚拟地址范围内. */</span></span><br><span class="line">			<span class="keyword">if</span> (params-&gt;hdr.e_entry &gt;= seg-&gt;p_vaddr &amp;&amp;</span><br><span class="line">			    params-&gt;hdr.e_entry &lt; seg-&gt;p_vaddr + seg-&gt;p_memsz) &#123;</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * 如果找到了, 计算出入口点的最终物理地址.</span></span><br><span class="line"><span class="comment">				 * 公式: 物理地址 = (入口点虚拟地址 - 段虚拟基地址) + 段物理基地址.</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				params-&gt;entry_addr =</span><br><span class="line">					(params-&gt;hdr.e_entry - seg-&gt;p_vaddr) +</span><br><span class="line">					seg-&gt;addr;</span><br><span class="line">				<span class="keyword">break</span>; <span class="comment">/* 找到后即可退出循环. */</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 确定程序头表(如果它本身也被加载了)在内存中的位置.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	stop = params-&gt;hdr.e_phoff; <span class="comment">/* 计算程序头表在文件中的范围. */</span></span><br><span class="line">	stop += params-&gt;hdr.e_phnum * <span class="keyword">sizeof</span> (<span class="keyword">struct</span> elf_phdr);</span><br><span class="line">	phdr = params-&gt;phdrs; <span class="comment">/* 指针指向内核中缓存的程序头表. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 遍历程序头表. */</span></span><br><span class="line">	<span class="keyword">for</span> (loop = <span class="number">0</span>; loop &lt; params-&gt;hdr.e_phnum; loop++, phdr++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (phdr-&gt;p_type != PT_LOAD) <span class="comment">/* 我们只关心被加载的段. */</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 检查程序头表是否位于当前这个LOAD段所加载的文件范围内. */</span></span><br><span class="line">		<span class="keyword">if</span> (phdr-&gt;p_offset &gt; params-&gt;hdr.e_phoff ||</span><br><span class="line">		    phdr-&gt;p_offset + phdr-&gt;p_filesz &lt; stop)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 如果是, 遍历加载映射表找到这个LOAD段被加载到了哪里. */</span></span><br><span class="line">		seg = loadmap-&gt;segs;</span><br><span class="line">		<span class="keyword">for</span> (loop = loadmap-&gt;nsegs; loop &gt; <span class="number">0</span>; loop--, seg++) &#123;</span><br><span class="line">			<span class="comment">/* 通过虚拟地址进行匹配. */</span></span><br><span class="line">			<span class="keyword">if</span> (phdr-&gt;p_vaddr &gt;= seg-&gt;p_vaddr &amp;&amp;</span><br><span class="line">			    phdr-&gt;p_vaddr + phdr-&gt;p_filesz &lt;=</span><br><span class="line">			    seg-&gt;p_vaddr + seg-&gt;p_memsz) &#123;</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * 计算出程序头表在内存中的最终物理地址.</span></span><br><span class="line"><span class="comment">				 * 公式复杂一些, 因为要考虑文件内和内存内的多重偏移.</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				params-&gt;ph_addr =</span><br><span class="line">					(phdr-&gt;p_vaddr - seg-&gt;p_vaddr) +</span><br><span class="line">					seg-&gt;addr +</span><br><span class="line">					params-&gt;hdr.e_phoff - phdr-&gt;p_offset;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 确定动态链接段(PT_DYNAMIC)在内存中的位置.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	phdr = params-&gt;phdrs;</span><br><span class="line">	<span class="comment">/* 遍历程序头表, 寻找PT_DYNAMIC段. */</span></span><br><span class="line">	<span class="keyword">for</span> (loop = <span class="number">0</span>; loop &lt; params-&gt;hdr.e_phnum; loop++, phdr++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (phdr-&gt;p_type != PT_DYNAMIC)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 遍历加载映射表, 找到PT_DYNAMIC段所在的LOAD段的加载信息. */</span></span><br><span class="line">		seg = loadmap-&gt;segs;</span><br><span class="line">		<span class="keyword">for</span> (loop = loadmap-&gt;nsegs; loop &gt; <span class="number">0</span>; loop--, seg++) &#123;</span><br><span class="line">			<span class="comment">/* 通过虚拟地址进行匹配. */</span></span><br><span class="line">			<span class="keyword">if</span> (phdr-&gt;p_vaddr &gt;= seg-&gt;p_vaddr &amp;&amp;</span><br><span class="line">			    phdr-&gt;p_vaddr + phdr-&gt;p_memsz &lt;=</span><br><span class="line">			    seg-&gt;p_vaddr + seg-&gt;p_memsz) &#123;</span><br><span class="line">				Elf_Dyn __user *dyn;</span><br><span class="line">				Elf_Sword d_tag;</span><br><span class="line"></span><br><span class="line">				<span class="comment">/* 计算出PT_DYNAMIC段在内存中的最终物理地址. */</span></span><br><span class="line">				params-&gt;dynamic_addr =</span><br><span class="line">					(phdr-&gt;p_vaddr - seg-&gt;p_vaddr) +</span><br><span class="line">					seg-&gt;addr;</span><br><span class="line"></span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * 对动态段进行一个简单的完整性检查.</span></span><br><span class="line"><span class="comment">				 * 确保它的大小不为0, 且是Elf_Dyn结构体大小的整数倍.</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				<span class="keyword">if</span> (phdr-&gt;p_memsz == <span class="number">0</span> ||</span><br><span class="line">				    phdr-&gt;p_memsz % <span class="keyword">sizeof</span>(Elf_Dyn) != <span class="number">0</span>)</span><br><span class="line">					<span class="keyword">goto</span> dynamic_error;</span><br><span class="line"></span><br><span class="line">				<span class="comment">/* 检查动态段的最后一项是否是DT_NULL(d_tag为0), 这是规范要求. */</span></span><br><span class="line">				tmp = phdr-&gt;p_memsz / <span class="keyword">sizeof</span>(Elf_Dyn);</span><br><span class="line">				dyn = (Elf_Dyn __user *)params-&gt;dynamic_addr;</span><br><span class="line">				<span class="keyword">if</span> (get_user(d_tag, &amp;dyn[tmp - <span class="number">1</span>].d_tag) ||</span><br><span class="line">				    d_tag != <span class="number">0</span>)</span><br><span class="line">					<span class="keyword">goto</span> dynamic_error;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 在有MMU的Linux上, 可以对加载映射表进行优化, 将物理上相邻的段合并成一个.</span></span><br><span class="line"><span class="comment">	 * 在无MMU的uClinux上, 因为段之间的空隙可能被其他进程或系统占用, 所以不能进行这种合并.</span></span><br><span class="line"><span class="comment">	 * 因此这部分代码被 #ifdef CONFIG_MMU 包围, 在STM32H750的no-MMU配置下不会被编译.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MMU</span></span><br><span class="line">	<span class="comment">// ... (合并逻辑)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 第四步: 打印调试信息, 显示所有映射结果.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	kdebug(<span class="string">&quot;Mapped Object [%s]:&quot;</span>, what);</span><br><span class="line">	kdebug(<span class="string">&quot;- elfhdr   : %lx&quot;</span>, params-&gt;elfhdr_addr);</span><br><span class="line">	kdebug(<span class="string">&quot;- entry    : %lx&quot;</span>, params-&gt;entry_addr);</span><br><span class="line">	kdebug(<span class="string">&quot;- PHDR[]   : %lx&quot;</span>, params-&gt;ph_addr);</span><br><span class="line">	kdebug(<span class="string">&quot;- DYNAMIC[]: %lx&quot;</span>, params-&gt;dynamic_addr);</span><br><span class="line">	seg = loadmap-&gt;segs;</span><br><span class="line">	<span class="keyword">for</span> (loop = <span class="number">0</span>; loop &lt; loadmap-&gt;nsegs; loop++, seg++)</span><br><span class="line">		kdebug(<span class="string">&quot;- LOAD[%d] : %08llx-%08llx [va=%llx ms=%llx]&quot;</span>,</span><br><span class="line">		       loop,</span><br><span class="line">		       (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) seg-&gt;addr,</span><br><span class="line">		       (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) seg-&gt;addr + seg-&gt;p_memsz - <span class="number">1</span>,</span><br><span class="line">		       (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) seg-&gt;p_vaddr,</span><br><span class="line">		       (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) seg-&gt;p_memsz);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 所有操作成功, 返回0. */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">dynamic_error: <span class="comment">/* 动态段错误处理标签. */</span></span><br><span class="line">	<span class="comment">/* 打印一条详细的错误信息, 指出哪个文件以及哪个inode出了问题. */</span></span><br><span class="line">	printk(<span class="string">&quot;ELF FDPIC %s with invalid DYNAMIC section (inode=%lu)\n&quot;</span>,</span><br><span class="line">	       what, file_inode(file)-&gt;i_ino);</span><br><span class="line">	<span class="comment">/* 返回库格式错误. */</span></span><br><span class="line">	<span class="keyword">return</span> -ELIBBAD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="create-elf-fdpic-tables-在新进程的栈上创建初始信息表"><a href="#create-elf-fdpic-tables-在新进程的栈上创建初始信息表" class="headerlink" title="create_elf_fdpic_tables: 在新进程的栈上创建初始信息表"></a>create_elf_fdpic_tables: 在新进程的栈上创建初始信息表</h2><p>此函数的主要职责是将<code>execve</code>系统调用传递进来的参数（<code>argv</code>）、环境变量（<code>envp</code>）以及内核需要告知用户空间动态链接器的一些关键信息（辅助向量），<strong>从内核空间复制并排列到新进程的用户空间栈上</strong>。这个过程必须精确无误，因为动态链接器和C库的启动代码将依赖这个布局来初始化程序。</p>
<ol>
<li><strong>确定栈顶</strong>: <code>sp = mm-&gt;start_stack;</code>。在无MMU系统上，<code>start_stack</code>就是物理内存块的最高地址。</li>
<li><strong>传递参数&#x2F;环境</strong>: <code>transfer_args_to_stack()</code>这个函数（在此代码片段中未显示，但逻辑相似）会把之前准备好的<code>argv</code>和<code>envp</code>字符串从内核的临时缓冲区复制到这个新栈的较高地址处。</li>
<li><strong>压入FDPIC加载映射表</strong>: 这是FDPIC机制的核心。它将<code>exec_params-&gt;loadmap</code>（以及解释器的<code>interp_params-&gt;loadmap</code>）这个描述了“哪个段被加载到了哪个物理地址”的<strong>映射表</strong>，完整地复制到栈上。</li>
<li><strong>构建辅助向量 (Auxiliary Vector)</strong>: 这是最关键的部分。辅助向量是一个由<code>{类型, 值}</code>键值对组成的列表，它在栈上传递了内核与用户空间动态链接器之间的“秘密情报”。<ul>
<li><strong><code>NEW_AUX_ENT(AT_FDPIC_LOADMAP, ...)</code> (此函数中没有直接出现，但由<code>AT_BASE</code>等间接实现)</strong>: 这条信息会把刚刚压入栈的<strong>加载映射表的地址</strong>告知动态链接器。链接器收到后，就会去这个地址读取映射表，从而知道代码段和数据段的真实物理位置。</li>
<li><strong><code>NEW_AUX_ENT(AT_ENTRY, exec_params-&gt;entry_addr)</code></strong>: 告知链接器，原始可执行文件的入口点在哪里。</li>
<li><strong><code>NEW_AUX_ENT(AT_PHDR, exec_params-&gt;ph_addr)</code></strong>: 告知链接器，程序头表被加载到了哪里。</li>
<li>其他如<code>AT_PAGESZ</code>（页大小）、<code>AT_UID</code>（用户ID）等提供了必要的系统信息。</li>
</ul>
</li>
<li><strong>构建<code>argv</code>和<code>envp</code>指针数组</strong>: 在栈的更低地址处，它会创建两个指针数组。<code>argv</code>数组的每个元素指向栈上对应参数字符串的起始地址。<code>envp</code>数组也一样。这两个数组都以一个<code>NULL</code>指针结尾。</li>
<li><strong>压入<code>argc</code></strong>: 最后，在栈的最底部（最低地址处），压入参数的个数<code>argc</code>。</li>
</ol>
<p>当所有这些都完成后，新进程的用户空间栈就完全准备好了。<code>start_thread</code>函数会将CPU的栈指针（SP）设置为<code>sp</code>的最终值。当动态链接器开始执行时，它会从这个栈指针开始，按照ABI规范，准确地找到<code>argc</code>、<code>argv</code>、<code>envp</code>和至关重要的辅助向量，从而完成最后的符号重定位和程序初始化，最终跳转到<code>main</code>函数。</p>
<hr>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * create_elf_fdpic_tables: present useful information to the program by</span></span><br><span class="line"><span class="comment"> * shovelling it onto the new process&#x27;s stack</span></span><br><span class="line"><span class="comment"> * 通过将有用的信息“铲到”新进程的栈上, 来呈现给程序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @bprm:          指向 linux_binprm 结构体的指针, 包含了argv/envp等信息.</span></span><br><span class="line"><span class="comment"> * @mm:            指向新进程的内存描述符.</span></span><br><span class="line"><span class="comment"> * @exec_params:   主可执行文件的FDPIC参数.</span></span><br><span class="line"><span class="comment"> * @interp_params: 解释器(动态链接器)的FDPIC参数.</span></span><br><span class="line"><span class="comment"> * @return:        成功时返回0, 失败时返回负值的错误码.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">create_elf_fdpic_tables</span><span class="params">(<span class="keyword">struct</span> linux_binprm *bprm,</span></span><br><span class="line"><span class="params">				   <span class="keyword">struct</span> mm_struct *mm,</span></span><br><span class="line"><span class="params">				   <span class="keyword">struct</span> elf_fdpic_params *exec_params,</span></span><br><span class="line"><span class="params">				   <span class="keyword">struct</span> elf_fdpic_params *interp_params)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * cred: 指向当前进程的凭证结构体.</span></span><br><span class="line"><span class="comment">	 * sp:   栈指针(Stack Pointer), 它将从栈顶(高地址)向下移动.</span></span><br><span class="line"><span class="comment">	 * csp:  一个临时的栈指针, 用于计算.</span></span><br><span class="line"><span class="comment">	 * nitems: 辅助向量(auxv)中的项目总数.</span></span><br><span class="line"><span class="comment">	 * argv, envp: 指向用户空间中argv和envp数组的指针.</span></span><br><span class="line"><span class="comment">	 * ...其他变量用于字符串和长度计算.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">cred</span> =</span> current_cred();</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> sp, csp, nitems;</span><br><span class="line">	<span class="type">elf_caddr_t</span> __user *argv, *envp;</span><br><span class="line">	<span class="type">size_t</span> platform_len = <span class="number">0</span>, len;</span><br><span class="line">	<span class="type">char</span> *k_platform, *k_base_platform;</span><br><span class="line">	<span class="type">char</span> __user *u_platform, *u_base_platform, *p;</span><br><span class="line">	<span class="type">int</span> loop;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> ei_index;</span><br><span class="line">	<span class="type">elf_addr_t</span> *elf_info;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MMU</span></span><br><span class="line">	<span class="comment">/* 在有MMU的系统上, 栈指针需要进行架构特定的对齐. */</span></span><br><span class="line">	sp = arch_align_stack(bprm-&gt;p);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="comment">/* 在无MMU系统上, 栈指针直接从内存描述符中记录的栈顶开始. */</span></span><br><span class="line">	sp = mm-&gt;start_stack;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 将参数和环境变量的字符串本身从内核临时缓冲区复制到新栈的顶部.</span></span><br><span class="line"><span class="comment">	 * transfer_args_to_stack会更新sp的值.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (transfer_args_to_stack(bprm, &amp;sp) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	<span class="comment">/* 确保栈指针是16字节对齐的, 这是许多ABI的要求. */</span></span><br><span class="line">	sp &amp;= ~<span class="number">15</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 将平台标识字符串(如&quot;armv7l&quot;)复制到栈上.</span></span><br><span class="line"><span class="comment">	 * 这允许程序知道自己正在什么平台上运行.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	k_platform = ELF_PLATFORM;</span><br><span class="line">	u_platform = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (k_platform) &#123;</span><br><span class="line">		platform_len = <span class="built_in">strlen</span>(k_platform) + <span class="number">1</span>;</span><br><span class="line">		sp -= platform_len; <span class="comment">/* 栈向下增长, &quot;分配&quot;空间. */</span></span><br><span class="line">		u_platform = (<span class="type">char</span> __user *) sp;</span><br><span class="line">		<span class="comment">/* 将内核空间的字符串复制到用户空间的栈上. */</span></span><br><span class="line">		<span class="keyword">if</span> (copy_to_user(u_platform, k_platform, platform_len) != <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 复制&quot;基础&quot;平台字符串 (如果存在).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	k_base_platform = ELF_BASE_PLATFORM;</span><br><span class="line">	u_base_platform = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (k_base_platform) &#123;</span><br><span class="line">		platform_len = <span class="built_in">strlen</span>(k_base_platform) + <span class="number">1</span>;</span><br><span class="line">		sp -= platform_len;</span><br><span class="line">		u_base_platform = (<span class="type">char</span> __user *) sp;</span><br><span class="line">		<span class="keyword">if</span> (copy_to_user(u_base_platform, k_base_platform, platform_len) != <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 确保栈指针是8字节对齐的. */</span></span><br><span class="line">	sp &amp;= ~<span class="number">7UL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 将FDPIC加载映射表(loadmap)复制到栈上. 这是FDPIC的关键步骤.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/* 计算主可执行文件的loadmap大小. */</span></span><br><span class="line">	len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> elf_fdpic_loadmap);</span><br><span class="line">	len += <span class="keyword">sizeof</span>(<span class="keyword">struct</span> elf_fdpic_loadseg) * exec_params-&gt;loadmap-&gt;nsegs;</span><br><span class="line">	sp = (sp - len) &amp; ~<span class="number">7UL</span>; <span class="comment">/* 向下分配空间并对齐. */</span></span><br><span class="line">	exec_params-&gt;map_addr = sp; <span class="comment">/* 记录下loadmap在栈上的最终地址. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 将内核中的loadmap复制到用户空间的栈上. */</span></span><br><span class="line">	<span class="keyword">if</span> (copy_to_user((<span class="type">void</span> __user *) sp, exec_params-&gt;loadmap, len) != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 在进程上下文中记录下这个地址. */</span></span><br><span class="line">	current-&gt;mm-&gt;context.exec_fdpic_loadmap = (<span class="type">unsigned</span> <span class="type">long</span>) sp;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果存在解释器(动态链接器), 也将其loadmap复制到栈上. */</span></span><br><span class="line">	<span class="keyword">if</span> (interp_params-&gt;loadmap) &#123;</span><br><span class="line">		len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> elf_fdpic_loadmap);</span><br><span class="line">		len += <span class="keyword">sizeof</span>(<span class="keyword">struct</span> elf_fdpic_loadseg) *</span><br><span class="line">			interp_params-&gt;loadmap-&gt;nsegs;</span><br><span class="line">		sp = (sp - len) &amp; ~<span class="number">7UL</span>;</span><br><span class="line">		interp_params-&gt;map_addr = sp;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (copy_to_user((<span class="type">void</span> __user *) sp, interp_params-&gt;loadmap,</span><br><span class="line">				 len) != <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">		current-&gt;mm-&gt;context.interp_fdpic_loadmap = (<span class="type">unsigned</span> <span class="type">long</span>) sp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 在栈上为辅助向量(auxv), argv指针数组, envp指针数组和argc分配空间.</span></span><br><span class="line"><span class="comment">	 * 这个计算是反向的, 先计算总共需要多少项.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DLINFO_ITEMS 15 <span class="comment">/* 一个预估的基本辅助向量项目数 */</span></span></span><br><span class="line"></span><br><span class="line">	nitems = <span class="number">1</span> + DLINFO_ITEMS + (k_platform ? <span class="number">1</span> : <span class="number">0</span>) +</span><br><span class="line">		(k_base_platform ? <span class="number">1</span> : <span class="number">0</span>) + AT_VECTOR_SIZE_ARCH;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bprm-&gt;have_execfd)</span><br><span class="line">		nitems++;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ELF_HWCAP2</span></span><br><span class="line">	nitems++;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	csp = sp; <span class="comment">/* 临时保存当前栈顶. */</span></span><br><span class="line">	sp -= nitems * <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>);		<span class="comment">/* 为辅助向量分配空间 (每项包含类型和值, 都是unsigned long). */</span></span><br><span class="line">	sp -= (bprm-&gt;envc + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="type">char</span> *);		<span class="comment">/* 为envp指针数组分配空间 (加1是为了结尾的NULL). */</span></span><br><span class="line">	sp -= (bprm-&gt;argc + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="type">char</span> *);		<span class="comment">/* 为argv指针数组分配空间 (加1是为了结尾的NULL). */</span></span><br><span class="line">	sp -= <span class="number">1</span> * <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>);				<span class="comment">/* 为argc分配空间. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 进行最终的16字节对齐. */</span></span><br><span class="line">	csp -= sp &amp; <span class="number">15UL</span>;</span><br><span class="line">	sp -= sp &amp; <span class="number">15UL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 在内核的一个临时缓冲区(mm-&gt;saved_auxv)中创建辅助向量.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	elf_info = (<span class="type">elf_addr_t</span> *)mm-&gt;saved_auxv;</span><br><span class="line">	<span class="comment">/* 一个用于方便地添加辅助向量项的宏. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEW_AUX_ENT(id, val) \</span></span><br><span class="line"><span class="meta">	do &#123; \</span></span><br><span class="line"><span class="meta">		*elf_info++ = id; \</span></span><br><span class="line"><span class="meta">		*elf_info++ = val; \</span></span><br><span class="line"><span class="meta">	&#125; while (0)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 添加架构特定的辅助向量项. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ARCH_DLINFO</span></span><br><span class="line">	ARCH_DLINFO;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* 添加硬件能力(HWCAP), 页面大小(PAGESZ), 时钟频率(CLKTCK)等标准信息. */</span></span><br><span class="line">	NEW_AUX_ENT(AT_HWCAP,	ELF_HWCAP);</span><br><span class="line">	NEW_AUX_ENT(AT_PAGESZ,	PAGE_SIZE);</span><br><span class="line">	NEW_AUX_ENT(AT_CLKTCK,	CLOCKS_PER_SEC);</span><br><span class="line">	<span class="comment">/* 添加ELF程序头表的信息: 地址, 每项大小, 项数. */</span></span><br><span class="line">	NEW_AUX_ENT(AT_PHDR,	exec_params-&gt;ph_addr);</span><br><span class="line">	NEW_AUX_ENT(AT_PHENT,	<span class="keyword">sizeof</span>(<span class="keyword">struct</span> elf_phdr));</span><br><span class="line">	NEW_AUX_ENT(AT_PHNUM,	exec_params-&gt;hdr.e_phnum);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 添加动态链接器的基地址. 动态链接器看到AT_BASE, 就知道自己被加载到了哪里.</span></span><br><span class="line"><span class="comment">	 * 对于FDPIC, 真正的基地址信息在loadmap里, 但这里通常会提供解释器的加载基地址.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	NEW_AUX_ENT(AT_BASE,	interp_params-&gt;elfhdr_addr);</span><br><span class="line">	<span class="keyword">if</span> (bprm-&gt;interp_flags &amp; BINPRM_FLAGS_PRESERVE_ARGV0)</span><br><span class="line">		flags |= AT_FLAGS_PRESERVE_ARGV0;</span><br><span class="line">	NEW_AUX_ENT(AT_FLAGS,	flags);</span><br><span class="line">	<span class="comment">/* 添加主可执行文件的入口点地址. */</span></span><br><span class="line">	NEW_AUX_ENT(AT_ENTRY,	exec_params-&gt;entry_addr);</span><br><span class="line">	<span class="comment">/* 添加真实的和有效的用户/组ID. */</span></span><br><span class="line">	NEW_AUX_ENT(AT_UID,	(<span class="type">elf_addr_t</span>) from_kuid_munged(cred-&gt;user_ns, cred-&gt;uid));</span><br><span class="line">	NEW_AUX_ENT(AT_EUID,	(<span class="type">elf_addr_t</span>) from_kuid_munged(cred-&gt;user_ns, cred-&gt;euid));</span><br><span class="line">	NEW_AUX_ENT(AT_GID,	(<span class="type">elf_addr_t</span>) from_kgid_munged(cred-&gt;user_ns, cred-&gt;gid));</span><br><span class="line">	NEW_AUX_ENT(AT_EGID,	(<span class="type">elf_addr_t</span>) from_kgid_munged(cred-&gt;user_ns, cred-&gt;egid));</span><br><span class="line">	<span class="comment">/* 添加安全执行标志(AT_SECURE). */</span></span><br><span class="line">	NEW_AUX_ENT(AT_SECURE,	bprm-&gt;secureexec);</span><br><span class="line">	<span class="comment">/* 添加可执行文件的路径名. */</span></span><br><span class="line">	NEW_AUX_ENT(AT_EXECFN,	bprm-&gt;exec);</span><br><span class="line">	<span class="comment">/* 如果有平台字符串, 添加其在栈上的地址. */</span></span><br><span class="line">	<span class="keyword">if</span> (k_platform)</span><br><span class="line">		NEW_AUX_ENT(AT_PLATFORM,</span><br><span class="line">			    (<span class="type">elf_addr_t</span>)(<span class="type">unsigned</span> <span class="type">long</span>)u_platform);</span><br><span class="line">	<span class="keyword">if</span> (k_base_platform)</span><br><span class="line">		NEW_AUX_ENT(AT_BASE_PLATFORM,</span><br><span class="line">			    (<span class="type">elf_addr_t</span>)(<span class="type">unsigned</span> <span class="type">long</span>)u_base_platform);</span><br><span class="line">	<span class="comment">/* 如果有execfd, 添加它. */</span></span><br><span class="line">	<span class="keyword">if</span> (bprm-&gt;have_execfd)</span><br><span class="line">		NEW_AUX_ENT(AT_EXECFD, bprm-&gt;execfd);</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> NEW_AUX_ENT</span></span><br><span class="line">	<span class="comment">/* 用0填充剩余的缓冲区, 最后的0对 &#123;0, 0&#125; 就是 AT_NULL, 表示辅助向量结束. */</span></span><br><span class="line">	<span class="built_in">memset</span>(elf_info, <span class="number">0</span>, (<span class="type">char</span> *)mm-&gt;saved_auxv +</span><br><span class="line">	       <span class="keyword">sizeof</span>(mm-&gt;saved_auxv) - (<span class="type">char</span> *)elf_info);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 将在内核缓冲区中准备好的辅助向量, 整体复制到用户空间的栈上.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ei_index = elf_info - (<span class="type">elf_addr_t</span> *)mm-&gt;saved_auxv;</span><br><span class="line">	csp -= ei_index * <span class="keyword">sizeof</span>(<span class="type">elf_addr_t</span>);</span><br><span class="line">	<span class="keyword">if</span> (copy_to_user((<span class="type">void</span> __user *)csp, mm-&gt;saved_auxv,</span><br><span class="line">			 ei_index * <span class="keyword">sizeof</span>(<span class="type">elf_addr_t</span>)))</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 计算出用户空间中argv和envp指针数组的位置.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	csp -= (bprm-&gt;envc + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="type">elf_caddr_t</span>);</span><br><span class="line">	envp = (<span class="type">elf_caddr_t</span> __user *) csp;</span><br><span class="line">	csp -= (bprm-&gt;argc + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="type">elf_caddr_t</span>);</span><br><span class="line">	argv = (<span class="type">elf_caddr_t</span> __user *) csp;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 在栈上写入argc的值.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	csp -= <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">	<span class="keyword">if</span> (put_user(bprm-&gt;argc, (<span class="type">unsigned</span> <span class="type">long</span> __user *) csp))</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 这是一个断言, 确保我们对栈空间的计算是精确的. */</span></span><br><span class="line">	BUG_ON(csp != sp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 填充argv和envp指针数组.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/* 获取参数字符串区域在用户空间的起始地址. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MMU</span></span><br><span class="line">	current-&gt;mm-&gt;arg_start = bprm-&gt;p;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="comment">/* 在无MMU系统上, 需要从栈顶反向计算. */</span></span><br><span class="line">	current-&gt;mm-&gt;arg_start = current-&gt;mm-&gt;start_stack -</span><br><span class="line">		(MAX_ARG_PAGES * PAGE_SIZE - bprm-&gt;p);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	p = (<span class="type">char</span> __user *) current-&gt;mm-&gt;arg_start;</span><br><span class="line">	<span class="comment">/* 遍历所有参数. */</span></span><br><span class="line">	<span class="keyword">for</span> (loop = bprm-&gt;argc; loop &gt; <span class="number">0</span>; loop--) &#123;</span><br><span class="line">		<span class="comment">/* 将当前参数字符串的地址写入argv数组的当前项. */</span></span><br><span class="line">		<span class="keyword">if</span> (put_user((<span class="type">elf_caddr_t</span>) p, argv++))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		<span class="comment">/* 获取字符串长度, 并将p指针移动到下一个字符串的开头. */</span></span><br><span class="line">		len = strnlen_user(p, MAX_ARG_STRLEN);</span><br><span class="line">		<span class="keyword">if</span> (!len || len &gt; MAX_ARG_STRLEN)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		p += len;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 写入argv数组结尾的NULL. */</span></span><br><span class="line">	<span class="keyword">if</span> (put_user(<span class="literal">NULL</span>, argv))</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	current-&gt;mm-&gt;arg_end = (<span class="type">unsigned</span> <span class="type">long</span>) p;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 用同样的方式填充envp数组. */</span></span><br><span class="line">	current-&gt;mm-&gt;env_start = (<span class="type">unsigned</span> <span class="type">long</span>) p;</span><br><span class="line">	<span class="keyword">for</span> (loop = bprm-&gt;envc; loop &gt; <span class="number">0</span>; loop--) &#123;</span><br><span class="line">		<span class="keyword">if</span> (put_user((<span class="type">elf_caddr_t</span>)(<span class="type">unsigned</span> <span class="type">long</span>) p, envp++))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		len = strnlen_user(p, MAX_ARG_STRLEN);</span><br><span class="line">		<span class="keyword">if</span> (!len || len &gt; MAX_ARG_STRLEN)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		p += len;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (put_user(<span class="literal">NULL</span>, envp))</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	current-&gt;mm-&gt;env_end = (<span class="type">unsigned</span> <span class="type">long</span>) p;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 最后, 更新内存描述符中的栈顶指针为我们计算出的最终值.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	mm-&gt;start_stack = (<span class="type">unsigned</span> <span class="type">long</span>) sp;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="load-elf-fdpic-binary-加载FDPIC-ELF可执行文件"><a href="#load-elf-fdpic-binary-加载FDPIC-ELF可执行文件" class="headerlink" title="load_elf_fdpic_binary: 加载FDPIC ELF可执行文件"></a>load_elf_fdpic_binary: 加载FDPIC ELF可执行文件</h2><p>此函数是 <code>binfmt_elf_fdpic</code> 模块的心脏。当 <code>execve</code> 系统调用发现一个文件是FDPIC ELF格式时，就会调用此函数。它的职责是：读取ELF文件的元数据，解析程序头，加载代码段和数据段到内存，设置新进程的内存布局（特别是栈和堆），准备好CPU寄存器，并最终启动新程序的执行。</p>
<ol>
<li>验证和解析</li>
<li>处理动态链接器 (Interpreter)</li>
<li>核心：加载和映射文件 (FDPIC的关键)</li>
<li>创建栈和堆 (no-MMU的特殊处理)</li>
<li>最后的准备与启动</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * load an fdpic binary into various bits of memory</span></span><br><span class="line"><span class="comment"> * 将一个FDPIC二进制文件加载到内存的各个部分</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @bprm: 指向 linux_binprm 结构体的指针, 它包含了要执行的文件的所有上下文信息.</span></span><br><span class="line"><span class="comment"> * @return: 成功时返回0, 失败时返回负值的错误码.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">load_elf_fdpic_binary</span><span class="params">(<span class="keyword">struct</span> linux_binprm *bprm)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * exec_params: 用于存储可执行文件本身的ELF参数 (如头部信息, 加载映射表等).</span></span><br><span class="line"><span class="comment">	 * interp_params: 用于存储其动态链接器(解释器)的ELF参数.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">elf_fdpic_params</span> <span class="title">exec_params</span>, <span class="title">interp_params</span>;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * regs: 指向当前进程的内核栈上保存的寄存器集合. 我们将修改它来启动新程序.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> *<span class="title">regs</span> =</span> current_pt_regs();</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * phdr: 用于遍历程序头表的指针.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">elf_phdr</span> *<span class="title">phdr</span>;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * stack_size: 新进程栈的大小.</span></span><br><span class="line"><span class="comment">	 * entryaddr: 新程序(或其解释器)的入口点地址.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> stack_size, entryaddr;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ELF_FDPIC_PLAT_INIT</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * dynaddr: 指向动态链接段的地址, 用于特定平台的初始化.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> dynaddr;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * stack_prot: 在无MMU系统上, 用于设置栈区域的保护标志 (读/写/执行).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> stack_prot;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * interpreter: 指向动态链接器文件的 &#x27;struct file&#x27; 对象.</span></span><br><span class="line"><span class="comment">	 * interpreter_name: 指向从文件中读出的动态链接器路径名字符串.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">interpreter</span> =</span> <span class="literal">NULL</span>; </span><br><span class="line">	<span class="type">char</span> *interpreter_name = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * executable_stack: 记录请求的栈是否需要可执行权限.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> executable_stack;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * retval: 用于存储函数调用的返回值.</span></span><br><span class="line"><span class="comment">	 * i: 用于循环的计数器.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> retval, i;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * pos: 用于在文件中定位的偏移量.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">loff_t</span> pos;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * kdebug: 内核调试打印宏, 打印当前进程的PID.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	kdebug(<span class="string">&quot;____ LOAD %d ____&quot;</span>, current-&gt;pid);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 使用 memset 将两个参数结构体清零, 确保没有垃圾数据.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;exec_params, <span class="number">0</span>, <span class="keyword">sizeof</span>(exec_params));</span><br><span class="line">	<span class="built_in">memset</span>(&amp;interp_params, <span class="number">0</span>, <span class="keyword">sizeof</span>(interp_params));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 将 bprm-&gt;buf (文件的前128字节) 中的内容强制转换为 elfhdr 结构体, 并复制到 exec_params.hdr.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	exec_params.hdr = *(<span class="keyword">struct</span> elfhdr *) bprm-&gt;buf;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 为可执行文件设置标志, 表示它存在且是一个可执行文件.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	exec_params.flags = ELF_FDPIC_FLAG_PRESENT | ELF_FDPIC_FLAG_EXECUTABLE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 检查这是否是一个我们能处理的二进制文件.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	retval = -ENOEXEC; <span class="comment">/* 默认返回码: 不支持的执行格式 */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 调用 is_elf 检查文件幻数等, 确认它是一个ELF文件.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!is_elf(&amp;exec_params.hdr, bprm-&gt;file))</span><br><span class="line">		<span class="keyword">goto</span> error; <span class="comment">/* 如果不是, 跳转到错误处理. */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 调用 elf_check_fdpic 检查ELF头部是否表明这是一个FDPIC兼容的文件.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!elf_check_fdpic(&amp;exec_params.hdr)) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MMU</span></span><br><span class="line">		<span class="comment">/* 在有MMU的系统上, 普通的ELF文件由 binfmt_elf 处理, 所以我们直接退出. */</span></span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		<span class="comment">/* 在无MMU系统上, 我们只接受 ET_DYN 类型的ELF文件(即位置无关可执行文件 PIE). */</span></span><br><span class="line">		<span class="keyword">if</span> (exec_params.hdr.e_type != ET_DYN)</span><br><span class="line">			<span class="keyword">goto</span> error; <span class="comment">/* 如果不是, 跳转到错误处理. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 读取程序头表(Program Header Table).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	retval = elf_fdpic_fetch_phdrs(&amp;exec_params, bprm-&gt;file);</span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>) <span class="comment">/* 如果读取失败, 跳转到错误处理. */</span></span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 扫描程序头表, 寻找一个指定了动态链接器(解释器)的段.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	phdr = exec_params.phdrs; <span class="comment">/* 指针指向程序头表的开始. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 遍历所有的程序头表项.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; exec_params.hdr.e_phnum; i++, phdr++) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 根据程序头项的类型(p_type)进行处理.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">switch</span> (phdr-&gt;p_type) &#123;</span><br><span class="line">		<span class="keyword">case</span> PT_INTERP: <span class="comment">/* 如果这是一个解释器段 */</span></span><br><span class="line">			retval = -ENOMEM; <span class="comment">/* 预设错误码: 内存不足 */</span></span><br><span class="line">			<span class="comment">/* 检查解释器路径名是否过长. */</span></span><br><span class="line">			<span class="keyword">if</span> (phdr-&gt;p_filesz &gt; PATH_MAX)</span><br><span class="line">				<span class="keyword">goto</span> error;</span><br><span class="line">			retval = -ENOENT; <span class="comment">/* 预设错误码: 文件不存在 */</span></span><br><span class="line">			<span class="comment">/* 检查路径名长度是否有效. */</span></span><br><span class="line">			<span class="keyword">if</span> (phdr-&gt;p_filesz &lt; <span class="number">2</span>)</span><br><span class="line">				<span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 分配内核内存以存储解释器的路径名. */</span></span><br><span class="line">			interpreter_name = kmalloc(phdr-&gt;p_filesz, GFP_KERNEL);</span><br><span class="line">			<span class="keyword">if</span> (!interpreter_name) <span class="comment">/* 如果分配失败... */</span></span><br><span class="line">				<span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 设置文件读取的起始偏移量. */</span></span><br><span class="line">			pos = phdr-&gt;p_offset;</span><br><span class="line">			<span class="comment">/* 从可执行文件中读取解释器的路径名到分配的内存中. */</span></span><br><span class="line">			retval = kernel_read(bprm-&gt;file, interpreter_name,</span><br><span class="line">					     phdr-&gt;p_filesz, &amp;pos);</span><br><span class="line">			<span class="comment">/* 检查读取的字节数是否与期望的完全一致. */</span></span><br><span class="line">			<span class="keyword">if</span> (unlikely(retval != phdr-&gt;p_filesz)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (retval &gt;= <span class="number">0</span>) <span class="comment">/* 如果读取成功但字节数不对, 这是个无效格式. */</span></span><br><span class="line">					retval = -ENOEXEC;</span><br><span class="line">				<span class="keyword">goto</span> error;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			retval = -ENOENT; <span class="comment">/* 预设错误码: 文件不存在 */</span></span><br><span class="line">			<span class="comment">/* 检查读出的路径名是否以空字符&#x27;\0&#x27;结尾. */</span></span><br><span class="line">			<span class="keyword">if</span> (interpreter_name[phdr-&gt;p_filesz - <span class="number">1</span>] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">				<span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 内核调试打印: 显示找到的ELF解释器名称. */</span></span><br><span class="line">			kdebug(<span class="string">&quot;Using ELF interpreter %s&quot;</span>, interpreter_name);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 用解释器替换掉当前要执行的程序. */</span></span><br><span class="line">			interpreter = open_exec(interpreter_name);</span><br><span class="line">			<span class="comment">/* 检查 open_exec 是否返回了错误. */</span></span><br><span class="line">			retval = PTR_ERR(interpreter);</span><br><span class="line">			<span class="keyword">if</span> (IS_ERR(interpreter)) &#123;</span><br><span class="line">				interpreter = <span class="literal">NULL</span>;</span><br><span class="line">				<span class="keyword">goto</span> error;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * 如果原始的二进制文件不可读, 那么无论解释器的权限如何, </span></span><br><span class="line"><span class="comment">			 * 都要强制新进程不可被dump.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			would_dump(bprm, interpreter);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 重置文件偏移量为0, 准备读取解释器的文件头. */</span></span><br><span class="line">			pos = <span class="number">0</span>;</span><br><span class="line">			<span class="comment">/* 将解释器的前128字节读入bprm-&gt;buf, 覆盖掉原始程序的内容. */</span></span><br><span class="line">			retval = kernel_read(interpreter, bprm-&gt;buf,</span><br><span class="line">					BINPRM_BUF_SIZE, &amp;pos);</span><br><span class="line">			<span class="comment">/* 检查是否成功读取了完整的缓冲区大小. */</span></span><br><span class="line">			<span class="keyword">if</span> (unlikely(retval != BINPRM_BUF_SIZE)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (retval &gt;= <span class="number">0</span>)</span><br><span class="line">					retval = -ENOEXEC;</span><br><span class="line">				<span class="keyword">goto</span> error;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 将解释器的ELF头部信息保存到 interp_params.hdr. */</span></span><br><span class="line">			interp_params.hdr = *((<span class="keyword">struct</span> elfhdr *) bprm-&gt;buf);</span><br><span class="line">			<span class="keyword">break</span>; <span class="comment">/* 退出 switch */</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> PT_LOAD: <span class="comment">/* 如果这是一个需要加载到内存的段 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MMU</span></span><br><span class="line">			<span class="comment">/* 在有MMU的系统上, 记录第一个加载段的虚拟地址作为基地址. */</span></span><br><span class="line">			<span class="keyword">if</span> (exec_params.load_addr == <span class="number">0</span>)</span><br><span class="line">				exec_params.load_addr = phdr-&gt;p_vaddr;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="comment">/* switch 结束 */</span></span><br><span class="line">	&#125; <span class="comment">/* for 循环结束 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 检查ELF头部是否指定了&quot;常量位移&quot;(constant displacement)加载模式. */</span></span><br><span class="line">	<span class="keyword">if</span> (is_constdisp(&amp;exec_params.hdr))</span><br><span class="line">		exec_params.flags |= ELF_FDPIC_FLAG_CONSTDISP;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 对解释器进行完整性检查. */</span></span><br><span class="line">	<span class="keyword">if</span> (interpreter_name) &#123; <span class="comment">/* 如果我们找到了一个解释器 */</span></span><br><span class="line">		retval = -ELIBBAD; <span class="comment">/* 预设错误码: 库格式错误 */</span></span><br><span class="line">		<span class="comment">/* 检查解释器本身是否是一个有效的ELF文件. */</span></span><br><span class="line">		<span class="keyword">if</span> (!is_elf(&amp;interp_params.hdr, interpreter))</span><br><span class="line">			<span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 为解释器设置&#x27;存在&#x27;标志. */</span></span><br><span class="line">		interp_params.flags = ELF_FDPIC_FLAG_PRESENT;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 读取解释器的程序头表. */</span></span><br><span class="line">		retval = elf_fdpic_fetch_phdrs(&amp;interp_params, interpreter);</span><br><span class="line">		<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> error;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 确定新进程的栈大小, 优先使用可执行文件指定的. */</span></span><br><span class="line">	stack_size = exec_params.stack_size;</span><br><span class="line">	<span class="comment">/* 检查可执行文件是否指定了栈的可执行权限. */</span></span><br><span class="line">	<span class="keyword">if</span> (exec_params.flags &amp; ELF_FDPIC_FLAG_EXEC_STACK)</span><br><span class="line">		executable_stack = EXSTACK_ENABLE_X;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (exec_params.flags &amp; ELF_FDPIC_FLAG_NOEXEC_STACK)</span><br><span class="line">		executable_stack = EXSTACK_DISABLE_X;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		executable_stack = EXSTACK_DEFAULT;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果可执行文件没有指定栈大小, 且有解释器, 则使用解释器指定的. */</span></span><br><span class="line">	<span class="keyword">if</span> (stack_size == <span class="number">0</span> &amp;&amp; interp_params.flags &amp; ELF_FDPIC_FLAG_PRESENT) &#123;</span><br><span class="line">		stack_size = interp_params.stack_size;</span><br><span class="line">		<span class="comment">/* 同时, 栈的可执行权限也由解释器决定. */</span></span><br><span class="line">		<span class="keyword">if</span> (interp_params.flags &amp; ELF_FDPIC_FLAG_EXEC_STACK)</span><br><span class="line">			executable_stack = EXSTACK_ENABLE_X;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (interp_params.flags &amp; ELF_FDPIC_FLAG_NOEXEC_STACK)</span><br><span class="line">			executable_stack = EXSTACK_DISABLE_X;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			executable_stack = EXSTACK_DEFAULT;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	retval = -ENOEXEC;</span><br><span class="line">	<span class="comment">/* 如果最终栈大小仍为0, 则使用一个默认值 (128KB). */</span></span><br><span class="line">	<span class="keyword">if</span> (stack_size == <span class="number">0</span>)</span><br><span class="line">		stack_size = <span class="number">131072UL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 检查解释器是否也使用了&quot;常量位移&quot;模式. */</span></span><br><span class="line">	<span class="keyword">if</span> (is_constdisp(&amp;interp_params.hdr))</span><br><span class="line">		interp_params.flags |= ELF_FDPIC_FLAG_CONSTDISP;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 清理当前进程的执行上下文, 准备加载新程序. 这是无法回头的一步. */</span></span><br><span class="line">	retval = begin_new_exec(bprm);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 从现在开始, 旧的用户空间镜像已经死亡. */</span></span><br><span class="line">	<span class="comment">/* 设置新进程的&quot;个性化&quot;标志, 以反映其ELF类型. */</span></span><br><span class="line">	SET_PERSONALITY(exec_params.hdr);</span><br><span class="line">	<span class="comment">/* 如果是FDPIC, 添加 PER_LINUX_FDPIC 标志. */</span></span><br><span class="line">	<span class="keyword">if</span> (elf_check_fdpic(&amp;exec_params.hdr))</span><br><span class="line">		current-&gt;personality |= PER_LINUX_FDPIC;</span><br><span class="line">	<span class="comment">/* 如果架构上读等同于执行, 添加 READ_IMPLIES_EXEC 标志. */</span></span><br><span class="line">	<span class="keyword">if</span> (elf_read_implies_exec(&amp;exec_params.hdr, executable_stack))</span><br><span class="line">		current-&gt;personality |= READ_IMPLIES_EXEC;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 设置新的执行上下文, 例如清除信号处理器等. */</span></span><br><span class="line">	setup_new_exec(bprm);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 在当前进程的task_struct中记录下我们正在使用的二进制格式处理器. */</span></span><br><span class="line">	set_binfmt(&amp;elf_fdpic_format);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化新进程的内存映射(mm_struct)中的各个段地址为0. */</span></span><br><span class="line">	current-&gt;mm-&gt;start_code = <span class="number">0</span>;</span><br><span class="line">	current-&gt;mm-&gt;end_code = <span class="number">0</span>;</span><br><span class="line">	current-&gt;mm-&gt;start_stack = <span class="number">0</span>;</span><br><span class="line">	current-&gt;mm-&gt;start_data = <span class="number">0</span>;</span><br><span class="line">	current-&gt;mm-&gt;end_data = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">/* FDPIC特定的加载映射表指针也清零. */</span></span><br><span class="line">	current-&gt;mm-&gt;context.exec_fdpic_loadmap = <span class="number">0</span>;</span><br><span class="line">	current-&gt;mm-&gt;context.interp_fdpic_loadmap = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MMU</span></span><br><span class="line">	<span class="comment">/* 在有MMU的系统上, 规划内存布局, 设置栈和堆的起始地址. */</span></span><br><span class="line">	elf_fdpic_arch_lay_out_mm(&amp;exec_params,</span><br><span class="line">				  &amp;interp_params,</span><br><span class="line">				  ¤t-&gt;mm-&gt;start_stack,</span><br><span class="line">				  ¤t-&gt;mm-&gt;start_brk);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 创建参数和环境变量所在的内存页. */</span></span><br><span class="line">	retval = setup_arg_pages(bprm, current-&gt;mm-&gt;start_stack,</span><br><span class="line">				 executable_stack);</span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ARCH_HAS_SETUP_ADDITIONAL_PAGES</span></span><br><span class="line">	<span class="comment">/* 特定架构可能需要设置一些额外的页. */</span></span><br><span class="line">	retval = arch_setup_additional_pages(bprm, !!interpreter_name);</span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 将可执行文件和解释器映射到内存. 这是FDPIC加载的核心步骤. */</span></span><br><span class="line">	retval = elf_fdpic_map_file(&amp;exec_params, bprm-&gt;file, current-&gt;mm,</span><br><span class="line">				    <span class="string">&quot;executable&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果有解释器, 也将其映射到内存. */</span></span><br><span class="line">	<span class="keyword">if</span> (interpreter_name) &#123;</span><br><span class="line">		retval = elf_fdpic_map_file(&amp;interp_params, interpreter,</span><br><span class="line">					    current-&gt;mm, <span class="string">&quot;interpreter&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (retval &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			printk(KERN_ERR <span class="string">&quot;Unable to load interpreter\n&quot;</span>);</span><br><span class="line">			<span class="keyword">goto</span> error;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 允许对解释器文件的写访问(之前被我们禁止了). */</span></span><br><span class="line">		exe_file_allow_write_access(interpreter);</span><br><span class="line">		<span class="comment">/* 释放对解释器文件的引用. */</span></span><br><span class="line">		fput(interpreter);</span><br><span class="line">		interpreter = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MMU</span></span><br><span class="line">	<span class="comment">/* 在有MMU系统上, 设置并对齐堆的起始地址. */</span></span><br><span class="line">	<span class="keyword">if</span> (!current-&gt;mm-&gt;start_brk)</span><br><span class="line">		current-&gt;mm-&gt;start_brk = current-&gt;mm-&gt;end_data;</span><br><span class="line"></span><br><span class="line">	current-&gt;mm-&gt;brk = current-&gt;mm-&gt;start_brk =</span><br><span class="line">		PAGE_ALIGN(current-&gt;mm-&gt;start_brk);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="comment">/* 在无MMU系统上, 显式地为栈分配物理内存. */</span></span><br><span class="line">	<span class="comment">/* 将栈大小对齐到页边界. */</span></span><br><span class="line">	stack_size = (stack_size + PAGE_SIZE - <span class="number">1</span>) &amp; PAGE_MASK;</span><br><span class="line">	<span class="comment">/* 确保栈至少有2个页大小. */</span></span><br><span class="line">	<span class="keyword">if</span> (stack_size &lt; PAGE_SIZE * <span class="number">2</span>)</span><br><span class="line">		stack_size = PAGE_SIZE * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 设置栈的保护标志: 可读, 可写. */</span></span><br><span class="line">	stack_prot = PROT_READ | PROT_WRITE;</span><br><span class="line">	<span class="comment">/* 根据之前的判断, 如果需要, 添加可执行标志. */</span></span><br><span class="line">	<span class="keyword">if</span> (executable_stack == EXSTACK_ENABLE_X ||</span><br><span class="line">	    (executable_stack == EXSTACK_DEFAULT &amp;&amp; VM_STACK_FLAGS &amp; VM_EXEC))</span><br><span class="line">		stack_prot |= PROT_EXEC;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 调用 vm_mmap (在no-MMU下是物理内存分配器)来分配栈空间.</span></span><br><span class="line"><span class="comment">	 * MAP_PRIVATE | MAP_ANONYMOUS: 私有的、匿名的内存.</span></span><br><span class="line"><span class="comment">	 * MAP_UNINITIALIZED: 内核无需清零, 提高效率.</span></span><br><span class="line"><span class="comment">	 * MAP_GROWSDOWN: 这是一个向下增长的栈.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	current-&gt;mm-&gt;start_brk = vm_mmap(<span class="literal">NULL</span>, <span class="number">0</span>, stack_size, stack_prot,</span><br><span class="line">					 MAP_PRIVATE | MAP_ANONYMOUS |</span><br><span class="line">					 MAP_UNINITIALIZED | MAP_GROWSDOWN,</span><br><span class="line">					 <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 检查内存分配是否成功. */</span></span><br><span class="line">	<span class="keyword">if</span> (IS_ERR_VALUE(current-&gt;mm-&gt;start_brk)) &#123;</span><br><span class="line">		retval = current-&gt;mm-&gt;start_brk;</span><br><span class="line">		current-&gt;mm-&gt;start_brk = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 在no-MMU系统上, 堆(brk)的起始点紧接着栈的末尾. */</span></span><br><span class="line">	current-&gt;mm-&gt;brk = current-&gt;mm-&gt;start_brk;</span><br><span class="line">	current-&gt;mm-&gt;context.end_brk = current-&gt;mm-&gt;start_brk;</span><br><span class="line">	<span class="comment">/* 栈顶地址在分配区域的最高处. */</span></span><br><span class="line">	current-&gt;mm-&gt;start_stack = current-&gt;mm-&gt;start_brk + stack_size;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 在新创建的栈上创建ELF表(主要是辅助向量, Auxiliary Vector).</span></span><br><span class="line"><span class="comment">	 * 这些信息将传递给用户空间的动态链接器.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	retval = create_elf_fdpic_tables(bprm, current-&gt;mm, &amp;exec_params,</span><br><span class="line">					 &amp;interp_params);</span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 内核调试打印: 显示最终确定的内存布局. */</span></span><br><span class="line">	kdebug(<span class="string">&quot;- start_code  %lx&quot;</span>, current-&gt;mm-&gt;start_code);</span><br><span class="line">	kdebug(<span class="string">&quot;- end_code    %lx&quot;</span>, current-&gt;mm-&gt;end_code);</span><br><span class="line">	kdebug(<span class="string">&quot;- start_data  %lx&quot;</span>, current-&gt;mm-&gt;start_data);</span><br><span class="line">	kdebug(<span class="string">&quot;- end_data    %lx&quot;</span>, current-&gt;mm-&gt;end_data);</span><br><span class="line">	kdebug(<span class="string">&quot;- start_brk   %lx&quot;</span>, current-&gt;mm-&gt;start_brk);</span><br><span class="line">	kdebug(<span class="string">&quot;- brk         %lx&quot;</span>, current-&gt;mm-&gt;brk);</span><br><span class="line">	kdebug(<span class="string">&quot;- start_stack %lx&quot;</span>, current-&gt;mm-&gt;start_stack);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ELF_FDPIC_PLAT_INIT</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 特定于平台的初始化宏.</span></span><br><span class="line"><span class="comment">	 * 根据ABI要求, 设置某些寄存器的初始值. 例如, FDPIC约定用一个特定寄存器</span></span><br><span class="line"><span class="comment">	 * 来存放私有数据段的基地址, 这个宏会完成这个设置.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	dynaddr = interp_params.dynamic_addr ?: exec_params.dynamic_addr;</span><br><span class="line">	ELF_FDPIC_PLAT_INIT(regs, exec_params.map_addr, interp_params.map_addr,</span><br><span class="line">			    dynaddr);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 最后的收尾工作.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	finalize_exec(bprm);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 一切就绪...准备启动用户空间上下文.</span></span><br><span class="line"><span class="comment">	 * 确定入口点地址, 优先使用解释器的.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	entryaddr = interp_params.entry_addr ?: exec_params.entry_addr;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 调用 start_thread, 修改内核栈上保存的寄存器状态(regs),</span></span><br><span class="line"><span class="comment">	 * 将程序计数器(PC)设置为入口点地址, 栈指针(SP)设置为新栈的栈顶.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	start_thread(regs, entryaddr, current-&gt;mm-&gt;start_stack);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果执行到这里, 说明一切成功. */</span></span><br><span class="line">	retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">error: <span class="comment">/* 错误处理标签 */</span></span><br><span class="line">	<span class="comment">/* 如果解释器文件被打开了但未被正常处理, 释放它. */</span></span><br><span class="line">	<span class="keyword">if</span> (interpreter) &#123;</span><br><span class="line">		exe_file_allow_write_access(interpreter);</span><br><span class="line">		fput(interpreter);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 释放所有在函数执行过程中动态分配的内存. */</span></span><br><span class="line">	kfree(interpreter_name);</span><br><span class="line">	kfree(exec_params.phdrs);</span><br><span class="line">	kfree(exec_params.loadmap);</span><br><span class="line">	kfree(interp_params.phdrs);</span><br><span class="line">	kfree(interp_params.loadmap);</span><br><span class="line">	<span class="comment">/* 返回最终的错误码. */</span></span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/wdfk-prog">Liya Huang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://wdfk-prog.space/posts/f793f059/">https://wdfk-prog.space/posts/f793f059/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://wdfk-prog.space" target="_blank">wdfk-prog的个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/linux/">linux</a><a class="post-meta__tags" href="/tags/fs/">fs</a></div><div class="post-share"><div class="social-share" data-image="/images/covers/05.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/images/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/images/alipay.png" target="_blank"><img class="post-qr-code-img" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/alipay.png" alt="支付寶"/></a><div class="post-qr-code-desc">支付寶</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/2089198e/" title="filesystems"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/09.jpg" onerror="onerror=null;src='/images/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">filesystems</div></div><div class="info-2"><div class="info-item-1">  [toc]  fs&#x2F; VFS - 虚拟文件系统(Virtual Filesystem) 内核统一的文件系统抽象层历史与背景这项技术是为了解决什么特定问题而诞生的？虚拟文件系统（Virtual Filesystem Switch, VFS）是Linux内核最核心、最强大的子系统之一。它的诞生是为了解决一个根本性的问题：如何让应用程序以一种统一的方式来访问各种不同类型的文件系统。 在VFS出现之前，操作系统如果想支持一种新的文件系统（例如，从Minix文件系统切换到ext文件系统），可能需要重写大量与文件操作相关的代码。应用程序也可能会与特定的文件系统实现产生耦合。VFS通过创建一个通用的抽象层来解决这个问题：  对应用程序的统一接口：无论底层是ext4、XFS、Btrfs、NFS（网络文件系统），还是一个USB U盘上的FAT32，应用程序都使用同样标准的系统调用（open, read, write, close, stat等）来操作文件。应用程序完全不需要知道底层文件系统的具体类型和实现细节。 对文件系统驱动的统一接口：VFS定义了一套标准的“插件”接口。任何想要被...</div></div></div></a><a class="pagination-related" href="/posts/56a583b/" title="fs_context"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/03.jpg" onerror="onerror=null;src='/images/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">fs_context</div></div><div class="info-2"><div class="info-item-1">[toc] fs&#x2F;fs_context.c 文件系统创建上下文(Filesystem Creation Context)历史与背景这项技术是为了解决什么特定问题而诞生的？fs_context 框架的诞生是为了彻底改革和现代化Linux内核中挂载文件系统的方式，以解决传统mount(2)系统调用长期以来存在的诸多根本性问题：  混乱的参数传递：mount(2)系统调用使用一个名为data的参数（void *data），它实际上被用作一个非结构化的、以逗号分隔的字符串来传递文件系统特定的挂载选项（如&quot;rw,noatime,jounal_checksum&quot;）。这种方式有几个巨大的缺点： 解析复杂且容易出错：每个文件系统都必须编写自己的、脆弱的字符串解析器来提取选项。 缺乏类型安全：所有选项都被当作字符串，无法以原生方式传递整数、布尔标志或二进制数据（如安全密钥）。 难以验证：内核很难在文件系统解析之前对选项进行统一的验证。   API不灵活且难以扩展：mount(2)的参数是固定的。当出现新的挂载需求或新型文件系统（特别是那些没有传统块设备源的，如网络文件...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/c674e474/" title="init"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/06.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-03</div><div class="info-item-2">init</div></div><div class="info-2"><div class="info-item-1"> [TOC] init&#x2F;init_task.c 内核线程的一个核心特征是：它们没有自己独立的用户地址空间。它们只在内核空间运行，而内核地址空间是所有进程共享的。因此，内核线程不需要一个属于自己的内存描述符 struct mm_struct，所以它们的 task-&gt;mm 指针通常是 NULL  init_task 就是大名鼎鼎的 PID 0 进程，也常被称为 swapper 进程。从它的标志位 .flags &#x3D; PF_KTHREAD 可以看出，它是一个内核线程。  init_task 的调度策略(policy)是 SCHED_NORMAL，这意味着它是一个普通的分时调度任务，而不是实时任务。但是初始化阶段调用了init_idle()，使得它的sched_class 是 SCHED_IDLE，这样它就可以作为 CPU 的空闲任务运行。但是fork出来的其他进程继承的还是 SCHED_NORMAL 策略。  进程的“始祖”：init_task 是系统中所有进程的祖先。在系统启动后，它会创建第一个内核线程 kernel_init（它最终会成为 PID 1 的 i...</div></div></div></a><a class="pagination-related" href="/posts/52310506/" title="anon_inodes"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/01.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-03</div><div class="info-item-2">anon_inodes</div></div><div class="info-2"><div class="info-item-1">[toc] fs&#x2F;anon_inodes.c 匿名inode文件系统(Anonymous Inode Filesystem) 提供内核事件驱动的文件描述符历史与背景这项技术是为了解决什么特定问题而诞生的？这项技术是为了给那些纯粹基于内核内部事件、而没有实体文件系统后端的对象提供一个标准的文件描述符（File Descriptor）接口而诞生的。 在Linux“一切皆文件”的设计哲学下，将各种资源抽象为文件描述符，可以使用read(), write(), poll(), epoll()等一套统一的I&#x2F;O接口来进行操作。 在anon_inodes出现之前，如果内核想提供一个事件通知机制（例如inotify），它可能需要实现一个迷你的、私有的伪文件系统，只为了创建一个inode和一个file对象返回给用户空间。 这导致了代码的重复和资源的浪费。 anon_inodes.c解决的核心问题是：如何以一种轻量级、标准化、且节约内存的方式，为内核子系统创建并返回一个功能性的文件描述符，而这个文件描述符背后并不对应任何磁盘上的文件或一个完整的伪文件系统。 它的发展经历了哪些重...</div></div></div></a><a class="pagination-related" href="/posts/17c21950/" title="drop_caches"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/05.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-03</div><div class="info-item-2">drop_caches</div></div><div class="info-2"><div class="info-item-1">[toc] fs&#x2F;drop_caches.c 内核缓存手动回收(Manual Kernel Cache Reclaiming) 提供清空页面、目录和inode缓存的接口历史与背景这项技术是为了解决什么特定问题而诞生的？这项技术是为了给系统管理员、性能测试工程师和内核开发者提供一个手动、强制性地清空内核主要缓存的手段，以解决以下特定问题：  可重复的性能基准测试：在进行磁盘I&#x2F;O或文件系统性能测试时，上一次运行的结果会“预热”内核缓存（Page Cache）。这导致下一次运行会直接从高速的内存中读取数据，而不是从慢速的磁盘读取，从而使得测试结果不准确，无法反映真实的“冷启动”性能。drop_caches 允许在每次测试前清空缓存，确保测试环境的一致性。 模拟内存压力：开发者需要测试应用程序或内核本身在内存资源紧张时的行为。通过手动清空缓存，可以快速回收大量内存，从而模拟出系统突然面临内存压力的场景。 诊断特定的内存问题：在极少数情况下，内核的slab分配器可能出现严重的内存碎片问题，或者某些驱动程序存在内存泄漏，导致缓存无法被正常回收。drop_caches 可...</div></div></div></a><a class="pagination-related" href="/posts/a5c27015/" title="dcache"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/06.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-03</div><div class="info-item-2">dcache</div></div><div class="info-2"><div class="info-item-1">[TOC] fs&#x2F;dcache.c 目录项缓存(Directory Entry Cache) VFS路径查找加速器历史与背景这项技术是为了解决什么特定问题而诞生的？这项技术以及它所实现的目录项缓存（dcache），是为了解决Linux虚拟文件系统（VFS）中最核心的性能瓶颈之一：路径名到inode的解析过程。  消除磁盘I&#x2F;O：在一个典型的文件系统中，解析一个路径如/home/user/file.txt需要一系列的磁盘读取操作。首先读取根目录/的内容找到home，然后读取home目录的内容找到user，以此类推，直到最后找到file.txt。每一次目录读取都是一次缓慢的磁盘I&#x2F;O。如果每次open()或stat()系统调用都执行这个过程，系统性能将无法接受。 提供快速路径查找：dcache在内存中缓存了目录项（dentry）的树状结构，它直接映射了文件系统的目录层次。当内核需要解析一个路径时，它首先在dcache中查找。如果路径的所有组件都在缓存中，整个解析过程就可以在内存中以极高的速度完成，完全无需访问磁盘。 缓存负面结果（Negative Loo...</div></div></div></a><a class="pagination-related" href="/posts/bb6f4ec5/" title="exec"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/01.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-03</div><div class="info-item-2">exec</div></div><div class="info-2"><div class="info-item-1">[TOC] fs&#x2F;exec.c 程序加载与执行(Program Loading and Execution) execve系统调用的核心实现历史与背景这项技术是为了解决什么特定问题而诞生的？fs/exec.c 中的代码是为了解决操作系统中最基本的一个需求：如何在一个正在运行的进程上下文中启动一个全新的程序。这个过程被称为“执行”一个程序。它与创建新进程（由 fork() 实现）是分离的，这种“创建”与“执行”的分离是Unix哲学的核心之一。具体来说，它解决了以下问题：  进程复用：当一个进程完成了它的使命，但需要启动另一个程序来接替它时（例如shell执行用户输入的命令），没有必要销毁当前进程再创建一个全新的进程。execve 允许重用现有的进程结构（如PID），只将内存中的程序镜像替换为新的程序，这大大提高了效率。 程序解耦：它使得任何程序都可以调用任何其他程序，而无需了解其内部实现。一个简单的程序可以通过 exec 来调用一个复杂的工具来完成特定任务。 支持多种可执行格式：操作系统需要能够运行不同格式的可执行文件，例如经典的 a.out 格式、COFF 格式，以及现...</div></div></div></a><a class="pagination-related" href="/posts/8c9f3610/" title="file"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/09.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-03</div><div class="info-item-2">file</div></div><div class="info-2"><div class="info-item-1">[TOC] fs&#x2F;file.c 文件句柄管理(File Handle Management) 管理已打开文件的核心数据结构历史与背景这项技术是为了解决什么特定问题而诞生的？fs/file.c 及其管理的数据结构是为了解决在多进程操作系统中如何清晰、高效地管理“已打开文件”这一核心概念而诞生的。它解决了以下几个基本问题：  状态的区分：需要区分“磁盘上的文件”和“被打开的文件”。磁盘上的文件有其固有的属性（大小、权限等），而被打开的文件则有其动态的状态，最典型的就是当前的读写位置（offset）。多个进程可以同时打开同一个文件，但每个进程都应该有自己独立的读写位置。 抽象与统一：操作系统需要一个统一的接口来处理所有类型的I&#x2F;O操作。无论是读写磁盘文件、管道、套接字还是硬件设备，用户空间程序都应该能使用相同的系统调用（read, write, close）。fs/file.c 提供的框架是实现这种统一接口（即VFS - 虚拟文件系统）的关键部分。 资源共享与隔离：需要一种机制来管理文件句柄在进程间的关系。例如，一个进程如何复制一个文件句柄（dup），以及父进程打开...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/avatar.png" onerror="this.onerror=null;this.src='/images/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Liya Huang</div><div class="author-info-description">WORK-LIFE BALANCE</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">417</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">49</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">53</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/wdfk-prog"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/wdfk-prog" rel="external nofollow noreferrer" target="_blank" title="GitHub"><i class="fab fa-github" style="color: #181717;"></i></a><a class="social-icon" href="https://wdfk-prog.blog.csdn.net/" rel="external nofollow noreferrer" target="_blank" title="CSDN"><i class="fas fa-blog" style="color: #FC5531;"></i></a><a class="social-icon" href="mailto:1425075683@qq.com" rel="external nofollow noreferrer" target="_blank" title="E-mail"><i class="fas fa-envelope" style="color: #4A4A4A;"></i></a><a class="social-icon" href="/images/wechat-qrcode.jpg" target="_blank" title="微信公众号"><i class="fab fa-weixin" style="color: #07C160;"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss" style="color: #EE802F;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎光临！有任何问题或想法，欢迎在文章下留言交流，或者通过 <a href='/about/'>关于页面</a> 联系我。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#include-uapi-linux-elf-h"><span class="toc-number">1.</span> <span class="toc-text">include&#x2F;uapi&#x2F;linux&#x2F;elf.h</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Elf32-Ehdr-%E5%86%85%E6%A0%B8%E4%B8%AD%E9%80%9A%E5%B8%B8%E7%94%A8-struct-elfhdr-ELF%E6%96%87%E4%BB%B6%E5%A4%B4%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.0.1.</span> <span class="toc-text">Elf32_Ehdr (内核中通常用 struct elfhdr): ELF文件头结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%A4%B4%E8%A1%A8%E9%A1%B9%E7%B1%BB%E5%9E%8B-p-type"><span class="toc-number">1.0.2.</span> <span class="toc-text">程序头表项类型 (p_type)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#fs-binfmt-script-c"><span class="toc-number">2.</span> <span class="toc-text">fs&#x2F;binfmt_script.c</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-bin-sh-%E4%B8%8E-bin-bash-Bourne-Shell-%E5%92%8C-Bourne-Again-Shell"><span class="toc-number">2.0.1.</span> <span class="toc-text">1. &#x2F;bin&#x2F;sh 与 &#x2F;bin&#x2F;bash (Bourne Shell 和 Bourne-Again Shell)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-usr-bin-python3-Python-3"><span class="toc-number">2.0.2.</span> <span class="toc-text">2. &#x2F;usr&#x2F;bin&#x2F;python3 (Python 3)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-usr-bin-perl-Perl"><span class="toc-number">2.0.3.</span> <span class="toc-text">3. &#x2F;usr&#x2F;bin&#x2F;perl (Perl)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-usr-bin-awk-f"><span class="toc-number">2.0.4.</span> <span class="toc-text">4. &#x2F;usr&#x2F;bin&#x2F;awk -f</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-usr-bin-env-%E7%9A%84%E5%B7%A7%E5%A6%99%E7%94%A8%E6%B3%95"><span class="toc-number">2.0.5.</span> <span class="toc-text">5. #!&#x2F;usr&#x2F;bin&#x2F;env 的巧妙用法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Shebang-%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E8%84%9A%E6%9C%AC"><span class="toc-number">2.1.</span> <span class="toc-text">#! (Shebang) 支持哪些脚本?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.1.1.</span> <span class="toc-text">工作流程示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B1-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84Shell%E8%84%9A%E6%9C%AC"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">示例1: 一个简单的Shell脚本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B2-%E8%A1%8C%E5%B8%A6%E6%9C%89%E5%8F%82%E6%95%B0"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">示例2: #! 行带有参数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#binfmt-script-c-%E5%86%85%E6%A0%B8%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%94%AF%E6%8C%81"><span class="toc-number">2.2.</span> <span class="toc-text">binfmt_script.c: 内核脚本执行支持</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#fs-binfmt-elf-fdpic-c"><span class="toc-number">3.</span> <span class="toc-text">fs&#x2F;binfmt_elf_fdpic.c</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ELF-FDPIC-Binary-Format-Support-%E5%9C%A8%E6%97%A0MMU%E7%B3%BB%E7%BB%9F%E4%B8%8A%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%BF%9B%E7%A8%8B"><span class="toc-number">3.1.</span> <span class="toc-text">ELF FDPIC Binary Format Support: 在无MMU系统上实现多进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FDPIC%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%9C%A8STM32H750%E4%B8%8A%E7%9A%84%E5%85%B3%E9%94%AE%E4%BD%9C%E7%94%A8"><span class="toc-number">3.1.1.</span> <span class="toc-text">FDPIC的原理与在STM32H750上的关键作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#is-elf-%E9%AA%8C%E8%AF%81%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E6%98%AF%E5%90%A6%E4%B8%BA%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%9A%84ELF%E6%96%87%E4%BB%B6"><span class="toc-number">3.2.</span> <span class="toc-text">is_elf: 验证一个文件是否为可执行的ELF文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#elf-fdpic-fetch-phdrs-%E8%AF%BB%E5%8F%96%E5%B9%B6%E8%A7%A3%E6%9E%90ELF%E7%A8%8B%E5%BA%8F%E5%A4%B4%E8%A1%A8"><span class="toc-number">3.3.</span> <span class="toc-text">elf_fdpic_fetch_phdrs: 读取并解析ELF程序头表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#elf-fdpic-map-file-constdisp-on-uclinux-%E5%9C%A8uClinux%E4%B8%8A%E6%98%A0%E5%B0%84%E5%9B%BA%E5%AE%9A%E4%BD%8D%E7%A7%BB%E7%9A%84%E6%96%87%E4%BB%B6"><span class="toc-number">3.4.</span> <span class="toc-text">elf_fdpic_map_file_constdisp_on_uclinux: 在uClinux上映射固定位移的文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#elf-fdpic-map-file-by-direct-mmap-%E9%80%90%E4%B8%AA%E6%98%A0%E5%B0%84PT-LOAD%E6%AE%B5"><span class="toc-number">3.5.</span> <span class="toc-text">elf_fdpic_map_file_by_direct_mmap: 逐个映射PT_LOAD段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#elf-fdpic-map-file-%E5%B0%86FDPIC%E7%A8%8B%E5%BA%8F%E6%98%A0%E5%B0%84%E5%88%B0%E5%86%85%E5%AD%98"><span class="toc-number">3.6.</span> <span class="toc-text">elf_fdpic_map_file: 将FDPIC程序映射到内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#create-elf-fdpic-tables-%E5%9C%A8%E6%96%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A0%88%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%88%9D%E5%A7%8B%E4%BF%A1%E6%81%AF%E8%A1%A8"><span class="toc-number">3.7.</span> <span class="toc-text">create_elf_fdpic_tables: 在新进程的栈上创建初始信息表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#load-elf-fdpic-binary-%E5%8A%A0%E8%BD%BDFDPIC-ELF%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6"><span class="toc-number">3.8.</span> <span class="toc-text">load_elf_fdpic_binary: 加载FDPIC ELF可执行文件</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/48974a1a/" title="mq-deadline"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/08.jpg" onerror="this.onerror=null;this.src='/images/404.jpg'" alt="mq-deadline"/></a><div class="content"><a class="title" href="/posts/48974a1a/" title="mq-deadline">mq-deadline</a><time datetime="2025-10-10T09:35:34.893Z" title="更新于 2025-10-10 17:35:34">2025-10-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/44c8f818/" title="list"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/10.jpg" onerror="this.onerror=null;this.src='/images/404.jpg'" alt="list"/></a><div class="content"><a class="title" href="/posts/44c8f818/" title="list">list</a><time datetime="2025-10-10T08:51:23.325Z" title="更新于 2025-10-10 16:51:23">2025-10-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/447af9b5/" title="genhd"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/09.jpg" onerror="this.onerror=null;this.src='/images/404.jpg'" alt="genhd"/></a><div class="content"><a class="title" href="/posts/447af9b5/" title="genhd">genhd</a><time datetime="2025-10-10T08:50:59.612Z" title="更新于 2025-10-10 16:50:59">2025-10-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/ed4b199f/" title="class"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/01.jpg" onerror="this.onerror=null;this.src='/images/404.jpg'" alt="class"/></a><div class="content"><a class="title" href="/posts/ed4b199f/" title="class">class</a><time datetime="2025-10-10T08:38:03.324Z" title="更新于 2025-10-10 16:38:03">2025-10-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/aa511041/" title="blk-core"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/covers/07.jpg" onerror="this.onerror=null;this.src='/images/404.jpg'" alt="blk-core"/></a><div class="content"><a class="title" href="/posts/aa511041/" title="blk-core">blk-core</a><time datetime="2025-10-10T08:15:30.737Z" title="更新于 2025-10-10 16:15:30">2025-10-10</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/images/covers/05.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">文档</div><div class="footer-flex-content"><a href="/categories/linux/" target="_blank" title="🚀 linux">🚀 linux</a><a href="/categories/rt-thread/" target="_blank" title="📑 rt-thread">📑 rt-thread</a><a href="/categories/uboot/" target="_blank" title="📌 uboot">📌 uboot</a><a href="/categories/LoraWan/" target="_blank" title="⚔️ LoraWan">⚔️ LoraWan</a><a href="/categories/hpatch/" target="_blank" title="❓ hpatch">❓ hpatch</a><a href="/categories/git/" target="_blank" title="⚡️ git">⚡️ git</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/gallery/" target="_blank" title="图库">图库</a><a href="/messageboard/" target="_blank" title="留言板">留言板</a><a href="/shuoshuo/" target="_blank" title="说说">说说</a><a href="/link/" target="_blank" title="示例">示例</a><a href="/link/" target="_blank" title="友链">友链</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">框架</div><div class="footer-flex-content"><a href="https://hexo.io/zh-cn/" rel="external nofollow noreferrer" target="_blank" title="Hexo">Hexo</a><a href="https://butterfly.js.org/" rel="external nofollow noreferrer" target="_blank" title="Butterfly">Butterfly</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">贊助</div><div class="footer-flex-content"><div><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/alipay.png" alt='wdfk_prog' width='100px' height='100px'></div></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Liya Huang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo 8.0.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.1</a></span></div><div class="footer_custom_text">你好，欢迎来到我的 <a href="/about/">数字花园</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天" style="display:none"><i class="fas fa-message"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script><script>(() => {
  const abcjsInit = () => {
    const abcjsFn = () => {
      setTimeout(() => {
        const sheets = document.querySelectorAll(".abc-music-sheet")
        for (let i = 0; i < sheets.length; i++) {
          const ele = sheets[i]
          if (ele.children.length > 0) continue

          // Parse parameters from data-params attribute
          let params = {}
          const dp = ele.getAttribute("data-params")
          if (dp) {
            try {
              params = JSON.parse(dp)
            } catch (e) {
              console.error("Failed to parse data-params:", e)
            }
          }

          // Merge parsed parameters with the responsive option
          // Ensures params content appears before responsive
          const options = { ...params, responsive: "resize" }

          // Render the music score using ABCJS.renderAbc
          ABCJS.renderAbc(ele, ele.innerHTML, options)
        }
      }, 100)
    }

    if (typeof ABCJS === "object") {
      abcjsFn()
    } else {
      btf.getScript("https://cdn.jsdelivr.net/npm/abcjs/dist/abcjs-basic-min.min.js").then(abcjsFn)
    }
  }

  if (window.pjax) {
    abcjsInit()
  } else {
    window.addEventListener("load", abcjsInit)
  }

  btf.addGlobalFn("encrypt", abcjsInit, "abcjs")
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: 'Ov23livBmwx65h3XIdfT',
      clientSecret: '9f23bdaa2ea11322f9f405d77bcdc27166077a7d',
      repo: 'wdfk-prog.github.io',
      owner: 'wdfk-prog',
      admin: ['wdfk-prog'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || '3e0f11ffb15018dd800605503aad9394'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script>window.newestComments = {
  changeContent: content => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<code>.*?<\/code>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g, "") // remove html tag

    if (content.length > 150) {
      content = content.substring(0, 150) + '...'
    }
    return content
  },

  generateHtml: (array, ele) => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class="aside-list-item">'

        if (true && array[i].avatar) {
          const imgAttr = 'data-lazy-src'
          const lazyloadNative = ''
          result += `<a href="${array[i].url}" class="thumbnail"><img ${imgAttr}="${array[i].avatar}" alt="${array[i].nick}" ${lazyloadNative}></a>`
        }

        result += `<div class="content">
        <a class="comment" href="${array[i].url}" title="${array[i].content}">${array[i].content}</a>
        <div class="name"><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '暂无评论'
    }

    ele.innerHTML = result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh(ele)
  },

  newestCommentInit: (name, getComment) => {
    const $dom = document.querySelector('#card-newest-comments .aside-list')
    if ($dom) {
      const data = btf.saveToLocal.get(name)
      if (data) {
        newestComments.generateHtml(JSON.parse(data), $dom)
      } else {
        getComment($dom)
      }
    }
  },

  run: (name, getComment) => {
    newestComments.newestCommentInit(name, getComment)
    btf.addGlobalFn('pjaxComplete', () => newestComments.newestCommentInit(name, getComment), name)
  }
}</script><script>window.addEventListener('load', () => {
  const keyName = 'github-newest-comments'
  const { changeContent, generateHtml, run } = window.newestComments

  const findTrueUrl = (array, ele) => {
    Promise.all(array.map(item =>
      fetch(item.url).then(resp => resp.json()).then(data => {
        let urlArray = data.body ? data.body.match(/(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?/ig) : []
        if (!Array.isArray(urlArray) || urlArray.length === 0) {
          urlArray = [`${data.html_url}`]
        }
        if (data.user.login === 'utterances-bot') {
          return urlArray.pop()
        } else {
          return urlArray.shift()
        }
      })
    )).then(res => {
        array = array.map((i,index)=> {
          return {
            ...i,
            url: res[index]
          }
        })

        btf.saveToLocal.set(keyName, JSON.stringify(array), 10/(60*24))
        generateHtml(array, ele)
    });
  }

  const getComment = ele => {
    fetch('https://api.github.com/repos/wdfk-prog/wdfk-prog.github.io/issues/comments?sort=updated&direction=desc&per_page=6&page=1',{
      "headers": {
        Accept: 'application/vnd.github.v3.html+json'
      }
    })
      .then(response => response.json())
      .then(data => {
        const githubArray = data.map(item => {
          return {
            'avatar': item.user.avatar_url,
            'content': changeContent(item.body_html || item.body),
            'nick': item.user.login,
            'url': item.issue_url,
            'date': item.updated_at
          }
        })
        findTrueUrl(githubArray, ele)
      }).catch(e => {
        console.error(e)
        ele.textContent= "无法获取评论，请确认相关配置是否正确"
      })
  }
  run(keyName, getComment)
})</script><div class="aplayer no-destroy" data-id="60198" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="false" data-volume="0.5"></div><script>
  var titleTime, OriginTitile = document.title;
  document.addEventListener("visibilitychange", function() {
    if (document.hidden) {
      titleTime = setTimeout(function() {
        document.title = "w(ﾟДﾟ)w 不要走！再看看嘛！";
      }, 300);
    } else {
      document.title = "♪(^∇^*)欢迎回来！" + OriginTitile;
      titleTime = setTimeout(function() {
        document.title = OriginTitile;
      }, 2000);
    }
  });
</script>
<script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script>(() => {
  window.ChatraID = '5cPWcnA8HKGzg5hoc'
  window.Chatra = window.Chatra || function() {
    (window.Chatra.q = window.Chatra.q || []).push(arguments)
  }

  btf.getScript('https://call.chatra.io/chatra.js').then(() => {
    const isChatBtn = true
    const isChatHideShow = true

    if (isChatBtn) {
      const close = () => {
        Chatra('minimizeWidget')
        Chatra('hide')
      }

      const open = () => {
        Chatra('openChat', true)
        Chatra('show')
      }

      window.ChatraSetup = { startHidden: true }
    
      window.chatBtnFn = () => document.getElementById('chatra').classList.contains('chatra--expanded') ? close() : open()

      document.getElementById('chat-btn').style.display = 'block'
    } else if (isChatHideShow) {
      window.chatBtn = {
        hide: () => Chatra('hide'),
        show: () => Chatra('show')
      }
    }
  })
})()</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: true,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      true
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-MF3J339H" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript></div><script src="https://cdn.jsdelivr.net/npm/echarts@5.5.1/dist/echarts.min.js"></script>
        
        <script>
            document.addEventListener("DOMContentLoaded", function() {
                const heatmapChartDom = document.getElementById('heatmapChart');
                if(heatmapChartDom){
                    const heatmapChart = echarts.init(heatmapChartDom, 'dark');
                    const cellSize = [18, 18];
                    
                    const groupByYear = (data) => {
                        const result = {};
                        data.forEach(([date, value]) => {
                            const [year] = date.split('-').map(Number);
                            if (!result[year]) {
                                result[year] = [];
                            }
                            result[year].push([date, value]);
                        });
                        return result;
                    };
                    
                    const groupedData = groupByYear([["2025-10-03",392],["2025-10-04",5],["2025-10-06",9],["2025-10-07",8],["2025-10-10",3]]);
                    const years = Object.keys(groupedData).reverse();
                    
                    var initYear = parseInt(heatmapChartDom.getAttribute('year')) || new Date().getFullYear();
                    const minYear = years[years.length - 1];
                    const maxYear = years[0];
                    if (initYear < minYear || initYear > maxYear) {
                        initYear = maxYear;
                    }
                    console.log('[hexo-graph]generateHeatmapChart|initYear:', initYear, 'minYear:', minYear, 'maxYear:', maxYear);
                    
                    heatmapChart.setOption({
                        grid: {},
                        tooltip: { 
                            position: 'top', 
                            formatter: params => `${params.value[0]}: ${params.value[1]} Articles` 
                        },
                        calendar: { 
                            top: '10%',
                            left: 'left', 
                            right: '8%',
                            range: initYear,
                            cellSize: cellSize, 
                            splitLine: { lineStyle: { color: '#E0E0E0', width: 1 } }, 
                            itemStyle: { borderWidth: 1, borderColor: '#E0E0E0' }, 
                            dayLabel: { show: false },
                            monthLabel: { show: true },
                            yearLabel: { show: false },
                        },
                        visualMap: { 
                            show: true,
                            right: '8%',
                            bottom: '5%',
                            type: 'piecewise',
                            orient: 'horizontal',
                            text: ['More', 'Less'],
                            min: 0,
                            max: Math.max(...groupedData[initYear].map(item => item[1])),
                            inRange: { color: ["#ACE7AE","#69C16D","#549F57"] }
                        },
                        legend: {
                            type: 'scroll',
                            icon: 'none',
                            data: years,
                            orient: 'vertical',
                            top: '5%',
                            right: 'right',
                            itemWidth: 20,
                            itemHeight: 20,
                            itemGap: 10,
                            pageIconSize: 10,
                            pageTextStyle: { fontSize: 14 },
                            selectedMode: 'single',
                        },
                        series: years.map(year => ({
                            type: 'heatmap',
                            coordinateSystem: 'calendar',
                            data: groupedData[year],
                            name: year,
                            emphasis: {
                                disabled: true,
                            },
                            silent: year !== initYear,
                        })),
                    });
                    
                    // init selected year
                    heatmapChart.dispatchAction({
                        type: 'legendSelect',
                        name: initYear,
                    });
                    
                    heatmapChart.on('legendselectchanged', function(params) {
                        console.log('[hexo-graph]generateHeatmapChart|legendselectchanged:', params);
                        const selectedYear = Object.keys(params.selected).find(key => params.selected[key]);
                        if (selectedYear && groupedData[selectedYear]) {
                            heatmapChart.setOption({
                                calendar: {
                                    range: selectedYear,
                                },
                                visualMap: {
                                    max: Math.max(...groupedData[selectedYear].map(item => item[1])),
                                },
                                series: years.map(year => ({
                                    type: 'heatmap',
                                    coordinateSystem: 'calendar',
                                    data: groupedData[year],
                                    name: year,
                                    emphasis: {
                                        disabled: true,
                                    },
                                    silent: year !== selectedYear,
                                })),
                            });
                        }
                    });
                    
                    heatmapChart.on('click', function (params) {
                        if (params.componentType === 'series') {
                            const [year, month] = params.value[0].split('-');
                            window.location.href = '/archives/' + year + '/' + month;
                        }
                    });
                }
            });
        </script>
    
        
        <script>
            document.addEventListener("DOMContentLoaded", function() {
                const monthlyChartDom = document.getElementById('monthlyChart');
                if(monthlyChartDom){
                    const monthlyChart = echarts.init(monthlyChartDom, 'dark');
                    monthlyChart.setOption({
                        xAxis: { 
                            type: 'category', 
                            data: ["2025-10"], 
                            axisLabel: { fontSize: 14, fontWeight: 'bold', fontFamily: 'Microsoft YaHei, SimSun, serif' }
                        },
                        yAxis: { type: 'value', splitLine: { lineStyle: { type: 'dashed', color: '#ccc' } } },
                        series: [{
                            name: 'Articles',
                            type: 'line',
                            data: [417],
                            smooth: true,
                            lineStyle: { color: '#5470C6', width: 2 },
                            itemStyle: { color: '#5470C6' },
                            areaStyle: { color: 'rgba(84, 112, 198, 0.4)' },
                            symbolSize: 10,
                            label: {
                                show: true,
                                position: 'top',
                                formatter: params => params.value,
                                fontSize: 14,
                                color: '#000',
                                fontWeight: 'bold',
                                fontFamily: 'Microsoft YaHei, SimSun, serif'
                            }
                        }]
                    });

                    monthlyChart.on('click', function (params) {
                        const [year, month] = params.name.split('-');
                        window.location.href = '/archives/' + year + '/' + month;
                    });
                }
            })
        </script>
    
        
        <script>
            document.addEventListener("DOMContentLoaded", function() {
                const tagsChartDom = document.getElementById('tagsChart');
                if(tagsChartDom){
                    const tagsChart = echarts.init(tagsChartDom, 'dark');
                    tagsChart.setOption({
                        tooltip: { trigger: 'item', formatter: '{b}: {c} ({d}%)' },
                        series: [{
                            type: 'pie',
                            radius: '60%',
                            data: [{"name":"linux","value":230},{"name":"uboot","value":68},{"name":"kernel","value":61},{"name":"rt-thread","value":44},{"name":"u-boot分类","value":44},{"name":"drivers","value":39},{"name":"fs","value":37},{"name":"other","value":28}],
                            label: {
                                position: 'outside',
                                formatter: '{b} {c} ({d}%)',
                                fontSize: 14,
                                fontWeight: 'bold',
                                fontFamily: 'Microsoft YaHei, SimSun, serif'
                            },
                            color: ["#5470C6","#91CC75","#FAC858","#EE6666","#73C0DE","#3BA272","#FC8452","#9A60B4"],
                            labelLine: { show: true }
                        }],
                        legend: {
                            bottom: '0',
                            left: 'center',
                            data: [{"name":"linux","value":230},{"name":"uboot","value":68},{"name":"kernel","value":61},{"name":"rt-thread","value":44},{"name":"u-boot分类","value":44},{"name":"drivers","value":39},{"name":"fs","value":37},{"name":"other","value":28}].map(tag => tag.name),
                            textStyle: { fontSize: 14, fontWeight: 'bold', fontFamily: 'Microsoft YaHei, SimSun, serif' }
                        }
                    });

                    tagsChart.on('click', function (params) {
                        window.location.href = '/tags/' + params.name;
                    });
                }
            })
        </script>
    
        
        <script>
            document.addEventListener("DOMContentLoaded", function() {
                const categoriesChartDom = document.getElementById('categoriesChart');
                if(categoriesChartDom){
                    const categoriesChart = echarts.init(categoriesChartDom, 'dark');
                    categoriesChart.setOption({
                        xAxis: { type: 'value', splitLine: { lineStyle: { type: 'dashed', color: '#ccc' } } },
                        yAxis: { 
                            type: 'category', 
                            data: [{"name":"linux","value":230},{"name":"uboot","value":68},{"name":"kernel","value":61},{"name":"rt-thread","value":44},{"name":"u-boot分类","value":44}].map(category => category.name).reverse(), 
                            axisLabel: { fontSize: 14, fontWeight: 'bold', fontFamily: 'Microsoft YaHei, SimSun, serif' }
                        },
                        series: [{
                            name: 'Category Count',
                            type: 'bar',
                            data: [{"name":"linux","value":230},{"name":"uboot","value":68},{"name":"kernel","value":61},{"name":"rt-thread","value":44},{"name":"u-boot分类","value":44}].map(category => category.value).reverse(),
                            label: {
                                show: true,
                                position: 'right',
                                formatter: params => params.value,
                                fontSize: 14,
                                color: '#000',
                                fontWeight: 'bold',
                                fontFamily: 'Microsoft YaHei, SimSun, serif'
                            },
                            itemStyle: {
                                color: new echarts.graphic.LinearGradient(0, 0, 1, 0, [
                                    { offset: 0, color: '#91CC75' },
                                    { offset: 1, color: '#73C0DE' }
                                ])
                            }
                        }]
                    });

                    categoriesChart.on('click', function (params) {
                        window.location.href = '/categories/' + params.name;
                    });
                }
            });
        </script>
    
        
        <script>
            document.addEventListener("DOMContentLoaded", function() {
                const categoriesTreeChartDom = document.getElementById('categoriesTreeChart');
                if(categoriesTreeChartDom){
                    const treeChart = echarts.init(categoriesTreeChartDom, 'dark');
                    treeChart.setOption({
                        title: {
                            text: '操作提示：单击展开分类，双击进入具体分类页面',
                            textStyle: {
                                fontSize: 12,
                                color: '#999',
                                fontWeight: 'normal'
                            },
                            bottom: 0,
                            left: 'center'
                        },
                        tooltip: {
                            trigger: 'item',
                            triggerOn: 'mousemove'
                        },
                        series: [{
                            type: 'tree',
                            data: [{"name":"Categories","children":[{"name":"git","children":[],"count":6,"path":"git"},{"name":"hpatch","children":[{"name":"libdivsufsort","children":[],"count":3,"path":"hpatch/libdivsufsort"},{"name":"SA-IS","children":[],"count":1,"path":"hpatch/SA-IS"}],"count":10,"path":"hpatch"},{"name":"LoraWan","children":[{"name":"LoRaWAN标准","children":[{"name":"LoRaWAN-Specification_ZH_CN","children":[{"name":"LoRaWAN-Specification_ZH_CN-190102","children":[{"name":"chapter","children":[],"count":20,"path":"LoraWan/LoRaWAN标准/LoRaWAN-Specification_ZH_CN/LoRaWAN-Specification_ZH_CN-190102/chapter"}],"count":22,"path":"LoraWan/LoRaWAN标准/LoRaWAN-Specification_ZH_CN/LoRaWAN-Specification_ZH_CN-190102"}],"count":22,"path":"LoraWan/LoRaWAN标准/LoRaWAN-Specification_ZH_CN"}],"count":22,"path":"LoraWan/LoRaWAN标准"}],"count":23,"path":"LoraWan"},{"name":"MCU","children":[],"count":23,"path":"MCU"},{"name":"linux","children":[{"name":"block","children":[],"count":8,"path":"linux/block"},{"name":"include","children":[],"count":10,"path":"linux/include"},{"name":"fs","children":[],"count":37,"path":"linux/fs"},{"name":"drivers","children":[{"name":"base","children":[],"count":14,"path":"linux/drivers/base"},{"name":"tty","children":[],"count":2,"path":"linux/drivers/tty"},{"name":"clk","children":[],"count":2,"path":"linux/drivers/clk"}],"count":39,"path":"linux/drivers"},{"name":"kernel","children":[{"name":"rcu","children":[],"count":3,"path":"linux/kernel/rcu"},{"name":"lock","children":[],"count":7,"path":"linux/kernel/lock"},{"name":"irq","children":[],"count":5,"path":"linux/kernel/irq"},{"name":"sched","children":[],"count":7,"path":"linux/kernel/sched"},{"name":"time","children":[],"count":10,"path":"linux/kernel/time"}],"count":61,"path":"linux/kernel"},{"name":"lib","children":[],"count":19,"path":"linux/lib"},{"name":"security","children":[],"count":1,"path":"linux/security"},{"name":"scripts","children":[],"count":2,"path":"linux/scripts"},{"name":"other","children":[],"count":17,"path":"linux/other"},{"name":"mm","children":[],"count":19,"path":"linux/mm"},{"name":"arch","children":[{"name":"arm","children":[],"count":10,"path":"linux/arch/arm"}],"count":10,"path":"linux/arch"}],"count":230,"path":"linux"},{"name":"tmc5160","children":[],"count":1,"path":"tmc5160"},{"name":"rt-thread","children":[{"name":"其他资料","children":[{"name":"fatfs","children":[],"count":1,"path":"rt-thread/其他资料/fatfs"}],"count":1,"path":"rt-thread/其他资料"}],"count":44,"path":"rt-thread"},{"name":"uboot","children":[{"name":"other","children":[],"count":12,"path":"uboot/other"},{"name":"子目录","children":[],"count":10,"path":"uboot/子目录"},{"name":"u-boot分类","children":[{"name":"arch","children":[{"name":"arm","children":[],"count":2,"path":"uboot/u-boot分类/arch/arm"}],"count":3,"path":"uboot/u-boot分类/arch"},{"name":"boot","children":[],"count":4,"path":"uboot/u-boot分类/boot"},{"name":"api","children":[],"count":1,"path":"uboot/u-boot分类/api"},{"name":"common","children":[],"count":10,"path":"uboot/u-boot分类/common"},{"name":"cmd","children":[],"count":1,"path":"uboot/u-boot分类/cmd"},{"name":"dm","children":[],"count":15,"path":"uboot/u-boot分类/dm"},{"name":"env","children":[],"count":1,"path":"uboot/u-boot分类/env"},{"name":"lib","children":[],"count":4,"path":"uboot/u-boot分类/lib"},{"name":"include","children":[],"count":3,"path":"uboot/u-boot分类/include"},{"name":"fdt","children":[],"count":1,"path":"uboot/u-boot分类/fdt"},{"name":"test","children":[],"count":1,"path":"uboot/u-boot分类/test"}],"count":44,"path":"uboot/u-boot分类"}],"count":68,"path":"uboot"},{"name":"杂谈","children":[],"count":8,"path":"杂谈"},{"name":"freertos","children":[],"count":1,"path":"freertos"}],"count":0,"path":""}],
                            initialTreeDepth: -1,
                            top: '5%',
                            bottom: '10%',
                            left: '0%',
                            right: '0%',
                            symbolSize: 15,
                            layout: 'orthogonal',
                            orient: 'TB',
                            itemStyle: {
                                color: '#91CC75',
                                borderColor: '#73C0DE'
                            },
                            label: {
                                position: 'bottom',
                                verticalAlign: 'middle',
                                align: 'center',
                                fontSize: 14,
                                distance: 28,
                                formatter: function(params) {
                                    return params.data.name + (params.data.count ? ' (' + params.data.count + ')' : '');
                                }
                            },
                            leaves: {
                                label: {
                                    position: 'top',
                                    verticalAlign: 'middle',
                                    align: 'center'
                                }
                            },
                            emphasis: {
                                focus: 'descendant'
                            },
                            expandAndCollapse: true
                        }]
                    });

                    treeChart.on('dblclick', function (params) {
                        if (params.data && params.data.path) {
                            window.location.href = '/categories/' + params.data.path;
                        }
                    });
                }
            });
        </script>
    
    <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"react":{"opacity":0.7},"log":false});</script></body></html>