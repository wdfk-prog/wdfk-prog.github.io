<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wdfk-prog的个人博客</title>
  
  <subtitle>WORK-LIFE BALANCE.</subtitle>
  <link href="https://wdfk-prog.space/atom.xml" rel="self"/>
  
  <link href="https://wdfk-prog.space/"/>
  <updated>2025-10-07T03:18:15.310Z</updated>
  <id>https://wdfk-prog.space/</id>
  
  <author>
    <name>Liya Huang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ext4</title>
    <link href="https://wdfk-prog.space/posts/1db9a982/"/>
    <id>https://wdfk-prog.space/posts/1db9a982/</id>
    <published>2025-10-07T03:15:45.000Z</published>
    <updated>2025-10-07T03:18:15.310Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>[toc]</p><h1 id="fs-ext4-super-c-Ext4文件系统核心-Ext4-Filesystem-Core-文件系统的挂载与生命周期管理"><a href="#fs-ext4-super-c-Ext4文件系统核心-Ext4-Filesystem-Core-文件系统的挂载与生命周期管理" class="headerlink" title="fs&#x2F;ext4&#x2F;super.c Ext4文件系统核心(Ext4 Filesystem Core) 文件系统的挂载与生命周期管理"></a>fs&#x2F;ext4&#x2F;super.c Ext4文件系统核心(Ext4 Filesystem Core) 文件系统的挂载与生命周期管理</h1><h3 id="历史与背景"><a href="#历史与背景" class="headerlink" title="历史与背景"></a>历史与背景</h3><h4 id="这项技术是为了解决什么特定问题而诞生的？"><a href="#这项技术是为了解决什么特定问题而诞生的？" class="headerlink" title="这项技术是为了解决什么特定问题而诞生的？"></a>这项技术是为了解决什么特定问题而诞生的？</h4><p><code>fs/ext4/super.c</code> 是Ext4文件系统驱动的核心，它的诞生是为了解决一个根本性的问题：<strong>如何将一个原始的块设备（如硬盘分区）解释并初始化为一个可供操作系统使用的、有组织的文件系统实例</strong>。</p><p>这个文件中的代码是内核与一个具体Ext4文件系统进行首次“握手”的地方。它负责的任务包括：</p><ul><li><strong>引导（Bootstrap）</strong>：当用户执行 <code>mount</code> 命令时，<code>super.c</code> 中的代码负责从块设备的预定位置读取<strong>超级块（Superblock）</strong>。超级块是文件系统的“元数据之母”，记录了该文件系统的所有宏观信息（如总大小、块大小、inode数量、魔数等）。</li><li><strong>验证与初始化</strong>：验证读取到的超级块是否合法（例如，通过检查魔数），并根据其中描述的特性（如是否启用日志、扩展属性等）在内存中建立起管理该文件系统所需的所有数据结构。</li><li><strong>生命周期管理</strong>：它不仅处理挂载（mount），还负责卸载（unmount）、重新挂载（remount）以及同步（sync）等操作，管理着一个已挂载文件系统从“出生”到“消亡”的整个生命周期。</li></ul><h4 id="它的发展经历了哪些重要的里程碑或版本迭代？"><a href="#它的发展经历了哪些重要的里程碑或版本迭代？" class="headerlink" title="它的发展经历了哪些重要的里程碑或版本迭代？"></a>它的发展经历了哪些重要的里程碑或版本迭代？</h4><p><code>fs/ext4/super.c</code> 的代码是Ext文件系统家族演进的直接体现：</p><ol><li><strong>Ext2时代</strong>：最初的 <code>super.c</code> 相对简单，负责管理一个没有日志功能的、基础的文件系统。</li><li><strong>Ext3的引入 (关键里程碑 - 日志)</strong>：为了解决Ext2在意外断电后需要长时间<code>fsck</code>检查的问题，Ext3引入了<strong>日志（Journaling）</strong>。<code>super.c</code> 经历了重大修改，增加了在挂载时查找、加载并初始化日志设备（通过JBD层，即Journaling Block Device）的复杂逻辑。这是文件系统可靠性的巨大飞跃。</li><li><strong>Ext4的演进 (关键里程碑 - 新特性)</strong>：Ext4在Ext3的基础上引入了大量新特性以提升性能和扩展性。<code>super.c</code> 再次变得复杂，其挂载逻辑需要能够解析和启用这些新特性，主要包括：<ul><li><strong>Extents</strong>：取代了传统的块映射，<code>super.c</code>需要在挂载时识别并启用extent树。</li><li><strong>64位支持</strong>：允许管理巨大容量的文件系统，挂载代码需要处理64位的块号。</li><li><strong>灵活块组 (Flexible Block Groups)</strong>：改进了元数据的布局，<code>super.c</code>需要能理解这种新的块组结构。</li><li><strong>元数据校验和 (Metadata Checksums)</strong>：为了增强数据完整性，<code>super.c</code>在挂载和同步时需要处理元数据的校验和计算与验证。</li></ul></li></ol><h4 id="目前该技术的社区活跃度和主流应用情况如何？"><a href="#目前该技术的社区活跃度和主流应用情况如何？" class="headerlink" title="目前该技术的社区活跃度和主流应用情况如何？"></a>目前该技术的社区活跃度和主流应用情况如何？</h4><p>Ext4是目前Linux生态系统中最成熟、最稳定、应用最广泛的文件系统之一。它是绝大多数主流Linux发行版（如Debian, Ubuntu, RHEL）的默认文件系统，并且在Android设备的数据分区中也扮演着核心角色。<br>因此，<code>fs/ext4/super.c</code> 是内核中<strong>关键的基础设施代码</strong>。虽然大规模的新功能开发已经放缓，但它仍然受到持续的维护，包括性能优化、bug修复以及为适应新硬件而进行的微调。它的稳定运行是数以亿计Linux系统的基石。</p><h3 id="核心原理与设计"><a href="#核心原理与设计" class="headerlink" title="核心原理与设计"></a>核心原理与设计</h3><h4 id="它的核心工作原理是什么？"><a href="#它的核心工作原理是什么？" class="headerlink" title="它的核心工作原理是什么？"></a>它的核心工作原理是什么？</h4><p><code>super.c</code> 的核心工作流程体现在文件系统的<strong>挂载过程</strong>中，主要由<code>ext4_mount()</code>函数驱动：</p><ol><li><strong>读取物理超级块</strong>：从块设备的固定偏移量（通常是1024字节）处读取<code>struct ext4_super_block</code>结构。</li><li><strong>验证魔数</strong>：检查超级块中的<code>s_magic</code>字段是否为<code>EXT4_SUPER_MAGIC</code>。如果不是，则挂载失败。</li><li><strong>特性兼容性检查</strong>：检查超级块中记录的特性标志（<code>s_feature_compat</code>, <code>s_feature_incompat</code>, <code>s_feature_ro_compat</code>）。如果该文件系统启用了当前运行的内核所不理解的“不兼容”特性，则挂载失败。如果启用了内核不理解的“只读兼容”特性，则只能以只读模式挂载。</li><li><strong>分配内存结构</strong>：在内存中分配一个通用的VFS <code>struct super_block</code>对象和一个Ext4私有的<code>struct ext4_sb_info</code>对象，后者用于存放Ext4特有的运行时信息。</li><li><strong>解析与填充</strong>：解析物理超级块中的信息（如块大小、inode大小、块组数量等），并用这些信息填充内存中的<code>super_block</code>和<code>ext4_sb_info</code>结构。</li><li><strong>加载日志（JBD2）</strong>：这是Ext3&#x2F;4的核心步骤。<code>super.c</code>会根据超级块中的日志信息，调用JBD2（Journaling Block Device, version 2）层的函数来找到并加载日志，为文件系统的元数据操作提供事务保护。</li><li><strong>加载根目录</strong>：读取文件系统的根inode（固定为2号inode），并将其设置为VFS <code>super_block</code>的根目录入口点。</li><li><strong>完成挂载</strong>：至此，一个文件系统实例在内存中被成功建立，VFS可以通过这个<code>super_block</code>对象来访问整个文件系统。</li></ol><p><strong>卸载 (<code>put_super</code>)</strong> 过程则相反：确保所有缓存数据被写回（sync），关闭日志，最后释放内存中的所有相关数据结构。</p><h4 id="它的主要优势体现在哪些方面？"><a href="#它的主要优势体现在哪些方面？" class="headerlink" title="它的主要优势体现在哪些方面？"></a>它的主要优势体现在哪些方面？</h4><p>Ext4的优势很大程度上是由<code>super.c</code>在挂载时奠定的基础决定的：</p><ul><li><strong>可靠性和健壮性</strong>：强制性的日志加载和错误处理逻辑（例如，在检测到错误时可以自动以只读模式重新挂载）是其核心优势。</li><li><strong>向后兼容性</strong>：<code>super.c</code>中的代码能够智能地识别并挂载旧的Ext2和Ext3文件系统，使得系统升级无缝衔接。</li><li><strong>高度可配置</strong>：支持大量的挂载选项（在<code>ext4_fill_super</code>中解析），允许管理员根据工作负载精细调整文件系统的行为。</li><li><strong>可扩展的特性设计</strong>：基于特性标志的设计，使得Ext4可以在不破坏向后兼容性的前提下，平滑地增加新功能。</li></ul><h4 id="它存在哪些已知的劣势、局限性或在特定场景下的不适用性？"><a href="#它存在哪些已知的劣势、局限性或在特定场景下的不适用性？" class="headerlink" title="它存在哪些已知的劣势、局限性或在特定场景下的不适用性？"></a>它存在哪些已知的劣势、局限性或在特定场景下的不适用性？</h4><p>这些劣势主要源于Ext4的根本设计，而<code>super.c</code>必须遵循这些设计：</p><ul><li><strong>非动态元数据</strong>：与Btrfs等现代文件系统不同，Ext4的元数据结构（如块组描述符表）在创建时相对固定，<code>super.c</code>在挂载时必须处理这些静态布局。</li><li><strong>复杂性</strong>：为了支持海量的特性和向后兼容性，挂载路径上的代码逻辑非常复杂，充满了条件判断。</li><li><strong>单设备限制</strong>：<code>super.c</code>的设计是面向单个块设备的，它本身不具备像ZFS或Btrfs那样的内建卷管理和多设备支持能力。</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><h4 id="在哪些具体的业务或技术场景下，它是首选解决方案？"><a href="#在哪些具体的业务或技术场景下，它是首选解决方案？" class="headerlink" title="在哪些具体的业务或技术场景下，它是首选解决方案？"></a>在哪些具体的业务或技术场景下，它是首选解决方案？</h4><p>由于其无与伦比的稳定性和普遍性，Ext4是几乎所有<strong>通用计算场景</strong>下的首选或默认解决方案：</p><ul><li><strong>桌面和服务器操作系统</strong>：作为根文件系统和数据分区，提供了性能和可靠性的最佳平衡。</li><li><strong>虚拟化</strong>：作为虚拟机镜像的内部文件系统，或者作为宿主机上存储这些镜像的文件系统。</li><li><strong>Android设备</strong>：用于<code>/data</code>等关键分区，受益于其稳定性和对扩展属性（用于安全上下文）的良好支持。</li><li><strong>兼容性要求高的场景</strong>：当需要在不同系统间交换数据时，Ext4的普遍支持使其成为一个安全的选择。</li></ul><h4 id="是否有不推荐使用该技术的场景？为什么？"><a href="#是否有不推荐使用该技术的场景？为什么？" class="headerlink" title="是否有不推荐使用该技术的场景？为什么？"></a>是否有不推荐使用该技术的场景？为什么？</h4><ul><li><strong>需要高级卷管理和快照的场景</strong>：对于需要内建快照、多盘RAID、动态卷扩展等高级功能的场景，ZFS和Btrfs是更合适的选择。Ext4需要依赖外部工具（如LVM）来实现类似功能。</li><li><strong>写时复制（CoW）为核心需求的场景</strong>：Btrfs原生的CoW特性使其在某些虚拟机和容器场景中具有优势。Ext4并非CoW文件系统。</li><li><strong>超大规模（PB级）和海量文件</strong>：虽然Ext4支持大容量，但像XFS这样的文件系统通常被认为在处理超大文件和超大规模文件系统时表现更佳。</li></ul><h3 id="对比分析"><a href="#对比分析" class="headerlink" title="对比分析"></a>对比分析</h3><h4 id="请将其-与-其他相似技术-进行详细对比。"><a href="#请将其-与-其他相似技术-进行详细对比。" class="headerlink" title="请将其 与 其他相似技术 进行详细对比。"></a>请将其 与 其他相似技术 进行详细对比。</h4><p>将<code>fs/ext4/super.c</code>的实现与<code>xfs</code>和<code>btrfs</code>的相应<code>super.c</code>进行对比，可以揭示文件系统设计的根本差异。</p><table><thead><tr><th align="left">特性</th><th align="left">fs&#x2F;ext4&#x2F;super.c</th><th align="left">fs&#x2F;xfs&#x2F;xfs_super.c</th><th align="left">fs&#x2F;btrfs&#x2F;super.c</th></tr></thead><tbody><tr><td align="left"><strong>磁盘布局</strong></td><td align="left">基于<strong>静态的块组（Block Groups）</strong>。挂载时读取固定的超级块和块组描述符表。</td><td align="left">基于<strong>动态的分配组（Allocation Groups）</strong>。布局更灵活，扩展性更好。</td><td align="left">完全基于<strong>B-Tree</strong>。所有元数据，包括块的位置，都存储在B-Tree中。挂载时需要遍历树来找到所有设备和元数据。</td></tr><tr><td align="left"><strong>日志机制</strong></td><td align="left">使用<strong>JBD2</strong>，一个独立的、通用的日志层。默认只记录元数据。</td><td align="left">内建的<strong>日志子系统</strong>，与XFS紧密集成，性能高度优化，也是元数据日志。</td><td align="left"><strong>不使用传统日志</strong>。依赖**写时复制（CoW）**机制来保证原子性和一致性。</td></tr><tr><td align="left"><strong>核心数据结构</strong></td><td align="left"><code>struct ext4_sb_info</code></td><td align="left"><code>struct xfs_mount</code></td><td align="left"><code>struct btrfs_fs_info</code></td></tr><tr><td align="left"><strong>多设备支持</strong></td><td align="left"><strong>无</strong>。只处理单个块设备。</td><td align="left"><strong>无</strong>。与Ext4类似。</td><td align="left"><strong>原生支持</strong>。<code>super.c</code>在挂载时需要扫描并组合多个物理设备来构建一个文件系统实例。</td></tr><tr><td align="left"><strong>特性启用</strong></td><td align="left">通过超级块中的<strong>位掩码特性标志</strong>来启用。</td><td align="left">通过超级块中的版本号和特性标志。</td><td align="left">通过超级块和B-Tree中的特性标志。原生支持子卷、快照等高级概念。</td></tr></tbody></table><h2 id="Ext4-文件系统模块生命周期管理：ext4-init-fs-与-ext4-exit-fs"><a href="#Ext4-文件系统模块生命周期管理：ext4-init-fs-与-ext4-exit-fs" class="headerlink" title="Ext4 文件系统模块生命周期管理：ext4_init_fs 与 ext4_exit_fs"></a>Ext4 文件系统模块生命周期管理：ext4_init_fs 与 ext4_exit_fs</h2><p>本代码片段展示了 Linux 内核中第四代扩展文件系统（Ext4）模块的初始化和退出流程。其核心功能是：在模块加载时 (<code>ext4_init_fs</code>)，按严格的依赖顺序，初始化 ext4 所需的全部核心子系统，包括内存分配器、inode 缓存、sysfs 接口、向后兼容层等，并最终向内核的虚拟文件系统（VFS）层注册 ext4 文件系统类型；在模块卸载时 (<code>ext4_exit_fs</code>)，则以相反的顺序，干净地拆除所有子系统，释放所有资源，并从 VFS 注销。</p><h3 id="实现原理分析"><a href="#实现原理分析" class="headerlink" title="实现原理分析"></a>实现原理分析</h3><p>此代码是内核中一个复杂子系统初始化的典型范例，其设计体现了高度的模块化和严谨的错误处理。</p><ol><li><p><strong>有序的子系统初始化</strong>: <code>ext4_init_fs</code> 不是一个单一的操作，而是一个由十几个独立的子系统初始化函数调用组成的序列。这个顺序至关重要，它遵循了依赖关系，例如：必须先初始化内存相关的子系统（如 <code>init_inodecache</code>, <code>ext4_init_mballoc</code>），然后才能注册依赖这些资源的文件系统本身。</p><ul><li><strong>核心组件</strong>:<ul><li><code>init_inodecache</code>: 创建一个专用的 SLAB 缓存，用于高效分配 <code>ext4_inode_info</code> 结构体。这是性能的关键。</li><li><code>ext4_init_mballoc</code>: 初始化 ext4 的多块分配器（mballoc），这是 ext4 用于在磁盘上寻找和分配空闲数据块的核心算法。</li><li><code>ext4_init_sysfs</code>: 在 sysfs 中创建 ext4 相关的目录和文件，用于监控和调试。</li><li><code>register_filesystem</code>: 这是最后一步的关键调用，它将 <code>ext4_fs_type</code> 结构体注册到 VFS 的全局文件系统链表中，使得用户空间可以通过 <code>mount -t ext4</code> 命令来使用 ext4。</li></ul></li><li><strong>向后兼容</strong>: <code>register_as_ext2</code> 和 <code>register_as_ext3</code> 调用使得 ext4 驱动也能处理 ext2 和 ext3 文件系统的挂载请求，极大地增强了其可用性。</li></ul></li><li><p><strong>健壮的错误处理（Goto 链）</strong>:</p><ul><li><code>ext4_init_fs</code> 函数广泛使用了 <code>goto</code> 语句。这在内核中是一种标准的、推荐的错误处理模式，尤其适用于多步初始化流程。</li><li><strong>原理</strong>: 每当一个初始化步骤 <code>func_N()</code> 失败时，代码会跳转到一个对应的标签 <code>outN</code>。从这个标签开始，会依次执行所有<strong>已经成功</strong>的初始化步骤的逆操作（<code>exit_func_N-1</code>, <code>exit_func_N-2</code>, …）。这种模式确保了无论初始化在哪一步失败，所有已经分配的资源都会被精确、无遗漏地释放掉，避免了资源泄漏。</li></ul></li><li><p><strong>对称的退出逻辑 (<code>ext4_exit_fs</code>)</strong>:</p><ul><li><code>ext4_exit_fs</code> 函数的实现逻辑与 <code>ext4_init_fs</code> 的错误处理路径非常相似。它以大致相反的顺序调用每个子系统的 <code>exit</code> 或 <code>destroy</code> 函数，确保了依赖关系被正确处理（例如，必须先从 VFS <code>unregister_filesystem</code>，才能安全地 <code>destroy_inodecache</code>）。</li></ul></li></ol><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief ext4_init_fs - ext4文件系统模块的初始化函数。</span></span><br><span class="line"><span class="comment"> * @return int: 成功返回0，失败返回相应的错误码。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">ext4_init_fs</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化用于限制挂载时内核消息频率的速率限制器。</span></span><br><span class="line">ratelimit_state_init(&amp;ext4_mount_msg_ratelimit, <span class="number">30</span> * HZ, <span class="number">64</span>);</span><br><span class="line">ext4_li_info = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在编译时或模块加载时检查 ext4 内部标志位定义的一致性。</span></span><br><span class="line">ext4_check_flag_values();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 extent status tree (es) 子系统。</span></span><br><span class="line">err = ext4_init_es();</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 pending aio dio writes 子系统。</span></span><br><span class="line">err = ext4_init_pending();</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> out7;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 post-read processing 子系统。</span></span><br><span class="line">err = ext4_init_post_read_processing();</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> out6;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 page I/O 相关的辅助结构。</span></span><br><span class="line">err = ext4_init_pageio();</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> out5;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 system zone 子系统。</span></span><br><span class="line">err = ext4_init_system_zone();</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> out4;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 sysfs 中创建 ext4 的相关条目。</span></span><br><span class="line">err = ext4_init_sysfs();</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> out3;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化多块分配器 (mballoc)。</span></span><br><span class="line">err = ext4_init_mballoc();</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> out2;</span><br><span class="line"><span class="comment">// 创建 ext4_inode_info 的 SLAB 缓存。</span></span><br><span class="line">err = init_inodecache();</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> out1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 fast-commit 的 dentry 缓存。</span></span><br><span class="line">err = ext4_fc_init_dentry_cache();</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> out05;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册 ext4 驱动以兼容 ext3 文件系统的挂载请求。</span></span><br><span class="line">register_as_ext3();</span><br><span class="line"><span class="comment">// 注册 ext4 驱动以兼容 ext2 文件系统的挂载请求。</span></span><br><span class="line">register_as_ext2();</span><br><span class="line"><span class="comment">// 向 VFS 注册 ext4 文件系统类型。</span></span><br><span class="line">err = register_filesystem(&amp;ext4_fs_type);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 错误处理 goto 链：按初始化的逆序清理已分配的资源。</span></span><br><span class="line">out:</span><br><span class="line">unregister_as_ext2();</span><br><span class="line">unregister_as_ext3();</span><br><span class="line">ext4_fc_destroy_dentry_cache();</span><br><span class="line">out05:</span><br><span class="line">destroy_inodecache();</span><br><span class="line">out1:</span><br><span class="line">ext4_exit_mballoc();</span><br><span class="line">out2:</span><br><span class="line">ext4_exit_sysfs();</span><br><span class="line">out3:</span><br><span class="line">ext4_exit_system_zone();</span><br><span class="line">out4:</span><br><span class="line">ext4_exit_pageio();</span><br><span class="line">out5:</span><br><span class="line">ext4_exit_post_read_processing();</span><br><span class="line">out6:</span><br><span class="line">ext4_exit_pending();</span><br><span class="line">out7:</span><br><span class="line">ext4_exit_es();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief ext4_exit_fs - ext4文件系统模块的退出函数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">ext4_exit_fs</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 销毁 lazyinit 内核线程。</span></span><br><span class="line">ext4_destroy_lazyinit_thread();</span><br><span class="line"><span class="comment">// 注销对 ext2 的兼容处理。</span></span><br><span class="line">unregister_as_ext2();</span><br><span class="line"><span class="comment">// 注销对 ext3 的兼容处理。</span></span><br><span class="line">unregister_as_ext3();</span><br><span class="line"><span class="comment">// 从 VFS 注销 ext4 文件系统类型。</span></span><br><span class="line">unregister_filesystem(&amp;ext4_fs_type);</span><br><span class="line"><span class="comment">// 销毁 fast-commit 的 dentry 缓存。</span></span><br><span class="line">ext4_fc_destroy_dentry_cache();</span><br><span class="line"><span class="comment">// 销毁 inode SLAB 缓存。</span></span><br><span class="line">destroy_inodecache();</span><br><span class="line"><span class="comment">// 退出多块分配器。</span></span><br><span class="line">ext4_exit_mballoc();</span><br><span class="line"><span class="comment">// 移除 sysfs 中的条目。</span></span><br><span class="line">ext4_exit_sysfs();</span><br><span class="line"><span class="comment">// 退出 system zone 子系统。</span></span><br><span class="line">ext4_exit_system_zone();</span><br><span class="line"><span class="comment">// 退出 page I/O 子系统。</span></span><br><span class="line">ext4_exit_pageio();</span><br><span class="line"><span class="comment">// 退出 post-read processing 子系统。</span></span><br><span class="line">ext4_exit_post_read_processing();</span><br><span class="line"><span class="comment">// 退出 extent status tree 子系统。</span></span><br><span class="line">ext4_exit_es();</span><br><span class="line"><span class="comment">// 退出 pending aio dio writes 子系统。</span></span><br><span class="line">ext4_exit_pending();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Remy Card, Stephen Tweedie, Andrew Morton, Andreas Dilger, Theodore Ts&#x27;o and others&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Fourth Extended Filesystem&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">module_init(ext4_init_fs);</span><br><span class="line">module_exit(ext4_exit_fs);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;


&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;fs-ext4-super-c-Ext4文件系统核心-Ext4-Filesystem-Core-文件系统的挂载与生命周期管理&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="linux" scheme="https://wdfk-prog.space/categories/linux/"/>
    
    <category term="fs" scheme="https://wdfk-prog.space/categories/linux/fs/"/>
    
    
    <category term="linux" scheme="https://wdfk-prog.space/tags/linux/"/>
    
    <category term="fs" scheme="https://wdfk-prog.space/tags/fs/"/>
    
  </entry>
  
  <entry>
    <title>mbcache</title>
    <link href="https://wdfk-prog.space/posts/b554c0f0/"/>
    <id>https://wdfk-prog.space/posts/b554c0f0/</id>
    <published>2025-10-07T03:10:42.000Z</published>
    <updated>2025-10-07T03:16:04.099Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>[toc]<br><img src="https://i-blog.csdnimg.cn/direct/3deff6962d9948b5afd2b3f42b6fc1f9.png" alt="在这里插入图片描述"></p><h1 id="fs-mbcache-c-扩展属性块缓存-Extended-Attribute-Block-Cache-加速文件系统元数据访问"><a href="#fs-mbcache-c-扩展属性块缓存-Extended-Attribute-Block-Cache-加速文件系统元数据访问" class="headerlink" title="fs&#x2F;mbcache.c 扩展属性块缓存(Extended Attribute Block Cache) 加速文件系统元数据访问"></a>fs&#x2F;mbcache.c 扩展属性块缓存(Extended Attribute Block Cache) 加速文件系统元数据访问</h1><h3 id="历史与背景"><a href="#历史与背景" class="headerlink" title="历史与背景"></a>历史与背景</h3><h4 id="这项技术是为了解决什么特定问题而诞生的？"><a href="#这项技术是为了解决什么特定问题而诞生的？" class="headerlink" title="这项技术是为了解决什么特定问题而诞生的？"></a>这项技术是为了解决什么特定问题而诞生的？</h4><p><code>fs/mbcache.c</code> 实现了一个通用的、基于内存的缓存，其核心目标是<strong>加速对存储在独立磁盘块中的文件系统元数据的访问</strong>。它专门为**扩展属性（Extended Attributes, xattrs）**的性能优化而设计。</p><p>在许多文件系统（如Ext3, Ext4）中，扩展属性（例如，SELinux的安全上下文、POSIX ACLs、用户自定义的元数据）并不总是与文件的inode存储在一起。当一个文件的xattrs过多或过大时，它们会被存储在一个或多个独立的磁盘块中。如果没有缓存，每次需要读取或写入这些xattrs时，文件系统都必须执行一次额外的、独立的磁盘I&#x2F;O操作。对于元数据密集型的操作（例如，在一个包含大量文件的目录上运行 <code>ls -Z</code>），这会导致显著的性能下降。</p><p><code>mbcache</code> 通过在内存中缓存这些扩展属性块，解决了这个问题。当文件系统需要访问一个xattr块时，它首先查询<code>mbcache</code>。如果命中（hit），则直接从内存中获取，避免了昂贵的磁盘读取。</p><h4 id="它的发展经历了哪些重要的里程碑或版本迭代？"><a href="#它的发展经历了哪些重要的里程碑或版本迭代？" class="headerlink" title="它的发展经历了哪些重要的里程碑或版本迭代？"></a>它的发展经历了哪些重要的里程碑或版本迭代？</h4><p><code>mbcache</code> 是一个相对稳定和成熟的内核组件，其发展历史与支持xattrs的文件系统的演进紧密相连。</p><ul><li><strong>早期引入</strong>：它作为Ext2&#x2F;Ext3文件系统引入xattrs支持时的一个配套性能优化组件被创建。其设计初衷就是提供一个可供多个文件系统复用的通用缓存层。</li><li><strong>设计稳定性</strong>：<code>mbcache</code> 的核心设计（基于哈希表的块查找）从诞生以来没有发生颠覆性的变化。它的演进更多体现在与内核其他部分的集成上，例如：<ul><li>与slab&#x2F;slub内存分配器的集成，以更高效地管理缓存条目的内存。</li><li>与内核的内存回收机制（shrinker）集成，使其能够在系统内存压力大时，主动释放不常用的缓存条目。</li></ul></li><li><strong>通用化</strong>：虽然最初与Ext文件系统紧密相关，但它被设计成一个独立的模块，任何采用类似方式存储元数据的文件系统都可以使用它。</li></ul><h4 id="目前该技术的社区活跃度和主流应用情况如何？"><a href="#目前该技术的社区活跃度和主流应用情况如何？" class="headerlink" title="目前该技术的社区活跃度和主流应用情况如何？"></a>目前该技术的社区活跃度和主流应用情况如何？</h4><p><code>mbcache</code> 是一个非常稳定且仍在被积极使用的内核组件。它不是一个用户直接交互的功能，而是一个对文件系统开发者透明的底层性能优化工具。</p><ul><li><strong>主要用户</strong>：<strong>Ext4文件系统</strong>是<code>mbcache</code>最主要和最广泛的用户。在任何运行Ext4并启用了SELinux或POSIX ACLs的系统上，<code>mbcache</code>都在后台默默地工作。</li><li><strong>成熟度</strong>：该代码库非常成熟，改动很少，通常只涉及细微的bug修复或代码清理。</li></ul><h3 id="核心原理与设计"><a href="#核心原理与设计" class="headerlink" title="核心原理与设计"></a>核心原理与设计</h3><h4 id="它的核心工作原理是什么？"><a href="#它的核心工作原理是什么？" class="headerlink" title="它的核心工作原理是什么？"></a>它的核心工作原理是什么？</h4><p><code>mbcache</code> 的核心是一个<strong>哈希表</strong>，它将**（块设备，块号）**二元组映射到内存中的一个缓存条目。</p><ol><li><strong>数据结构</strong>：<ul><li><code>struct mb_cache</code>：代表一个缓存实例。</li><li><code>struct mb_cache_entry</code>：代表一个缓存条目，它通过哈希表链接起来。每个条目都包含了它所代表的块的设备和块号。</li></ul></li><li><strong>查找流程 (<code>mb_cache_get</code>)</strong>：<ul><li>当一个文件系统（如Ext4）需要读取一个xattr块时，它会调用 <code>mb_cache_get(cache, bdev, block)</code>。</li><li><code>mbcache</code> 会根据块设备和块号计算出一个哈希值，然后在哈希表中查找对应的<code>mb_cache_entry</code>。</li><li><strong>命中 (Hit)</strong>：如果找到了条目，意味着这个块的信息已经在缓存中。<code>mbcache</code> 会返回一个指向该条目的指针。文件系统可以通过这个条目快速找到关联的、已在内存中的<strong>缓冲区头（<code>struct buffer_head</code>）</strong>，从而直接访问块数据，无需I&#x2F;O。</li><li><strong>未命中 (Miss)</strong>：如果没有找到条目，<code>mbcache</code> 返回<code>NULL</code>。文件系统此时必须从磁盘读取该块，在读取成功后，再调用 <code>mb_cache_add()</code> 将这个新块的信息添加到缓存中，以备后续使用。</li></ul></li><li><strong>缓存失效 (<code>mb_cache_invalidate</code>)</strong>：<ul><li>当文件系统修改或删除了一个xattr块时，为了保证数据一致性，它<strong>必须</strong>调用相应的函数来使<code>mbcache</code>中对应的缓存条目失效。这会从哈希表中移除该条目，确保下一次访问会重新从磁盘读取。</li></ul></li><li><strong>内存回收 (Shrinker)</strong>：<ul><li><code>mbcache</code> 本身不实现复杂的LRU等回收策略。它通过向内核注册一个<code>shrinker</code>回调函数来参与内存回收。</li><li>当系统内存不足时，内核的<code>vmscan.c</code>会调用这个<code>shrinker</code>。<code>shrinker</code>会扫描<code>mbcache</code>中的条目，并尝试释放那些当前未被使用的条目，从而回收内存。</li></ul></li></ol><h4 id="它的主要优势体现在哪些方面？"><a href="#它的主要优势体现在哪些方面？" class="headerlink" title="它的主要优势体现在哪些方面？"></a>它的主要优势体现在哪些方面？</h4><ul><li><strong>显著的性能提升</strong>：通过避免对xattr块的重复磁盘读取，极大地降低了元数据密集型操作的延迟。</li><li><strong>代码复用</strong>：为文件系统开发者提供了一个现成的、可靠的缓存解决方案，避免了每个文件系统都重复实现自己的缓存逻辑。</li><li><strong>简单的API</strong>：提供了一组简洁的API（<code>mb_cache_create</code>, <code>mb_cache_destroy</code>, <code>mb_cache_get</code>, <code>mb_cache_add</code> 等），易于集成。</li></ul><h4 id="它存在哪些已知的劣势、局限性或在特定场景下的不适用性？"><a href="#它存在哪些已知的劣势、局限性或在特定场景下的不适用性？" class="headerlink" title="它存在哪些已知的劣势、局限性或在特定场景下的不适用性？"></a>它存在哪些已知的劣势、局限性或在特定场景下的不适用性？</h4><ul><li><strong>内存消耗</strong>：缓存本身会占用一定的内核内存。在内存极度受限的系统上，这可能是一个需要考虑的因素。</li><li><strong>通用性的限制</strong>：它被设计用于缓存<strong>固定大小的块</strong>，并且这些块的内容被视为不透明的数据。它不适用于结构更复杂、需要更精细缓存策略的元数据。</li><li><strong>一致性依赖</strong>：缓存的一致性完全依赖于文件系统驱动程序能否在正确的时间调用失效接口。驱动中的bug可能导致缓存中存在过时的数据。</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><h4 id="在哪些具体的业务或技术场景下，它是首选解决方案？请举-说明。"><a href="#在哪些具体的业务或技术场景下，它是首选解决方案？请举-说明。" class="headerlink" title="在哪些具体的业务或技术场景下，它是首选解决方案？请举_说明。"></a>在哪些具体的业务或技术场景下，它是首选解决方案？请举_说明。</h4><p><code>mbcache</code> 对于<strong>采用将扩展属性存储在独立磁盘块策略的块设备文件系统</strong>来说，是首选的、内建的解决方案。</p><ul><li><strong>Ext3&#x2F;Ext4文件系统</strong>：这是最典型的使用场景。在一个启用了SELinux的系统上，每个文件和目录都有一个<code>security.selinux</code> xattr。当你执行 <code>ls -lZ /usr/bin</code> 时，如果没有<code>mbcache</code>，系统可能需要为该目录下的数千个文件执行数千次额外的磁盘读取来获取SELinux上下文。有了<code>mbcache</code>，这些xattr块在第一次被读取后就会被缓存，后续的访问将极快。</li><li><strong>启用POSIX ACLs</strong>：同样，当大量文件使用POSIX ACLs进行精细的权限控制时，这些ACL信息也存储在xattr中，<code>mbcache</code>会显著加速对这些信息的访问。</li></ul><h4 id="是否有不推荐使用该技术的场景？为什么？"><a href="#是否有不推荐使用该技术的场景？为什么？" class="headerlink" title="是否有不推荐使用该技术的场景？为什么？"></a>是否有不推荐使用该技术的场景？为什么？</h4><p>它不是一个“推荐”或“不推荐”的技术，而是由文件系统的设计决定的。在以下场景中，它<strong>不适用</strong>：</p><ul><li><strong>设计不同的文件系统</strong>：像 XFS 或 Btrfs 这样的现代文件系统，它们有自己更复杂的元数据管理和缓存策略。例如，它们可能会将小的xattrs直接内联存储在inode结构中，或者使用B-tree来管理xattrs，因此它们不使用也不需要通用的<code>mbcache</code>。</li><li><strong>不存储元数据在独立块中的文件系统</strong>：如果一个文件系统的xattrs总是和inode存储在一起，那么读取inode时就已经读取了xattr，自然也就不需要一个独立的缓存机制。</li><li><strong>非块设备文件系统</strong>：<code>mbcache</code> 的设计与块设备和块号紧密相关，不适用于网络文件系统或虚拟文件系统。</li></ul><h3 id="对比分析"><a href="#对比分析" class="headerlink" title="对比分析"></a>对比分析</h3><h4 id="请将其-与-其他相似技术-进行详细对比。"><a href="#请将其-与-其他相似技术-进行详细对比。" class="headerlink" title="请将其 与 其他相似技术 进行详细对比。"></a>请将其 与 其他相似技术 进行详细对比。</h4><p><code>mbcache</code> 最适合与内核的**缓冲区缓存（Buffer Cache）**进行对比，因为它们关系紧密但角色不同。</p><table><thead><tr><th align="left">特性</th><th align="left"><code>mbcache</code> (扩展属性块缓存)</th><th align="left">缓冲区缓存 (Buffer Cache, <code>buffer_head</code>)</th></tr></thead><tbody><tr><td align="left"><strong>功能概述</strong></td><td align="left">一个<strong>索引</strong>或<strong>查找加速器</strong>。它的主要作用是快速判断一个元数据块是否在内存中，并找到它。</td><td align="left">一个通用的<strong>数据容器</strong>。它实际持有从块设备读取的原始数据块内容。</td></tr><tr><td align="left"><strong>缓存内容</strong></td><td align="left">缓存的是<strong>元数据块的元数据</strong>：一个<code>mb_cache_entry</code>，包含了（设备，块号）等信息，并指向一个<code>buffer_head</code>。</td><td align="left">缓存的是<strong>块的实际数据</strong>，存储在一个<code>buffer_head</code>结构及其关联的内存页中。</td></tr><tr><td align="left"><strong>数据结构</strong></td><td align="left">一个专用的、相对简单的<strong>哈希表</strong>。</td><td align="left">更复杂，使用哈希表、LRU链表等来管理所有的<code>buffer_head</code>。</td></tr><tr><td align="left"><strong>关系</strong></td><td align="left"><strong>建立在缓冲区缓存之上</strong>。<code>mbcache</code> 本身不存储块数据，它的命中结果是一个指向已存在于缓冲区缓存中的<code>buffer_head</code>的指针。它使得在庞大的缓冲区缓存中<strong>快速定位</strong>特定类型的块成为可能。</td><td align="left"><strong>基础层</strong>。为所有对块设备的I&#x2F;O提供服务，包括被<code>mbcache</code>索引的块。</td></tr><tr><td align="left"><strong>使用范围</strong></td><td align="left"><strong>特定</strong>。仅被设计用于缓存特定类型的元数据块（主要是xattrs）。</td><td align="left"><strong>通用</strong>。被内核的所有部分用于缓存任何来自块设备的数据，包括超级块、inode表、数据块等。</td></tr></tbody></table><p>总结来说，<code>mbcache</code> 不是缓冲区缓存的替代品，而是它的一个<strong>专用、语义增强的“快速索引”层</strong>。它为文件系统提供了一个更高层次的、基于语义（“这是一个xattr块”）的缓存接口，而其底层实现则完全依赖于通用的缓冲区缓存来存储实际数据。</p><h2 id="元数据块缓存初始化与销毁-mbcache-init-及-mbcache-exit"><a href="#元数据块缓存初始化与销毁-mbcache-init-及-mbcache-exit" class="headerlink" title="元数据块缓存初始化与销毁: mbcache_init 及 mbcache_exit"></a>元数据块缓存初始化与销毁: mbcache_init 及 mbcache_exit</h2><p>本代码片段展示了一个名为 <code>mbcache</code> 的内核模块的生命周期管理。其核心功能是在模块加载时 (<code>mbcache_init</code>)，创建一个专用的 SLAB 缓存池，用于高效地分配和管理 <code>mb_cache_entry</code> 结构体；在模块卸载时 (<code>mbcache_exit</code>)，则负责销毁该缓存池，将所有相关内存资源归还给系统。根据模块描述，这个缓存专门用于文件系统的“元数据块”（Meta block），特别是为了加速对扩展属性（extended attributes）的访问。</p><h3 id="实现原理分析"><a href="#实现原理分析" class="headerlink" title="实现原理分析"></a>实现原理分析</h3><p>此代码是内核中实现专用对象缓存的典型模式，旨在为特定类型的数据结构提供高性能的内存分配服务。</p><ol><li><p><strong>专用 SLAB 缓存 (<code>kmem_cache_create</code>)</strong>:</p><ul><li><code>mbcache_init</code> 函数的核心是 <code>KMEM_CACHE(...)</code> 宏，它是一个对 <code>kmem_cache_create</code> 函数的便捷封装。</li><li><strong>目的</strong>: 内核中会频繁创建和销毁大量相同大小的小型对象（如此处的 <code>mb_cache_entry</code>）。如果每次都使用通用的 <code>kmalloc</code>&#x2F;<code>kfree</code>，不仅效率较低，还容易导致内存碎片。通过创建一个专用的“对象缓存池”（即 SLAB 缓存），内核可以预先分配一组 <code>mb_cache_entry</code> 对象。当需要时，可以直接从这个“热”缓存中快速获取一个；当不再需要时，则快速将其归还。这极大地提升了性能。</li><li><strong><code>SLAB_RECLAIM_ACCOUNT</code> 标志</strong>: 这是一个组合标志：<br>a. <code>SLAB_RECLAIM</code>: 表示这个缓存是“可回收的”。当系统面临内存压力时，内存管理子系统（shrinker）可以通知这个 SLAB 缓存，要求其释放掉一部分未使用的空闲对象，将内存归还给系统。<br>b. <code>SLAB_ACCOUNT</code>: 表示对这个缓存的内存使用情况进行追踪和统计，其信息会出现在 <code>/proc/slabinfo</code> 等接口中，便于开发者进行调试和性能分析。</li></ul></li><li><p><strong>模块生命周期管理</strong>:</p><ul><li><code>module_init(mbcache_init)</code>: 这个宏将 <code>mbcache_init</code> 函数注册为模块的初始化入口点。当内核加载 <code>mbcache</code> 模块时（无论是静态编译进内核在启动时加载，还是后续通过 <code>insmod</code> 动态加载），<code>mbcache_init</code> 函数会被自动调用。</li><li><code>module_exit(mbcache_exit)</code>: 类似地，这个宏将 <code>mbcache_exit</code> 函数注册为模块的退出点。当通过 <code>rmmod</code> 卸载 <code>mbcache</code> 模块时，<code>mbcache_exit</code> 会被调用，执行 <code>kmem_cache_destroy</code> 来安全地销毁之前创建的缓存池，确保没有内存泄漏。</li></ul></li></ol><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief mbcache_init - mbcache 模块的初始化函数。</span></span><br><span class="line"><span class="comment"> * @return int: 成功返回0，失败返回 -ENOMEM。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">mbcache_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 使用 KMEM_CACHE 宏创建一个 SLAB 缓存，用于存储 mb_cache_entry 对象。</span></span><br><span class="line"><span class="comment">// SLAB_RECLAIM_ACCOUNT 标志表示此缓存是可回收的，并且其使用情况会被统计。</span></span><br><span class="line">mb_entry_cache = KMEM_CACHE(mb_cache_entry, SLAB_RECLAIM_ACCOUNT);</span><br><span class="line"><span class="comment">// 如果缓存创建失败 (返回NULL)...</span></span><br><span class="line"><span class="keyword">if</span> (!mb_entry_cache)</span><br><span class="line"><span class="comment">// ...则返回内存不足错误。</span></span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"><span class="comment">// 成功则返回0。</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief mbcache_exit - mbcache 模块的退出函数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">mbcache_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 销毁在模块初始化时创建的 SLAB 缓存，释放所有相关内存。</span></span><br><span class="line">kmem_cache_destroy(mb_entry_cache);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 mbcache_init 注册为模块的初始化函数。</span></span><br><span class="line">module_init(mbcache_init)</span><br><span class="line"><span class="comment">// 将 mbcache_exit 注册为模块的退出函数。</span></span><br><span class="line">module_exit(mbcache_exit)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是标准的模块元数据信息。</span></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Jan Kara &lt;jack@suse.cz&gt;&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Meta block cache (for extended attributes)&quot;</span>); <span class="comment">// 模块功能描述：元数据块缓存（用于扩展属性）</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;

&lt;p&gt;[toc]&lt;br&gt;&lt;img src=&quot;https://i-blog.csdnimg.cn/direct/3deff6962d9948b5afd2b3f42b6fc1f9.png&quot;</summary>
      
    
    
    
    <category term="linux" scheme="https://wdfk-prog.space/categories/linux/"/>
    
    <category term="fs" scheme="https://wdfk-prog.space/categories/linux/fs/"/>
    
    
    <category term="linux" scheme="https://wdfk-prog.space/tags/linux/"/>
    
    <category term="fs" scheme="https://wdfk-prog.space/tags/fs/"/>
    
  </entry>
  
  <entry>
    <title>hweight</title>
    <link href="https://wdfk-prog.space/posts/933a291e/"/>
    <id>https://wdfk-prog.space/posts/933a291e/</id>
    <published>2025-10-07T02:45:26.000Z</published>
    <updated>2025-10-07T02:49:48.378Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>[toc]</p><p><img src="https://i-blog.csdnimg.cn/direct/8faa3439d8df495990042829a8bf7c7e.png" alt="在这里插入图片描述"></p><h1 id="include-asm-generic-bitops-const-hweight-h"><a href="#include-asm-generic-bitops-const-hweight-h" class="headerlink" title="include&#x2F;asm-generic&#x2F;bitops&#x2F;const_hweight.h"></a>include&#x2F;asm-generic&#x2F;bitops&#x2F;const_hweight.h</h1><h1 id="lib-hweight-c"><a href="#lib-hweight-c" class="headerlink" title="lib&#x2F;hweight.c"></a>lib&#x2F;hweight.c</h1><h2 id="软件汉明权重计算：-sw-hweight-系列函数"><a href="#软件汉明权重计算：-sw-hweight-系列函数" class="headerlink" title="软件汉明权重计算：__sw_hweight 系列函数"></a>软件汉明权重计算：__sw_hweight 系列函数</h2><p>本代码片段提供了一组用于计算不同位宽整数（8、16、32、64位）汉明权重（Hamming Weight）的纯软件实现。汉明权重，又称“置位比特计数”（population count），指的是一个二进制数中 ‘1’ 的总个数。这些函数是内核中需要进行位操作统计时的基础工具，其实现采用了高效的、不依赖特定处理器指令的“分治”并行算法。</p><h3 id="实现原理分析"><a href="#实现原理分析" class="headerlink" title="实现原理分析"></a>实现原理分析</h3><p>这些函数的核心是采用了一种经典的分治算法（Divide and Conquer），在对数时间内完成计算，远比逐位检查的方法高效。以 <code>__sw_hweight32</code> 为例，其算法步骤如下：</p><ol><li><p><strong>两比特分组求和</strong>:<br><code>w -= (w &gt;&gt; 1) &amp; 0x55555555;</code></p><ul><li><code>0x55555555</code> 的二进制表示为 <code>01010101...</code>。</li><li><code>(w &gt;&gt; 1) &amp; 0x55555555</code> 的作用是分离出 <code>w</code> 中每两个比特位中的高位。</li><li>将 <code>w</code> 减去这个值，其效果是在每个两比特的“窗口”内，独立地计算出 ‘1’ 的个数。例如，对于两位 <code>b1b0</code>，其计算为 <code>(b1*2 + b0) - b1 = b1 + b0</code>。运算后，<code>w</code> 的每两位存储了原始数值对应位置两位中 ‘1’ 的个数。</li></ul></li><li><p><strong>四比特分组求和</strong>:<br><code>w = (w &amp; 0x33333333) + ((w &gt;&gt; 2) &amp; 0x33333333);</code></p><ul><li><code>0x33333333</code> 的二进制表示为 <code>00110011...</code>。</li><li><code>w &amp; 0x33333333</code> 取出上一步中每四位里的低两位（即第一个两比特分组的和）。</li><li><code>(w &gt;&gt; 2) &amp; 0x33333333</code> 取出高两位（即第二个两比特分组的和）。</li><li>将两者相加，就在每个四比特的窗口内，得到了 ‘1’ 的总数。</li></ul></li><li><p><strong>八比特（字节）分组求和</strong>:<br><code>w = (w + (w &gt;&gt; 4)) &amp; 0x0f0f0f0f;</code></p><ul><li><code>0x0f0f0f0f</code> 的二进制表示为 <code>00001111...</code>。</li><li>此步骤将相邻的两个四比特分组的和相加，得到每个字节（8位）中 ‘1’ 的总数。</li></ul></li><li><p><strong>最终求和（两种策略）</strong>:</p><ul><li><strong>快速乘法器策略 (<code>CONFIG_ARCH_HAS_FAST_MULTIPLIER</code>)</strong>:<br><code>return (w * 0x01010101) &gt;&gt; 24;</code><br>这是一个非常巧妙的技巧。此时 <code>w</code> 的四个字节分别存储了原始数值对应四个字节的汉明权重。将 <code>w</code> 乘以 <code>0x01010101</code>，其效果会将所有字节的和累加到结果的最高字节中。右移24位即可分离出这个最终总和。此方法依赖于一个高效的硬件乘法器。</li><li><strong>移位与加法策略</strong>:<br><code>res = res + (res &gt;&gt; 8); return (res + (res &gt;&gt; 16)) &amp; 0x000000FF;</code><br>这是一种不依赖乘法器的通用方法。它通过移位和加法，先将相邻字节的和累加，再将相邻16位半字的和累加，最终结果会汇集到最低的字节中，通过与 <code>0xFF</code> 相与即可得到。</li></ul></li></ol><p>其他函数如 <code>__sw_hweight16</code> 和 <code>__sw_hweight8</code> 遵循完全相同的算法逻辑，只是使用的位掩码和移位数不同。<code>__sw_hweight64</code> 则根据系统的字长（<code>BITS_PER_LONG</code>）来决定实现方式。</p><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-2.0</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/export.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/bitops.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * hweightN - 返回 N 位字的汉明权重</span></span><br><span class="line"><span class="comment"> * @x: 需要计算权重的字</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 一个数的汉明权重是其中被置位的比特的总数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief __sw_hweight32 - 计算32位无符号整数的汉明权重。</span></span><br><span class="line"><span class="comment"> * @param w: 32位输入值。</span></span><br><span class="line"><span class="comment"> * @return unsigned int: 输入值中&#x27;1&#x27;的个数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> __sw_hweight32(<span class="type">unsigned</span> <span class="type">int</span> w)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 如果目标架构有快速硬件乘法器。</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARCH_HAS_FAST_MULTIPLIER</span></span><br><span class="line"><span class="comment">// 步骤1: 累加每2个比特位的&#x27;1&#x27;。结果存储在2比特的窗口中。</span></span><br><span class="line">w -= (w &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>;</span><br><span class="line"><span class="comment">// 步骤2: 累加每4个比特位的&#x27;1&#x27;。结果存储在4比特的窗口中。</span></span><br><span class="line">w =  (w &amp; <span class="number">0x33333333</span>) + ((w &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line"><span class="comment">// 步骤3: 累加每8个比特位的&#x27;1&#x27;。结果存储在8比特的窗口中（字节）。</span></span><br><span class="line">w =  (w + (w &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0f0f0f0f</span>;</span><br><span class="line"><span class="comment">// 步骤4: 将所有字节的和累加到最高字节，然后返回。</span></span><br><span class="line"><span class="keyword">return</span> (w * <span class="number">0x01010101</span>) &gt;&gt; <span class="number">24</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">// 如果没有快速乘法器，采用移位和加法策略。</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> res = w - ((w &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">res = (res &amp; <span class="number">0x33333333</span>) + ((res &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">res = (res + (res &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0F0F0F0F</span>;</span><br><span class="line"><span class="comment">// 步骤4a: 累加相邻字节。</span></span><br><span class="line">res = res + (res &gt;&gt; <span class="number">8</span>);</span><br><span class="line"><span class="comment">// 步骤4b: 累加相邻半字，最终结果在最低字节，屏蔽后返回。</span></span><br><span class="line"><span class="keyword">return</span> (res + (res &gt;&gt; <span class="number">16</span>)) &amp; <span class="number">0x000000FF</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__sw_hweight32);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief __sw_hweight16 - 计算16位无符号整数的汉明权重。</span></span><br><span class="line"><span class="comment"> * @param w: 16位输入值。</span></span><br><span class="line"><span class="comment"> * @return unsigned int: 输入值中&#x27;1&#x27;的个数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> __sw_hweight16(<span class="type">unsigned</span> <span class="type">int</span> w)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 算法与32位版本相同，但使用16位的掩码和移位数。</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> res = w - ((w &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x5555</span>);</span><br><span class="line">res = (res &amp; <span class="number">0x3333</span>) + ((res &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x3333</span>);</span><br><span class="line">res = (res + (res &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0F0F</span>;</span><br><span class="line"><span class="keyword">return</span> (res + (res &gt;&gt; <span class="number">8</span>)) &amp; <span class="number">0x00FF</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__sw_hweight16);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief __sw_hweight8 - 计算8位无符号整数的汉明权重。</span></span><br><span class="line"><span class="comment"> * @param w: 8位输入值。</span></span><br><span class="line"><span class="comment"> * @return unsigned int: 输入值中&#x27;1&#x27;的个数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> __sw_hweight8(<span class="type">unsigned</span> <span class="type">int</span> w)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 算法与32位版本相同，但使用8位的掩码和移位数。</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> res = w - ((w &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55</span>);</span><br><span class="line">res = (res &amp; <span class="number">0x33</span>) + ((res &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33</span>);</span><br><span class="line"><span class="keyword">return</span> (res + (res &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0F</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__sw_hweight8);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief __sw_hweight64 - 计算64位无符号整数的汉明权重。</span></span><br><span class="line"><span class="comment"> * @param w: 64位输入值。</span></span><br><span class="line"><span class="comment"> * @return unsigned long: 输入值中&#x27;1&#x27;的个数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> __sw_hweight64(__u64 w)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 如果系统是32位架构 (long类型是32位)。</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> BITS_PER_LONG == 32</span></span><br><span class="line"><span class="comment">// 将64位输入拆分为高32位和低32位，分别计算后相加。</span></span><br><span class="line"><span class="keyword">return</span> __sw_hweight32((<span class="type">unsigned</span> <span class="type">int</span>)(w &gt;&gt; <span class="number">32</span>)) +</span><br><span class="line">       __sw_hweight32((<span class="type">unsigned</span> <span class="type">int</span>)w);</span><br><span class="line"><span class="comment">// 如果系统是64位架构 (long类型是64位)。</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> BITS_PER_LONG == 64</span></span><br><span class="line"><span class="comment">// 算法与32位版本相同，但使用64位的掩码和移位数。</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARCH_HAS_FAST_MULTIPLIER</span></span><br><span class="line">w -= (w &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x5555555555555555u</span>l;</span><br><span class="line">w =  (w &amp; <span class="number">0x3333333333333333u</span>l) + ((w &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x3333333333333333u</span>l);</span><br><span class="line">w =  (w + (w &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0f0f0f0f0f0f0f0fu</span>l;</span><br><span class="line"><span class="keyword">return</span> (w * <span class="number">0x0101010101010101u</span>l) &gt;&gt; <span class="number">56</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">__u64 res = w - ((w &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x5555555555555555u</span>l);</span><br><span class="line">res = (res &amp; <span class="number">0x3333333333333333u</span>l) + ((res &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x3333333333333333u</span>l);</span><br><span class="line">res = (res + (res &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0F0F0F0F0F0F0F0Fu</span>l;</span><br><span class="line">res = res + (res &gt;&gt; <span class="number">8</span>);</span><br><span class="line">res = res + (res &gt;&gt; <span class="number">16</span>);</span><br><span class="line"><span class="keyword">return</span> (res + (res &gt;&gt; <span class="number">32</span>)) &amp; <span class="number">0x00000000000000FFu</span>l;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__sw_hweight64);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;

&lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i-blog.csdnimg.cn/direct/8faa3439d8df495990042829a8bf7c7e.</summary>
      
    
    
    
    <category term="linux" scheme="https://wdfk-prog.space/categories/linux/"/>
    
    <category term="lib" scheme="https://wdfk-prog.space/categories/linux/lib/"/>
    
    
    <category term="linux" scheme="https://wdfk-prog.space/tags/linux/"/>
    
    <category term="lib" scheme="https://wdfk-prog.space/tags/lib/"/>
    
  </entry>
  
  <entry>
    <title>fcntl</title>
    <link href="https://wdfk-prog.space/posts/b4dd5ab6/"/>
    <id>https://wdfk-prog.space/posts/b4dd5ab6/</id>
    <published>2025-10-07T02:39:55.000Z</published>
    <updated>2025-10-07T02:48:41.551Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>[toc]</p><h1 id="fs-fcntl-c-文件控制-File-Control-管理文件锁和文件描述符属性"><a href="#fs-fcntl-c-文件控制-File-Control-管理文件锁和文件描述符属性" class="headerlink" title="fs&#x2F;fcntl.c 文件控制(File Control) 管理文件锁和文件描述符属性"></a>fs&#x2F;fcntl.c 文件控制(File Control) 管理文件锁和文件描述符属性</h1><p><img src="https://i-blog.csdnimg.cn/direct/f45117ffda1a4c1da66c4bc96646e055.png" alt="在这里插入图片描述"></p><h3 id="历史与背景"><a href="#历史与背景" class="headerlink" title="历史与背景"></a>历史与背景</h3><h4 id="这项技术是为了解决什么特定问题而诞生的？"><a href="#这项技术是为了解决什么特定问题而诞生的？" class="headerlink" title="这项技术是为了解决什么特定问题而诞生的？"></a>这项技术是为了解决什么特定问题而诞生的？</h4><p><code>fs/fcntl.c</code> 实现的 <code>fcntl()</code> 系统调用是为了解决一个基本问题：在文件被打开之后，如何<strong>查询和修改其属性及状态</strong>。标准的 <code>open()</code>, <code>read()</code>, <code>write()</code>, <code>close()</code> 提供了对文件内容的基本I&#x2F;O操作，但现实世界的应用程序需要更精细的控制能力，主要包括：</p><ul><li><strong>并发访问控制</strong>：当多个进程同时访问同一个文件时，如何防止数据损坏？这就需要一种机制来协调访问，即<strong>文件锁（File Locking）</strong>。</li><li><strong>修改描述符行为</strong>：如何将一个阻塞的文件描述符（File Descriptor, FD）变为非阻塞的？如何防止一个打开的FD被子进程继承？这就需要对FD的属性进行管理。</li><li><strong>复制文件描述符</strong>：如何创建一个新的FD，使其指向与现有FD相同的打开文件实例（<code>struct file</code>），例如用于重定向标准输入&#x2F;输出。</li></ul><p><code>fcntl()</code> 被设计成一个多功能的“瑞士军刀”，通过一个单一的系统调用入口，提供了对上述所有问题的标准化解决方案。</p><h4 id="它的发展经历了哪些重要的里程碑或版本迭代？"><a href="#它的发展经历了哪些重要的里程碑或版本迭代？" class="headerlink" title="它的发展经历了哪些重要的里程碑或版本迭代？"></a>它的发展经历了哪些重要的里程碑或版本迭代？</h4><p><code>fcntl()</code> 的历史与POSIX标准的演进紧密相关。</p><ul><li><strong>POSIX 标准化</strong>：<code>fcntl()</code> 成为UNIX世界中进行文件控制的标准接口，定义了 <code>F_DUPFD</code> (复制FD), <code>F_GETFL</code>&#x2F;<code>F_SETFL</code> (获取&#x2F;设置文件状态标志), <code>F_GETLK</code>&#x2F;<code>F_SETLK</code>&#x2F;<code>F_SETLKW</code> (文件锁) 等核心命令。</li><li><strong>原子性的 <code>CLOEXEC</code></strong>：为了解决一个常见的安全问题（在 <code>fork()</code> 和 <code>execve()</code> 之间存在一个时间窗口，可能导致敏感FD泄漏给子进程），内核引入了 <code>F_DUPFD_CLOEXEC</code> 命令和 <code>O_CLOEXEC</code> 标志，允许原子性地创建FD并设置“执行时关闭”属性。</li><li><strong>开放文件描述锁 (Open File Description Locks)</strong>：这是一个<strong>极其重要</strong>的里程碑。在Linux 3.15之前，所有的<code>fcntl</code>锁都是“进程关联锁”，这种锁存在一个重大缺陷：在一个多线程程序中，只要任何一个线程关闭了指向该文件的<strong>任何一个FD</strong>，那么由该<strong>进程</strong>持有的所有锁都会被释放。为了解决这个问题，内核引入了OFD锁（命令以 <code>F_OFD_</code> 开头）。OFD锁与**打开文件描述（<code>struct file</code>）**本身相关联，而不是进程。只要至少还有一个FD指向这个打开文件描述，锁就会保持有效，这极大地简化了多线程程序的锁管理。</li></ul><h4 id="目前该技术的社区活跃度和主流应用情况如何？"><a href="#目前该技术的社区活跃度和主流应用情况如何？" class="headerlink" title="目前该技术的社区活跃度和主流应用情况如何？"></a>目前该技术的社区活跃度和主流应用情况如何？</h4><p><code>fcntl()</code> 是Linux VFS（虚拟文件系统）层一个极其稳定和基础的部分。它被几乎所有需要进行高级文件操作的应用程序所使用：</p><ul><li><strong>数据库</strong>：SQLite、PostgreSQL等数据库使用<code>fcntl</code>锁来管理对数据库文件的并发写访问，确保事务的原子性和隔离性。</li><li><strong>系统服务</strong>：许多后台守护进程通过对PID文件（pidfile）加锁来确保系统中只有一个实例在运行。</li><li><strong>网络服务器</strong>：Nginx、Apache等高性能服务器使用 <code>fcntl(fd, F_SETFL, O_NONBLOCK)</code> 将套接字设置为非阻塞模式，这是实现高效事件驱动I&#x2F;O（epoll）的基础。</li></ul><h3 id="核心原理与设计"><a href="#核心原理与设计" class="headerlink" title="核心原理与设计"></a>核心原理与设计</h3><h4 id="它的核心工作原理是什么？"><a href="#它的核心工作原理是什么？" class="headerlink" title="它的核心工作原理是什么？"></a>它的核心工作原理是什么？</h4><p><code>fs/fcntl.c</code> 的核心是一个大型的 <code>switch</code> 语句，它根据用户传入的 <code>cmd</code> 参数来分发到不同的处理逻辑。</p><ul><li><p><strong>文件描述符操作 (<code>F_DUPFD</code>, <code>F_SETFD</code>, <code>F_GETFD</code>)</strong>：</p><ul><li>这些操作主要与进程的文件描述符表（<code>current-&gt;files</code>，一个 <code>struct files_struct</code>）交互。</li><li><code>F_DUPFD</code> 会在该表中查找一个未使用的最小FD号，并使其指向与源FD相同的 <code>struct file</code>（打开文件描述）。</li><li><code>F_GETFD</code>&#x2F;<code>F_SETFD</code> 用于管理 <code>FD_CLOEXEC</code> 标志，这个标志位存储在文件描述符表中，而不是<code>struct file</code>里。</li></ul></li><li><p><strong>文件状态标志操作 (<code>F_GETFL</code>, <code>F_SETFL</code>)</strong>：</p><ul><li>这些操作直接读取或修改与<strong>打开文件描述</strong>相关联的 <code>f_flags</code> 成员（在 <code>struct file</code> 中）。</li><li>例如，设置 <code>O_NONBLOCK</code> 会改变后续对这个 <code>struct file</code> 进行 <code>read</code>&#x2F;<code>write</code> 操作的行为。</li></ul></li><li><p><strong>文件锁操作 (<code>F_GETLK</code>, <code>F_SETLK(W)</code>, <code>F_OFD_...</code>)</strong>：</p><ul><li>这是最复杂的部分。锁的信息被存储在一个 <code>struct file_lock</code> 结构中，并被挂载到文件的 <code>inode</code> 上（<code>inode-&gt;i_flock</code> 链表）。</li><li>当一个加锁请求到达时，内核会遍历该inode的锁链表，检查是否存在与请求范围（offset, length）和类型（读&#x2F;写锁）相冲突的锁。</li><li><strong>进程关联锁 (Traditional)</strong>：<code>struct file_lock</code> 的所有者 (<code>fl_owner</code>) 指向一个进程。锁的生命周期与进程绑定。</li><li><strong>OFD锁 (Modern)</strong>：<code>struct file_lock</code> 的所有者 (<code>fl_owner</code>) 指向一个 <code>struct file</code>。锁的生命周期与打开文件描述绑定。</li></ul></li></ul><h4 id="它的主要优势体现在哪些方面？"><a href="#它的主要优势体现在哪些方面？" class="headerlink" title="它的主要优势体现在哪些方面？"></a>它的主要优势体现在哪些方面？</h4><ul><li><strong>标准化和可移植性</strong>：作为POSIX标准的一部分，<code>fcntl</code>提供了跨UNIX-like系统的可移植并发控制和文件属性管理能力。</li><li><strong>灵活性</strong>：单一系统调用提供了丰富的功能。特别是其字节范围锁（byte-range locking）能力，允许不同进程对同一文件的不同部分独立加锁。</li><li><strong>强大的并发模型</strong>：OFD锁的引入，为现代多线程应用程序提供了一个健壮、符合直觉的锁模型。</li></ul><h4 id="它存在哪些已知的劣势、局限性或在特定场景下的不适用性？"><a href="#它存在哪些已知的劣势、局限性或在特定场景下的不适用性？" class="headerlink" title="它存在哪些已知的劣势、局限性或在特定场景下的不适用性？"></a>它存在哪些已知的劣势、局限性或在特定场景下的不适用性？</h4><ul><li><strong>劝告式锁 (Advisory Locking)</strong>：默认情况下，<code>fcntl</code>锁是“劝告式”的。这意味着它们只对那些<strong>同样使用<code>fcntl</code>检查锁</strong>的“合作”进程有效。一个不检查锁的进程仍然可以对锁定的文件区域进行读写，内核不会阻止。虽然Linux支持强制式锁（Mandatory Locking），但它很少被使用且通常不被推荐。</li><li><strong>复杂性</strong>：进程关联锁和OFD锁的区别、文件描述符标志和文件状态标志的区别，都可能给开发者带来困惑。</li><li><strong>网络文件系统（NFS）上的行为</strong>：在NFS上，锁的实现依赖于网络锁管理器（NLM）协议，其语义和性能可能与本地文件系统有所不同，且可能更弱。</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><h4 id="在哪些具体的业务或技术场景下，它是首选解决方案？请举例说明。"><a href="#在哪些具体的业务或技术场景下，它是首选解决方案？请举例说明。" class="headerlink" title="在哪些具体的业务或技术场景下，它是首选解决方案？请举例说明。"></a>在哪些具体的业务或技术场景下，它是首选解决方案？请举例说明。</h4><ul><li><strong>保证单实例应用</strong>：一个服务程序在启动时，可以尝试对一个固定的锁文件（如<code>/var/run/app.lock</code>）获取一个排他性的、覆盖整个文件的写锁。如果加锁成功，则程序继续运行；如果失败（意味着锁已被其他进程持有），则程序退出，从而保证了只有一个实例在运行。</li><li><strong>数据库记录级锁定</strong>：一个简单的文件型数据库，当需要更新文件中的某条记录时，可以对该记录所在的字节范围（例如，从偏移量1024开始，长度为128字节）施加一个写锁。这允许其他进程同时读取或更新文件的其他部分。</li><li><strong>实现非阻塞I&#x2F;O</strong>：一个基于<code>epoll</code>的Web服务器，在接受一个新的客户端连接后，会立即使用<code>fcntl(client_fd, F_SETFL, O_NONBLOCK)</code>将代表该连接的socket设置为非阻塞模式，然后将其加入<code>epoll</code>的监听集合中。</li></ul><h4 id="是否有不推荐使用该技术的场景？为什么？"><a href="#是否有不推荐使用该技术的场景？为什么？" class="headerlink" title="是否有不推荐使用该技术的场景？为什么？"></a>是否有不推荐使用该技术的场景？为什么？</h4><ul><li><strong>替代<code>ioctl</code></strong>：<code>fcntl</code> 用于通用的、文件系统无关的操作。对于设备特定的控制（例如，设置串口波特率、获取摄像头参数），应该使用<code>ioctl</code>。</li><li><strong>替代<code>inotify</code></strong>：<code>fcntl</code> 提供了 <code>F_NOTIFY</code> 功能用于目录变更通知，但它是一个陈旧且功能有限的接口（dnotify）。对于现代的文件系统事件监控需求，功能更强大、更高效的<code>inotify</code>是唯一正确的选择。</li></ul><h3 id="对比分析"><a href="#对比分析" class="headerlink" title="对比分析"></a>对比分析</h3><h4 id="请将其-与-其他相似技术-进行详细对比。"><a href="#请将其-与-其他相似技术-进行详细对比。" class="headerlink" title="请将其 与 其他相似技术 进行详细对比。"></a>请将其 与 其他相似技术 进行详细对比。</h4><p><strong><code>fcntl()</code> vs. <code>flock()</code></strong></p><table><thead><tr><th align="left">特性</th><th align="left"><code>fcntl()</code></th><th align="left"><code>flock()</code></th></tr></thead><tbody><tr><td align="left"><strong>标准</strong></td><td align="left"><strong>POSIX 标准</strong></td><td align="left">BSD 来源，Linux也支持</td></tr><tr><td align="left"><strong>锁粒度</strong></td><td align="left"><strong>字节范围锁 (Byte-range locking)</strong></td><td align="left"><strong>文件级锁 (Whole-file locking)</strong></td></tr><tr><td align="left"><strong>锁关联</strong></td><td align="left">进程关联 或 <strong>OFD</strong> (Open File Description)</td><td align="left"><strong>OFD</strong> (Open File Description)</td></tr><tr><td align="left"><strong>死锁检测</strong></td><td align="left">内核可以检测并返回<code>EDEADLK</code>错误</td><td align="left">不会检测死锁</td></tr><tr><td align="left"><strong>继承性</strong></td><td align="left">锁<strong>不会</strong>被<code>fork()</code>出的子进程继承</td><td align="left">锁<strong>不会</strong>被<code>fork()</code>出的子进程继承</td></tr><tr><td align="left"><strong>NFS支持</strong></td><td align="left">通常支持良好</td><td align="left">支持可能不佳或行为不一致</td></tr><tr><td align="left"><strong>使用场景</strong></td><td align="left">需要对文件不同部分进行精细控制的场景（如数据库）。</td><td align="left">简单的、对整个文件进行独占或共享访问的场景。</td></tr></tbody></table><p><strong><code>fcntl()</code> vs. <code>ioctl()</code></strong></p><table><thead><tr><th align="left">特性</th><th align="left"><code>fcntl()</code></th><th align="left"><code>ioctl()</code></th></tr></thead><tbody><tr><td align="left"><strong>功能范围</strong></td><td align="left"><strong>通用的、标准化的</strong>文件&#x2F;FD操作。</td><td align="left"><strong>设备或文件系统特定的</strong>、非标准化的操作。</td></tr><tr><td align="left"><strong>可移植性</strong></td><td align="left"><strong>高</strong>。命令（如 <code>F_SETLK</code>）在所有POSIX系统上意义相同。</td><td align="left"><strong>低</strong>。命令码（<code>cmd</code>）的含义完全由具体驱动定义，不可移植。</td></tr><tr><td align="left"><strong>适用对象</strong></td><td align="left">任何文件描述符（文件、套接字、管道等）。</td><td align="left">主要用于字符设备、块设备等可以执行特殊命令的对象。</td></tr></tbody></table><h2 id="fcntl-初始化及-FASYNC-缓存创建：fcntl-init"><a href="#fcntl-初始化及-FASYNC-缓存创建：fcntl-init" class="headerlink" title="fcntl 初始化及 FASYNC 缓存创建：fcntl_init"></a>fcntl 初始化及 FASYNC 缓存创建：fcntl_init</h2><p>本代码片段展示了 Linux 内核文件控制（<code>fcntl</code>）子系统的一个初始化例程 <code>fcntl_init</code>。其核心功能有两点：第一，在内核编译时，通过一个静态断言（<code>BUILD_BUG_ON</code>）来校验文件打开标志位（<code>open flags</code>）定义的唯一性和完整性，确保底层 ABI 的正确性；第二，在内核启动时，创建一个专用的 SLAB 缓存（<code>kmem_cache</code>），用于高效地分配和释放 <code>fasync_struct</code> 结构体，该结构体是实现文件描述符异步 I&#x2F;O 通知（<code>FASYNC</code>）机制的基础。</p><h3 id="实现原理分析"><a href="#实现原理分析" class="headerlink" title="实现原理分析"></a>实现原理分析</h3><ol><li><p><strong>编译时标志位校验 (<code>BUILD_BUG_ON</code>)</strong>:</p><ul><li>这行代码是保证内核健壮性的一个典型范例，它在编译阶段而非运行阶段检查系统常量的一致性。</li><li><strong>核心技巧</strong>: 它使用 <code>HWEIGHT32</code> 宏（计算32位整数中置1比特位的数量，即汉明权重）来统计所有有效的、唯一的 <code>open()</code> 标志位的数量。</li><li><strong>表达式解析</strong>:<br>a. <code>VALID_OPEN_FLAGS &amp; ~(O_NONBLOCK | O_NDELAY)</code>: 从所有有效标志位的集合 <code>VALID_OPEN_FLAGS</code> 中，移除 <code>O_NONBLOCK</code> 和 <code>O_NDELAY</code> 这两个特例标志。注释解释了这是因为它们在不同平台上的定义可能重叠或特殊。<br>b. <code>... | __FMODE_EXEC</code>: 将内部使用的执行模式标志 <code>__FMODE_EXEC</code> 添加回集合中进行计数。<br>c. <code>20 - 1</code>: 这个魔法数字代表了期望的标志位总数。<code>-1</code> 是因为 <code>O_RDONLY</code> 的值通常为0，它不包含置1的比特位，因此 <code>HWEIGHT32</code> 无法统计到它，需要手动在总数中减去。</li><li><strong>最终目的</strong>: 这行代码断言，经过处理后的标志位集合中，置1的比特位必须恰好有19个。如果开发者在添加新的文件标志时忘记更新这里的数字，或者某个平台的体系结构定义了冲突的标志位，内核编译将会失败。这强制保证了文件访问模式标志的唯一性和跨平台的一致性。</li></ul></li><li><p><strong>SLAB 缓存创建 (<code>kmem_cache_create</code>)</strong>:</p><ul><li>这是内核内存管理的核心实践。对于内核中会频繁分配和释放的同尺寸小型对象（如此处的 <code>fasync_struct</code>），使用 <code>kmalloc</code> 会导致内存碎片和较大的管理开销。</li><li><code>kmem_cache_create</code> 创建了一个专门用于 <code>fasync_struct</code> 对象的“对象缓存池”。当内核需要一个新的 <code>fasync_struct</code> 时，它可以直接从这个预先分配好的缓存池中快速获取，使用完毕后也快速归还。这极大地提高了性能并减少了内存碎片。</li><li><code>SLAB_PANIC</code>: 这个标志意味着如果从该缓存中分配内存失败，内核将立即崩溃（panic）。这表明 <code>fasync_struct</code> 被认为是系统核心功能的一部分，无法分配它是一个不可恢复的严重错误。</li><li><code>SLAB_ACCOUNT</code>: 启用额外的 slab 统计，便于调试和分析内存使用情况。</li></ul></li></ol><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个指向 kmem_cache 结构体的指针，用于管理 fasync_struct 对象的分配。</span></span><br><span class="line"><span class="comment">// __ro_after_init 属性表示该指针在内核初始化之后将变为只读。</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">fasync_cache</span> __<span class="title">ro_after_init</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief fcntl_init - fcntl子系统的初始化函数。</span></span><br><span class="line"><span class="comment"> * @return int: 始终返回0，表示成功。</span></span><br><span class="line"><span class="comment"> * @note 此函数使用 module_init 宏注册，在内核启动时被调用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">fcntl_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 请在此处添加新的比特位以确保分配的唯一性。</span></span><br><span class="line"><span class="comment"> * 例外：O_NONBLOCK 在 parisc 架构上是一个两位定义；O_NDELAY</span></span><br><span class="line"><span class="comment"> * 在某些平台上被定义为 O_NONBLOCK，而在其他平台上则没有。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 这是一个编译时断言，用于检查文件打开标志位的定义是否符合预期。</span></span><br><span class="line"><span class="comment">// 它计算所有有效标志位的汉明权重（置1比特位的数量），并确保其等于一个期望值。</span></span><br><span class="line"><span class="comment">// 如果检查失败，内核编译将中止。</span></span><br><span class="line">BUILD_BUG_ON(<span class="number">20</span> - <span class="number">1</span> <span class="comment">/* O_RDONLY 的值为0，因此从总数中减1 */</span> !=</span><br><span class="line">HWEIGHT32(</span><br><span class="line"><span class="comment">// 从所有有效打开标志中移除 O_NONBLOCK 和 O_NDELAY 这两个特例。</span></span><br><span class="line">(VALID_OPEN_FLAGS &amp; ~(O_NONBLOCK | O_NDELAY)) |</span><br><span class="line"><span class="comment">// 将内部的执行模式标志包含进来一起计数。</span></span><br><span class="line">__FMODE_EXEC));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个名为 &quot;fasync_cache&quot; 的 SLAB 缓存。</span></span><br><span class="line">fasync_cache = kmem_cache_create(<span class="string">&quot;fasync_cache&quot;</span>,</span><br><span class="line"> <span class="comment">// 每个对象的大小为 fasync_struct 结构体的大小。</span></span><br><span class="line"> <span class="keyword">sizeof</span>(<span class="keyword">struct</span> fasync_struct), <span class="number">0</span>,</span><br><span class="line"> <span class="comment">// 标志位：SLAB_PANIC 表示分配失败则内核崩溃，</span></span><br><span class="line"> <span class="comment">// SLAB_ACCOUNT 表示启用额外的内存统计。</span></span><br><span class="line"> SLAB_PANIC | SLAB_ACCOUNT, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 fcntl_init 函数注册为内核的一个初始化模块。</span></span><br><span class="line">module_init(fcntl_init)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;

&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;fs-fcntl-c-文件控制-File-Control-管理文件锁和文件描述符属性&quot;&gt;&lt;a href=&quot;#fs-fcntl-c-文件控制-F</summary>
      
    
    
    
    <category term="linux" scheme="https://wdfk-prog.space/categories/linux/"/>
    
    <category term="fs" scheme="https://wdfk-prog.space/categories/linux/fs/"/>
    
    
    <category term="linux" scheme="https://wdfk-prog.space/tags/linux/"/>
    
    <category term="fs" scheme="https://wdfk-prog.space/tags/fs/"/>
    
  </entry>
  
  <entry>
    <title>workingset</title>
    <link href="https://wdfk-prog.space/posts/0/"/>
    <id>https://wdfk-prog.space/posts/0/</id>
    <published>2025-10-07T01:50:14.000Z</published>
    <updated>2025-10-07T02:37:46.787Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>[toc]</p><p><img src="https://i-blog.csdnimg.cn/direct/a68fec7b405d47f4900401898a1f4faf.png" alt="在这里插入图片描述"></p><h1 id="mm-workingset-c-工作集检测-Working-Set-Detection-提升页面回收效率的热点内存识别机制"><a href="#mm-workingset-c-工作集检测-Working-Set-Detection-提升页面回收效率的热点内存识别机制" class="headerlink" title="mm&#x2F;workingset.c 工作集检测(Working Set Detection) 提升页面回收效率的热点内存识别机制"></a>mm&#x2F;workingset.c 工作集检测(Working Set Detection) 提升页面回收效率的热点内存识别机制</h1><h3 id="历史与背景"><a href="#历史与背景" class="headerlink" title="历史与背景"></a>历史与背景</h3><h4 id="这项技术是为了解决什么特定问题而诞生的？"><a href="#这项技术是为了解决什么特定问题而诞生的？" class="headerlink" title="这项技术是为了解决什么特定问题而诞生的？"></a>这项技术是为了解决什么特定问题而诞生的？</h4><p><code>mm/workingset.c</code> 中的代码是为了解决传统页面回收算法（如<code>vmscan.c</code>中的两阶段LRU）的一个核心痛点：<strong>无法精确区分真正的“工作集”和短暂的、非核心的内存使用</strong>。</p><p>工作集（Working Set）指的是一个进程在当前阶段为了高效运行而需要频繁访问的内存页面集合。传统LRU算法通过<code>active</code>&#x2F;<code>inactive</code>链表来近似这个集合，但存在以下问题：</p><ul><li><strong>抖动（Thrashing）</strong>：当内存压力增大时，一个暂时不活动的进程（例如，用户切换到了另一个窗口），其工作集页面可能会被从<code>active</code>链表老化到<code>inactive</code>链表，并最终被回收。当用户切回该进程时，进程会遭遇大量的缺页中断（page faults），需要从磁盘或交换空间重新读取其工作集，导致系统响应缓慢，磁盘I&#x2F;O飙升。<code>workingset.c</code> 的核心目标就是<strong>识别并保护这些被错误回收的工作集页面</strong>，从而抑制抖动。</li><li><strong>无法区分不同原因的缺页中断</strong>：内核无法轻易区分一个缺页中断是因为访问一个全新的页面（如首次读取文件），还是因为访问一个刚刚被回收的、本应属于工作集的页面。<code>workingset.c</code>提供了一种机制来做出这种区分。</li></ul><h4 id="它的发展经历了哪些重要的里程碑或版本迭代？"><a href="#它的发展经历了哪些重要的里程碑或版本迭代？" class="headerlink" title="它的发展经历了哪些重要的里程碑或版本迭代？"></a>它的发展经历了哪些重要的里程碑或版本迭代？</h4><p><code>workingset.c</code> 的实现是由内核开发者 Johannes Weiner 引入的，是对传统LRU机制的一次重要增强。其核心创新是引入了**“影子条目”（Shadow Entries）**机制。</p><ul><li><strong>概念提出与实现</strong>：该机制被设计为一种低开销的方式，用于在页面被从LRU链表中换出后，继续“追踪”它一小段时间。</li><li><strong>与<code>vmscan.c</code>的集成</strong>：<code>workingset.c</code> 的代码被深度集成到<code>vmscan.c</code>的页面回收路径和<code>mm/memory.c</code>的缺页中断处理路径中。它不是一个独立的算法，而是对现有算法的一个“插件式”增强。</li></ul><h4 id="目前该技术的社区活跃度和主流应用情况如何？"><a href="#目前该技术的社区活跃度和主流应用情况如何？" class="headerlink" title="目前该技术的社区活跃度和主流应用情况如何？"></a>目前该技术的社区活跃度和主流应用情况如何？</h4><p>工作集检测是当前Linux内核内存管理中一项标准的、默认开启的基础功能。它不是一个可选模块，而是内存管理子系统不可或-的一部分。它的效果体现在所有现代Linux系统中，尤其是在以下场景中：</p><ul><li><strong>桌面和移动环境（如Android）</strong>：用户频繁地在多个应用之间切换，工作集保护机制对于保持系统流畅响应至关重要。</li><li><strong>内存过载（Over-committed）的服务器</strong>：在虚拟化和容器环境中，物理内存经常被超额分配。精确的工作集检测可以帮助内核在回收内存时做出更明智的决策，避免杀死错误的进程或导致关键服务性能下降。</li></ul><h3 id="核心原理与设计"><a href="#核心原理与设计" class="headerlink" title="核心原理与设计"></a>核心原理与设计</h3><h4 id="它的核心工作原理是什么？"><a href="#它的核心工作原理是什么？" class="headerlink" title="它的核心工作原理是什么？"></a>它的核心工作原理是什么？</h4><p><code>workingset.c</code> 的核心是巧妙的**“影子条目”**机制，它像是一个页面的“墓碑”，记录了一个页面刚刚“死亡”（被回收）的事实。</p><ol><li><strong>创建影子条目</strong>：当页面回收器（<code>vmscan.c</code>）决定从<code>inactive</code> LRU链表中回收一个页面时，它<strong>不会</strong>立即完全忘记这个页面。相反，它会在一个特殊的数据结构——基于Radix Tree的<code>page_owner</code>中，为这个页面创建一个<strong>影子条目</strong>。这个影子条目非常小，只包含足够识别该页面的信息（不包含数据），因此内存开销很低。</li><li><strong>处理缺页中断</strong>：稍后，如果一个进程试图访问这个刚刚被回收的页面，就会触发一个缺页中断。</li><li><strong>检查影子条目</strong>：在处理缺页中断的路径上，内核会调用<code>workingset_refault()</code>函数。这个函数会检查刚才发生中断的页面地址是否存在对应的<strong>影子条目</strong>。</li><li><strong>做出决策</strong>：<ul><li><strong>情况A：存在影子条目（Refault）</strong>：这是一个强烈的信号，表明这个页面是<strong>工作集的一部分</strong>！因为它刚被回收就立即被再次需要。内核会认为这次缺页中断是一次“再激活”（refault）。作为奖励，当这个页面被重新读入内存时，它会被<strong>直接放入<code>active</code> LRU链表的头部</strong>，绕过了<code>inactive</code>链表。这可以有效防止该页面在下一次回收扫描中被立即再次回收，从而打破了抖动的恶性循环。之后，这个影子条目被移除。</li><li><strong>情况B：不存在影子条目（Cold Fault）</strong>：这表明这是一次真正的“冷”缺页中断，例如进程在访问一个全新的、之前从未访问过的页面。这个页面会按照标准流程被放入<code>inactive</code> LRU链表的头部。</li></ul></li></ol><p>通过统计“再激活”的次数和频率，内核还能对一个进程或整个系统的工作集大小和活跃度进行更精确的评估。</p><h4 id="它的主要优势体现在哪些方面？"><a href="#它的主要优势体现在哪些方面？" class="headerlink" title="它的主要优势体现在哪些方面？"></a>它的主要优势体现在哪些方面？</h4><ul><li><strong>抑制抖动</strong>：核心优势。通过快速识别和保护被错误回收的工作集页面，显著提高了系统在内存压力下的响应速度。</li><li><strong>提高回收效率</strong>：它为页面回收器提供了更准确的“热度”信号，帮助<code>vmscan.c</code>做出更好的回收决策，避免浪费I&#x2F;O在频繁换入换出同一批页面上。</li><li><strong>更好的可观察性</strong>：通过<code>/proc/meminfo</code>中的<code>PgRefault</code>等指标，它为系统管理员提供了观察和诊断内存抖动问题的数据。</li></ul><h4 id="它存在哪些已知的劣势、局限性或在特定场景下的不适用性？"><a href="#它存在哪些已知的劣势、局限性或在特定场景下的不适用性？" class="headerlink" title="它存在哪些已知的劣势、局限性或在特定场景下的不适用性？"></a>它存在哪些已知的劣势、局限性或在特定场景下的不适用性？</h4><ul><li><strong>CPU和内存开销</strong>：虽然影子条目的开销很低，但创建、查找和销毁它们仍然需要消耗一定的CPU时间和内存。在极端的、高频率的回收和缺页场景下，这部分开销可能会变得显著。</li><li><strong>启发式而非完美</strong>：它仍然是一种启发式算法。某些特殊的内存访问模式可能无法从中受益，或者在极少数情况下可能做出错误的判断。</li><li><strong>复杂性</strong>：它为本已极其复杂的内存管理子系统增加了又一层逻辑，使得理解和调试变得更加困难。</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><h4 id="在哪些具体的业务或技术场景下，它是首选解决方案？"><a href="#在哪些具体的业务或技术场景下，它是首选解决方案？" class="headerlink" title="在哪些具体的业务或技术场景下，它是首选解决方案？"></a>在哪些具体的业务或技术场景下，它是首选解决方案？</h4><p>它不是一个“可选方案”，而是内核的内建机制。其正面效果在以下场景中表现得最为明显：</p><ul><li><strong>交互式应用</strong>：如上所述，桌面、IDE、浏览器等，用户在多个任务间切换，工作集保护能确保切换回来的应用能快速恢复响应。</li><li><strong>内存数据库</strong>：当数据库的工作集（如频繁查询的索引和数据）略大于可用内存时，该机制能保护核心数据不被后台的批量操作冲刷出内存。</li><li><strong>Java虚拟机（JVM）</strong>：JVM的垃圾回收（GC）过程可能会导致应用的内存访问模式剧烈变化。工作集检测有助于在GC之后快速恢复应用的性能。</li></ul><h4 id="是否有不推荐使用该技术的场景？为什么？"><a href="#是否有不推荐使用该技术的场景？为什么？" class="headerlink" title="是否有不推荐使用该技术的场景？为什么？"></a>是否有不推荐使用该技术的场景？为什么？</h4><p>不能“不推荐使用”，因为它默认集成且对绝大多数场景有益。但可以理解在哪些场景下其<strong>作用有限</strong>：</p><ul><li><strong>内存充裕的系统</strong>：如果系统几乎没有内存压力，页面回收器很少运行，那么工作集检测机制也大部分时间处于空闲状态。</li><li><strong>内存锁定的应用（硬实时&#x2F;HPC）</strong>：如果一个应用通过<code>mlock()</code>系统调用将其关键数据段锁定在物理内存中，这些内存从一开始就不会参与页面回收，因此工作集检测对这部分内存无效。</li></ul><h3 id="对比分析"><a href="#对比分析" class="headerlink" title="对比分析"></a>对比分析</h3><h4 id="请将其-与-其他相似技术-进行详细对比。"><a href="#请将其-与-其他相似技术-进行详细对比。" class="headerlink" title="请将其 与 其他相似技术 进行详细对比。"></a>请将其 与 其他相似技术 进行详细对比。</h4><p><code>workingset.c</code> 与 <code>vmscan.c</code> 的关系是<strong>协作</strong>而非<strong>竞争</strong>。它不是<code>vmscan.c</code>的替代品，而是它的一个“智能顾问”。</p><table><thead><tr><th align="left">特性</th><th align="left"><code>workingset.c</code> (工作集检测)</th><th align="left"><code>vmscan.c</code> (页面回收器)</th></tr></thead><tbody><tr><td align="left"><strong>角色定位</strong></td><td align="left"><strong>信息提供者（Advisor）</strong></td><td align="left"><strong>决策者和执行者（Executor）</strong></td></tr><tr><td align="left"><strong>核心功能</strong></td><td align="left">通过“影子条目”机制，识别被回收后又立即被访问的页面（refault），从而<strong>判断页面的“热度”</strong>。</td><td align="left">扫描<code>active</code>&#x2F;<code>inactive</code> LRU链表，根据页面的访问状态和类型，<strong>决定并执行页面的回收动作</strong>（丢弃、写回、换出）。</td></tr><tr><td align="left"><strong>工作时机</strong></td><td align="left">在<strong>页面被回收时</strong>创建影子条目，在<strong>缺页中断时</strong>检查影子条目。</td><td align="left">在<strong>内存压力下</strong>（由<code>kswapd</code>或直接回收触发）被激活，开始扫描和回收。</td></tr><tr><td align="left"><strong>交互关系</strong></td><td align="left"><code>vmscan.c</code>在回收页面时调用<code>workingset.c</code>来创建影子条目。缺页中断处理代码调用<code>workingset.c</code>，其结果（是否是refault）会<strong>影响新页面被放入哪个LRU链表</strong>，从而影响<code>vmscan.c</code>未来的决策。</td><td align="left"><code>vmscan.c</code>是页面回收的主导者。它利用<code>workingset.c</code>提供的信息，但最终的回收决策由它自己做出。</td></tr><tr><td align="left"><strong>最终目标</strong></td><td align="left"><strong>提高回收决策的质量</strong>，减少不必要的I&#x2F;O，抑制抖动。</td><td align="left"><strong>释放物理内存</strong>，满足新的内存分配请求，维持系统运行。</td></tr></tbody></table><p><strong>与多代LRU（MGLRU）的对比</strong>：<br>MGLRU是比<code>workingset.c</code>所增强的传统两阶段LRU更进一步的演进。</p><ul><li><strong><code>workingset.c</code></strong> 是对两阶段LRU的一个<strong>补丁式增强</strong>，它在不改变核心LRU扫描逻辑的情况下，通过外部信息（影子条目）来修正其行为。</li><li><strong>MGLRU</strong> 则是一种<strong>全新的页面分类和老化算法</strong>，它用多个“代”（generations）来取代简单的<code>active</code>&#x2F;<code>inactive</code>二分法，试图从根本上更精确地模拟页面的生命周期和热度。可以说，MGLRU在设计上就内化了<code>workingset.c</code>想要解决的问题。</li></ul><h2 id="workingset-init-工作集检测与影子LRU初始化"><a href="#workingset-init-工作集检测与影子LRU初始化" class="headerlink" title="workingset_init: 工作集检测与影子LRU初始化"></a>workingset_init: 工作集检测与影子LRU初始化</h2><p>本代码片段负责初始化内核中一个高级的内存管理特性：<strong>工作集（Working Set）检测</strong>。其核心功能是创建一个“影子LRU” (<code>shadow_nodes</code>) 数据结构和一个相应的 <code>shrinker</code>。这个机制在后台追踪近期被从内存中换出（Evicted）的页面，并监测它们是否被迅速地重新载入（Refault）。通过分析这种“换出-重载”模式，内核可以更智能地判断哪些页面是进程真正活跃使用的工作集，从而在未来做出更优的页面回收决策，避免内存颠簸（Thrashing）。</p><h3 id="实现原理分析"><a href="#实现原理分析" class="headerlink" title="实现原理分析"></a>实现原理分析</h3><p>该机制的实现是内核LRU页面置换算法的一个重要优化，它通过一个轻量级的元数据缓存（影子条目）来获取关于页面访问历史的额外信息。</p><ol><li><p><strong>“换出代价”的量化 (<code>bucket_order</code> 计算)</strong>:</p><ul><li>内核需要一种方法来衡量一个页面被换出后，过了“多久”才被重新载入。这个“多久”不是以时间衡量，而是以期间发生的其他内存分配活动的数量来衡量，这被称为<strong>重载距离（Refault Distance）</strong>。</li><li>为了在一个有限的位宽（<code>BITS_PER_LONG</code>）内记录这个可能非常大的距离，代码采用了一种**分桶（Bucketing）**策略。</li><li><code>timestamp_bits</code> 计算出页标志位中可用于存储时间戳（一个随内存活动递增的计数器）的位数。</li><li><code>max_order</code> 计算出表示系统中总页数所需的位数（即 <code>log2(totalram_pages)</code>）。</li><li>如果总页数太大，以至于重载距离无法直接用 <code>timestamp_bits</code> 来表示（会导致计数器过快回绕），<code>bucket_order</code> 就会被设置为一个正值。它作为一个移位因子，将庞大的重载距离压缩到一个较小的范围内，相当于将连续的距离值分到同一个“桶”里。这是一种以牺牲精度来换取更大测量范围的典型技巧。</li></ul></li><li><p><strong>Shrinker 框架集成</strong>:</p><ul><li>Linux 内核使用 <code>shrinker</code> 机制来统一管理各种可收缩的内存缓存。当系统内存不足时，内核会调用所有已注册的 <code>shrinker</code> 的回调函数来释放内存。</li><li><code>workingset_init</code> 创建了一个专门用于管理“影子条目”元数据的 <code>shrinker</code>。标志 <code>SHRINKER_NUMA_AWARE</code> 和 <code>SHRINKER_MEMCG_AWARE</code> 表明该机制能够感知 NUMA 架构和内存控制组（cgroups），在相应的粒度上进行工作。</li></ul></li><li><p><strong>影子LRU (<code>shadow_nodes</code>)</strong>:</p><ul><li><code>list_lru_init_memcg_key</code> 初始化了核心数据结构 <code>shadow_nodes</code>。这是一个 <code>list_lru</code>，专门用于存储被换出页面的元数据（影子条目），而不是页面本身。</li><li>当一个页面被从页缓存中换出时，内核不会立即丢弃它的所有信息，而是会创建一个小的“影子条目”放入 <code>shadow_nodes</code> 链表中，并记录下当时的“时间戳”。</li><li><code>count_shadow_nodes</code> 和 <code>scan_shadow_nodes</code> 是注册给 <code>shrinker</code> 的回调函数。它们的作用是，当系统内存极度紧张，连存储这些元数据的内存都需要回收时，<code>shrinker</code> 机制会调用它们来清理（释放）最旧的影子条目。</li></ul></li></ol><h3 id="特定场景分析：单核、无MMU的STM32H750平台"><a href="#特定场景分析：单核、无MMU的STM32H750平台" class="headerlink" title="特定场景分析：单核、无MMU的STM32H750平台"></a>特定场景分析：单核、无MMU的STM32H750平台</h3><h4 id="功能相关性：优化-uClinux-的页缓存"><a href="#功能相关性：优化-uClinux-的页缓存" class="headerlink" title="功能相关性：优化 uClinux 的页缓存"></a>功能相关性：优化 uClinux 的页缓存</h4><ul><li>在无 MMU 的 uClinux 系统上，虽然没有匿名页的换出，但**页缓存（Page Cache）**的管理至关重要，尤其是对于从外部 Flash（如 QSPI Flash）执行代码（XIP）或读取数据的场景。</li><li>工作集检测机制在这里的<strong>核心作用</strong>是优化页缓存的替换策略。当 SRAM 不足时，内核需要决定丢弃哪些缓存的页面。如果它错误地丢弃了一个程序马上就要用到的代码页，就会立即引发一次昂贵的从 Flash 重新加载的操作（即“重载”）。</li><li>通过 <code>workingset</code> 机制，内核能够识别出那些被频繁重载的页面，并将它们标记为活跃工作集的一部分，从而在未来的内存回收中倾向于保留它们，而优先回收那些被换出后很久都未被再次访问的“冷”页面。这对于提升应用性能、减少 I&#x2F;O 抖动至关重要。</li></ul><h4 id="平台特性影响"><a href="#平台特性影响" class="headerlink" title="平台特性影响"></a>平台特性影响</h4><ul><li><strong>NUMA 与 Memcg</strong>: STM32H750 是一个典型的 UMA（统一内存访问）平台，并且通常不使用内存控制组。因此，<code>SHRINKER_NUMA_AWARE</code> 和 <code>SHRINKER_MEMCG_AWARE</code> 标志虽然存在，但该机制的实际行为会退化为管理一个单一的、全局的影子 LRU 链表，这完全符合该平台的硬件架构。</li><li><strong><code>bucket_order</code> 计算</strong>: STM32H750 的总内存 <code>totalram_pages()</code> 相对较小。因此，在计算中 <code>max_order</code> 的值会很小，很可能小于 <code>timestamp_bits</code>。这将导致 <code>bucket_order</code> 被设置为 <code>0</code>。这意味着在该平台上，内核可以直接使用高精度的时间戳来计算重载距离，无需进行分桶压缩，这对于内存较小的系统是完全合理的。</li><li><strong>单核并发</strong>: <code>list_lru</code> 内部的锁（<code>list_lru-&gt;lock</code>）是 IRQ 安全的。在单核抢占式内核上，这个锁可以有效防止在更新 <code>shadow_nodes</code> 链表时被中断服务程序打断，从而保证了数据结构的一致性。</li></ul><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 我们的 list_lru-&gt;lock 是 IRQ 安全的，因为它嵌套在同样是 IRQ 安全的</span></span><br><span class="line"><span class="comment"> * i_pages 锁内部。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">shadow_nodes_key</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 工作集检测机制的初始化函数。</span></span><br><span class="line"><span class="comment"> * @return 成功返回0，失败返回负数错误码。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">workingset_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shrinker</span> *<span class="title">workingset_shadow_shrinker</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> timestamp_bits;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> max_order;</span><br><span class="line"><span class="type">int</span> ret = -ENOMEM;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译时检查，确保用于存储时间戳和标志位的 long 类型足够大。</span></span><br><span class="line">BUILD_BUG_ON(BITS_PER_LONG &lt; EVICTION_SHIFT);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 计算换出桶的大小，以覆盖最长的可操作重载距离，</span></span><br><span class="line"><span class="comment"> * 目前该距离是内存的一半 (totalram_pages/2)。然而，内存热插拔</span></span><br><span class="line"><span class="comment"> * 可能会在运行时增加更多页面，因此我们以 totalram_pages 为基准，</span></span><br><span class="line"><span class="comment"> * 这样可以处理高达初始内存两倍的情况。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 计算可用于时间戳的位数。</span></span><br><span class="line">timestamp_bits = BITS_PER_LONG - EVICTION_SHIFT;</span><br><span class="line"><span class="comment">// 计算表示总页数所需的位数 (log2)。</span></span><br><span class="line">max_order = fls_long(totalram_pages() - <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 如果表示总页数所需的位数超过了时间戳的位数，则需要分桶。</span></span><br><span class="line"><span class="keyword">if</span> (max_order &gt; timestamp_bits)</span><br><span class="line"><span class="comment">// bucket_order 是一个移位值，用于压缩重载距离以防止时间戳回绕。</span></span><br><span class="line">bucket_order = max_order - timestamp_bits;</span><br><span class="line">pr_info(<span class="string">&quot;workingset: timestamp_bits=%d max_order=%d bucket_order=%u\n&quot;</span>,</span><br><span class="line">       timestamp_bits, max_order, bucket_order);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配一个 shrinker 实例，用于管理影子节点的元数据。</span></span><br><span class="line"><span class="comment">// SHRINKER_NUMA_AWARE 和 SHRINKER_MEMCG_AWARE 使其能感知 NUMA 和 cgroup。</span></span><br><span class="line">workingset_shadow_shrinker = shrinker_alloc(SHRINKER_NUMA_AWARE |</span><br><span class="line">    SHRINKER_MEMCG_AWARE,</span><br><span class="line">    <span class="string">&quot;mm-shadow&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!workingset_shadow_shrinker)</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化用于存储影子节点的 list_lru 数据结构。</span></span><br><span class="line">ret = list_lru_init_memcg_key(&amp;shadow_nodes, workingset_shadow_shrinker,</span><br><span class="line">      &amp;shadow_nodes_key);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> err_list_lru;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册 shrinker 的回调函数。</span></span><br><span class="line">workingset_shadow_shrinker-&gt;count_objects = count_shadow_nodes; <span class="comment">// 用于计算可收缩对象数量</span></span><br><span class="line">workingset_shadow_shrinker-&gt;scan_objects = scan_shadow_nodes;  <span class="comment">// 用于执行收缩操作</span></span><br><span class="line"><span class="comment">// -&gt;count 只报告完全可丢弃的节点，因此 seeks 设为0，表示扫描开销很小。</span></span><br><span class="line">workingset_shadow_shrinker-&gt;seeks = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向内核注册此 shrinker，使其生效。</span></span><br><span class="line">shrinker_register(workingset_shadow_shrinker);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误处理路径</span></span><br><span class="line">err_list_lru:</span><br><span class="line">shrinker_free(workingset_shadow_shrinker);</span><br><span class="line">err:</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将 workingset_init 注册为模块初始化函数。</span></span><br><span class="line">module_init(workingset_init);</span><br></pre></td></tr></table></figure><h2 id="工作集影子节点-LRU-状态同步：workingset-update-node"><a href="#工作集影子节点-LRU-状态同步：workingset-update-node" class="headerlink" title="工作集影子节点 LRU 状态同步：workingset_update_node"></a>工作集影子节点 LRU 状态同步：workingset_update_node</h2><p>本代码片段定义了工作集（Working Set）检测机制的核心更新函数 <code>workingset_update_node</code>。其主要功能是：在页缓存的 XArray 树节点 (<code>xa_node</code>) 内容发生变化时被调用，动态地判断该节点是否应该被纳入“影子节点 LRU 链表” (<code>shadow_nodes</code>) 的管理之下，并同步更新其在链表中的存在状态以及相关的内核统计计数。</p><h3 id="实现原理分析-1"><a href="#实现原理分析-1" class="headerlink" title="实现原理分析"></a>实现原理分析</h3><p>该函数是工作集检测机制与 <code>list_lru</code> 回收框架之间的关键“胶水”逻辑。它通过一个精确的条件判断，决定一个 <code>xa_node</code> 的生命周期状态。</p><ol><li><p><strong>状态判断条件</strong>: 函数的核心是 <code>if (node-&gt;count &amp;&amp; node-&gt;count == node-&gt;nr_values)</code> 这个条件。</p><ul><li><code>node-&gt;count</code> 记录了 <code>xa_node</code> 中条目的总数（包括实际的页面指针和影子条目）。</li><li><code>node-&gt;nr_values</code> 专门记录了影子条目的数量。</li><li>因此，当且仅当一个节点<strong>非空</strong> (<code>node-&gt;count != 0</code>) 并且其<strong>所有条目都是影子条目</strong>时，这个条件为真。这种节点被称为“纯影子节点”，它不再持有任何有用的页面缓存数据，但其包含的影子条目仍然对工作集检测有价值。然而，这些节点本身占用了内存，因此它们是内存回收的候选对象。</li></ul></li><li><p><strong>动态链表管理</strong>:</p><ul><li>当一个节点<strong>变成</strong>纯影子节点时，<code>workingset_update_node</code> 会检查它是否已在 <code>shadow_nodes</code> 链表上 (<code>list_empty</code>)。如果不在，就通过 <code>list_lru_add_obj</code> 将其加入链表尾部，并增加 <code>WORKINGSET_NODES</code> 计数。</li><li>反之，当一个节点<strong>不再是</strong>纯影子节点时（因为它变为空，或者一个页面被插入其中），函数会检查它是否仍在链表上。如果在，就通过 <code>list_lru_del_obj</code> 将其移除，并减少 <code>WORKINGSET_NODES</code> 计数。</li></ul></li><li><p><strong>锁与同步</strong>:</p><ul><li><code>lockdep_assert_held(&amp;node-&gt;array-&gt;xa_lock)</code> 断言明确指出，调用此函数时必须持有 XArray 的锁（即页缓存的 <code>i_pages</code> 锁）。这个锁保证了在函数执行期间，<code>node-&gt;count</code> 和 <code>node-&gt;nr_values</code> 的值不会被并发修改，从而确保了状态判断的原子性和正确性。</li><li><code>list_empty</code> 检查是在持有 <code>i_pages</code> 锁的情况下进行的，这是安全的。而 <code>list_lru_add_obj</code> 和 <code>list_lru_del_obj</code> 内部会获取 <code>shadow_nodes</code> 自己的自旋锁，实现了对 LRU 链表自身的保护。这种两级锁的策略确保了数据的一致性。</li></ul></li><li><p><strong>优化</strong>: 代码通过 <code>if (list_empty(...))</code> 的预检查，避免了在节点的 LRU 状态已经是期望状态时，去调用 <code>list_lru_add/del_obj</code>，从而减少了不必要的 LRU 锁获取和释放开销。</p></li></ol><h3 id="代码分析-1"><a href="#代码分析-1" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @struct shadow_nodes</span></span><br><span class="line"><span class="comment"> * @brief 一个全局的 list_lru 实例。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这个 LRU 链表专门用于追踪所有“纯影子节点”（即仅包含影子条目的 xa_node）。</span></span><br><span class="line"><span class="comment"> * 当系统内存紧张时，内核的 shrinker 机制会遍历此链表，回收这些节点以释放内存。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_lru</span> <span class="title">shadow_nodes</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief workingset_update_node - 更新一个 xa_node 在影子 LRU 链表中的状态。</span></span><br><span class="line"><span class="comment"> * @param node: 指向被修改的 xa_node 结构体的指针。</span></span><br><span class="line"><span class="comment"> * @note 此函数必须在持有 xa_node 所属 XArray 的锁 (xa_lock/i_pages lock) 的情况下调用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">workingset_update_node</span><span class="params">(<span class="keyword">struct</span> xa_node *node)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 获取 node 结构体所在的物理页的 page 结构体指针，用于更新页状态计数。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> virt_to_page(node);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一个调试断言，确保调用者已经持有了保护此节点的锁。</span></span><br><span class="line">lockdep_assert_held(&amp;node-&gt;<span class="built_in">array</span>-&gt;xa_lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件判断：如果节点非空，并且节点中的总条目数等于影子条目数，</span></span><br><span class="line"><span class="comment">// 这意味着它是一个“纯影子节点”，应该被 LRU 链表追踪。</span></span><br><span class="line"><span class="keyword">if</span> (node-&gt;count &amp;&amp; node-&gt;count == node-&gt;nr_values) &#123;</span><br><span class="line"><span class="comment">// 如果此纯影子节点尚未在 LRU 链表上。</span></span><br><span class="line"><span class="keyword">if</span> (list_empty(&amp;node-&gt;private_list)) &#123;</span><br><span class="line"><span class="comment">// 将其添加到 shadow_nodes LRU 链表中。</span></span><br><span class="line">list_lru_add_obj(&amp;shadow_nodes, &amp;node-&gt;private_list);</span><br><span class="line"><span class="comment">// 增加全局的 WORKINGSET_NODES 统计计数。</span></span><br><span class="line">__inc_node_page_state(page, WORKINGSET_NODES);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 否则，此节点或为空，或包含实际的页面，不应被 LRU 追踪。</span></span><br><span class="line"><span class="comment">// 如果此节点当前仍在 LRU 链表上。</span></span><br><span class="line"><span class="keyword">if</span> (!list_empty(&amp;node-&gt;private_list)) &#123;</span><br><span class="line"><span class="comment">// 将其从 shadow_nodes LRU 链表中移除。</span></span><br><span class="line">list_lru_del_obj(&amp;shadow_nodes, &amp;node-&gt;private_list);</span><br><span class="line"><span class="comment">// 减少全局的 WORKINGSET_NODES 统计计数。</span></span><br><span class="line">__dec_node_page_state(page, WORKINGSET_NODES);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工作集影子节点收缩器：count-shadow-nodes-scan-shadow-nodes-及-shadow-lru-isolate"><a href="#工作集影子节点收缩器：count-shadow-nodes-scan-shadow-nodes-及-shadow-lru-isolate" class="headerlink" title="工作集影子节点收缩器：count_shadow_nodes, scan_shadow_nodes 及 shadow_lru_isolate"></a>工作集影子节点收缩器：count_shadow_nodes, scan_shadow_nodes 及 shadow_lru_isolate</h2><p>本代码片段展示了 Linux 内核内存管理中，用于回收“工作集”检测机制所使用的“影子条目”的 shrinker 实现。其核心功能是：在系统面临内存压力时，精确地计算应回收的、用于存储影子条目的 <code>xa_node</code> 数量，并安全地从 LRU 链表上将其隔离和释放，从而回收这部分元数据所占用的内存。这套机制由三个函数协同完成：<code>count_shadow_nodes</code> 负责决策，<code>scan_shadow_nodes</code> 负责发起扫描，<code>shadow_lru_isolate</code> 负责具体执行。</p><h3 id="实现原理分析-2"><a href="#实现原理分析-2" class="headerlink" title="实现原理分析"></a>实现原理分析</h3><p>此机制是内核 shrinker 框架的一个实例，专门用于管理工作集检测（working set detection）的内存开销。工作集检测通过在页缓存（Page Cache）的基数树（Radix Tree，现为 XArray）中留下“影子条目”来判断一个页面被回收后是否很快被重新访问（即“refault”）。这些影子条目本身存储在 <code>xa_node</code> 结构中，也消耗内存，因此需要被管理和回收。</p><ol><li><p><strong>回收数量决策 (<code>count_shadow_nodes</code>)</strong>:</p><ul><li>此函数是 shrinker 的 <code>count</code> 回调，用于判断有多少个影子节点<em>可以被</em>回收。</li><li>它首先通过 <code>list_lru_shrink_count</code> 获取当前 LRU 链表上影子节点的总数 <code>nodes</code>。</li><li>核心原理是计算一个允许存在的最大影子节点数 <code>max_nodes</code>。这个最大值与系统或内存控制组（cgroup）中的总页数 <code>pages</code> 成正比。其计算公式为 <code>max_nodes = pages &gt;&gt; (XA_CHUNK_SHIFT - 3)</code>。</li><li><strong>公式解析</strong>: <code>XA_CHUNK_SHIFT</code> 是 XArray 一个节点能容纳的条目数量的对数（通常为6，代表64个条目）。<code>- 3</code> 等价于 <code>* 8</code>。因此，公式可以理解为 <code>max_nodes = pages / (ENTRIES_PER_NODE / 8)</code>。这是一种启发式算法，其意图是：我们允许用于存储影子节点的内存开销，与被监控的总内存大小成一个固定的比例。这个比例被设定为，在最坏情况下（每个节点只有一个影子条目），我们最多愿意为每 <code>ENTRIES_PER_NODE / 8</code> 个页面就分配一个 <code>xa_node</code> 来跟踪其工作集。这在内存开销和工作集检测精度之间取得了平衡。</li><li>最终，函数返回 <code>nodes - max_nodes</code>，即超出阈值的、需要被回收的节点数量。</li></ul></li><li><p><strong>节点扫描与隔离 (<code>scan_shadow_nodes</code> 和 <code>shadow_lru_isolate</code>)</strong>:</p><ul><li><code>scan_shadow_nodes</code> 是 shrinker 的 <code>scan</code> 回调。它非常简单，直接调用 <code>list_lru_shrink_walk_irq</code> 函数，该函数会遍历 <code>shadow_nodes</code> 这个 LRU 链表，并对链表上的每个节点调用 <code>shadow_lru_isolate</code> 回调函数。</li><li><code>shadow_lru_isolate</code> 是实际执行节点回收的核心逻辑。其过程体现了内核中复杂的锁同步技巧：<br>a.  <strong>锁顺序反转</strong>: 正常情况下，修改页缓存树需要先持有 <code>address_space</code> 的 <code>i_pages</code> 锁，再持有 LRU 链表锁。但此函数从 LRU 链表开始，已经持有了 LRU 锁。为了安全地操作节点的 <code>address_space</code>，它必须再去获取 <code>i_pages</code> 锁。<br>b.  <strong>非阻塞尝试</strong>: 由于在持有自旋锁（LRU 锁）时不能睡眠，它必须使用 <code>xa_trylock</code> 来尝试获取 <code>i_pages</code> 锁。如果失败，说明该 <code>address_space</code> 正被其他任务锁定，此时必须放弃，释放 LRU 锁并返回 <code>LRU_RETRY</code>，以便 shrinker 稍后重试。对于与 inode 关联的页缓存，还需额外尝试获取 <code>inode-&gt;i_lock</code>。<br>c.  <strong>隔离与删除</strong>: 成功获取所有需要的锁之后，它将节点从 LRU 链表中移除 (<code>list_lru_isolate</code>)，更新相关的统计计数，然后调用 <code>xa_delete_node</code> 将节点从 XArray 中彻底删除，并释放其占用的内存。<br>d.  <strong>状态验证</strong>: 通过 <code>WARN_ON_ONCE</code> 宏进行健全性检查，确保被回收的节点确实只包含影子条目 (<code>node-&gt;nr_values</code>)，而不包含任何实际的页面 (<code>node-&gt;count</code>)。</li></ul></li></ol><h3 id="特定场景分析：单核、无MMU的-STM32H750-平台"><a href="#特定场景分析：单核、无MMU的-STM32H750-平台" class="headerlink" title="特定场景分析：单核、无MMU的 STM32H750 平台"></a>特定场景分析：单核、无MMU的 STM32H750 平台</h3><h4 id="功能相关性"><a href="#功能相关性" class="headerlink" title="功能相关性"></a>功能相关性</h4><p>在标准的、用于嵌入式场景的 STM32H750 应用中，通常不会启用完整的 Linux 内存管理子系统，尤其是像工作集检测这样的高级功能。工作集检测（<code>CONFIG_WORKING_SET_DETECTION</code>）的核心前提是存在基于页（Page）的按需换页（demand paging）和页面回收机制。</p><ol><li><strong>无 MMU 的影响</strong>: 在没有内存管理单元（MMU）的 ARMv7-M 架构上，无法实现虚拟内存，也就没有传统意义上的“页错误”（Page Fault）和页面换出（swap out）。内存管理较为直接，不存在页面被“回收”到后备存储后又被“refault”回内存的场景。</li><li><strong>结论</strong>: 因此，工作集检测机制及其影子条目对于无 MMU 的平台是<strong>没有意义的</strong>。在为 STM32H750 这类平台配置内核时，<code>CONFIG_WORKING_SET_DETECTION</code> 选项几乎总会被禁用。所以，这段代码（<code>count_shadow_nodes</code>, <code>scan_shadow_nodes</code>, <code>shadow_lru_isolate</code>）在功能上与该特定平台无关，它们对应的代码路径不会被编译进最终的内核镜像，也不会被执行。</li></ol><h4 id="单核环境影响"><a href="#单核环境影响" class="headerlink" title="单核环境影响"></a>单核环境影响</h4><p>尽管此代码在该平台上不适用，但我们可以从纯粹的软件角度分析其在单核环境下的行为。</p><p>代码中使用了 <code>spin_unlock_irq</code> 等自旋锁原语。在单核处理器上，获取一个 <code>spin_lock_irqsave</code> 锁的操作等价于“保存当前中断状态并禁用本地中断”。释放锁则恢复中断状态。这种机制足以防止在临界区代码执行期间被中断服务程序打断，从而保证了对共享数据（如 LRU 链表）访问的原子性。<code>trylock</code> 逻辑在这种环境下依然是正确的，用于处理需要获取多个“锁”（实为中断屏蔽状态）时的复杂同步，避免死锁。因此，代码中的同步机制在单核环境下是正确且有效的。</p><h3 id="代码分析-2"><a href="#代码分析-2" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief count_shadow_nodes - 计算应被回收的影子节点的数量。</span></span><br><span class="line"><span class="comment"> * @param shrinker: 指向 shrinker 控制块的指针 (未使用)。</span></span><br><span class="line"><span class="comment"> * @param sc: 指向 shrinker 控制参数的指针，包含了目标节点和 cgroup 信息。</span></span><br><span class="line"><span class="comment"> * @return unsigned long 返回值: 如果当前节点数未超过阈值，返回0；否则返回超出阈值的节点数。如果链表为空，返回 SHRINK_EMPTY。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">count_shadow_nodes</span><span class="params">(<span class="keyword">struct</span> shrinker *shrinker,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> shrink_control *sc)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> max_nodes; <span class="comment">/// &lt; 允许存在的最大节点数。</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> nodes;     <span class="comment">/// &lt; 当前LRU链表上的节点总数。</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> pages;     <span class="comment">/// &lt; 用于计算阈值的总页面数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 shadow_nodes 这个 LRU 链表上的对象数量。</span></span><br><span class="line">nodes = list_lru_shrink_count(&amp;shadow_nodes, sc);</span><br><span class="line"><span class="comment">// 如果链表为空，则无需回收。</span></span><br><span class="line"><span class="keyword">if</span> (!nodes)</span><br><span class="line"><span class="keyword">return</span> SHRINK_EMPTY;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMCG</span></span><br><span class="line"><span class="comment">// 如果是在一个内存控制组 (cgroup) 的上下文中进行回收。</span></span><br><span class="line"><span class="keyword">if</span> (sc-&gt;memcg) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lruvec</span> *<span class="title">lruvec</span>;</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 刷新 cgroup 的统计数据（有速率限制）。</span></span><br><span class="line">mem_cgroup_flush_stats_ratelimited(sc-&gt;memcg);</span><br><span class="line"><span class="comment">// 获取指定 cgroup 和 NUMA 节点的 lruvec。</span></span><br><span class="line">lruvec = mem_cgroup_lruvec(sc-&gt;memcg, NODE_DATA(sc-&gt;nid));</span><br><span class="line"><span class="comment">// 累加所有LRU链表（活跃/不活跃的匿名页和文件页）的页面数。</span></span><br><span class="line"><span class="keyword">for</span> (pages = <span class="number">0</span>, i = <span class="number">0</span>; i &lt; NR_LRU_LISTS; i++)</span><br><span class="line">pages += lruvec_page_state_local(lruvec,</span><br><span class="line"> NR_LRU_BASE + i);</span><br><span class="line"><span class="comment">// 累加可回收和不可回收的 slab 页面数。</span></span><br><span class="line">pages += lruvec_page_state_local(</span><br><span class="line">lruvec, NR_SLAB_RECLAIMABLE_B) &gt;&gt; PAGE_SHIFT;</span><br><span class="line">pages += lruvec_page_state_local(</span><br><span class="line">lruvec, NR_SLAB_UNRECLAIMABLE_B) &gt;&gt; PAGE_SHIFT;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">// 如果不在 cgroup 上下文中，则使用整个 NUMA 节点的物理页面数。</span></span><br><span class="line">pages = node_present_pages(sc-&gt;nid);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算最大节点数。pages / (2^(XA_CHUNK_SHIFT) / 8)。</span></span><br><span class="line"><span class="comment">// XA_CHUNK_SHIFT 通常为 6 (64个条目)，所以相当于 pages / (64/8) = pages / 8。</span></span><br><span class="line">max_nodes = pages &gt;&gt; (XA_CHUNK_SHIFT - <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果当前节点数未超过上限，则不需要回收。</span></span><br><span class="line"><span class="keyword">if</span> (nodes &lt;= max_nodes)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 返回需要回收的节点数，即当前数量减去允许的最大数量。</span></span><br><span class="line"><span class="keyword">return</span> nodes - max_nodes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief shadow_lru_isolate - 从LRU链表中隔离一个影子节点以准备回收。</span></span><br><span class="line"><span class="comment"> * @param item: 指向节点在LRU链表中的 list_head 成员的指针。</span></span><br><span class="line"><span class="comment"> * @param lru: 指向 list_lru_one 实例的指针。</span></span><br><span class="line"><span class="comment"> * @param arg: 用户自定义参数 (未使用)。</span></span><br><span class="line"><span class="comment"> * @return enum lru_status: 返回隔离操作的状态 (成功、重试等)。</span></span><br><span class="line"><span class="comment"> * @note 此函数在执行时必须已持有 lru-&gt;lock。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">enum</span> lru_status <span class="title function_">shadow_lru_isolate</span><span class="params">(<span class="keyword">struct</span> list_head *item,</span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> list_lru_one *lru,</span></span><br><span class="line"><span class="params">  <span class="type">void</span> *arg)</span> __<span class="title function_">must_hold</span><span class="params">(lru-&gt;lock)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 通过 list_head 指针找到其所属的 xa_node 结构体。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xa_node</span> *<span class="title">node</span> =</span> container_of(item, <span class="keyword">struct</span> xa_node, private_list);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span>;</span> <span class="comment">/// &lt; 节点所属的地址空间。</span></span><br><span class="line"><span class="type">int</span> ret; <span class="comment">/// &lt; 操作返回值。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从节点的 XArray 成员找到其所属的 address_space 结构体。</span></span><br><span class="line">mapping = container_of(node-&gt;<span class="built_in">array</span>, <span class="keyword">struct</span> address_space, i_pages);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从LRU链表开始，需要反转锁的获取顺序。尝试获取 i_pages 锁。</span></span><br><span class="line"><span class="keyword">if</span> (!xa_trylock(&amp;mapping-&gt;i_pages)) &#123;</span><br><span class="line"><span class="comment">// 如果无法立即获取(锁被占用)，则释放LRU锁，要求上层重试。</span></span><br><span class="line">spin_unlock_irq(&amp;lru-&gt;lock);</span><br><span class="line">ret = LRU_RETRY;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于页缓存，我们还需要持有 inode 的 i_lock。</span></span><br><span class="line"><span class="keyword">if</span> (mapping-&gt;host != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="comment">// 尝试获取 inode 锁。</span></span><br><span class="line"><span class="keyword">if</span> (!spin_trylock(&amp;mapping-&gt;host-&gt;i_lock)) &#123;</span><br><span class="line"><span class="comment">// 如果失败，释放已获取的 i_pages 锁和 LRU 锁，然后要求重试。</span></span><br><span class="line">xa_unlock(&amp;mapping-&gt;i_pages);</span><br><span class="line">spin_unlock_irq(&amp;lru-&gt;lock);</span><br><span class="line">ret = LRU_RETRY;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功获取所有锁后，将节点从 LRU 链表中隔离出来。</span></span><br><span class="line">list_lru_isolate(lru, item);</span><br><span class="line"><span class="comment">// 将此节点的页状态计数器(WORKINGSET_NODES)减一。</span></span><br><span class="line">__dec_node_page_state(virt_to_page(node), WORKINGSET_NODES);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时已将节点与LRU解耦，可以释放LRU锁了。</span></span><br><span class="line">spin_unlock(&amp;lru-&gt;lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 警告：如果节点中没有影子条目，说明状态异常。</span></span><br><span class="line"><span class="keyword">if</span> (WARN_ON_ONCE(!node-&gt;nr_values))</span><br><span class="line"><span class="keyword">goto</span> out_invalid;</span><br><span class="line"><span class="comment">// 警告：如果节点中的总条目数不等于影子条目数（意味着含有页面），状态异常。</span></span><br><span class="line"><span class="keyword">if</span> (WARN_ON_ONCE(node-&gt;count != node-&gt;nr_values))</span><br><span class="line"><span class="keyword">goto</span> out_invalid;</span><br><span class="line"><span class="comment">// 从 XArray 中删除此节点，删除过程中会调用 workingset_update_node 更新状态。</span></span><br><span class="line">xa_delete_node(node, workingset_update_node);</span><br><span class="line"><span class="comment">// 增加 lruvec 中节点回收的统计计数。</span></span><br><span class="line">__inc_lruvec_kmem_state(node, WORKINGSET_NODERECLAIM);</span><br><span class="line"></span><br><span class="line">out_invalid:</span><br><span class="line"><span class="comment">// 释放 i_pages 锁，并恢复中断。</span></span><br><span class="line">xa_unlock_irq(&amp;mapping-&gt;i_pages);</span><br><span class="line"><span class="comment">// 如果存在宿主 inode。</span></span><br><span class="line"><span class="keyword">if</span> (mapping-&gt;host != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="comment">// 如果这个 mapping 是可收缩的，则将其 inode 添加到 LRU 中以便后续处理。</span></span><br><span class="line"><span class="keyword">if</span> (mapping_shrinkable(mapping))</span><br><span class="line">inode_add_lru(mapping-&gt;host);</span><br><span class="line"><span class="comment">// 释放 inode 锁。</span></span><br><span class="line">spin_unlock(&amp;mapping-&gt;host-&gt;i_lock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回状态，表示已成功移除一个节点，并建议重试扫描，因为锁已被释放。</span></span><br><span class="line">ret = LRU_REMOVED_RETRY;</span><br><span class="line">out:</span><br><span class="line"><span class="comment">// 提供一个调度点，允许其他任务运行。</span></span><br><span class="line">cond_resched();</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief scan_shadow_nodes - 扫描并回收超出限额的影子节点。</span></span><br><span class="line"><span class="comment"> * @param shrinker: 指向 shrinker 控制块的指针 (未使用)。</span></span><br><span class="line"><span class="comment"> * @param sc: 指向 shrinker 控制参数的指针。</span></span><br><span class="line"><span class="comment"> * @return unsigned long: 返回成功回收的对象数量。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">scan_shadow_nodes</span><span class="params">(<span class="keyword">struct</span> shrinker *shrinker,</span></span><br><span class="line"><span class="params">       <span class="keyword">struct</span> shrink_control *sc)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 调用通用的 LRU 链表遍历和收缩函数。</span></span><br><span class="line"><span class="comment">// 它会遍历 shadow_nodes 链表，并对每个元素调用 shadow_lru_isolate 函数。</span></span><br><span class="line"><span class="keyword">return</span> list_lru_shrink_walk_irq(&amp;shadow_nodes, sc, shadow_lru_isolate,</span><br><span class="line"><span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;

&lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i-blog.csdnimg.cn/direct/a68fec7b405d47f4900401898a1f4faf.</summary>
      
    
    
    
    <category term="linux" scheme="https://wdfk-prog.space/categories/linux/"/>
    
    <category term="mm" scheme="https://wdfk-prog.space/categories/linux/mm/"/>
    
    
    <category term="linux" scheme="https://wdfk-prog.space/tags/linux/"/>
    
    <category term="mm" scheme="https://wdfk-prog.space/tags/mm/"/>
    
  </entry>
  
  <entry>
    <title>vmscan</title>
    <link href="https://wdfk-prog.space/posts/e8ec9031/"/>
    <id>https://wdfk-prog.space/posts/e8ec9031/</id>
    <published>2025-10-07T01:38:39.000Z</published>
    <updated>2025-10-07T01:46:46.312Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>[toc]</p><p><img src="https://i-blog.csdnimg.cn/direct/9c2a6eafb4ca43199d26bb1cefd9c67c.png" alt="在这里插入图片描述"></p><h1 id="mm-vmscan-c-页面回收-Page-Reclaim-内核内存管理的核心压力调节器"><a href="#mm-vmscan-c-页面回收-Page-Reclaim-内核内存管理的核心压力调节器" class="headerlink" title="mm&#x2F;vmscan.c 页面回收(Page Reclaim) 内核内存管理的核心压力调节器"></a>mm&#x2F;vmscan.c 页面回收(Page Reclaim) 内核内存管理的核心压力调节器</h1><h3 id="历史与背景"><a href="#历史与背景" class="headerlink" title="历史与背景"></a>历史与背景</h3><h4 id="这项技术是为了解决什么特定问题而诞生的？"><a href="#这项技术是为了解决什么特定问题而诞生的？" class="headerlink" title="这项技术是为了解决什么特定问题而诞生的？"></a>这项技术是为了解决什么特定问题而诞生的？</h4><p><code>mm/vmscan.c</code> 中的代码是为了解决计算机科学中最基本的问题之一：<strong>物理内存是一种有限资源</strong>。当系统运行的应用程序和内核本身需要的内存总量超过了可用的物理RAM时，操作系统必须有一种机制来释放一些当前已分配但“不那么重要”的内存，以便为新的、更紧迫的内存请求腾出空间。</p><p>如果没有页面回收机制，系统在内存耗尽时唯一的选择就是拒绝新的内存分配请求，这将导致应用程序崩溃或系统完全停止响应。<code>vmscan.c</code> 实现的页面回收（Page Reclaim）算法，其核心目标是在内存压力（Memory Pressure）下，智能地选择并回收内存页面，从而保证系统的持续运行和响应能力。</p><h4 id="它的发展经历了哪些重要的里程碑或版本迭代？"><a href="#它的发展经历了哪些重要的里程碑或版本迭代？" class="headerlink" title="它的发展经历了哪些重要的里程碑或版本迭代？"></a>它的发展经历了哪些重要的里程碑或版本迭代？</h4><p>Linux的页面回收算法经历了重大的演进，以适应不断变化的硬件和工作负载：</p><ul><li><strong>早期的LRU</strong>：最初的Linux内核使用了相当简单的“最近最少使用”（Least Recently Used, LRU）算法。</li><li><strong>两阶段LRU (Active&#x2F;Inactive Lists)</strong>：一个革命性的改进是引入了<strong>Active</strong>和<strong>Inactive</strong>两个链表来管理页面。由Rik van Riel等人提出的这个方案，旨在更好地区分真正“热”的（经常被访问）页面和“冷”的（不常被访问）页面，从而避免了“缓存污染”（当一次大的、顺序的读操作将所有热数据都冲出缓存时）的问题，极大地提高了回收决策的准确性。<code>vmscan.c</code>的核心逻辑就是围绕这个模型构建的。</li><li><strong>File vs. Anonymous Pages分离</strong>：内核进一步将LRU链表区分为<strong>文件页面（File Pages）<strong>和</strong>匿名页面（Anonymous Pages）</strong>。这两类页面的回收成本截然不同：干净的文件页面可以直接丢弃（需要时可从磁盘重新读取），而匿名的“脏”页面则必须先写入交换空间（swap），这是一个昂贵的操作。这种分离使得回收策略可以更加精细。</li><li><strong>NUMA感知</strong>：在非统一内存访问（NUMA）架构的服务器上，<code>vmscan.c</code> 发展为NUMA感知的。这意味着内核会优先在内存压力所在的NUMA节点上进行本地回收，以避免昂贵的跨节点内存访问。</li><li><strong>多代LRU (MGLRU)</strong>：近年来，为了解决传统两阶段LRU在某些现代工作负载下的不足，Google的工程师们提出了多代LRU（Multi-Generational LRU）机制。MGLRU通过更精细的页面老化和分代管理，旨在做出更优的回收决策，目前已合并到主线内核中，作为一种可选的、更现代化的回收策略。</li></ul><h4 id="目前该技术的社区活跃度和主流应用情况如何？"><a href="#目前该技术的社区活跃度和主流应用情况如何？" class="headerlink" title="目前该技术的社区活跃度和主流应用情况如何？"></a>目前该技术的社区活跃度和主流应用情况如何？</h4><p>页面回收是Linux内存管理子系统的<strong>心脏</strong>，其稳定性和效率直接决定了整个操作系统的性能表现。因此，它一直是内核社区中研究、讨论和优化的热点。它被应用于所有运行Linux的设备上，从最小的嵌入式系统到最大的超级计算机。任何时候，只要Linux系统遇到内存压力，<code>vmscan.c</code> 中的代码就会被激活。</p><h3 id="核心原理与设计"><a href="#核心原理与设计" class="headerlink" title="核心原理与设计"></a>核心原理与设计</h3><h4 id="它的核心工作原理是什么？"><a href="#它的核心工作原理是什么？" class="headerlink" title="它的核心工作原理是什么？"></a>它的核心工作原理是什么？</h4><p><code>mm/vmscan.c</code> 的核心工作是扫描和回收页面，其逻辑由两个主要场景触发：</p><ol><li><strong>kswapd（后台回收）</strong>：这是一个内核线程，每个NUMA节点都有一个。它在后台被周期性地唤醒，检查当前节点的内存水位。如果空闲内存低于某个“低水位线”（low watermark），<code>kswapd</code> 就会被唤醒并开始<strong>异步地</strong>、<strong>主动地</strong>回收页面，直到空闲内存恢复到“高水位线”（high watermark）。这是一种预防性的机制。</li><li><strong>直接回收（Direct Reclaim）</strong>：当一个进程请求分配内存，但系统空闲内存已经低于“最低水位线”（min watermark）时，意味着<code>kswapd</code> 已经跟不上内存消耗的速度。此时，该进程会被<strong>阻塞</strong>，并<strong>同步地</strong>、<strong>被动地</strong>调用页面回收代码为自己腾出空间。这是一个高成本的操作，因为它会增加应用程序的延迟。</li></ol><p><strong>回收过程的核心步骤</strong>：</p><ol><li><strong>扫描LRU链表</strong>：回收算法主要扫描上文提到的四个LRU链表：<code>active_file</code>, <code>inactive_file</code>, <code>active_anon</code>, <code>inactive_anon</code>。</li><li><strong>页面老化（Aging）</strong>：算法从<code>active</code>链表的尾部开始扫描。当它检查一个页面时，会查看该页面是否被访问过（通过CPU的Accessed bit）。<ul><li>如果页面被访问过，则认为它“还很热”，会清除其访问标记，并将其留在<code>active</code>链表中，但可能会移到链表头部，给它一次新的机会。</li><li>如果页面未被访问过，则认为它“变冷了”，会将其从<code>active</code>链表移动到<code>inactive</code>链表的头部。</li></ul></li><li><strong>选择回收候选者</strong>：算法从<code>inactive</code>链表的尾部开始扫描，这里的页面是“最冷”的。<ul><li>如果一个<code>inactive</code>页面再次被访问，它会被“激活”，重新移回到<code>active</code>链表。</li><li>如果一个<code>inactive</code>页面长时间未被访问，它就成为回收的候选者。</li></ul></li><li><strong>执行回收</strong>：<ul><li><strong>干净的文件页面</strong>：直接从页缓存中移除，释放内存。这是成本最低的回收方式。</li><li><strong>脏的文件页面</strong>：必须先将其内容写回到磁盘（writeback），这是一个I&#x2F;O操作。写回完成后，页面才能被释放。</li><li><strong>脏的匿名页面</strong>：必须将其内容写入到交换空间（swap out），这也是一个昂贵的I&#x2F;O操作。</li><li><strong>slab缓存</strong>：<code>vmscan.c</code>也会调用<code>shrink_slab()</code>来尝试收缩内核的slab&#x2F;slub分配器缓存（如dentry, inode缓存）。</li></ul></li></ol><h4 id="它的主要优势体现在哪些方面？"><a href="#它的主要优势体现在哪些方面？" class="headerlink" title="它的主要优势体现在哪些方面？"></a>它的主要优势体现在哪些方面？</h4><ul><li><strong>系统稳定性</strong>：它是Linux系统在高内存压力下仍能保持运行的关键。</li><li><strong>性能启发式</strong>：两阶段LRU模型在大多数通用工作负载下，都能很好地平衡性能和内存使用，有效区分工作集（working set）和可回收内存。</li><li><strong>区分处理</strong>：通过分离文件页和匿名页，系统可以优先回收成本较低的页面。<code>vm.swappiness</code>这个<code>sysctl</code>参数就是用来调节回收文件页和匿名页的倾向性的。</li></ul><h4 id="它存在哪些已知的劣势、局限性或在特定场景下的不适用性？"><a href="#它存在哪些已知的劣势、局限性或在特定场景下的不适用性？" class="headerlink" title="它存在哪些已知的劣势、局限性或在特定场景下的不适用性？"></a>它存在哪些已知的劣势、局限性或在特定场景下的不适用性？</h4><ul><li><strong>性能抖动</strong>：直接回收会给应用程序带来显著的延迟，是性能优化的重点关注对象。</li><li><strong>抖动（Thrashing）</strong>：在内存极度不足的情况下，系统可能会陷入“抖动”状态：不断地换出页面，但这些页面很快又被需要，于是又被换入，导致系统大部分时间都在进行I&#x2F;O而不是有用的计算。</li><li><strong>LRU的局限性</strong>：经典的LRU对某些访问模式（如大文件顺序扫描）不友好，可能做出错误的回收决策。这也是MGLRU试图解决的问题。</li><li><strong>复杂性与调优</strong>：页面回收的逻辑非常复杂，并且有多个<code>sysctl</code>参数可以调整其行为。不正确的调优可能会导致性能下降。</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><h4 id="在哪些具体的业务或技术场景下，它是首选解决方案？"><a href="#在哪些具体的业务或技术场景下，它是首选解决方案？" class="headerlink" title="在哪些具体的业务或技术场景下，它是首选解决方案？"></a>在哪些具体的业务或技术场景下，它是首选解决方案？</h4><p>由于<code>vmscan.c</code>是内核的核心机制，它没有“可选”的场景，而是在以下场景中其<strong>行为表现</strong>至关重要：</p><ul><li><strong>内存密集型应用</strong>：数据库（如MySQL, PostgreSQL）、内存缓存（Redis, Memcached）、大数据处理（Spark）等，这些应用会消耗大量内存，并持续对页面回收机制构成压力。</li><li><strong>文件服务器</strong>：文件服务器会大量使用页缓存（page cache）来加速文件访问。当内存不足时，<code>vmscan.c</code>负责从页缓存中回收旧的文件页面。</li><li><strong>资源受限的系统</strong>：在嵌入式设备或小型虚拟机中，物理内存非常有限，页面回收机制被激活的频率会更高。</li></ul><h4 id="是否有不推荐使用该技术的场景？为什么？"><a href="#是否有不推荐使用该技术的场景？为什么？" class="headerlink" title="是否有不推荐使用该技术的场景？为什么？"></a>是否有不推荐使用该技术的场景？为什么？</h4><p>不能“不使用”该技术，但可以<strong>避免其最坏情况的发生</strong>。在某些场景下，应该通过其他方式管理内存，以避免触发昂贵的回收路径：</p><ul><li><strong>硬实时系统</strong>：硬实时系统无法容忍直接回收带来的不可预测的延迟。这类系统通常会通过内存锁定（<code>mlock()</code>）等技术将关键内存锁定在RAM中，防止其被回收。</li><li><strong>超低延迟应用</strong>：在高频交易等场景中，任何由直接回收或缺页中断（page fault）引起的延迟都是不可接受的。这些应用通常会预先分配并锁定所有需要的内存。</li></ul><h3 id="对比分析"><a href="#对比分析" class="headerlink" title="对比分析"></a>对比分析</h3><h4 id="请将其-与-其他相似技术-进行详细对比。"><a href="#请将其-与-其他相似技术-进行详细对比。" class="headerlink" title="请将其 与 其他相似技术 进行详细对比。"></a>请将其 与 其他相似技术 进行详细对比。</h4><p><code>vmscan.c</code>（页面回收）与<strong>OOM Killer</strong>（Out-of-Memory Killer）是内核处理内存压力的两个不同阶段的机制。</p><table><thead><tr><th align="left">特性</th><th align="left">页面回收 (Page Reclaim, <code>vmscan.c</code>)</th><th align="left">OOM Killer (<code>mm/oom_kill.c</code>)</th></tr></thead><tbody><tr><td align="left"><strong>功能概述</strong></td><td align="left"><strong>优雅地、渐进地</strong>释放内存。通过回收单个页面或小批量页面来缓解内存压力。</td><td align="left"><strong>粗暴地、最后</strong>的手段。当页面回收也无法满足内存分配请求时，选择一个进程并将其<strong>杀死</strong>，以一次性释放其占用的所有内存。</td></tr><tr><td align="left"><strong>触发时机</strong></td><td align="left">内存水位低于预设的阈值时，由<code>kswapd</code>或直接分配路径触发。是<strong>常规的、预期的</strong>内存管理活动。</td><td align="left">当页面回收和所有其他尝试都失败后，在内存分配的最终环节被触发。是<strong>异常的、失败的</strong>标志。</td></tr><tr><td align="left"><strong>实现方式</strong></td><td align="left">复杂的算法，扫描LRU链表，进行页面老化、写回、交换等操作。</td><td align="left">根据一系列启发式规则（如进程的内存占用、<code>oom_score_adj</code>值等）计算每个进程的“牺牲”分数，并杀死分数最高的进程。</td></tr><tr><td align="left"><strong>对系统的影响</strong></td><td align="left"><strong>性能影响</strong>。可能导致I&#x2F;O增高、应用程序延迟增加。</td><td align="left"><strong>服务中断</strong>。被杀死的进程会丢失所有未保存的状态，导致服务中断或应用程序崩溃。</td></tr><tr><td align="left"><strong>目标</strong></td><td align="left"><strong>维持系统运行</strong>。通过“腾挪”内存空间来满足需求，保持系统稳定。</td><td align="left"><strong>避免系统崩溃</strong>。在无法满足一个关键的内存请求（可能来自内核自身）时，通过牺牲一个进程来保全整个系统。</td></tr></tbody></table><h2 id="kswapd-init-与内存回收线程的启动和配置"><a href="#kswapd-init-与内存回收线程的启动和配置" class="headerlink" title="kswapd_init 与内存回收线程的启动和配置"></a>kswapd_init 与内存回收线程的启动和配置</h2><p>本代码片段负责初始化 Linux 内核核心的内存回收机制。其核心功能是为系统中的每一个 NUMA 内存节点（Memory Node）启动一个专用的内核守护线程 <code>kswapd</code>。该线程在后台运行，负责在系统内存不足时扫描并回收内存页，以释放空间供新的分配请求使用。此外，代码还通过 <code>sysctl</code> 在 <code>/proc/sys/vm/</code> 目录下创建了用于调整内存回收行为的配置文件，如 <code>swappiness</code>。</p><h3 id="实现原理分析"><a href="#实现原理分析" class="headerlink" title="实现原理分析"></a>实现原理分析</h3><p>该机制的实现围绕着内核线程的动态创建、NUMA 架构的感知以及通过 <code>sysctl</code> 提供的运行时可调优性。</p><ol><li><p><strong>基于 NUMA 节点的线程管理 (<code>kswapd_run</code>, <code>kswapd_stop</code>)</strong>:</p><ul><li>Linux 内核为每个物理内存节点（由 <code>pg_data_t</code> 结构体表示，<code>nid</code> 为其ID）都配备一个独立的 <code>kswapd</code> 线程。这种设计确保了内存回收操作可以在本地节点上进行，减少了跨节点内存访问的开销，从而在 NUMA 系统上获得更好的性能。</li><li><code>kswapd_run</code> 函数是启动线程的核心。它首先检查 <code>pgdat-&gt;kswapd</code> 指针，确保每个节点只启动一个实例（幂等性）。然后，它调用 <code>kthread_create_on_node</code> 来创建一个新的内核线程，该线程执行 <code>kswapd</code> 函数（未在此代码段中显示）。关键在于，该线程被明确地绑定到指定的内存节点 <code>nid</code> 上。</li><li><code>kswapd_stop</code> 函数则与之对应，用于在内存节点被热拔除（hot-removed）时，安全地停止并清理该节点上的 <code>kswapd</code> 线程。</li></ul></li><li><p><strong>启动时自动初始化 (<code>kswapd_init</code>)</strong>:</p><ul><li>此函数通过 <code>module_init</code> 宏注册，确保在内核启动过程中被自动调用。</li><li>它首先调用 <code>swap_setup()</code> 初始化交换子系统（即使没有交换分区，此步骤也是必要的）。</li><li>然后，它使用 <code>for_each_node_state(nid, N_MEMORY)</code> 宏来遍历系统中所有当前存在的内存节点，并对每一个节点调用 <code>kswapd_run</code>，从而为整个系统启动所有必要的内存回收线程。</li><li>最后，它调用 <code>register_sysctl_init</code> 将 <code>vmscan_sysctl_table</code> 注册到 <code>sysctl</code> 树中，创建 <code>/proc/sys/vm/swappiness</code> 等配置文件。</li></ul></li><li><p><strong>运行时可调参数 (<code>vmscan_sysctl_table</code>)</strong>:</p><ul><li><code>swappiness</code>: 这是一个关键的性能调优参数（0-200），它控制了内核在进行内存回收时，回收文件页（Page Cache）与回收匿名页（Anonymous Pages，如进程堆栈）之间的倾向性。高值倾向于回收匿名页（即进行交换），低值则倾向于回收文件页。</li><li><code>zone_reclaim_mode</code> (仅限 NUMA): 控制当一个节点内存不足时，是从远程节点分配内存还是在本地节点内进行更积极的回收。</li></ul></li></ol><h3 id="特定场景分析：单核、无MMU的STM32H750平台"><a href="#特定场景分析：单核、无MMU的STM32H750平台" class="headerlink" title="特定场景分析：单核、无MMU的STM32H750平台"></a>特定场景分析：单核、无MMU的STM32H750平台</h3><h4 id="功能相关性与-kswapd-的角色变化"><a href="#功能相关性与-kswapd-的角色变化" class="headerlink" title="功能相关性与 kswapd 的角色变化"></a>功能相关性与 <code>kswapd</code> 的角色变化</h4><ul><li><strong>核心作用</strong>: 在 STM32H750 这样的微控制器上，通常没有硬盘等块设备作为交换（Swap）空间。此外，<strong>无MMU的Linux (uClinux) 无法实现真正的匿名页换出</strong>，因为无法通过缺页异常来将页面换回。因此，<code>kswapd</code> 的“交换”功能（swapping dirty anonymous pages）在此平台上是无效的。</li><li><strong>剩余的关键角色</strong>: 尽管如此，<code>kswapd</code> 仍然扮演着至关重要的<strong>页面回收</strong>（Page Reclaiming）角色。当系统内存耗尽时，<code>kswapd</code> 会被唤醒来扫描并回收那些“干净”的、可以被安全丢弃的内存页。在无MMU的STM32H750上，这主要指的是<strong>文件页缓存</strong>（Page Cache）。例如，如果系统从外部Flash的文件系统中读取了可执行文件或数据文件到RAM中，当RAM紧张时，<code>kswapd</code> 可以释放这些缓存页，因为它们可以按需从原始Flash中重新读取。这个机制是防止系统因内存耗尽而崩溃（OOM Killer）的关键防线。</li></ul><h4 id="NUMA-架构的简化"><a href="#NUMA-架构的简化" class="headerlink" title="NUMA 架构的简化"></a>NUMA 架构的简化</h4><ul><li>STM32H750 是一个典型的<strong>UMA (Uniform Memory Access)</strong> 架构，它只有一个内存控制器和一块统一的内存区域。因此，在Linux内核看来，它只有一个内存节点，即 Node 0 (<code>nid=0</code>)。</li><li>这意味着 <code>for_each_node_state</code> 循环只会执行一次。整个系统将只会创建一个 <code>kswapd0</code> 内核线程。所有NUMA相关的复杂性都退化为最简单的单节点情况。<code>CONFIG_NUMA</code> 宏在此平台上通常是未定义的，因此 <code>zone_reclaim_mode</code> 这个 <code>sysctl</code> 条目也不会被编译进去。</li></ul><h4 id="swappiness-的意义"><a href="#swappiness-的意义" class="headerlink" title="swappiness 的意义"></a><code>swappiness</code> 的意义</h4><ul><li>即使没有交换空间，<code>swappiness</code> 参数在 STM32H750 上<strong>仍然有意义</strong>。它在这里控制的是内核回收<strong>文件页缓存</strong>的积极性。设置为 0 (<code>vm_swappiness = 0</code>) 会让内核尽可能地保留文件页缓存，只有在万不得已时才回收它们。对于需要频繁访问文件系统（如从SD卡或QSPI Flash运行应用）的场景，这可能不是最佳选择。适当提高 <code>swappiness</code> 的值可以使内核在内存压力下更愿意释放文件缓存，为新的内存分配腾出空间。</li></ul><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 在指定的内存节点上启动 kswapd 线程。</span></span><br><span class="line"><span class="comment"> * @param nid 要启动 kswapd 的节点ID。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 此函数由内核初始化和节点热添加代码调用。</span></span><br><span class="line"><span class="comment"> * 它会检查 kswapd 是否已在运行，确保幂等性。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> __meminit <span class="title function_">kswapd_run</span><span class="params">(<span class="type">int</span> nid)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 获取指定节点ID对应的 pg_data_t 结构体指针。</span></span><br><span class="line"><span class="type">pg_data_t</span> *pgdat = NODE_DATA(nid);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对该节点的 kswapd 指针进行加锁保护，防止并发访问。</span></span><br><span class="line">pgdat_kswapd_lock(pgdat);</span><br><span class="line"><span class="comment">// 如果该节点的 kswapd 线程尚未创建...</span></span><br><span class="line"><span class="keyword">if</span> (!pgdat-&gt;kswapd) &#123;</span><br><span class="line"><span class="comment">// 在指定的节点上创建一个内核线程，执行 kswapd 函数，并命名为 &quot;kswapd&lt;nid&gt;&quot;。</span></span><br><span class="line">pgdat-&gt;kswapd = kthread_create_on_node(kswapd, pgdat, nid, <span class="string">&quot;kswapd%d&quot;</span>, nid);</span><br><span class="line"><span class="comment">// 检查线程创建是否失败。</span></span><br><span class="line"><span class="keyword">if</span> (IS_ERR(pgdat-&gt;kswapd)) &#123;</span><br><span class="line"><span class="comment">/* 在启动阶段失败是致命的。 */</span></span><br><span class="line">pr_err(<span class="string">&quot;Failed to start kswapd on node %d，ret=%ld\n&quot;</span>,</span><br><span class="line">nid, PTR_ERR(pgdat-&gt;kswapd));</span><br><span class="line"><span class="comment">// 如果系统尚未完全运行，则触发 BUG() 导致系统停机。</span></span><br><span class="line">BUG_ON(system_state &lt; SYSTEM_RUNNING);</span><br><span class="line">pgdat-&gt;kswapd = <span class="literal">NULL</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 线程创建成功后，唤醒它使其开始运行。</span></span><br><span class="line">wake_up_process(pgdat-&gt;kswapd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解锁。</span></span><br><span class="line">pgdat_kswapd_unlock(pgdat);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 在指定的内存节点上停止 kswapd 线程。</span></span><br><span class="line"><span class="comment"> * @param nid 要停止 kswapd 的节点ID。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 此函数由内存热拔除代码在节点的所有内存都被下线时调用。</span></span><br><span class="line"><span class="comment"> * 调用者必须持有 mem_hotplug 锁。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> __meminit <span class="title function_">kswapd_stop</span><span class="params">(<span class="type">int</span> nid)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">pg_data_t</span> *pgdat = NODE_DATA(nid);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">kswapd</span>;</span></span><br><span class="line"></span><br><span class="line">pgdat_kswapd_lock(pgdat);</span><br><span class="line">kswapd = pgdat-&gt;kswapd;</span><br><span class="line"><span class="comment">// 如果 kswapd 线程存在...</span></span><br><span class="line"><span class="keyword">if</span> (kswapd) &#123;</span><br><span class="line"><span class="comment">// 发送停止信号并等待线程退出。</span></span><br><span class="line">kthread_stop(kswapd);</span><br><span class="line">pgdat-&gt;kswapd = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">pgdat_kswapd_unlock(pgdat);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">- 从 0 到 MAX_SWAPPINESS。数值越高，换出倾向越大。从 0 到 MAX_SWAPPINESS。数值越高，换出倾向越大。 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> vm_swappiness = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @var vmscan_sysctl_table</span></span><br><span class="line"><span class="comment"> * @brief 定义了 /proc/sys/vm/ 目录下与页面扫描相关的 sysctl 参数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">ctl_table</span> <span class="title">vmscan_sysctl_table</span>[] =</span> &#123;</span><br><span class="line">&#123;</span><br><span class="line">.procname= <span class="string">&quot;swappiness&quot;</span>, <span class="comment">/**&lt; 文件名 */</span></span><br><span class="line">.data= &amp;vm_swappiness, <span class="comment">/**&lt; 指向内核中的 vm_swappiness 全局变量 */</span></span><br><span class="line">.maxlen= <span class="keyword">sizeof</span>(vm_swappiness), <span class="comment">/**&lt; 数据大小 */</span></span><br><span class="line">.mode= <span class="number">0644</span>, <span class="comment">/**&lt; 文件权限 */</span></span><br><span class="line">.proc_handler= proc_dointvec_minmax, <span class="comment">/**&lt; 使用标准的整数范围检查处理函数 */</span></span><br><span class="line">.extra1= SYSCTL_ZERO, <span class="comment">/**&lt; 额外参数1：允许的最小值 (0) */</span></span><br><span class="line">.extra2= SYSCTL_TWO_HUNDRED, <span class="comment">/**&lt; 额外参数2：允许的最大值 (200) */</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">&#123;</span><br><span class="line">.procname= <span class="string">&quot;zone_reclaim_mode&quot;</span>,</span><br><span class="line">.data= &amp;node_reclaim_mode,</span><br><span class="line">.maxlen= <span class="keyword">sizeof</span>(node_reclaim_mode),</span><br><span class="line">.mode= <span class="number">0644</span>,</span><br><span class="line">.proc_handler= proc_dointvec_minmax,</span><br><span class="line">.extra1= SYSCTL_ZERO,</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief kswapd 和相关 sysctl 的初始化函数。</span></span><br><span class="line"><span class="comment"> * @return 总是返回0。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">kswapd_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> nid;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化交换子系统。</span></span><br><span class="line">swap_setup();</span><br><span class="line"><span class="comment">// 遍历系统中所有存在的内存节点。</span></span><br><span class="line">for_each_node_state(nid, N_MEMORY)</span><br><span class="line"> <span class="comment">// 在每个节点上运行 kswapd。</span></span><br><span class="line"> kswapd_run(nid);</span><br><span class="line"><span class="comment">// 将 vmscan_sysctl_table 注册到 &quot;vm&quot; 目录下。</span></span><br><span class="line">register_sysctl_init(<span class="string">&quot;vm&quot;</span>, vmscan_sysctl_table);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 kswapd_init 注册为模块初始化函数，使其在内核启动时被调用。</span></span><br><span class="line">module_init(kswapd_init)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;


&lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i-blog.csdnimg.cn/direct/9c2a6eafb4ca43199d26bb1cefd9c67c</summary>
      
    
    
    
    <category term="linux" scheme="https://wdfk-prog.space/categories/linux/"/>
    
    <category term="mm" scheme="https://wdfk-prog.space/categories/linux/mm/"/>
    
    
    <category term="linux" scheme="https://wdfk-prog.space/tags/linux/"/>
    
    <category term="mm" scheme="https://wdfk-prog.space/tags/mm/"/>
    
  </entry>
  
  <entry>
    <title>utsname_sysctl</title>
    <link href="https://wdfk-prog.space/posts/feb74a0/"/>
    <id>https://wdfk-prog.space/posts/feb74a0/</id>
    <published>2025-10-07T01:20:51.000Z</published>
    <updated>2025-10-07T01:37:41.791Z</updated>
    
    <content type="html"><![CDATA[<hr><meta name="referrer" content="no-referrer" /><p>[TOC]</p><p><img src="https://i-blog.csdnimg.cn/direct/bd176eb7fe7143cca30f5097efc16173.png" alt="在这里插入图片描述"></p><h1 id="kernel-utsname-sysctl-c-UTS命名空间与Sysctl接口-管理和暴露系统标识信息"><a href="#kernel-utsname-sysctl-c-UTS命名空间与Sysctl接口-管理和暴露系统标识信息" class="headerlink" title="kernel&#x2F;utsname_sysctl.c UTS命名空间与Sysctl接口 管理和暴露系统标识信息"></a>kernel&#x2F;utsname_sysctl.c UTS命名空间与Sysctl接口 管理和暴露系统标识信息</h1><h3 id="历史与背景"><a href="#历史与背景" class="headerlink" title="历史与背景"></a>历史与背景</h3><h4 id="这项技术是为了解决什么特定问题而诞生的？"><a href="#这项技术是为了解决什么特定问题而诞生的？" class="headerlink" title="这项技术是为了解决什么特定问题而诞生的？"></a>这项技术是为了解决什么特定问题而诞生的？</h4><p>这项技术是为了提供一个标准化的、可在运行时<strong>动态查询和修改系统核心标识信息</strong>的机制而诞生的。这些标识信息，统称为UTS（UNIX Time-sharing System）名称，包括：</p><ul><li><strong>主机名 (Hostname)</strong> 和 <strong>域名 (Domainname)</strong>：在网络中唯一标识一台机器。</li><li><strong>操作系统发布版本 (OS Release)</strong> 和 <strong>版本号 (Version)</strong>：允许软件检查其运行的内核版本，以确定兼容性或是否存在特定功能&#x2F;错误。</li><li><strong>硬件架构 (Machine)</strong>：指明系统运行的CPU架构（如 <code>x86_64</code>, <code>aarch64</code>）。</li></ul><p><code>utsname_sysctl.c</code> 的核心任务是：</p><ol><li><strong>提供访问接口</strong>：允许用户空间程序和管理员通过 <code>uname(2)</code> 系统调用和 <code>/proc/sys/kernel/</code> 文件系统接口来读取这些信息。</li><li><strong>提供配置能力</strong>：尤其是对于主机名和域名，系统必须提供一种在运行时进行修改的方法，而无需重启。<code>sysctl</code> 接口（即<code>/proc/sys/</code>下的文件）正是为此而生。</li></ol><h4 id="它的发展经历了哪些重要的里程碑或版本迭代？"><a href="#它的发展经历了哪些重要的里程碑或版本迭代？" class="headerlink" title="它的发展经历了哪些重要的里程碑或版本迭代？"></a>它的发展经历了哪些重要的里程碑或版本迭代？</h4><p><code>utsname</code> 结构和 <code>uname()</code> 系统调用是源自经典UNIX的标准。然而，<code>kernel/utsname_sysctl.c</code> 的实现逻辑经历了一个重大的演进：</p><ul><li><strong>全局单实例时代</strong>：在早期内核中，整个系统只有一个全局的 <code>utsname</code> 实例。设置主机名会影响整个操作系统。</li><li><strong>UTS命名空间的引入 (Major Milestone)</strong>：Linux 2.6.19引入了UTS命名空间（UTS Namespaces）。这是一个革命性的变化，它允许系统上存在多个隔离的 <code>utsname</code> 实例。这意味着，每个容器都可以拥有自己独立的主机名和域名，而不会与宿主机或其他容器冲突。<code>utsname_sysctl.c</code> 的代码逻辑必须从操作全局变量，演变为操作与<strong>当前进程</strong>相关联的特定UTS命名空间。这是该文件现代实现的核心。</li></ul><h4 id="目前该技术的社区活跃度和主流应用情况如何？"><a href="#目前该技术的社区活跃度和主流应用情况如何？" class="headerlink" title="目前该技术的社区活跃度和主流应用情况如何？"></a>目前该技术的社区活跃度和主流应用情况如何？</h4><p>该技术是Linux内核中一个非常基础且稳定的部分。它不是一个经常变动的功能，但却是所有现代Linux系统不可或缺的组成部分。其主流应用包括：</p><ul><li><strong>系统基础工具</strong>：<code>hostname</code>、<code>uname</code>、<code>domainname</code> 等命令行工具直接依赖此机制。</li><li><strong>容器化</strong>：这是UTS命名空间最广泛的应用。Docker、Kubernetes、Podman等所有容器技术都利用此机制为每个容器提供隔离的主机名。</li><li><strong>系统初始化</strong>：在系统启动过程中，初始化脚本（如systemd）会通过写入 <code>/proc/sys/kernel/hostname</code> 来设置系统的主机名。</li></ul><h3 id="核心原理与设计"><a href="#核心原理与设计" class="headerlink" title="核心原理与设计"></a>核心原理与设计</h3><h4 id="它的核心工作原理是什么？"><a href="#它的核心工作原理是什么？" class="headerlink" title="它的核心工作原理是什么？"></a>它的核心工作原理是什么？</h4><p><code>kernel/utsname_sysctl.c</code> 的核心是作为<strong>UTS命名空间数据</strong>和<strong>sysctl文件系统接口</strong>之间的桥梁。</p><ol><li><strong>数据存储</strong>：内核为每个UTS命名空间维护一个 <code>struct uts_namespace</code> 结构体。这个结构体中包含了 <code>nodename</code> (主机名)、<code>domainname</code> 等字符串数组。系统中的每个进程都通过其 <code>nsproxy</code> 指针关联到一个特定的 <code>uts_namespace</code>。</li><li><strong>Sysctl注册</strong>：该文件定义了一个 <code>ctl_table</code>（控制表）。这个表将 <code>/proc/sys/kernel/</code> 目录下的特定文件名（如<code>hostname</code>、<code>domainname</code>、<code>osrelease</code>）映射到该文件中实现的特定处理函数（handler functions）。</li><li><strong>处理请求</strong>：<ul><li><strong>读操作</strong>：当用户读取 <code>/proc/sys/kernel/hostname</code> 时，内核的VFS（虚拟文件系统）层会调用在 <code>ctl_table</code> 中注册的 handler。该 handler 会找到<strong>当前进程</strong>所属的 <code>uts_namespace</code>，从中读取 <code>nodename</code> 字符串，并将其复制到用户空间。</li><li><strong>写操作</strong>：当用户（需要<code>CAP_SYS_ADMIN</code>权限）写入 <code>/proc/sys/kernel/hostname</code> 时，handler 会执行权限检查，然后将来自用户空间的新主机名复制到当前进程所属的 <code>uts_namespace</code> 结构中，从而完成修改。</li></ul></li><li><strong>命名空间隔离</strong>：关键在于，所有的操作都是针对 <code>current-&gt;nsproxy-&gt;uts_ns</code>，即当前进程的命名空间。因此，在一个容器内修改主机名，只会影响该容器的 <code>uts_namespace</code>，而不会影响宿主机或其他容器。</li></ol><h4 id="它的主要优势体现在哪些方面？"><a href="#它的主要优势体现在哪些方面？" class="headerlink" title="它的主要优势体现在哪些方面？"></a>它的主要优势体现在哪些方面？</h4><ul><li><strong>灵活性与动态性</strong>：允许在系统运行时轻松更改关键的系统标识符。</li><li><strong>命名空间隔离</strong>：为容器化等虚拟化技术提供了基础，使得主机名和域名可以在每个容器中独立存在。</li><li><strong>标准化的文件接口</strong>：<code>/proc/sys/</code> 提供了一个简单、易于脚本操作的文本文件接口，与传统的 <code>sethostname(2)</code> 系统调用互为补充。</li><li><strong>一致性</strong>：确保通过 <code>sysctl</code> 接口所做的更改能立即通过 <code>uname(2)</code> 系统调用反映出来，保证了数据的一致性。</li></ul><h4 id="它存在哪些已知的劣势、局限性或在特定场景下的不适用性？"><a href="#它存在哪些已知的劣势、局限性或在特定场景下的不适用性？" class="headerlink" title="它存在哪些已知的劣势、局限性或在特定场景下的不适用性？"></a>它存在哪些已知的劣势、局限性或在特定场景下的不适用性？</h4><ul><li><strong>固定长度限制</strong>：UTS名称的长度受到内核中 <code>__NEW_UTS_LEN</code> 宏（通常为64）的硬编码限制。</li><li><strong><code>sysctl</code> 接口的局限性</strong>：对于简单的字符串读写，<code>sysctl</code> 足够简单。但对于更复杂的、结构化的数据配置，<code>netlink</code> 或 <code>configfs</code> 等接口通常被认为是更现代、更强大的选择。</li><li><strong>权限模型</strong>：修改主机名等操作需要 <code>CAP_SYS_ADMIN</code> 权能，这是一个非常强大的权能。虽然这是必要的，但也意味着任何需要此操作的进程都需要较高的权限。</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><h4 id="在哪些具体的业务或技术场景下，它是首选解决方案？请举例说明。"><a href="#在哪些具体的业务或技术场景下，它是首选解决方案？请举例说明。" class="headerlink" title="在哪些具体的业务或技术场景下，它是首选解决方案？请举例说明。"></a>在哪些具体的业务或技术场景下，它是首选解决方案？请举例说明。</h4><ul><li><strong>系统初始化配置主机名</strong>：在系统首次启动或通过自动化工具（如Ansible, Puppet）配置时，最直接的方式就是写入 <code>/proc/sys/kernel/hostname</code>。<ul><li>示例：<code>echo &quot;web-server-01&quot; &gt; /proc/sys/kernel/hostname</code></li></ul></li><li><strong>容器运行时</strong>：当启动一个新容器时，容器运行时（如Docker）会为该容器创建一个新的UTS命名空间，并通过此机制设置容器内部的主机名。<ul><li>示例：<code>docker run --hostname my-container-name -it ubuntu</code>，Docker在后台为容器设置了主机名。</li></ul></li><li><strong>监控和资产管理</strong>：监控脚本或代理需要获取内核版本号来上报或判断兼容性。最简单的方式是读取 <code>/proc/sys/kernel/osrelease</code>。<ul><li>示例：<code>kernel_version=$(cat /proc/sys/kernel/osrelease)</code></li></ul></li><li><strong>临时修改主机名进行测试</strong>：在不永久更改配置文件的情况下，临时修改主机名进行网络测试。</li></ul><h4 id="是否有不推荐使用该技术的场景？为什么？"><a href="#是否有不推荐使用该技术的场景？为什么？" class="headerlink" title="是否有不推荐使用该技术的场景？为什么？"></a>是否有不推荐使用该技术的场景？为什么？</h4><p>该技术的功能非常专一，因此不存在“不推荐”的场景，只有“不适用”的场景。例如，配置网络IP地址、路由表或防火墙规则等，这些都属于网络子系统的范畴，需要使用 <code>iproute2</code>（netlink）、<code>nftables</code> 等专用工具，而与 <code>utsname</code> 无关。</p><h3 id="对比分析"><a href="#对比分析" class="headerlink" title="对比分析"></a>对比分析</h3><h4 id="请将其-与-其他相似技术-进行详细对比。"><a href="#请将其-与-其他相似技术-进行详细对比。" class="headerlink" title="请将其 与 其他相似技术 进行详细对比。"></a>请将其 与 其他相似技术 进行详细对比。</h4><p><code>utsname_sysctl.c</code> 提供的 <code>sysctl</code> 文件接口，最直接的对比对象是 <code>sethostname(2)</code> 和 <code>gethostname(2)</code> 系统调用。</p><table><thead><tr><th align="left">特性</th><th align="left">Sysctl 接口 (<code>/proc/sys/kernel/...</code>)</th><th align="left"><code>sethostname(2)</code> &#x2F; <code>gethostname(2)</code> 系统调用</th></tr></thead><tbody><tr><td align="left"><strong>功能概述</strong></td><td align="left">通过读写<strong>文件</strong>来查询和修改UTS名称。</td><td align="left">通过<strong>函数调用</strong>来查询和修改UTS名称。</td></tr><tr><td align="left"><strong>实现方式</strong></td><td align="left">VFS层将文件操作映射到内核中的<code>ctl_table</code>处理器。</td><td align="left">标准的系统调用接口，通过软件中断进入内核执行相应函数。</td></tr><tr><td align="left"><strong>底层逻辑</strong></td><td align="left"><strong>共享</strong>。<code>sysctl</code>的写操作处理函数最终会调用与<code>sethostname</code>系统调用相同的内部内核函数（如<code>set_uts_name</code>）来修改<code>uts_namespace</code>结构体。它们是同一功能的两个不同入口。</td><td align="left"><strong>共享</strong>。直接调用内核的内部函数来完成操作。</td></tr><tr><td align="left"><strong>易用性</strong></td><td align="left"><strong>对脚本友好</strong>。在shell脚本或简单的自动化任务中非常易于使用，无需编写C代码。</td><td align="left"><strong>对程序友好</strong>。在C&#x2F;C++等编译型语言编写的应用程序中，是标准的、可移植的（POSIX）方式。</td></tr><tr><td align="left"><strong>性能开销</strong></td><td align="left"><strong>略高</strong>。涉及VFS路径查找、文件打开&#x2F;关闭等上下文切换开销。</td><td align="left"><strong>略低</strong>。更直接的系统调用路径，开销更小。</td></tr><tr><td align="left"><strong>主要用途</strong></td><td align="left">系统管理、自动化脚本、临时配置。</td><td align="left"><code>hostname</code>等系统命令的底层实现、需要设置主机名的应用程序。</td></tr></tbody></table><p><strong>与Netlink&#x2F;ConfigFS对比</strong>：</p><ul><li><strong>Sysctl</strong>：适用于简单的、扁平化的键值对（如一个字符串、一个整数）。</li><li><strong>Netlink</strong>：基于套接字的异步消息传递机制，适用于复杂的、事务性的配置，是现代网络配置（<code>iproute2</code>）的标准。</li><li><strong>ConfigFS&#x2F;Sysfs</strong>：基于文件系统的对象模型，适用于表示和配置具有复杂层次结构和属性的内核对象。</li></ul><p>对于UTS名称这种简单的字符串属性，<code>sysctl</code> 接口虽然古老，但因其简单直观，仍然是完全适用且高效的解决方案。</p><h2 id="utsname-sysctl-init-内核身份标识-sysctl-接口初始化"><a href="#utsname-sysctl-init-内核身份标识-sysctl-接口初始化" class="headerlink" title="utsname_sysctl_init: 内核身份标识 sysctl 接口初始化"></a>utsname_sysctl_init: 内核身份标识 sysctl 接口初始化</h2><p>本代码片段负责在 Linux 内核的 <code>sysctl</code> 文件系统中，于 <code>/proc/sys/kernel/</code> 目录下，创建一系列用于展示和（部分）修改系统身份标识信息的文件。这些信息与用户空间 <code>uname</code> 命令所展示的内容相对应，例如主机名、操作系统版本、硬件架构等。其核心功能是将内核内部的初始 UTS 命名空间 (<code>init_uts_ns</code>) 中的数据结构成员直接暴露给用户空间，并为其中可变的项目（如主机名）提供了异步变更通知机制。</p><h3 id="实现原理分析"><a href="#实现原理分析" class="headerlink" title="实现原理分析"></a>实现原理分析</h3><p>该机制是内核 <code>sysctl</code> 框架的典型应用，通过一个静态定义的 <code>ctl_table</code> 结构体数组，将内核数据与 VFS 文件系统接口进行绑定。</p><ol><li><p><strong>直接数据绑定</strong>:</p><ul><li><code>uts_kern_table</code> 数组是此功能的核心。它的每个条目都定义了一个 <code>sysctl</code> 文件。关键在于 <code>.data</code> 成员，它被直接设置为指向内核全局变量 <code>init_uts_ns.name</code> 结构体中某个字段的指针（例如，<code>.data = init_uts_ns.name.nodename</code>）。</li><li>这意味着当用户空间读写这些 <code>/proc</code> 文件时，<code>sysctl</code> 的处理函数 (<code>proc_do_uts_string</code>) 将直接操作内核核心数据结构所在的内存，而非通过一个中间缓冲区。这种设计效率很高，但要求处理函数必须正确地处理并发访问（例如，通过锁）。</li></ul></li><li><p><strong>异步变更通知机制 (<code>poll</code>)</strong>:</p><ul><li>对于可被用户修改的条目，如 <code>hostname</code> 和 <code>domainname</code>，<code>sysctl</code> 表中额外指定了一个 <code>.poll</code> 字段。</li><li><code>DEFINE_CTL_TABLE_POLL</code> 宏为每个条目创建了一个 <code>ctl_table_poll</code> 结构体，其内部包含一个等待队列（wait queue）。</li><li>当用户空间的应用程序对 <code>/proc/sys/kernel/hostname</code> 的文件描述符使用 <code>poll()</code>, <code>select()</code> 或 <code>epoll()</code> 等系统调用时，内核会将该进程放入 <code>hostname_poll</code> 对应的等待队列中并使其睡眠。</li><li>当内核的其他部分（例如，通过 <code>sethostname()</code> 系统调用）修改了主机名后，会调用 <code>uts_proc_notify</code> 函数。此函数通过 <code>proc_sys_poll_notify</code> 唤醒所有在该等待队列上睡眠的进程。</li><li>这套机制实现了一个高效的事件驱动模型，允许用户空间程序异步地、低开销地监控系统关键配置的变化。</li></ul></li><li><p><strong>初始化与注册</strong>:</p><ul><li><code>utsname_sysctl_init</code> 函数调用 <code>register_sysctl</code>，将 <code>uts_kern_table</code> 注册到内核的 <code>sysctl</code> 树的 <code>kernel</code> 目录下。</li><li><code>device_initcall</code> 宏将 <code>utsname_sysctl_init</code> 函数注册为一个内核启动回调，确保在内核初始化过程中的适当阶段自动完成 <code>sysctl</code> 接口的创建。</li></ul></li></ol><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 为 hostname 和 domainname sysctl 条目定义 poll 结构体。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * DEFINE_CTL_TABLE_POLL 宏创建了一个 ctl_table_poll 类型的静态变量，</span></span><br><span class="line"><span class="comment"> * 该变量内部包含一个等待队列头 (wait_queue_head_t)，用于支持 poll 系统调用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">DEFINE_CTL_TABLE_POLL</span><span class="params">(hostname_poll)</span>;</span><br><span class="line"><span class="type">static</span> <span class="title function_">DEFINE_CTL_TABLE_POLL</span><span class="params">(domainname_poll)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @var uts_kern_table</span></span><br><span class="line"><span class="comment"> * @brief 定义 /proc/sys/kernel/ 下与 UTS (uname) 信息相关的 sysctl 文件。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：对该表的任何修改都必须同步更新内核头文件中的 &#x27;enum uts_proc&#x27;。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">ctl_table</span> <span class="title">uts_kern_table</span>[] =</span> &#123;</span><br><span class="line">&#123;</span><br><span class="line">.procname= <span class="string">&quot;arch&quot;</span>, <span class="comment">/**&lt; 文件名: architecture */</span></span><br><span class="line">.data= init_uts_ns.name.machine, <span class="comment">/**&lt; 直接指向内核初始UTS命名空间中的 machine 字段 */</span></span><br><span class="line">.maxlen= <span class="keyword">sizeof</span>(init_uts_ns.name.machine), <span class="comment">/**&lt; 最大长度，用于边界检查 */</span></span><br><span class="line">.mode= <span class="number">0444</span>, <span class="comment">/**&lt; 权限：全局只读 */</span></span><br><span class="line">.proc_handler= proc_do_uts_string, <span class="comment">/**&lt; 指定专用的读写处理函数 */</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">.procname= <span class="string">&quot;ostype&quot;</span>, <span class="comment">/**&lt; 文件名: operating system type */</span></span><br><span class="line">.data= init_uts_ns.name.sysname,</span><br><span class="line">.maxlen= <span class="keyword">sizeof</span>(init_uts_ns.name.sysname),</span><br><span class="line">.mode= <span class="number">0444</span>,</span><br><span class="line">.proc_handler= proc_do_uts_string,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">.procname= <span class="string">&quot;osrelease&quot;</span>, <span class="comment">/**&lt; 文件名: operating system release */</span></span><br><span class="line">.data= init_uts_ns.name.release,</span><br><span class="line">.maxlen= <span class="keyword">sizeof</span>(init_uts_ns.name.release),</span><br><span class="line">.mode= <span class="number">0444</span>,</span><br><span class="line">.proc_handler= proc_do_uts_string,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">.procname= <span class="string">&quot;version&quot;</span>, <span class="comment">/**&lt; 文件名: kernel version */</span></span><br><span class="line">.data= init_uts_ns.name.version,</span><br><span class="line">.maxlen= <span class="keyword">sizeof</span>(init_uts_ns.name.version),</span><br><span class="line">.mode= <span class="number">0444</span>,</span><br><span class="line">.proc_handler= proc_do_uts_string,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">.procname= <span class="string">&quot;hostname&quot;</span>, <span class="comment">/**&lt; 文件名: host name */</span></span><br><span class="line">.data= init_uts_ns.name.nodename,</span><br><span class="line">.maxlen= <span class="keyword">sizeof</span>(init_uts_ns.name.nodename),</span><br><span class="line">.mode= <span class="number">0644</span>, <span class="comment">/**&lt; 权限：root 可读写，其他用户只读 */</span></span><br><span class="line">.proc_handler= proc_do_uts_string,</span><br><span class="line">.poll= &amp;hostname_poll, <span class="comment">/**&lt; 关联 poll 结构体，以支持变更通知 */</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">.procname= <span class="string">&quot;domainname&quot;</span>, <span class="comment">/**&lt; 文件名: domain name */</span></span><br><span class="line">.data= init_uts_ns.name.domainname,</span><br><span class="line">.maxlen= <span class="keyword">sizeof</span>(init_uts_ns.name.domainname),</span><br><span class="line">.mode= <span class="number">0644</span>,</span><br><span class="line">.proc_handler= proc_do_uts_string,</span><br><span class="line">.poll= &amp;domainname_poll, <span class="comment">/**&lt; 关联 poll 结构体 */</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PROC_SYSCTL</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 通知用户空间 uts_kern_table 中的某个条目发生了变化。</span></span><br><span class="line"><span class="comment"> * @param proc 枚举值，作为 uts_kern_table 数组的索引，标识哪个条目已更改。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">uts_proc_notify</span><span class="params">(<span class="keyword">enum</span> uts_proc proc)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 根据索引获取对应的 ctl_table 条目。</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">ctl_table</span> *<span class="title">table</span> =</span> &amp;uts_kern_table[proc];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒所有在该条目的 poll 等待队列上睡眠的进程。</span></span><br><span class="line">proc_sys_poll_notify(table-&gt;poll);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief UTS sysctl 接口的初始化函数。</span></span><br><span class="line"><span class="comment"> * @return 总是返回 0 表示成功。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 此函数被标记为 __init，其代码段在内核启动后会被释放。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">utsname_sysctl_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 将 uts_kern_table 注册到 &quot;kernel&quot; 目录下。</span></span><br><span class="line">register_sysctl(<span class="string">&quot;kernel&quot;</span>, uts_kern_table);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 使用 device_initcall 宏来注册初始化函数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 确保 utsname_sysctl_init 在内核启动的 device 初始化阶段被调用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">device_initcall(utsname_sysctl_init);</span><br></pre></td></tr></table></figure><h2 id="proc-do-uts-string-命名空间感知且锁安全的UTS字符串处理"><a href="#proc-do-uts-string-命名空间感知且锁安全的UTS字符串处理" class="headerlink" title="proc_do_uts_string: 命名空间感知且锁安全的UTS字符串处理"></a>proc_do_uts_string: 命名空间感知且锁安全的UTS字符串处理</h2><p>本代码片段是 <code>sysctl</code> 框架中一个至关重要的、专用的处理函数，用于安全地读写与 UTS 命名空间相关的字符串，如主机名和域名。其核心功能是作为一个桥梁，在遵循内核严格的并发控制规则（不能在持有锁时睡眠）的前提下，实现对当前进程所属 UTS 命名空间内数据的读写，并确保变更可以被其他应用程序异步感知。</p><h3 id="实现原理分析-1"><a href="#实现原理分析-1" class="headerlink" title="实现原理分析"></a>实现原理分析</h3><p>此函数的设计是解决内核中一个经典并发问题的范例：如何安全地操作一个受锁保护且可能需要与用户空间进行可睡眠操作（如 <code>copy_from_user</code>）的数据。它采用了一种“<strong>拷贝-修改-写回</strong>”（Copy-Modify-Writeback）的缓冲策略。</p><ol><li><p><strong>命名空间感知地址解析 (<code>get_uts</code>)</strong>:</p><ul><li>此函数是实现命名空间隔离的关键。<code>sysctl</code> 表中定义的 <code>.data</code> 指针（<code>table-&gt;data</code>）指向的是<strong>初始命名空间</strong>（<code>init_uts_ns</code>）中的字段地址。</li><li><code>get_uts</code> 函数首先获取<strong>当前进程</strong>所属的 UTS 命名空间（<code>current-&gt;nsproxy-&gt;uts_ns</code>）。</li><li>然后，通过指针算术 <code>(which - (char *)&amp;init_uts_ns)</code> 计算出目标字段（如 <code>nodename</code>）相对于 <code>init_uts_ns</code> 结构体起始地址的<strong>偏移量</strong>。</li><li>最后，将这个偏移量加到当前进程的 UTS 命名空间基地址上，从而精确地定位到当前进程应该看到和修改的数据的实际内存地址。</li></ul></li><li><p><strong>两阶段加锁与临时缓冲</strong>:</p><ul><li><strong>核心问题</strong>: <code>proc_dostring</code> 函数内部可能会因为调用 <code>copy_from_user</code>&#x2F;<code>copy_to_user</code> 而导致进程睡眠。在 Linux 内核中，持有信号量（<code>uts_sem</code>）或自旋锁时睡眠是严格禁止的，因为它可能导致死锁。</li><li><strong>解决方案</strong>:<br>a.  <strong>创建临时副本</strong>: 函数在栈上创建了一个临时缓冲区 <code>tmp_data</code>，并创建了一个 <code>ctl_table</code> 的临时副本 <code>uts_table</code>，将其 <code>.data</code> 指针指向这个安全的栈上缓冲区。<br>b.  <strong>第一阶段：带锁读取</strong>: 它获取一个<strong>读信号量</strong>（<code>down_read(&amp;uts_sem)</code>），这允许多个并发的读操作。在这个短暂的临界区内，它将受保护的真实 UTS 数据从当前命名空间拷贝到 <code>tmp_data</code> 缓冲区，然后<strong>立即释放锁</strong>（<code>up_read(&amp;uts_sem)</code>）。<br>c.  <strong>无锁操作</strong>: 接下来，它调用 <code>proc_dostring</code>。此时，<code>proc_dostring</code> 的所有读写操作都只针对 <code>tmp_data</code> 这个位于栈上的、不受保护的局部变量。即使 <code>proc_dostring</code> 睡眠，也不会有任何锁被持有，从而避免了死锁。<br>d.  <strong>第二阶段：带锁写回</strong> (仅限写操作): 如果是写操作，在 <code>proc_dostring</code> 返回后（此时 <code>tmp_data</code> 已包含用户写入的新数据），它获取一个<strong>写信号量</strong>（<code>down_write(&amp;uts_sem)</code>），这是排他性的。在临界区内，它将 <code>tmp_data</code> 的内容写回到真实的 UTS 命名空间内存中，然后<strong>立即释放锁</strong>（<code>up_write(&amp;uts_sem)</code>）。</li></ul></li><li><p><strong>熵贡献与变更通知</strong>:</p><ul><li><code>add_device_randomness</code>: 在写回新值之前，将用户提供的新主机名&#x2F;域名作为随机源，贡献给内核的熵池，以提高系统随机数的质量。</li><li><code>proc_sys_poll_notify</code>: 写操作成功后，调用此函数来唤醒任何正在 <code>poll</code> 相应 <code>sysctl</code> 文件的进程，实现了对配置变更的异步通知。</li></ul></li></ol><h3 id="代码分析-1"><a href="#代码分析-1" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 获取当前进程UTS命名空间中特定字段的地址。</span></span><br><span class="line"><span class="comment"> * @param table 指向 ctl_table 的指针，其 .data 字段用作计算偏移量的模板。</span></span><br><span class="line"><span class="comment"> * @return 指向当前命名空间中目标字段的 void 指针。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">get_uts</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> ctl_table *table)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// which 最初指向 init_uts_ns 中的字段（模板地址）。</span></span><br><span class="line"><span class="type">char</span> *which = table-&gt;data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uts_namespace</span> *<span class="title">uts_ns</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前进程关联的 UTS 命名空间。</span></span><br><span class="line">uts_ns = current-&gt;nsproxy-&gt;uts_ns;</span><br><span class="line"><span class="comment">// 计算目标字段在结构体内的偏移量，并将其加到当前命名空间的基地址上，</span></span><br><span class="line"><span class="comment">// 从而得到当前上下文下正确的字段地址。</span></span><br><span class="line">which = (which - (<span class="type">char</span> *)&amp;init_uts_ns) + (<span class="type">char</span> *)uts_ns;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> which;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief UTS 结构体专用的 sysctl 字符串处理函数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这是一个 proc_dostring 的特例，因为它需要处理锁。</span></span><br><span class="line"><span class="comment"> * 它通过一个临时缓冲区来避免在持有锁时调用可能睡眠的函数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">proc_do_uts_string</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> ctl_table *table, <span class="type">int</span> write,</span></span><br><span class="line"><span class="params">  <span class="type">void</span> *buffer, <span class="type">size_t</span> *lenp, <span class="type">loff_t</span> *ppos)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ctl_table</span> <span class="title">uts_table</span>;</span></span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"><span class="comment">// 在栈上创建一个临时缓冲区，用于与 proc_dostring 交互。</span></span><br><span class="line"><span class="type">char</span> tmp_data[__NEW_UTS_LEN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制一份 ctl_table，以便我们可以安全地修改其 .data 指针。</span></span><br><span class="line"><span class="built_in">memcpy</span>(&amp;uts_table, table, <span class="keyword">sizeof</span>(uts_table));</span><br><span class="line"><span class="comment">// 将副本的 .data 指针指向我们的临时栈缓冲区。</span></span><br><span class="line">uts_table.data = tmp_data;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将值缓冲到 tmp_data 中，这样就可以在不持有任何锁的情况下调用 proc_dostring()。</span></span><br><span class="line"><span class="comment"> * 在 write==1 的情况下，我们也需要读取原始值以支持部分写入。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">down_read(&amp;uts_sem); <span class="comment">// 获取读锁</span></span><br><span class="line"><span class="built_in">memcpy</span>(tmp_data, get_uts(table), <span class="keyword">sizeof</span>(tmp_data)); <span class="comment">// 从真实位置拷贝到临时缓冲</span></span><br><span class="line">up_read(&amp;uts_sem);   <span class="comment">// 立即释放读锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在，在不持有任何锁的情况下，对临时缓冲区执行标准的字符串读写操作。</span></span><br><span class="line">r = proc_dostring(&amp;uts_table, write, buffer, lenp, ppos);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (write) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将新值写回。</span></span><br><span class="line"><span class="comment"> * 注意：由于我们已释放 uts_sem，如果存在两个对同一 sysctl 在非零偏移量</span></span><br><span class="line"><span class="comment"> * 上的并行写入，理论上结果可能不正确。这是一个已知的权衡。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 将用户输入的数据贡献给内核的熵池。</span></span><br><span class="line">add_device_randomness(tmp_data, <span class="keyword">sizeof</span>(tmp_data));</span><br><span class="line">down_write(&amp;uts_sem); <span class="comment">// 获取排他性的写锁</span></span><br><span class="line"><span class="built_in">memcpy</span>(get_uts(table), tmp_data, <span class="keyword">sizeof</span>(tmp_data)); <span class="comment">// 从临时缓冲写回到真实位置</span></span><br><span class="line">up_write(&amp;uts_sem);   <span class="comment">// 释放写锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通知任何正在 poll 此文件的用户空间进程，数据已发生变更。</span></span><br><span class="line">proc_sys_poll_notify(table-&gt;poll);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="init-version-timestamp-c"><a href="#init-version-timestamp-c" class="headerlink" title="init&#x2F;version-timestamp.c"></a>init&#x2F;version-timestamp.c</h1><h2 id="init-uts-ns-与-linux-banner-内核身份标识的静态定义"><a href="#init-uts-ns-与-linux-banner-内核身份标识的静态定义" class="headerlink" title="init_uts_ns 与 linux_banner: 内核身份标识的静态定义"></a>init_uts_ns 与 linux_banner: 内核身份标识的静态定义</h2><p>本代码片段展示了 Linux 内核在编译时如何静态定义其核心身份标识。它初始化了两个关键的全局变量：<code>init_uts_ns</code>，即初始 UTS 命名空间，它以结构化形式存储了系统名、主机名、内核版本等信息；以及 <code>linux_banner</code>，一个包含了部分上述信息的、用于在启动时显示的、人类可读的常量字符串。</p><h3 id="实现原理分析-2"><a href="#实现原理分析-2" class="headerlink" title="实现原理分析"></a>实现原理分析</h3><p>此代码是内核自描述能力的基础，其原理基于 C 语言的静态初始化和构建系统的宏替换。</p><ol><li><p><strong>静态初始化</strong>:</p><ul><li><code>init_uts_ns</code> 和 <code>linux_banner</code> 都是全局变量，在内核加载到内存时，它们就已经存在，并且其内容由编译器在生成内核映像时直接填充。它们不依赖于任何运行时的初始化代码来创建。</li><li><code>init_uts_ns</code> 被初始化为一个 <code>struct uts_namespace</code> 实例。其 <code>.name</code> 成员是一个嵌套的结构体，包含了所有 <code>uname</code> 系统调用所需返回的信息。</li></ul></li><li><p><strong>编译时宏定义</strong>:</p><ul><li>初始化的值，如 <code>UTS_SYSNAME</code>, <code>UTS_RELEASE</code>, <code>LINUX_COMPILE_BY</code> 等，并非硬编码的字符串。它们是 C 预处理器宏。</li><li>这些宏的值是在内核的编译过程中，由 Kconfig 配置系统和顶层 Makefile 文件根据当前的配置、编译器版本、编译主机名、编译者等环境信息动态生成的。这些信息最终通过 <code>-D</code> 编译器标志传递给 C 编译器。</li><li>这种机制确保了每一个编译出的内核二进制文件都精确地内嵌了其自身的元数据，包括版本号、构建环境等，这对于调试、版本跟踪和系统识别至关重要。</li></ul></li><li><p><strong>命名空间根节点</strong>:</p><ul><li><code>init_uts_ns</code> 不仅仅是一个数据容器，它还是内核中所有 UTS 命名空间的<strong>根</strong>。当系统启动时，<code>init</code> 进程就属于这个命名空间。</li><li>如果系统后续创建了新的 UTS 命名空间（例如，用于容器），新命名空间的初始内容通常会从其父命名空间复制而来，最终可以追溯到 <code>init_uts_ns</code>。</li><li><code>.ns.__ns_ref = REFCOUNT_INIT(2)</code> 初始化了该命名空间的引用计数为2。一个引用由命名空间子系统本身持有，另一个由初始任务（<code>init</code>）的 <code>nsproxy</code> 持有。</li></ul></li></ol><h3 id="代码分析-2"><a href="#代码分析-2" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @var init_uts_ns</span></span><br><span class="line"><span class="comment"> * @brief 内核的初始 UTS (UNIX Time-sharing System) 命名空间。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这是一个全局变量，在内核编译时被静态初始化。它包含了系统的核心身份信息，</span></span><br><span class="line"><span class="comment"> * 并且是系统中所有后续创建的 UTS 命名空间的根。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uts_namespace</span> <span class="title">init_uts_ns</span> =</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @var ns.ns_type</span></span><br><span class="line"><span class="comment"> * @brief 命名空间的类型，对于UTS ns，此宏返回一个固定的类型标识。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">.ns.ns_type = ns_common_type(&amp;init_uts_ns),</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @var ns.__ns_ref</span></span><br><span class="line"><span class="comment"> * @brief 命名空间的引用计数，初始为2。</span></span><br><span class="line"><span class="comment"> * (一个用于nsfs，一个用于init_nsproxy)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">.ns.__ns_ref = REFCOUNT_INIT(<span class="number">2</span>),</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @var name</span></span><br><span class="line"><span class="comment"> * @brief 包含所有 uname 信息的结构体。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">.name = &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @var sysname</span></span><br><span class="line"><span class="comment"> * @brief 操作系统名称 (例如 &quot;Linux&quot;)。值由 UTS_SYSNAME 宏在编译时确定。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">.sysname= UTS_SYSNAME,</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @var nodename</span></span><br><span class="line"><span class="comment"> * @brief 节点名/主机名 (例如 &quot;localhost&quot;)。值由 UTS_NODENAME 宏在编译时确定。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">.nodename= UTS_NODENAME,</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @var release</span></span><br><span class="line"><span class="comment"> * @brief 内核发布版本 (例如 &quot;5.10.0&quot;)。值由 UTS_RELEASE 宏在编译时确定。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">.release= UTS_RELEASE,</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @var version</span></span><br><span class="line"><span class="comment"> * @brief 内核详细版本字符串 (例如 &quot;#1 SMP PREEMPT ...&quot;)。值由 UTS_VERSION 宏在编译时确定。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">.version= UTS_VERSION,</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @var machine</span></span><br><span class="line"><span class="comment"> * @brief 硬件架构名称 (例如 &quot;armv7l&quot;)。值由 UTS_MACHINE 宏在编译时确定。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">.machine= UTS_MACHINE,</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @var domainname</span></span><br><span class="line"><span class="comment"> * @brief NIS/YP 域名。值由 UTS_DOMAINNAME 宏在编译时确定。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">.domainname= UTS_DOMAINNAME,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @var user_ns</span></span><br><span class="line"><span class="comment"> * @brief 指向此命名空间所属的用户命名空间，初始时指向初始用户命名空间。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">.user_ns = &amp;init_user_ns,</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @var ns.inum</span></span><br><span class="line"><span class="comment"> * @brief 此命名空间在 nsfs 文件系统中的 inode 号。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">.ns.inum = ns_init_inum(&amp;init_uts_ns),</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_UTS_NS</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @var ns.ops</span></span><br><span class="line"><span class="comment"> * @brief 指向UTS命名空间操作函数的指针表。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">.ns.ops = &amp;utsns_operations,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 固定的字符串！请勿修改！ */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @var linux_banner</span></span><br><span class="line"><span class="comment"> * @brief 内核启动时打印的横幅信息。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这是一个静态常量字符串，其内容在内核编译时由多个宏拼接而成，</span></span><br><span class="line"><span class="comment"> * 包含了版本、编译器、编译主机等信息。它通常通过 /proc/version 文件暴露给用户空间。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> linux_banner[] =</span><br><span class="line"><span class="string">&quot;Linux version &quot;</span> UTS_RELEASE <span class="string">&quot; (&quot;</span> LINUX_COMPILE_BY <span class="string">&quot;@&quot;</span></span><br><span class="line">LINUX_COMPILE_HOST <span class="string">&quot;) (&quot;</span> LINUX_COMPILER <span class="string">&quot;) &quot;</span> UTS_VERSION <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><h1 id="kernel-user-c"><a href="#kernel-user-c" class="headerlink" title="kernel&#x2F;user.c"></a>kernel&#x2F;user.c</h1><h2 id="init-user-ns-初始用户命名空间的静态定义"><a href="#init-user-ns-初始用户命名空间的静态定义" class="headerlink" title="init_user_ns: 初始用户命名空间的静态定义"></a>init_user_ns: 初始用户命名空间的静态定义</h2><p>本代码片段定义并初始化了 <code>init_user_ns</code>，即内核的<strong>初始用户命名空间</strong>（Root User Namespace）。这是 Linux 内核中用户和组身份标识体系的基石。其核心功能是为整个系统建立一个初始的、1:1 的身份映射，并作为所有进程默认的用户命名空间，以及未来创建任何新用户命名空间的最终父节点。</p><h3 id="实现原理分析-3"><a href="#实现原理分析-3" class="headerlink" title="实现原理分析"></a>实现原理分析</h3><p><code>init_user_ns</code> 的实现依赖于 C 语言的静态初始化，并为内核的用户隔离机制（用户命名空间）提供了基础配置。</p><ol><li><p><strong>静态初始化</strong>:</p><ul><li><code>init_user_ns</code> 是一个在编译时就被完全初始化的全局变量。它不依赖于任何运行时的代码来创建，而是作为内核 <code>.data</code> 段的一部分，在内核映像加载到内存时就已存在。</li></ul></li><li><p><strong>身份映射 (Identity Mapping)</strong>:</p><ul><li>用户命名空间的核心功能是建立一套 UID&#x2F;GID 的映射规则。<code>init_user_ns</code> 的 <code>uid_map</code>、<code>gid_map</code> 和 <code>projid_map</code> 被配置为最基础的<strong>身份映射</strong>。</li><li><code>.first = 0</code>: 映射范围从命名空间内部的 ID 0 开始。</li><li><code>.lower_first = 0</code>: 内部 ID 0 映射到父命名空间（对于根命名空间，即物理系统）的 ID 0。</li><li><code>.count = 4294967295U</code>: 映射范围覆盖了整个 32 位 ID 空间。</li><li>综合来看，这套配置意味着在初始用户命名空间中，任意一个 UID&#x2F;GID <code>X</code> 都等同于物理系统中的 UID&#x2F;GID <code>X</code>。这是所有后续嵌套命名空间进行ID转换的参照系原点。</li></ul></li><li><p><strong>引用计数 (<code>REFCOUNT_INIT(3)</code>)</strong>:</p><ul><li><code>init_user_ns</code> 的引用计数被初始化为 3。这是一个关键的细节，确保了根命名空间在系统运行期间不会被意外释放。这三个引用通常来源于：<ol><li>用户命名空间子系统本身持有的一个引用，作为其根节点。</li><li>初始任务（<code>init_task</code>，即 pid 0 的 <code>swapper</code> 进程）的凭证（<code>cred</code>）结构持有的一个引用。</li><li>初始任务代理（<code>init_nsproxy</code>）通过其包含的其他命名空间（如 <code>init_uts_ns</code>，它本身需要关联一个用户命名空间）间接持有的一个引用。</li></ol></li><li>代码注释中的 <code>?</code> 暗示了第三个引用的来源不那么直观，但它确保了所有初始内核子系统都能安全地关联到这个根用户命名空间。</li></ul></li><li><p><strong>符号导出 (<code>EXPORT_SYMBOL_GPL</code>)</strong>:</p><ul><li>此宏将 <code>init_user_ns</code> 变量的地址导出到内核的符号表中。这使得遵循 GPL 许可证的可加载内核模块（LKMs）能够在运行时查找到并使用这个变量，例如，用于与用户身份相关的操作。</li></ul></li></ol><h3 id="代码分析-3"><a href="#代码分析-3" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 用户命名空间引用计数：1个来自 root 用户，1个来自 init_uts_ns，</span></span><br><span class="line"><span class="comment"> * 还有1个来自...？（实际上是来自内核子系统和初始任务凭证）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @var init_user_ns</span></span><br><span class="line"><span class="comment"> * @brief 内核的初始用户命名空间 (Root User Namespace)。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这是系统中所有用户/组身份的根。它定义了一个覆盖所有ID的 1:1 映射，</span></span><br><span class="line"><span class="comment"> * 并作为所有初始进程和未来创建的新用户命名空间的最终父节点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> <span class="title">init_user_ns</span> =</span> &#123;</span><br><span class="line"><span class="comment">/** @brief UID 映射表 */</span></span><br><span class="line">.uid_map = &#123; &#123;</span><br><span class="line">.extent[<span class="number">0</span>] = &#123;</span><br><span class="line">.first = <span class="number">0</span>,       <span class="comment">/**&lt; 命名空间内的起始 UID */</span></span><br><span class="line">.lower_first = <span class="number">0</span>, <span class="comment">/**&lt; 映射到父命名空间中的起始 UID */</span></span><br><span class="line">.count = <span class="number">4294967295U</span>, <span class="comment">/**&lt; 映射范围覆盖整个32位UID空间 */</span></span><br><span class="line">&#125;,</span><br><span class="line">.nr_extents = <span class="number">1</span>, <span class="comment">/**&lt; 只有一个映射范围 */</span></span><br><span class="line">&#125;, &#125;,</span><br><span class="line"><span class="comment">/** @brief GID 映射表，结构同 UID 映射 */</span></span><br><span class="line">.gid_map = &#123; &#123;</span><br><span class="line">.extent[<span class="number">0</span>] = &#123;</span><br><span class="line">.first = <span class="number">0</span>,</span><br><span class="line">.lower_first = <span class="number">0</span>,</span><br><span class="line">.count = <span class="number">4294967295U</span>,</span><br><span class="line">&#125;,</span><br><span class="line">.nr_extents = <span class="number">1</span>,</span><br><span class="line">&#125;, &#125;,</span><br><span class="line"><span class="comment">/** @brief Project ID 映射表，结构同 UID 映射 */</span></span><br><span class="line">.projid_map = &#123; &#123;</span><br><span class="line">.extent[<span class="number">0</span>] = &#123;</span><br><span class="line">.first = <span class="number">0</span>,</span><br><span class="line">.lower_first = <span class="number">0</span>,</span><br><span class="line">.count = <span class="number">4294967295U</span>,</span><br><span class="line">&#125;,</span><br><span class="line">.nr_extents = <span class="number">1</span>,</span><br><span class="line">&#125;, &#125;,</span><br><span class="line"><span class="comment">/** @brief 命名空间的通用类型信息 */</span></span><br><span class="line">.ns.ns_type = ns_common_type(&amp;init_user_ns),</span><br><span class="line"><span class="comment">/** @brief 命名空间的引用计数，初始为3 */</span></span><br><span class="line">.ns.__ns_ref = REFCOUNT_INIT(<span class="number">3</span>),</span><br><span class="line"><span class="comment">/** @brief 此命名空间的创建者UID，对于初始命名空间为全局 root */</span></span><br><span class="line">.owner = GLOBAL_ROOT_UID,</span><br><span class="line"><span class="comment">/** @brief 此命名空间的创建者GID，对于初始命名空间为全局 root */</span></span><br><span class="line">.group = GLOBAL_ROOT_GID,</span><br><span class="line"><span class="comment">/** @brief 此命名空间在 nsfs 文件系统中的 inode 号 */</span></span><br><span class="line">.ns.inum = ns_init_inum(&amp;init_user_ns),</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_USER_NS</span></span><br><span class="line"><span class="comment">/** @brief 指向用户命名空间操作函数的指针表 */</span></span><br><span class="line">.ns.ops = &amp;userns_operations,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/** @brief 命名空间的标志位 */</span></span><br><span class="line">.flags = USERNS_INIT_FLAGS,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line"><span class="comment">/** @brief 内核密钥环相关的链表头 */</span></span><br><span class="line">.keyring_name_list = LIST_HEAD_INIT(init_user_ns.keyring_name_list),</span><br><span class="line"><span class="comment">/** @brief 内核密钥环相关的读写信号量 */</span></span><br><span class="line">.keyring_sem = __RWSEM_INITIALIZER(init_user_ns.keyring_sem),</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> IS_ENABLED(CONFIG_BINFMT_MISC)</span></span><br><span class="line"><span class="comment">/** @brief 指向 binfmt_misc 数据结构的指针 */</span></span><br><span class="line">.binfmt_misc = &amp;init_binfmt_misc,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 将 init_user_ns 符号导出，使其对 GPL 兼容的内核模块可见。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">EXPORT_SYMBOL_GPL(init_user_ns);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;

&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i-blog.csdnimg.cn/direct/bd176eb7fe7143cca30f5097efc1</summary>
      
    
    
    
    <category term="linux" scheme="https://wdfk-prog.space/categories/linux/"/>
    
    <category term="kernel" scheme="https://wdfk-prog.space/categories/linux/kernel/"/>
    
    
    <category term="linux" scheme="https://wdfk-prog.space/tags/linux/"/>
    
    <category term="kernel" scheme="https://wdfk-prog.space/tags/kernel/"/>
    
  </entry>
  
  <entry>
    <title>seccomp</title>
    <link href="https://wdfk-prog.space/posts/2c09369a/"/>
    <id>https://wdfk-prog.space/posts/2c09369a/</id>
    <published>2025-10-07T00:32:30.000Z</published>
    <updated>2025-10-07T01:14:20.309Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>[toc]</p><p><img src="https://i-blog.csdnimg.cn/direct/7bd978e994964bb098abe907c7dbc062.png" alt="在这里插入图片描述"></p><h1 id="kernel-seccomp-c-安全计算模式-Secure-Computing-Mode-系统调用防火墙"><a href="#kernel-seccomp-c-安全计算模式-Secure-Computing-Mode-系统调用防火墙" class="headerlink" title="kernel&#x2F;seccomp.c 安全计算模式(Secure Computing Mode) 系统调用防火墙"></a>kernel&#x2F;seccomp.c 安全计算模式(Secure Computing Mode) 系统调用防火墙</h1><h3 id="历史与背景"><a href="#历史与背景" class="headerlink" title="历史与背景"></a>历史与背景</h3><h4 id="这项技术是为了解决什么特定问题而诞生的？"><a href="#这项技术是为了解决什么特定问题而诞生的？" class="headerlink" title="这项技术是为了解决什么特定问题而诞生的？"></a>这项技术是为了解决什么特定问题而诞生的？</h4><p>Seccomp（Secure Computing Mode）是为了解决一个核心的安全问题而诞生的：<strong>如何安全地运行不可信的代码</strong>。 在复杂的软件环境中，一个进程被赋予了访问数百个系统调用（syscall）的能力，这些系统调用是用户空间程序与内核交互的接口。 然而，大多数程序在其整个生命周期中只需要使用这些系统调用中的一小部分。 如果一个程序（例如，一个处理外部输入的Web浏览器渲染进程）被恶意代码攻陷，攻击者就可以利用那些该程序本不需要、但内核依然暴露给它的系统调用来进一步攻击和破坏整个系统。</p><p>Seccomp通过提供一种机制来<strong>限制一个进程可以调用的系统调用集合</strong>，从而<strong>减少内核的攻击面</strong>。 它的核心思想是实施“最小权限原则”：只授予程序执行其核心功能所必需的最小权限集合。 这样，即使程序被攻破，攻击者能造成的损害也因为其可用的系统调用极其有限而受到严格控制。 这对于构建应用程序沙箱（sandbox）至关重要。</p><h4 id="它的发展经历了哪些重要的里程碑或版本迭代？"><a href="#它的发展经历了哪些重要的里程碑或版本迭代？" class="headerlink" title="它的发展经历了哪些重要的里程碑或版本迭代？"></a>它的发展经历了哪些重要的里程碑或版本迭代？</h4><p>Seccomp的发展经历了两个主要阶段：</p><ol><li><p><strong>模式1：严格模式 (Strict Mode)</strong></p><ul><li>该模式于2005年在Linux内核2.6.12版本中被引入。 最初由Andrea Arcangeli为网格计算场景设计，旨在安全地“出租”CPU算力。</li><li>在此模式下，一旦启用，进程只能使用四个极其基础的系统调用：<code>read()</code>、<code>write()</code>、<code>exit()</code> 和 <code>sigreturn()</code>。 任何尝试调用其他系统调用的行为都会导致进程被内核以 <code>SIGKILL</code> 信号终止。</li><li>启用方式最初是通过写入 <code>/proc/self/seccomp</code> 文件，后来改为使用 <code>prctl(PR_SET_SECCOMP, SECCOMP_MODE_STRICT)</code> 系统调用。</li></ul></li><li><p><strong>模式2：过滤模式 (Filter Mode &#x2F; seccomp-bpf)</strong></p><ul><li>由于严格模式的限制过于严苛，实用性有限，社区在2012年的Linux 3.5版本中引入了革命性的过滤模式。</li><li>这个模式允许进程加载一个**伯克利包过滤器（Berkeley Packet Filter, BPF）**程序。 内核会在每次系统调用发生时执行这个BPF程序，BPF程序可以检查系统调用的编号及其参数，然后决定是允许、拒绝、终止进程还是记录日志等。</li><li>这一改变极大地提升了seccomp的灵活性和实用性，使其成为现代沙箱技术（如浏览器、容器）的基石。</li><li>在Linux 3.17中，新增了<code>seccomp(2)</code>系统调用，为多线程程序的过滤器同步提供了更好的支持。</li></ul></li></ol><h4 id="目前该技术的社区活跃度和主流应用情况如何？"><a href="#目前该技术的社区活跃度和主流应用情况如何？" class="headerlink" title="目前该技术的社区活跃度和主流应用情况如何？"></a>目前该技术的社区活跃度和主流应用情况如何？</h4><p>Seccomp是一项非常成熟且被广泛应用的核心内核安全技术。 它的应用遍及：</p><ul><li><strong>容器技术</strong>：Docker、Kubernetes、Podman等容器运行时默认都会使用一个seccomp配置文件，该文件会禁用约44个已知的高风险系统调用，以防止容器逃逸。</li><li><strong>Web浏览器</strong>：Google Chrome和Firefox使用seccomp来沙箱化其渲染进程，严格限制这些处理网络不可信内容的进程与系统交互的能力。</li><li><strong>系统服务</strong>：Systemd和OpenSSH等系统关键服务也使用seccomp来限制自身权限，加强安全性。</li><li><strong>移动平台</strong>：Android自8.0版本起在Zygote进程（所有应用的父进程）中使用了seccomp过滤器。</li></ul><h3 id="核心原理与设计"><a href="#核心原理与设计" class="headerlink" title="核心原理与设计"></a>核心原理与设计</h3><h4 id="它的核心工作原理是什么？"><a href="#它的核心工作原理是什么？" class="headerlink" title="它的核心工作原理是什么？"></a>它的核心工作原理是什么？</h4><p><code>kernel/seccomp.c</code>中的代码实现了系统调用拦截和过滤的逻辑。其核心工作原理如下：</p><ol><li><strong>启用与加载</strong>：进程通过<code>prctl()</code>或<code>seccomp()</code>系统调用请求进入安全计算模式。在过滤模式下，用户空间会提供一个BPF程序作为过滤器。</li><li><strong>过滤器附加</strong>：内核会将这个BPF过滤器附加到当前进程的<code>task_struct</code>结构体上。一旦设置，这个策略是单向的，无法撤销，并且会被所有子进程继承。</li><li><strong>系统调用路径拦截</strong>：在进入实际的系统调用处理函数之前，内核的系统调用入口路径上会有一个检查点。 这个检查点会调用<code>__secure_computing()</code>函数。</li><li><strong>执行BPF过滤器</strong>：<code>__secure_computing()</code>函数会检查当前进程是否设置了seccomp过滤器。如果有，它会准备一个<code>struct seccomp_data</code>结构体，其中包含当前系统调用的编号、参数、指令指针等信息，然后将此结构体作为输入数据，在内核态执行附加的BPF程序。</li><li><strong>返回裁决</strong>：BPF程序执行后会返回一个32位的“裁决”值。 这个值的高16位代表要执行的<strong>动作</strong>（如<code>SECCOMP_RET_ALLOW</code>允许、<code>SECCOMP_RET_KILL</code>终止、<code>SECCOMP_RET_TRAP</code>、<code>SECCOMP_RET_ERRNO</code>返回错误码、<code>SECCOMP_RET_LOG</code>记录），低16位是与该动作相关的数据（例如，要返回的错误码）。</li><li><strong>内核执行动作</strong>：内核根据BPF程序返回的裁决值，决定是继续执行该系统调用，还是立即终止进程，或是返回一个错误给用户空间等。</li></ol><h4 id="它的主要优势体现在哪些方面？"><a href="#它的主要优势体现在哪些方面？" class="headerlink" title="它的主要优势体现在哪些方面？"></a>它的主要优势体现在哪些方面？</h4><ul><li><strong>显著减小攻击面</strong>：通过白名单或黑名单的方式，精确控制进程可用的系统调用，极大地限制了漏洞利用的可能性。</li><li><strong>低性能开销</strong>：BPF过滤器直接在内核态执行，非常高效，对系统性能的影响通常很小。 Linux 5.11内核中引入的常量动作位图等优化，进一步将常见过滤场景的开销从O(N)降低到O(1)。</li><li><strong>灵活性高</strong>：过滤模式允许基于系统调用编号及其参数创建复杂的、细粒度的过滤规则。</li><li><strong>防御TOCTOU攻击</strong>：BPF程序不能解引用指针，只能直接评估系统调用参数的值，这使得seccomp能有效防御常见的“检查时-使用时”（Time-of-Check-Time-of-Use）攻击。</li></ul><h4 id="它存在哪些已知的劣势、局限性或在特定场景下的不适用性？"><a href="#它存在哪些已知的劣势、局限性或在特定场景下的不适用性？" class="headerlink" title="它存在哪些已知的劣势、局限性或在特定场景下的不适用性？"></a>它存在哪些已知的劣势、局限性或在特定场景下的不适用性？</h4><ul><li><strong>策略创建复杂</strong>：为一个复杂的应用程序创建一个精确且最小化的系统调用白名单是一项非常困难的任务。 需要使用<code>strace</code>等工具仔细分析程序行为，错误的策略可能导致应用崩溃。</li><li><strong>可移植性问题</strong>：系统调用的编号和可用性在不同的CPU架构（如x86_64 vs aarch64）之间存在差异，这使得编写可移植的seccomp策略变得复杂。</li><li><strong>性能敏感场景</strong>：尽管开销很低，但在每秒进行海量系统调用的极端高性能计算（HPC）场景中，任何额外的检查都可能成为瓶颈。</li><li><strong>非银弹</strong>：Seccomp只关注系统调用层面，它无法防御所有类型的攻击，例如内存损坏漏洞、逻辑缺陷或配置错误。 它需要与其他安全机制（如AppArmor, SELinux）结合，形成深度防御。</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><h4 id="在哪些具体的业务或技术场景下，它是首选解决方案？请举例说明。"><a href="#在哪些具体的业务或技术场景下，它是首选解决方案？请举例说明。" class="headerlink" title="在哪些具体的业务或技术场景下，它是首选解决方案？请举例说明。"></a>在哪些具体的业务或技术场景下，它是首选解决方案？请举例说明。</h4><p>Seccomp是实现<strong>进程级沙箱</strong>、遵循<strong>最小权限原则</strong>的首选技术。</p><ul><li><strong>容器安全</strong>：在Docker或Kubernetes中，为Pod或容器配置seccomp配置文件是标准的安全实践。默认配置文件会禁用<code>unshare</code>、<code>kexec_load</code>等危险的系统调用，防止一个被攻陷的容器影响到宿主机或其他容器。</li><li><strong>沙箱化不可信代码</strong>：Web浏览器将处理网页内容的渲染器进程置于seccomp沙箱中。即使渲染器被恶意JavaScript代码利用，seccomp也会阻止它执行文件系统访问、网络连接创建等高风险操作。</li><li><strong>加固应用程序</strong>：对于处理敏感数据的应用程序，可以使用seccomp来限制其行为。例如，一个只进行计算任务的程序可以被禁止所有网络和文件相关的系统调用。</li></ul><h4 id="是否有不推荐使用该技术的场景？为什么？"><a href="#是否有不推荐使用该技术的场景？为什么？" class="headerlink" title="是否有不推荐使用该技术的场景？为什么？"></a>是否有不推荐使用该技术的场景？为什么？</h4><ul><li><strong>通用开发和调试环境</strong>：在开发和调试阶段，严格的seccomp策略会干扰<code>gdb</code>等调试工具（它们依赖<code>ptrace</code>系统调用）的正常工作，并可能因为频繁的合法系统调用被误拦而降低开发效率。</li><li><strong>需要完整系统功能的场景</strong>：对于需要广泛访问系统资源和功能的特权进程或管理工具，使用seccomp会过度限制其能力，使其无法正常工作。</li></ul><h3 id="对比分析"><a href="#对比分析" class="headerlink" title="对比分析"></a>对比分析</h3><h4 id="请将其-与-其他相似技术-进行详细对比。"><a href="#请将其-与-其他相似技术-进行详细对比。" class="headerlink" title="请将其 与 其他相似技术 进行详细对比。"></a>请将其 与 其他相似技术 进行详细对比。</h4><p>Seccomp通常与AppArmor和SELinux这两大Linux安全模块（LSM）进行比较。它们都用于强制访问控制，但作用层面和机制不同。</p><table><thead><tr><th align="left">特性</th><th align="left">Seccomp</th><th align="left">AppArmor</th><th align="left">SELinux</th></tr></thead><tbody><tr><td align="left"><strong>功能概述</strong></td><td align="left"><strong>系统调用过滤器</strong>。它决定一个进程<strong>可以</strong>或<strong>不可以</strong>调用哪些系统调用。</td><td align="left"><strong>路径名强制访问控制 (MAC)</strong>。它控制一个程序可以访问哪些<strong>文件路径</strong>以及以何种方式访问（读、写、执行）。</td><td align="left"><strong>标签式强制访问控制 (MAC)</strong>。它为所有主体（进程）和客体（文件、套接字等）打上安全标签，通过策略规则控制主体对客体的访问。</td></tr><tr><td align="left"><strong>实现方式</strong></td><td align="left">在系统调用入口处执行BPF程序。</td><td align="left">基于路径名的规则集，通过Linux安全模块（LSM）钩子实现。</td><td align="left">基于安全上下文标签，通过LSM钩子实现。</td></tr><tr><td align="left"><strong>隔离级别</strong></td><td align="left"><strong>动作&#x2F;能力</strong>级别。关注的是“进程能做什么动作”（如<code>open</code>, <code>socket</code>）。</td><td align="left"><strong>资源</strong>级别（基于名称）。关注的是“进程能访问什么资源”（如<code>/etc/passwd</code>）。</td><td align="left"><strong>资源</strong>级别（基于标签）。关注的是“<code>user_t</code>类型的进程能否写入<code>etc_t</code>类型的文件”。</td></tr><tr><td align="left"><strong>性能开销</strong></td><td align="left"><strong>低</strong>。BPF执行非常快。</td><td align="left"><strong>低</strong>。开销通常可以忽略。</td><td align="left"><strong>中等</strong>。标签匹配和策略查询比AppArmor更复杂，可能带来稍高的开销。</td></tr><tr><td align="left"><strong>易用性</strong></td><td align="left"><strong>策略复杂</strong>。精确定义一个应用所需的所有系统调用非常困难。</td><td align="left"><strong>相对简单</strong>。策略基于文件路径，更直观，且有“complain mode”辅助生成策略。</td><td align="left"><strong>非常复杂</strong>。需要理解标签、类型、角色等概念，策略编写和维护难度最大。</td></tr><tr><td align="left"><strong>结合使用</strong></td><td align="left"><strong>推荐</strong>。Seccomp与LSM（AppArmor&#x2F;SELinux）是互补的，可以形成深度防御。例如，Seccomp可以允许<code>write</code>系统调用，而AppArmor可以进一步限制该<code>write</code>只能作用于<code>/tmp</code>目录下的文件。</td><td align="left"></td><td align="left"></td></tr></tbody></table><h2 id="Seccomp-日志动作的位掩码与字符串名称转换"><a href="#Seccomp-日志动作的位掩码与字符串名称转换" class="headerlink" title="Seccomp 日志动作的位掩码与字符串名称转换"></a>Seccomp 日志动作的位掩码与字符串名称转换</h2><p>本代码片段是 Seccomp (安全计算模式) 子系统的一部分，其核心功能是定义了一套机制，用于在内核内部使用的 <code>u32</code> 位掩码与用户空间交互时使用的人类可读字符串之间进行双向转换。它通过一个静态查找表和一系列辅助函数，实现了对 <code>seccomp</code> 日志动作配置的解析和格式化，是 <code>sysctl</code> 接口实现的基础。</p><h3 id="实现原理分析"><a href="#实现原理分析" class="headerlink" title="实现原理分析"></a>实现原理分析</h3><p>该机制的核心是基于一个静态的、数据驱动的查找表（Look-Up Table, LUT），从而将具体的转换逻辑与数据分离，提高了代码的可维护性和扩展性。</p><ol><li><p><strong>核心数据结构 (<code>seccomp_log_name</code>, <code>seccomp_log_names</code>)</strong>:</p><ul><li><code>seccomp_log_name</code> 结构体将一个 <code>u32</code> 类型的位标志 (<code>log</code>) 与其对应的 <code>const char *</code> 字符串名称 (<code>name</code>) 绑定在一起，形成一个原子映射单元。</li><li><code>seccomp_log_names</code> 数组是这个机制的中心。它是一个静态常量数组，实例化了一系列的映射关系。这种设计将所有可能的转换关系集中存放在一个地方。数组以一个空成员 <code>{}</code> 作为结束标记（哨兵），这是一种常见的 C 语言编程范式，使得遍历该数组的循环代码无需知道数组的确切大小，只需检查 <code>cur-&gt;name</code> 是否为 <code>NULL</code> 即可终止。</li></ul></li><li><p><strong>位掩码到字符串的转换 (<code>seccomp_names_from_actions_logged</code>)</strong>:</p><ul><li>此函数实现了从二进制到位图到文本的格式化。它遍历 <code>seccomp_log_names</code> 查找表。</li><li>对于表中的每一个条目，它使用按位与操作符 (<code>&amp;</code>) 来测试输入的 <code>actions_logged</code> 位掩码中是否设置了与当前条目对应的位。</li><li>如果位被设置，它就将该条目对应的字符串名称复制到输出缓冲区。函数通过一个布尔标志 <code>append_sep</code> 来控制分隔符的插入，确保只有在第一个有效名称被添加之后，才在后续名称前添加分隔符。</li><li>函数使用了 <code>strscpy</code>，这是一个安全的字符串复制函数，可以防止缓冲区溢出。</li></ul></li><li><p><strong>字符串到原子位标志的转换 (<code>seccomp_action_logged_from_name</code>)</strong>:</p><ul><li>这是一个反向查找函数。它线性遍历查找表，使用 <code>strcmp</code> 函数将输入的 <code>name</code> 字符串与表中的每一个名称进行比较。</li><li>一旦找到匹配项，它就将对应的 <code>log</code> 位标志值写入到调用者提供的指针中，并返回成功。如果遍历完整个表都没有找到匹配项，则返回失败。</li></ul></li><li><p><strong>字符串到复合位掩码的转换 (<code>seccomp_actions_logged_from_names</code>)</strong>:</p><ul><li>此函数实现了从文本到二进制位图的解析。它使用 <code>strsep</code> 函数来按空格分割输入的字符串，<code>strsep</code> 会在原地修改字符串，用 <code>\0</code> 替换分隔符，并依次返回每个子字符串（token）的指针。</li><li>对于每一个 token，它调用 <code>seccomp_action_logged_from_name</code> 来查找其对应的位标志。</li><li>查找到的位标志通过按位或赋值操作符 (<code>|=</code>) 被累加到最终的 <code>actions_logged</code> 结果中，从而构建出完整的位掩码。</li></ul></li></ol><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @struct seccomp_log_name</span></span><br><span class="line"><span class="comment"> * @brief 将 u32 位标志与其字符串名称关联的结构体。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seccomp_log_name</span> &#123;</span></span><br><span class="line">u32<span class="built_in">log</span>;  <span class="comment">/**&lt; seccomp 日志动作的位标志 */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>*name;<span class="comment">/**&lt; 对应的人类可读名称 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** @name seccomp 日志动作的位标志定义 */</span></span><br><span class="line"><span class="comment">///@&#123;</span></span><br><span class="line"><span class="comment">/* 用于 seccomp_actions_logged 全局变量 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_LOG_KILL_PROCESS(1 &lt;&lt; 0) <span class="comment">/**&lt; 记录 kill_process 动作 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_LOG_KILL_THREAD(1 &lt;&lt; 1) <span class="comment">/**&lt; 记录 kill_thread 动作 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_LOG_TRAP(1 &lt;&lt; 2) <span class="comment">/**&lt; 记录 trap 动作 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_LOG_ERRNO(1 &lt;&lt; 3) <span class="comment">/**&lt; 记录 errno 动作 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_LOG_TRACE(1 &lt;&lt; 4) <span class="comment">/**&lt; 记录 trace 动作 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_LOG_LOG(1 &lt;&lt; 5) <span class="comment">/**&lt; 记录 log 动作 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_LOG_ALLOW(1 &lt;&lt; 6) <span class="comment">/**&lt; 记录 allow 动作 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_LOG_USER_NOTIF(1 &lt;&lt; 7) <span class="comment">/**&lt; 记录 user_notif 动作 */</span></span></span><br><span class="line"><span class="comment">///@&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @var seccomp_log_names</span></span><br><span class="line"><span class="comment"> * @brief seccomp 日志动作位标志到名称的静态查找表。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">seccomp_log_name</span> <span class="title">seccomp_log_names</span>[] =</span> &#123;</span><br><span class="line">&#123; SECCOMP_LOG_KILL_PROCESS, SECCOMP_RET_KILL_PROCESS_NAME &#125;,</span><br><span class="line">&#123; SECCOMP_LOG_KILL_THREAD, SECCOMP_RET_KILL_THREAD_NAME &#125;,</span><br><span class="line">&#123; SECCOMP_LOG_TRAP, SECCOMP_RET_TRAP_NAME &#125;,</span><br><span class="line">&#123; SECCOMP_LOG_ERRNO, SECCOMP_RET_ERRNO_NAME &#125;,</span><br><span class="line">&#123; SECCOMP_LOG_USER_NOTIF, SECCOMP_RET_USER_NOTIF_NAME &#125;,</span><br><span class="line">&#123; SECCOMP_LOG_TRACE, SECCOMP_RET_TRACE_NAME &#125;,</span><br><span class="line">&#123; SECCOMP_LOG_LOG, SECCOMP_RET_LOG_NAME &#125;,</span><br><span class="line">&#123; SECCOMP_LOG_ALLOW, SECCOMP_RET_ALLOW_NAME &#125;,</span><br><span class="line">&#123; &#125; <span class="comment">/* 哨兵，标记数组结束 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 从 u32 位掩码生成以分隔符连接的动作名称字符串。</span></span><br><span class="line"><span class="comment"> * @param[out] names 目标缓冲区，用于存放生成的字符串。</span></span><br><span class="line"><span class="comment"> * @param size 目标缓冲区的大小。</span></span><br><span class="line"><span class="comment"> * @param actions_logged 源 u32 位掩码。</span></span><br><span class="line"><span class="comment"> * @param sep 名称之间的分隔符字符串。</span></span><br><span class="line"><span class="comment"> * @return 成功返回 true，若缓冲区不足则返回 false。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">seccomp_names_from_actions_logged</span><span class="params">(<span class="type">char</span> *names, <span class="type">size_t</span> size,</span></span><br><span class="line"><span class="params">      u32 actions_logged,</span></span><br><span class="line"><span class="params">      <span class="type">const</span> <span class="type">char</span> *sep)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">seccomp_log_name</span> *<span class="title">cur</span>;</span></span><br><span class="line"><span class="type">bool</span> append_sep = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历查找表，直到遇到哨兵条目 (cur-&gt;name 为 NULL)</span></span><br><span class="line"><span class="keyword">for</span> (cur = seccomp_log_names; cur-&gt;name &amp;&amp; size; cur++) &#123;</span><br><span class="line"><span class="type">ssize_t</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用按位与检查 actions_logged 中是否设置了当前动作的标志位</span></span><br><span class="line"><span class="keyword">if</span> (!(actions_logged &amp; cur-&gt;<span class="built_in">log</span>))</span><br><span class="line"><span class="keyword">continue</span>; <span class="comment">// 如果未设置，则跳过</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果这不是第一个要添加的名称，则先添加分隔符</span></span><br><span class="line"><span class="keyword">if</span> (append_sep) &#123;</span><br><span class="line">ret = strscpy(names, sep, size); <span class="comment">// 安全地复制分隔符</span></span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 检查缓冲区是否已满</span></span><br><span class="line">names += ret; size -= ret; <span class="comment">// 更新缓冲区指针和剩余大小</span></span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">append_sep = <span class="literal">true</span>; <span class="comment">// 标记第一个名称已添加</span></span><br><span class="line"></span><br><span class="line">ret = strscpy(names, cur-&gt;name, size); <span class="comment">// 安全地复制动作名称</span></span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 检查缓冲区是否已满</span></span><br><span class="line">names += ret; size -= ret; <span class="comment">// 更新缓冲区指针和剩余大小</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 从单个动作名称字符串查找其对应的 u32 位标志。</span></span><br><span class="line"><span class="comment"> * @param[out] action_logged 指向 u32 的指针，用于存放找到的位标志。</span></span><br><span class="line"><span class="comment"> * @param name 要查找的动作名称。</span></span><br><span class="line"><span class="comment"> * @return 找到返回 true，否则返回 false。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">seccomp_action_logged_from_name</span><span class="params">(u32 *action_logged,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">seccomp_log_name</span> *<span class="title">cur</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线性遍历查找表</span></span><br><span class="line"><span class="keyword">for</span> (cur = seccomp_log_names; cur-&gt;name; cur++) &#123;</span><br><span class="line"><span class="comment">// 比较输入名称与表中的名称</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cur-&gt;name, name)) &#123;</span><br><span class="line">*action_logged = cur-&gt;<span class="built_in">log</span>; <span class="comment">// 如果匹配，则写入位标志</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 并返回成功</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 遍历结束仍未找到，返回失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 从空格分隔的动作名称字符串解析出 u32 位掩码。</span></span><br><span class="line"><span class="comment"> * @param[out] actions_logged 指向 u32 的指针，用于存放最终的位掩码。</span></span><br><span class="line"><span class="comment"> * @param names 包含动作名称的源字符串（此字符串会被 strsep 修改）。</span></span><br><span class="line"><span class="comment"> * @return 所有名称都有效则返回 true，否则返回 false。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">seccomp_actions_logged_from_names</span><span class="params">(u32 *actions_logged, <span class="type">char</span> *names)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> *name;</span><br><span class="line"></span><br><span class="line">*actions_logged = <span class="number">0</span>; <span class="comment">// 初始化结果位掩码为 0</span></span><br><span class="line"><span class="comment">// strsep 按 &quot; &quot; 分割字符串，直到返回 NULL</span></span><br><span class="line"><span class="keyword">while</span> ((name = strsep(&amp;names, <span class="string">&quot; &quot;</span>)) &amp;&amp; *name) &#123;</span><br><span class="line">u32 action_logged = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找当前名称对应的位标志</span></span><br><span class="line"><span class="keyword">if</span> (!seccomp_action_logged_from_name(&amp;action_logged, name))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果有任何一个名称无效，则整个解析失败</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用按位或将找到的位标志合并到结果中</span></span><br><span class="line">*actions_logged |= action_logged;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="seccomp-actions-logged-handler-Seccomp-日志配置的读写与审计"><a href="#seccomp-actions-logged-handler-Seccomp-日志配置的读写与审计" class="headerlink" title="seccomp_actions_logged_handler: Seccomp 日志配置的读写与审计"></a>seccomp_actions_logged_handler: Seccomp 日志配置的读写与审计</h2><p>本代码片段是 <code>seccomp</code> 子系统 <code>sysctl</code> 接口的核心实现，它为 <code>/proc/sys/kernel/seccomp/actions_logged</code> 文件的读写操作提供了完整的处理逻辑。其核心功能是作为内核内部的 <code>u32</code> 位掩码（<code>seccomp_actions_logged</code>）与用户空间的、人类可读的字符串之间的桥梁，并在此过程中执行严格的权限检查、输入验证和安全审计。</p><h3 id="实现原理分析-1"><a href="#实现原理分析-1" class="headerlink" title="实现原理分析"></a>实现原理分析</h3><p>该实现巧妙地复用了内核的标准 <code>sysctl</code> 处理函数 <code>proc_dostring</code>，并通过一个临时栈缓冲区作为中介，将复杂的双向数据转换、验证和状态更新逻辑封装起来。</p><ol><li><p><strong>分发与调度 (<code>seccomp_actions_logged_handler</code>)</strong>:</p><ul><li>这是由 <code>sysctl</code> 框架直接调用的顶层处理函数。它扮演一个分发器的角色，根据内核传入的 <code>write</code> 参数，将请求路由到 <code>read_actions_logged</code> 或 <code>write_actions_logged</code> 函数，从而将读写逻辑清晰地分离开。</li><li>对于写操作，它遵循一个严谨的“<strong>操作-审计</strong>”模式：在执行完写操作后，无论成功与否 (<code>ret</code> 的值)，都会立即调用 <code>audit_actions_logged</code> 函数记录此次配置变更尝试。</li></ul></li><li><p><strong>读操作实现 (<code>read_actions_logged</code>)</strong>:</p><ul><li><strong>状态到文本的转换</strong>: 首先，在栈上分配一个足够大的临时缓冲区 <code>names</code>。然后调用 <code>seccomp_names_from_actions_logged</code> 将内核当前的全局位掩码 <code>seccomp_actions_logged</code> 转换为人类可读的字符串，并存入该缓冲区。</li><li><strong>复用标准处理器</strong>: 这是此实现中最巧妙的部分。它不直接调用 <code>copy_to_user</code> 等底层函数，而是创建了一个临时的 <code>ctl_table</code> 结构体，将它的 <code>.data</code> 和 <code>.maxlen</code> 成员指向栈上的 <code>names</code> 缓冲区及其大小。最后，它调用内核通用的 <code>proc_dostring</code> 函数，并让这个标准函数去处理将 <code>names</code> 缓冲区内容安全地拷贝到用户空间的所有细节。</li></ul></li><li><p><strong>写操作实现 (<code>write_actions_logged</code>)</strong>:</p><ul><li><strong>权限检查</strong>: 操作的第一步是调用 <code>capable(CAP_SYS_ADMIN)</code>，检查当前进程是否拥有系统管理员权限。这是保护关键内核参数不被非授权修改的标准安全措施。</li><li><strong>用户数据获取</strong>: 与读操作类似，它使用 <code>proc_dostring</code> (此时 <code>write</code> 参数为1) 将用户写入的数据从用户空间拷贝到内核栈上的临时 <code>names</code> 缓冲区。</li><li><strong>文本到状态的解析与验证</strong>: 调用 <code>seccomp_actions_logged_from_names</code> 将 <code>names</code> 缓冲区中的字符串解析成 <code>u32</code> 位掩码。紧接着，进行一项关键的业务逻辑验证：<code>*actions_logged &amp; SECCOMP_LOG_ALLOW</code>。此检查禁止用户启用对 <code>allow</code> 动作的日志记录，因为这通常是默认行为，记录它会产生海量的、无价值的日志信息，可能导致拒绝服务（DoS）。</li><li><strong>原子状态更新</strong>: 只有在所有检查和验证都通过后，才会执行 <code>seccomp_actions_logged = *actions_logged;</code> 这一步，将新的配置应用到全局状态。</li></ul></li><li><p><strong>审计日志 (<code>audit_actions_logged</code>)</strong>:</p><ul><li>此函数提供了配置变更的可追溯性。它将变更前和变更后的 <code>u32</code> 位掩码都转换为字符串形式，然后调用内核审计框架的专用函数 <code>audit_seccomp_actions_logged</code>，生成一条详细的审计日志，记录谁、在何时、尝试将配置从什么改成什么，以及操作是否成功。</li></ul></li></ol><h3 id="代码分析-1"><a href="#代码分析-1" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 处理对 actions_logged sysctl 文件的读操作。</span></span><br><span class="line"><span class="comment"> * @param ro_table sysctl 框架传入的只读 ctl_table 指针。</span></span><br><span class="line"><span class="comment"> * @param buffer 指向用户空间的缓冲区，用于接收数据。</span></span><br><span class="line"><span class="comment"> * @param lenp 指向用户空间中表示缓冲区大小的变量的指针，返回时写入实际数据长度。</span></span><br><span class="line"><span class="comment"> * @param ppos 文件读写位置的指针。</span></span><br><span class="line"><span class="comment"> * @return 成功返回0，失败返回负数错误码。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">read_actions_logged</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> ctl_table *ro_table, <span class="type">void</span> *buffer,</span></span><br><span class="line"><span class="params">       <span class="type">size_t</span> *lenp, <span class="type">loff_t</span> *ppos)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 在栈上分配一个临时缓冲区，大小与所有可用动作名称的总长度相同。</span></span><br><span class="line"><span class="type">char</span> names[<span class="keyword">sizeof</span>(seccomp_actions_avail)];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ctl_table</span> <span class="title">table</span>;</span> <span class="comment">// 创建一个可修改的 ctl_table 副本。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化临时缓冲区。</span></span><br><span class="line"><span class="built_in">memset</span>(names, <span class="number">0</span>, <span class="keyword">sizeof</span>(names));</span><br><span class="line"><span class="comment">// 将全局的 seccomp_actions_logged 位掩码转换为字符串，存入 names。</span></span><br><span class="line"><span class="keyword">if</span> (!seccomp_names_from_actions_logged(names, <span class="keyword">sizeof</span>(names),</span><br><span class="line">       seccomp_actions_logged, <span class="string">&quot; &quot;</span>))</span><br><span class="line"><span class="keyword">return</span> -EINVAL; <span class="comment">// 如果转换失败，返回无效参数错误。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制传入的 ctl_table，以便修改其数据指针。</span></span><br><span class="line">table = *ro_table;</span><br><span class="line"><span class="comment">// 将副本的数据指针指向我们栈上的临时缓冲区。</span></span><br><span class="line">table.data = names;</span><br><span class="line">table.maxlen = <span class="keyword">sizeof</span>(names);</span><br><span class="line"><span class="comment">// 调用内核标准函数 proc_dostring，由它处理将 names 内容拷贝到用户空间 buffer 的所有细节。</span></span><br><span class="line"><span class="keyword">return</span> proc_dostring(&amp;table, <span class="number">0</span>, buffer, lenp, ppos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 处理对 actions_logged sysctl 文件的写操作。</span></span><br><span class="line"><span class="comment"> * @param ... (参数同上)</span></span><br><span class="line"><span class="comment"> * @param actions_logged 指向 u32 的指针，用于返回解析出的新位掩码（供审计函数使用）。</span></span><br><span class="line"><span class="comment"> * @return 成功返回0，失败返回负数错误码。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">write_actions_logged</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> ctl_table *ro_table, <span class="type">void</span> *buffer,</span></span><br><span class="line"><span class="params"><span class="type">size_t</span> *lenp, <span class="type">loff_t</span> *ppos, u32 *actions_logged)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> names[<span class="keyword">sizeof</span>(seccomp_actions_avail)];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ctl_table</span> <span class="title">table</span>;</span></span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查当前进程是否具有系统管理员权限。</span></span><br><span class="line"><span class="keyword">if</span> (!capable(CAP_SYS_ADMIN)) <span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(names, <span class="number">0</span>, <span class="keyword">sizeof</span>(names));</span><br><span class="line">table = *ro_table;</span><br><span class="line">table.data = names;</span><br><span class="line">table.maxlen = <span class="keyword">sizeof</span>(names);</span><br><span class="line"><span class="comment">// 调用 proc_dostring (write=1)，将用户空间 buffer 的内容拷贝到内核栈上的 names 缓冲区。</span></span><br><span class="line">ret = proc_dostring(&amp;table, <span class="number">1</span>, buffer, lenp, ppos);</span><br><span class="line"><span class="keyword">if</span> (ret) <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 names 缓冲区中的字符串解析为位掩码。</span></span><br><span class="line"><span class="keyword">if</span> (!seccomp_actions_logged_from_names(actions_logged, table.data))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="comment">// 业务逻辑验证：不允许记录 SECCOMP_RET_ALLOW 动作。</span></span><br><span class="line"><span class="keyword">if</span> (*actions_logged &amp; SECCOMP_LOG_ALLOW)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证通过后，更新全局的 seccomp 日志动作配置。</span></span><br><span class="line">seccomp_actions_logged = *actions_logged;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 将 actions_logged 的变更记录到内核审计日志。</span></span><br><span class="line"><span class="comment"> * @param actions_logged 新的 u32 位掩码配置。</span></span><br><span class="line"><span class="comment"> * @param old_actions_logged 旧的 u32 位掩码配置。</span></span><br><span class="line"><span class="comment"> * @param ret 写操作的返回值 (0表示成功，非0表示失败)。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">audit_actions_logged</span><span class="params">(u32 actions_logged, u32 old_actions_logged,</span></span><br><span class="line"><span class="params"> <span class="type">int</span> ret)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> names[<span class="keyword">sizeof</span>(seccomp_actions_avail)];</span><br><span class="line"><span class="type">char</span> old_names[<span class="keyword">sizeof</span>(seccomp_actions_avail)];</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *new = names, *old = old_names;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果审计系统未启用，则直接返回。</span></span><br><span class="line"><span class="keyword">if</span> (!audit_enabled) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(names, <span class="number">0</span>, <span class="keyword">sizeof</span>(names));</span><br><span class="line"><span class="built_in">memset</span>(old_names, <span class="number">0</span>, <span class="keyword">sizeof</span>(old_names));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据写操作结果和新值，准备用于日志的 &quot;new&quot; 字符串。</span></span><br><span class="line"><span class="keyword">if</span> (ret) new = <span class="string">&quot;?&quot;</span>; <span class="comment">// 操作失败</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!actions_logged) new = <span class="string">&quot;(none)&quot;</span>; <span class="comment">// 新值为空</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!seccomp_names_from_actions_logged(names, <span class="keyword">sizeof</span>(names),</span><br><span class="line">    actions_logged, <span class="string">&quot;,&quot;</span>)) new = <span class="string">&quot;?&quot;</span>; <span class="comment">// 转换失败</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备用于日志的 &quot;old&quot; 字符串。</span></span><br><span class="line"><span class="keyword">if</span> (!old_actions_logged) old = <span class="string">&quot;(none)&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!seccomp_names_from_actions_logged(old_names,</span><br><span class="line">    <span class="keyword">sizeof</span>(old_names),</span><br><span class="line">    old_actions_logged, <span class="string">&quot;,&quot;</span>)) old = <span class="string">&quot;?&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用内核审计子系统的函数来记录事件。</span></span><br><span class="line"><span class="keyword">return</span> audit_seccomp_actions_logged(new, old, !ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief actions_logged sysctl 的主处理函数，根据操作是读还是写进行分发。</span></span><br><span class="line"><span class="comment"> * @param ... (参数同 read_actions_logged)</span></span><br><span class="line"><span class="comment"> * @param write 标志位，非0表示写操作，0表示读操作。</span></span><br><span class="line"><span class="comment"> * @return 成功返回0，失败返回负数错误码。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">seccomp_actions_logged_handler</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> ctl_table *ro_table, <span class="type">int</span> write,</span></span><br><span class="line"><span class="params">  <span class="type">void</span> *buffer, <span class="type">size_t</span> *lenp,</span></span><br><span class="line"><span class="params">  <span class="type">loff_t</span> *ppos)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (write) &#123;</span><br><span class="line">u32 actions_logged = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 在修改前，保存当前的配置以供审计使用。</span></span><br><span class="line">u32 old_actions_logged = seccomp_actions_logged;</span><br><span class="line"><span class="comment">// 执行写操作。</span></span><br><span class="line">ret = write_actions_logged(ro_table, buffer, lenp, ppos,</span><br><span class="line">   &amp;actions_logged);</span><br><span class="line"><span class="comment">// 对写操作的结果进行审计。</span></span><br><span class="line">audit_actions_logged(actions_logged, old_actions_logged, ret);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 执行读操作。</span></span><br><span class="line">ret = read_actions_logged(ro_table, buffer, lenp, ppos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="seccomp-sysctl-init-Seccomp-子系统-sysctl-接口初始化"><a href="#seccomp-sysctl-init-Seccomp-子系统-sysctl-接口初始化" class="headerlink" title="seccomp_sysctl_init: Seccomp 子系统 sysctl 接口初始化"></a>seccomp_sysctl_init: Seccomp 子系统 sysctl 接口初始化</h2><p>本代码片段展示了 Linux 内核中 <code>seccomp</code> (安全计算模式) 子系统如何通过 <code>sysctl</code> 机制向用户空间暴露其配置接口。其核心功能是在 <code>/proc/sys/kernel/seccomp/</code> 目录下创建两个文件：<code>actions_avail</code> 和 <code>actions_logged</code>。这使得系统管理员或应用程序能够查询当前内核支持的所有 <code>seccomp</code> 动作，并动态配置哪些动作需要被记录到内核日志中。</p><h3 id="实现原理分析-2"><a href="#实现原理分析-2" class="headerlink" title="实现原理分析"></a>实现原理分析</h3><p>该机制是内核子系统提供运行时配置的标准范例，它利用了内核的 <code>sysctl</code> 框架。</p><ol><li><p><strong>数据定义</strong>:</p><ul><li>首先，通过宏定义了一系列人类可读的字符串，分别对应 <code>seccomp</code> 过滤器可以返回的各种处置动作（如 <code>kill_process</code>, <code>trap</code>, <code>allow</code> 等）。</li><li><code>seccomp_actions_avail</code> 是一个静态常量字符串，它在编译时将所有可用的动作名称拼接成一个以空格分隔的列表。这个字符串将作为 <code>/proc/sys/kernel/seccomp/actions_avail</code> 文件的内容。</li></ul></li><li><p><strong>Sysctl 表定义 (<code>seccomp_sysctl_table</code>)</strong>:</p><ul><li>这是 <code>sysctl</code> 框架的核心数据结构。它是一个 <code>ctl_table</code> 结构体数组，每个元素定义了 <code>/proc/sys/</code> 下的一个文件接口。</li><li><strong><code>actions_avail</code> 条目</strong>:<ul><li><code>.procname</code>: 定义了文件名。</li><li><code>.data</code> 和 <code>.maxlen</code>: 将此接口直接绑定到 <code>seccomp_actions_avail</code> 字符串。</li><li><code>.mode = 0444</code>: 设置文件权限为全局只读。</li><li><code>.proc_handler = proc_dostring</code>: 指定使用内核提供的标准处理函数，该函数专门用于处理对静态字符串的读操作。</li></ul></li><li><strong><code>actions_logged</code> 条目</strong>:<ul><li><code>.mode = 0644</code>: 设置文件权限为 root 可读写，其他用户只读。</li><li><code>.proc_handler = seccomp_actions_logged_handler</code>: 指定一个自定义的处理函数。这意味着当用户读写此文件时，内核会调用 <code>seccomp_actions_logged_handler</code> 函数来执行相应的逻辑（例如，解析用户输入的字符串并更新内核内部的日志掩码）。</li></ul></li></ul></li><li><p><strong>注册与初始化 (<code>seccomp_sysctl_init</code>, <code>device_initcall</code>)</strong>:</p><ul><li><code>seccomp_sysctl_init</code> 函数通过调用 <code>register_sysctl_init</code>，将上述定义的 <code>seccomp_sysctl_table</code> 注册到内核的 <code>sysctl</code> 树中，并指定其路径为 <code>kernel/seccomp</code>。</li><li><code>device_initcall</code> 是一个宏，它将 <code>seccomp_sysctl_init</code> 函数注册为一个内核初始化回调。这确保了在内核启动过程中的 “device” 阶段，该函数会被自动调用，从而完成 <code>sysctl</code> 接口的创建。</li></ul></li></ol><h3 id="代码分析-2"><a href="#代码分析-2" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file</span></span><br><span class="line"><span class="comment"> * @brief seccomp 子系统的 sysctl 接口定义。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** @name 用于 sysctl 交互的人类可读的动作名称 */</span></span><br><span class="line"><span class="comment">///@&#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_RET_KILL_PROCESS_NAME<span class="string">&quot;kill_process&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_RET_KILL_THREAD_NAME<span class="string">&quot;kill_thread&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_RET_TRAP_NAME<span class="string">&quot;trap&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_RET_ERRNO_NAME<span class="string">&quot;errno&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_RET_USER_NOTIF_NAME<span class="string">&quot;user_notif&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_RET_TRACE_NAME<span class="string">&quot;trace&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_RET_LOG_NAME<span class="string">&quot;log&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_RET_ALLOW_NAME<span class="string">&quot;allow&quot;</span></span></span><br><span class="line"><span class="comment">///@&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @var seccomp_actions_avail</span></span><br><span class="line"><span class="comment"> * @brief 一个静态常量字符串，包含了所有内核支持的 seccomp 动作，以空格分隔。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 此字符串将作为 /proc/sys/kernel/seccomp/actions_avail 文件的内容。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> seccomp_actions_avail[] =</span><br><span class="line">SECCOMP_RET_KILL_PROCESS_NAME<span class="string">&quot; &quot;</span></span><br><span class="line">SECCOMP_RET_KILL_THREAD_NAME<span class="string">&quot; &quot;</span></span><br><span class="line">SECCOMP_RET_TRAP_NAME<span class="string">&quot; &quot;</span></span><br><span class="line">SECCOMP_RET_ERRNO_NAME<span class="string">&quot; &quot;</span></span><br><span class="line">SECCOMP_RET_USER_NOTIF_NAME     <span class="string">&quot; &quot;</span></span><br><span class="line">SECCOMP_RET_TRACE_NAME<span class="string">&quot; &quot;</span></span><br><span class="line">SECCOMP_RET_LOG_NAME<span class="string">&quot; &quot;</span></span><br><span class="line">SECCOMP_RET_ALLOW_NAME;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @var seccomp_sysctl_table</span></span><br><span class="line"><span class="comment"> * @brief 定义 seccomp sysctl 接口的表。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 每个条目对应 /proc/sys/kernel/seccomp/ 下的一个文件。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">ctl_table</span> <span class="title">seccomp_sysctl_table</span>[] =</span> &#123;</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @property procname</span></span><br><span class="line"><span class="comment"> * @brief 在 /proc/sys/ 下的文件名。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">.procname= <span class="string">&quot;actions_avail&quot;</span>,</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @property data</span></span><br><span class="line"><span class="comment"> * @brief 指向要暴露的数据的指针。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">.data= (<span class="type">void</span> *) &amp;seccomp_actions_avail,</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @property maxlen</span></span><br><span class="line"><span class="comment"> * @brief 数据的大小。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">.maxlen= <span class="keyword">sizeof</span>(seccomp_actions_avail),</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @property mode</span></span><br><span class="line"><span class="comment"> * @brief 文件的访问权限 (0444 表示全局只读)。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">.mode= <span class="number">0444</span>,</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @property proc_handler</span></span><br><span class="line"><span class="comment"> * @brief 处理此文件读写操作的内核函数。proc_dostring 是用于读取静态字符串的标准处理程序。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">.proc_handler= proc_dostring,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">.procname= <span class="string">&quot;actions_logged&quot;</span>,</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 权限 (0644 表示 root 可读写，其他用户只读)。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">.mode= <span class="number">0644</span>,</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 指定一个自定义处理函数，用于处理用户对此文件的读写请求，</span></span><br><span class="line"><span class="comment"> * 以动态配置哪些 seccomp 动作需要被记录。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">.proc_handler= seccomp_actions_logged_handler,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief seccomp sysctl 初始化函数。</span></span><br><span class="line"><span class="comment"> * @return 总是返回 0 表示成功。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 此函数被标记为 __init，意味着它仅在内核启动期间执行，</span></span><br><span class="line"><span class="comment"> * 其占用的内存随后会被释放。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">seccomp_sysctl_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 将 seccomp_sysctl_table 注册到 &quot;kernel/seccomp&quot; 路径下。</span></span><br><span class="line">register_sysctl_init(<span class="string">&quot;kernel/seccomp&quot;</span>, seccomp_sysctl_table);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 使用 device_initcall 宏来注册初始化函数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这会安排 seccomp_sysctl_init 在内核启动过程中的 &quot;device&quot; 初始化阶段被调用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">device_initcall(seccomp_sysctl_init);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;

&lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i-blog.csdnimg.cn/direct/7bd978e994964bb098abe907c7dbc062.</summary>
      
    
    
    
    <category term="linux" scheme="https://wdfk-prog.space/categories/linux/"/>
    
    <category term="kernel" scheme="https://wdfk-prog.space/categories/linux/kernel/"/>
    
    
    <category term="linux" scheme="https://wdfk-prog.space/tags/linux/"/>
    
    <category term="kernel" scheme="https://wdfk-prog.space/tags/kernel/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核kallsyms符号压缩的完整构建流程</title>
    <link href="https://wdfk-prog.space/posts/b27151c8/"/>
    <id>https://wdfk-prog.space/posts/b27151c8/</id>
    <published>2025-10-06T07:20:29.000Z</published>
    <updated>2025-10-06T07:24:28.687Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>@[toc]</p><h3 id="Linux内核kallsyms符号压缩的完整构建流程"><a href="#Linux内核kallsyms符号压缩的完整构建流程" class="headerlink" title="Linux内核kallsyms符号压缩的完整构建流程"></a><strong>Linux内核kallsyms符号压缩的完整构建流程</strong></h3><p><img src="https://i-blog.csdnimg.cn/direct/0fde91d9655d4d7baad45efd4bb3b85d.png" alt="在这里插入图片描述"></p><h4 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a><strong>1. 引言</strong></h4><p>Linux内核的<code>kallsyms</code>机制是其自省（Introspection）和调试能力的核心基石。它允许内核在运行时将内存地址解析为可读的符号名称，这对于错误追踪（Oops messages）、性能分析和内核调试至关重要。然而，在一个现代内核中，符号数量可达数十万之多，直接以字符串形式存储将消耗数兆字节的宝贵内存。</p><p>为了解决这一问题，内核构建系统采用了一套精巧的多趟链接（Multi-pass Linking）和符号压缩（Symbol Compression）流程。此流程由<code>scripts/link-vmlinux.sh</code>脚本调度，并使用一个专门的宿主工具<code>scripts/kallsyms</code>来执行核心的压缩算法。本文将完整地、分步骤地剖析这一流程，从构建脚本的宏观调度到压缩工具的微观算法实现。</p><h4 id="2-宏观调度：scripts-link-vmlinux-sh的多趟链接"><a href="#2-宏观调度：scripts-link-vmlinux-sh的多趟链接" class="headerlink" title="2. 宏观调度：scripts/link-vmlinux.sh的多趟链接"></a><strong>2. 宏观调度：<code>scripts/link-vmlinux.sh</code>的多趟链接</strong></h4><p>整个<code>kallsyms</code>数据的生成过程并非一次完成，而是通过一个迭代收敛的过程，以确保最终嵌入内核的符号地址是完全准确的。这个过程巧妙地解决了“测量行为本身影响测量结果”的典型问题——即<code>kallsyms</code>数据段的大小会影响其他符号的地址，而这些地址的变动又会反过来改变<code>kallsyms</code>数据本身。</p><h5 id="流程图：vmlinux链接与kallsyms生成"><a href="#流程图：vmlinux链接与kallsyms生成" class="headerlink" title="流程图：vmlinux链接与kallsyms生成"></a><strong>流程图：vmlinux链接与kallsyms生成</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    subgraph &quot;阶段一：编译宿主工具&quot;</span><br><span class="line">        A[&quot;CONFIG_KALLSYMS=y&quot;] --&gt; B(&quot;scripts/Makefile&quot;);</span><br><span class="line">        B --&gt; C&#123;&quot;make hostprogs&quot;&#125;;</span><br><span class="line">        C --&gt; D[&quot;编译 scripts/kallsyms.c&quot;];</span><br><span class="line">        D --&gt; E[&quot;生成可执行文件 scripts/kallsyms&quot;];</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    subgraph &quot;阶段二：链接 vmlinux (由 scripts/link-vmlinux.sh 驱动)&quot;</span><br><span class="line">        F[&quot;make vmlinux&quot;] --&gt; G(&quot;scripts/Makefile.vmlinux&quot;);</span><br><span class="line">        G --&gt; H[&quot;执行 scripts/link-vmlinux.sh&quot;];</span><br><span class="line">        </span><br><span class="line">        subgraph &quot;Pass 1: 生成基础镜像&quot;</span><br><span class="line">            H --&gt; I[&quot;链接 .tmp_vmlinux1 (含空的kallsyms节)&quot;];</span><br><span class="line">            I -- &quot;nm -n | sed&quot; --&gt; J[&quot;&lt;b&gt;.tmp_vmlinux1.syms&lt;/b&gt; (干净的符号列表)&quot;];</span><br><span class="line">        end</span><br><span class="line">        </span><br><span class="line">        subgraph &quot;Pass 2 &amp; 3: 迭代生成并稳定kallsyms数据&quot;</span><br><span class="line">            J -- &quot;作为输入&quot; --&gt; L[&quot;执行 &lt;b&gt;scripts/kallsyms&lt;/b&gt; 程序&quot;];</span><br><span class="line">            L -- &quot;压缩符号&quot; --&gt; M[&quot;&lt;b&gt;.kallsyms.S&lt;/b&gt; (包含压缩数据的汇编文件)&quot;];</span><br><span class="line">            M -- &quot;CC (汇编器)&quot; --&gt; N[&quot;&lt;b&gt;.kallsyms.o&lt;/b&gt; (目标文件)&quot;];</span><br><span class="line">            N -- &quot;链接进内核&quot; --&gt; O[&quot;链接 .tmp_vmlinux2 (包含真实的kallsyms数据)&quot;];</span><br><span class="line">            O --&gt; P&#123;&quot;比较两次 .kallsyms.o 的大小是否一致&quot;&#125;;</span><br><span class="line">            P -- &quot;否 (地址不稳定)&quot; --&gt; J;</span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">        subgraph &quot;阶段三：生成最终产品&quot;</span><br><span class="line">           P -- &quot;是 (地址已收敛)&quot; --&gt; Q[&quot;使用最终的 .kallsyms.o&quot;];</span><br><span class="line">           Q --&gt; R[&quot;链接最终的 vmlinux&quot;];</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    style J fill:#ccf,stroke:#333,stroke-width:2px</span><br><span class="line">    style L fill:#f9f,stroke:#333,stroke-width:2px</span><br><span class="line">    style M fill:#cfc,stroke:#333,stroke-width:2px</span><br></pre></td></tr></table></figure><h5 id="脚本代码片段与注释-scripts-link-vmlinux-sh"><a href="#脚本代码片段与注释-scripts-link-vmlinux-sh" class="headerlink" title="脚本代码片段与注释 (scripts/link-vmlinux.sh)"></a><strong>脚本代码片段与注释 (<code>scripts/link-vmlinux.sh</code>)</strong></h5><p>以下是<code>link-vmlinux.sh</code>中执行此多趟链接的核心逻辑，并附有详细注释。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># ... (脚本头部)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ... (vmlinux_link, mksysmap, kallsyms等辅助函数定义) ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> is_enabled CONFIG_KALLSYMS; <span class="keyword">then</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># kallsyms支持</span></span><br><span class="line"><span class="comment"># 生成一个包含所有符号的节，并将其添加到vmlinux中。</span></span><br><span class="line"><span class="comment"># 这是一个多步骤的过程:</span></span><br><span class="line"><span class="comment"># 0) 首先，生成一个空的kallsyms符号列表，用于第一次链接。</span></span><br><span class="line"><span class="comment">#    这确保了链接器知道__kallsyms节的存在。</span></span><br><span class="line"><span class="literal">true</span> &gt; .tmp_vmlinux0.syms</span><br><span class="line">kallsyms .tmp_vmlinux0.syms .tmp_vmlinux0.kallsyms</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1) 链接 .tmp_vmlinux1。这个版本包含了所有真实的符号和节，</span></span><br><span class="line"><span class="comment">#    但其__kallsyms节是基于一个空列表生成的，因此几乎为空。</span></span><br><span class="line"><span class="comment">#    对.tmp_vmlinux1运行kallsyms，会得到一个大小基本正确的</span></span><br><span class="line"><span class="comment">#    .tmp_vmlinux1.kallsyms.o。</span></span><br><span class="line">vmlinux_link .tmp_vmlinux1</span><br><span class="line">sysmap_and_kallsyms .tmp_vmlinux1</span><br><span class="line">size1=$(<span class="variable">$&#123;CONFIG_SHELL&#125;</span> <span class="string">&quot;<span class="variable">$&#123;srctree&#125;</span>/scripts/file-size.sh&quot;</span> <span class="variable">$&#123;kallsymso&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2) 链接 .tmp_vmlinux2。这一次，我们将上一步生成的、大小基本正确的</span></span><br><span class="line"><span class="comment">#    .kallsyms.o链接进去。由于这个.o文件有实际大小，它的加入</span></span><br><span class="line"><span class="comment">#    会导致其他符号的地址发生偏移。</span></span><br><span class="line"><span class="comment">#    我们再基于.tmp_vmlinux2生成一个新的、更精确的.kallsyms.o。</span></span><br><span class="line">vmlinux_link .tmp_vmlinux2</span><br><span class="line">sysmap_and_kallsyms .tmp_vmlinux2</span><br><span class="line">size2=$(<span class="variable">$&#123;CONFIG_SHELL&#125;</span> <span class="string">&quot;<span class="variable">$&#123;srctree&#125;</span>/scripts/file-size.sh&quot;</span> <span class="variable">$&#123;kallsymso&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3) 检查收敛性。如果第二次生成的.kallsyms.o大小与第一次不同，</span></span><br><span class="line"><span class="comment">#    说明地址仍在变动（例如，链接器可能因为地址变化而插入了新的跳转桩，</span></span><br><span class="line"><span class="comment">#    引入了新的符号）。此时需要再进行一轮链接以确保地址稳定收敛。</span></span><br><span class="line"><span class="comment">#    KALLSYMS_EXTRA_PASS=1环境变量可用于强制执行额外一轮。</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$size1</span> -ne <span class="variable">$size2</span> ] || [ -n <span class="string">&quot;<span class="variable">$&#123;KALLSYMS_EXTRA_PASS&#125;</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">vmlinux_link .tmp_vmlinux3</span><br><span class="line">sysmap_and_kallsyms .tmp_vmlinux3</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ... (最终链接)</span></span><br><span class="line"><span class="comment"># 使用最后一轮生成的、最准确的$&#123;kallsymso&#125;来链接最终的vmlinux。</span></span><br><span class="line">vmlinux_link <span class="string">&quot;<span class="variable">$&#123;VMLINUX&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><h4 id="3-压缩引擎：scripts-kallsyms-c的算法实现"><a href="#3-压缩引擎：scripts-kallsyms-c的算法实现" class="headerlink" title="3. 压缩引擎：scripts/kallsyms.c的算法实现"></a><strong>3. 压缩引擎：<code>scripts/kallsyms.c</code>的算法实现</strong></h4><p><code>kallsyms</code>工具的核心是一种**“查表压缩”（Table Lookup Compression）<strong>算法。其基本思想是：在所有符号名称中，找出最常出现的</strong>双字符组合（Token）**，用一个未被使用的单字节值来替换它们，从而达到压缩的目的。这个过程是迭代的，直到所有可用的单字节值都被用于替换最高频的Token。</p><h5 id="main-函数：流程主干"><a href="#main-函数：流程主干" class="headerlink" title="main() 函数：流程主干"></a><strong><code>main()</code> 函数：流程主干</strong></h5><p><code>main</code>函数清晰地展示了压缩工具的执行步骤。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief kallsyms工具的主函数。</span></span><br><span class="line"><span class="comment"> * @param argc 参数数量。</span></span><br><span class="line"><span class="comment"> * @param argv 参数数组。</span></span><br><span class="line"><span class="comment"> * @return 成功返回0，失败返回非0。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ... (解析命令行参数，如 --all-symbols)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 读取并解析输入的.map或.syms文件，构建一个包含所有符号的内存表。</span></span><br><span class="line">read_map(argv[optind]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 根据--all-symbols选项，过滤掉不需要的符号（如调试符号、非文本段符号等）。</span></span><br><span class="line">shrink_table();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 按地址对符号表进行排序，这是生成kallsyms_offsets的基础。</span></span><br><span class="line">sort_symbols();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 记录所有符号中的最低地址，作为计算相对偏移的基准。</span></span><br><span class="line">record_relative_base();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 执行核心的查表压缩算法，优化Token表并压缩所有符号名称。</span></span><br><span class="line">optimize_token_table();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 将所有处理和压缩后的数据（地址偏移、压缩名称、Token表等）</span></span><br><span class="line"><span class="comment">//    以汇编语言（.S）的格式输出到标准输出。</span></span><br><span class="line">write_src();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="optimize-token-table-与-optimize-result-：压缩核心"><a href="#optimize-token-table-与-optimize-result-：压缩核心" class="headerlink" title="optimize_token_table() 与 optimize_result()：压缩核心"></a><strong><code>optimize_token_table()</code> 与 <code>optimize_result()</code>：压缩核心</strong></h5><p>这是算法的核心部分，通过迭代找到并替换最高频的Token。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 优化Token表的主函数，协调整个压缩过程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">optimize_token_table</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 1. 遍历所有符号，统计所有双字符Token的出现频率。</span></span><br><span class="line">build_initial_token_table();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 遍历所有符号，将所有实际出现过的单字符标记为“已使用”，</span></span><br><span class="line"><span class="comment">//    并放入Token表的对应位置。</span></span><br><span class="line">insert_real_symbols_in_table();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 执行迭代优化，找出最高频的Token并用未使用的单字节值替换它们。</span></span><br><span class="line">optimize_result();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 迭代优化过程，是压缩算法的核心循环。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">optimize_result</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i, best;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从255到0循环，尝试填满所有可用的单字节编码空间。*/</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">255</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果当前字节值i是空闲的（即没有任何单字符使用它）*/</span></span><br><span class="line"><span class="keyword">if</span> (!best_table_len[i]) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1. 在所有Token中，找到当前“利润”最高（出现频率最高）的一个。*/</span></span><br><span class="line">best = find_best_token();</span><br><span class="line"><span class="keyword">if</span> (token_profit[best] == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>; <span class="comment">/* 如果利润为0，说明没有可压缩的了。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2. 将这个最赚钱的Token（一个双字节值）存入当前空闲的best_table[i]中。*/</span></span><br><span class="line">best_table_len[i] = <span class="number">2</span>;</span><br><span class="line">best_table[i][<span class="number">0</span>] = best &amp; <span class="number">0xFF</span>;</span><br><span class="line">best_table[i][<span class="number">1</span>] = (best &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3. 遍历所有符号，将所有出现的该Token替换为单字节i。</span></span><br><span class="line"><span class="comment"> *    此函数还会动态更新其他Token的利润值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">compress_symbols(best_table[i], i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="write-src-：生成最终的汇编输出"><a href="#write-src-：生成最终的汇编输出" class="headerlink" title="write_src()：生成最终的汇编输出"></a><strong><code>write_src()</code>：生成最终的汇编输出</strong></h5><p>在压缩完成后，此函数负责将所有数据结构以汇编格式写入文件，最终被编译链接进内核。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 将所有压缩后的kallsyms数据写入汇编源文件。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">write_src</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ... (输出汇编文件头) ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出符号总数</span></span><br><span class="line">output_label(<span class="string">&quot;kallsyms_num_syms&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t.long\t%u\n&quot;</span>, table_cnt);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出压缩后的符号名称流 (kallsyms_names)</span></span><br><span class="line"><span class="comment">// 格式为：[长度][压缩数据]...</span></span><br><span class="line">output_label(<span class="string">&quot;kallsyms_names&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; table_cnt; i++) &#123;</span><br><span class="line"><span class="comment">// ... (输出变长编码的长度) ...</span></span><br><span class="line"><span class="comment">// ... (输出压缩后的字节序列) ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出加速查找的标记表 (kallsyms_markers)</span></span><br><span class="line">output_label(<span class="string">&quot;kallsyms_markers&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; markers_cnt; i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t.long\t%u\n&quot;</span>, markers[i]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出Token字典表 (kallsyms_token_table)</span></span><br><span class="line"><span class="comment">// 这是解压时用来查找替换片段的表。</span></span><br><span class="line">output_label(<span class="string">&quot;kallsyms_token_table&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line"><span class="comment">// ... (解压并输出每个Token代表的原始字符串) ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出Token索引表 (kallsyms_token_index)</span></span><br><span class="line"><span class="comment">// 这是一个short数组，快速定位Token在字典表中的偏移。</span></span><br><span class="line">output_label(<span class="string">&quot;kallsyms_token_index&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t.short\t%d\n&quot;</span>, best_idx[i]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出符号地址偏移表 (kallsyms_offsets)</span></span><br><span class="line"><span class="comment">// 存储每个符号相对于relative_base的32位偏移。</span></span><br><span class="line">output_label(<span class="string">&quot;kallsyms_offsets&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; table_cnt; i++) &#123;</span><br><span class="line">offset = table[i]-&gt;addr - relative_base;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t.long\t%#x\t/* %s */\n&quot;</span>, (<span class="type">int</span>)offset, table[i]-&gt;sym);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出相对基地址 (kallsyms_relative_base)</span></span><br><span class="line">output_label(<span class="string">&quot;kallsyms_relative_base&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\tPTR\t_text + %#llx\n&quot;</span>, relative_base - _text);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... (输出按名称排序的符号序列，用于按名查找) ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-结论"><a href="#4-结论" class="headerlink" title="4. 结论"></a><strong>4. 结论</strong></h4><p>Linux内核<code>kallsyms</code>的生成是一个高度工程化的典范。它通过<code>scripts/link-vmlinux.sh</code>的<strong>多趟链接机制</strong>，解决了符号数据加入后地址偏移的收敛性问题，确保了地址的最终准确性。同时，其核心压缩工具<code>scripts/kallsyms</code>利用高效的<strong>迭代式查表压缩算法</strong>，将庞大的符号名称表压缩至原来约50%的大小，显著节省了内核的内存占用。这两个组件的协同工作，为Linux内核提供了一个既节省空间又功能强大的符号解析系统。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;

&lt;p&gt;@[toc]&lt;/p&gt;
&lt;h3 id=&quot;Linux内核kallsyms符号压缩的完整构建流程&quot;&gt;&lt;a href=&quot;#Linux内核kallsyms符号压缩的完整构建流程&quot; clas</summary>
      
    
    
    
    <category term="linux" scheme="https://wdfk-prog.space/categories/linux/"/>
    
    <category term="other" scheme="https://wdfk-prog.space/categories/linux/other/"/>
    
    
    <category term="linux" scheme="https://wdfk-prog.space/tags/linux/"/>
    
    <category term="other" scheme="https://wdfk-prog.space/tags/other/"/>
    
  </entry>
  
  <entry>
    <title>link-vmlinux</title>
    <link href="https://wdfk-prog.space/posts/619e5aa1/"/>
    <id>https://wdfk-prog.space/posts/619e5aa1/</id>
    <published>2025-10-06T06:51:32.000Z</published>
    <updated>2025-10-06T10:48:14.797Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>[toc]<br><img src="https://i-blog.csdnimg.cn/direct/3819fdf7df8847459710cba7186d6fc8.png" alt="在这里插入图片描述"></p><h1 id="scripts-Makefile-vmlinux"><a href="#scripts-Makefile-vmlinux" class="headerlink" title="scripts&#x2F;Makefile.vmlinux"></a>scripts&#x2F;Makefile.vmlinux</h1><h2 id="输出文件"><a href="#输出文件" class="headerlink" title="输出文件"></a>输出文件</h2><ul><li>.tmp_vmlinux2.kallsyms.S</li><li>.tmp_vmlinux2.kallsyms.o</li><li>.tmp_vmlinux2.syms</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-rw-rw-r--   1 embedsky embedsky 285K Oct  5 10:38 .tmp_vmlinux2.kallsyms.o</span><br><span class="line">-rw-rw-r--   1 embedsky embedsky 2.9M Oct  5 10:38 .tmp_vmlinux2.kallsyms.S</span><br><span class="line">-rw-rw-r--   1 embedsky embedsky 625K Oct  5 10:38 .tmp_vmlinux2.syms</span><br></pre></td></tr></table></figure><ul><li>.tmp_vmlinux2.syms截取一点的内容如下所示</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">00000000 A cpu_v7m_suspend_size</span><br><span class="line">c0008000 T _text</span><br><span class="line">c0008000 T stext</span><br><span class="line">c0008028 t __vet_atags</span><br><span class="line">c0008060 T __entry_text_start</span><br><span class="line">c0008060 T __idmap_text_end</span><br><span class="line">c0008060 T __idmap_text_start</span><br><span class="line">c0008060 t __ret_fast_syscall</span><br><span class="line">c0008060 T _stext</span><br><span class="line">c0008060 t ret_fast_syscall</span><br><span class="line">c00080ac t fast_work_pending</span><br><span class="line">c00080b8 t slow_work_pending</span><br><span class="line">c00080d4 t ret_slow_syscall</span><br><span class="line">c00080d4 T ret_to_user</span><br><span class="line">c00080d8 T ret_to_user_from_irq</span><br><span class="line">c00080e0 t no_work_pending</span><br><span class="line">c0008120 T ret_from_fork</span><br><span class="line">c0008140 T vector_swi</span><br><span class="line">c000818e t local_restart</span><br><span class="line">c00081c4 t __sys_trace</span><br><span class="line">c00081ea t __sys_trace_return_nosave</span><br><span class="line">c00081f4 t __sys_trace_return</span><br><span class="line">c0008200 T sys_call_table</span><br><span class="line">c0008960 t sys_syscall</span><br></pre></td></tr></table></figure><h2 id="输入scripts-link-vmlinux-sh的命令是什么"><a href="#输入scripts-link-vmlinux-sh的命令是什么" class="headerlink" title="输入scripts&#x2F;link-vmlinux.sh的命令是什么?"></a>输入scripts&#x2F;link-vmlinux.sh的命令是什么?</h2><p>好的，这是一个非常好的问题，它触及了内核构建过程的核心。Makefile 中的定义是抽象的，实际执行的命令会根据你的架构、配置和工具链被具体化。</p><p>实际上，Makefile 规则会扩展成一个类似下面这样的<strong>命令行</strong>，并传递给你的 shell 来执行。这个命令行是<strong>对 <code>scripts/link-vmlinux.sh</code> 脚本的调用</strong>。</p><h3 id="传递给脚本的命令模板"><a href="#传递给脚本的命令模板" class="headerlink" title="传递给脚本的命令模板"></a>传递给脚本的命令模板</h3><p>其基本形式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scripts/link-vmlinux.sh &lt;链接器&gt; &lt;链接器标志&gt; &lt;输出文件名&gt;</span><br></pre></td></tr></table></figure><h3 id="针对-STM32H750-ARMv7-M-的一个具体示例"><a href="#针对-STM32H750-ARMv7-M-的一个具体示例" class="headerlink" title="针对 STM32H750 (ARMv7-M) 的一个具体示例"></a>针对 STM32H750 (ARMv7-M) 的一个具体示例</h3><p>如果我们假设你正在为 STM32H750 平台进行交叉编译，那么实际在你的主机终端上执行的命令会非常接近下面这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为了可读性，用反斜杠分行</span></span><br><span class="line">scripts/link-vmlinux.sh \</span><br><span class="line">    arm-none-eabi-ld \</span><br><span class="line">    <span class="string">&quot;-p --build-id=none -X -T arch/arm/kernel/vmlinux.lds&quot;</span> \</span><br><span class="line">    vmlinux.unstripped</span><br></pre></td></tr></table></figure><p>我们来逐个解析这个命令的参数，它们都是 <code>scripts/link-vmlinux.sh</code> 脚本的输入：</p><ol><li><p><strong><code>scripts/link-vmlinux.sh</code></strong>: 要执行的脚本本身。</p></li><li><p><strong><code>arm-none-eabi-ld</code></strong>: 这是传递给脚本的<strong>第一个参数</strong> (<code>$1</code>)。它代表了将要使用的链接器程序。对于 ARM Cortex-M 裸机目标，通常是 <code>arm-none-eabi-ld</code>。这个值来自 Makefile 变量 <code>$(LD)</code>。</p></li><li><p><strong><code>&quot;-p --build-id=none -X -T arch/arm/kernel/vmlinux.lds&quot;</code></strong>: 这是传递给脚本的<strong>第二个参数</strong> (<code>$2</code>)，一个包含所有链接器标志的长字符串。</p><ul><li><code>-p</code>: 是一个链接器选项。</li><li><code>--build-id=none</code>: 指示链接器不要生成 build-id note section。</li><li><code>-X</code>: 是另一个链接器选项。</li><li><strong><code>-T arch/arm/kernel/vmlinux.lds</code></strong>: 这是其中<strong>最关键</strong>的标志。它告诉链接器使用 <code>arch/arm/kernel/vmlinux.lds</code> 这个链接器脚本来指导链接过程。对于无 MMU 的 STM32H750，这个脚本会定义内核代码和数据应该被放置在哪个<strong>物理内存地址</strong>，以及各个段（section）的布局。</li></ul></li><li><p><strong><code>vmlinux.unstripped</code></strong>: 这是传递给脚本的<strong>第三个参数</strong> (<code>$3</code>)，指定了最终输出文件的名称。</p></li></ol><h3 id="脚本内部做了什么？"><a href="#脚本内部做了什么？" class="headerlink" title="脚本内部做了什么？"></a>脚本内部做了什么？</h3><p>理解这一点至关重要：上面这条命令<strong>并不是最终的链接命令</strong>。<code>scripts/link-vmlinux.sh</code> 脚本是一个<strong>封装器 (wrapper)</strong>。它接收到上述参数后，会在其内部<strong>构造一个更长、更复杂的最终链接命令</strong>，然后才去执行它。</p><p>脚本内部构造的最终命令可能看起来像这样（这是一个极大简化的示意）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是由 link-vmlinux.sh 脚本在内部生成并执行的命令</span></span><br><span class="line">arm-none-eabi-ld \</span><br><span class="line">    -p --build-id=none -X -T <span class="built_in">arch</span>/arm/kernel/vmlinux.lds \</span><br><span class="line">    -o vmlinux.unstripped \</span><br><span class="line">    --start-group \</span><br><span class="line">    init/built-in.a \</span><br><span class="line">    usr/built-in.a \</span><br><span class="line">    block/built-in.a \</span><br><span class="line">    crypto/built-in.a \</span><br><span class="line">    drivers/built-in.a \</span><br><span class="line">    fs/built-in.a \</span><br><span class="line">    ipc/built-in.a \</span><br><span class="line">    kernel/built-in.a \</span><br><span class="line">    lib/built-in.a \</span><br><span class="line">    net/built-in.a \</span><br><span class="line">    security/built-in.a \</span><br><span class="line">    sound/built-in.a \</span><br><span class="line">    <span class="built_in">arch</span>/arm/lib/lib.a \</span><br><span class="line">    --end-group</span><br></pre></td></tr></table></figure><p><strong>脚本的核心作用</strong>：</p><ol><li><strong>解析参数</strong>：接收来自 Makefile 的链接器、标志和输出文件名。</li><li><strong>构造输入文件列表</strong>：最关键的一步是，它会负责将 <code>vmlinux.o</code> 这个“伪”对象文件（实际上是一个描述文件）展开成一个包含内核所有部分的 <code>built-in.a</code> 归档文件的完整列表。</li><li><strong>执行链接</strong>：使用接收到的链接器和标志，以及它自己构造的完整输入文件列表，执行真正的链接操作。</li><li><strong>执行额外任务</strong>：在链接之后，脚本还会负责生成 <code>System.map</code> 文件，这个文件是内核符号地址的文本映射表，对于调试至关重要。</li></ol><p>总结来说，Makefile 调用 <code>link-vmlinux.sh</code> 并给它一些高级指令，然后 <code>link-vmlinux.sh</code> 脚本负责处理所有繁琐的细节，构造出一条完整的、包含数百个输入文件的最终链接命令来生成 <code>vmlinux.unstripped</code>。</p><h1 id="scripts-link-vmlinux-sh-内核映像最终链接的主控脚本"><a href="#scripts-link-vmlinux-sh-内核映像最终链接的主控脚本" class="headerlink" title="scripts&#x2F;link-vmlinux.sh 内核映像最终链接的主控脚本"></a>scripts&#x2F;link-vmlinux.sh 内核映像最终链接的主控脚本</h1><p>本代码是一个 shell 脚本，是 Linux 内核构建系统（Kbuild）的核心组件。它扮演着最终链接阶段的“主控程序”角色，负责将内核的所有组成部分（<code>vmlinux.a</code> 等）链接成一个单一的、完整的 <code>vmlinux</code> ELF 可执行文件。这个脚本远不止是简单地调用链接器 <code>ld</code>；它是一个复杂的多阶段过程的 orchestrator，负责处理条件编译、生成并嵌入内核符号表（Kallsyms）、生成 BTF 调试信息、创建 <code>System.map</code> 文件，并处理架构特定的需求。</p><h3 id="实现原理分析"><a href="#实现原理分析" class="headerlink" title="实现原理分析"></a>实现原理分析</h3><p>此脚本的实现原理体现了内核构建过程的复杂性和对精确性的要求，其核心是<strong>基于配置的条件化执行</strong>和<strong>解决自引用数据依赖的迭代链接</strong>。</p><ol><li><p><strong>封装与参数化</strong>: 脚本首先从命令行接收由 Makefile 传递来的参数（<code>$1</code> 到 <code>$4</code>），如链接器程序、链接器标志和输出文件名。这是一种典型的封装，将复杂的链接逻辑从 Makefile 语法中解耦出来，提高了可读性和可维护性。</p></li><li><p><strong>条件化特征集成</strong>: 脚本的主体由大量的 <code>if is_enabled CONFIG_...</code> 判断构成。<code>is_enabled</code> 函数通过检查 <code>include/config/auto.conf</code> 文件来确定某个内核配置项是否被启用。这使得脚本的行为是高度动态的：</p><ul><li>如果 <code>CONFIG_KALLSYMS</code> 被启用，脚本会执行一个复杂的多遍链接过程来生成和嵌入符号表。</li><li>如果 <code>CONFIG_DEBUG_INFO_BTF</code> 被启用，它会调用 <code>pahole</code> 工具来生成 BTF 类型信息，并将其链接到内核中。</li><li>如果 <code>CONFIG_LTO_CLANG</code> (链接时优化) 被启用，它会直接使用 <code>vmlinux.o</code> 而不是 <code>vmlinux.a</code> 作为输入，以避免重复执行耗时的 LTO 链接。<br>这种设计使得最终的链接过程可以根据内核配置，精确地包含所需的功能，而不会引入不必要的开销或依赖。</li></ul></li><li><p><strong>迭代链接解决“鸡生蛋”问题 (Kallsyms)</strong>: 脚本中最复杂的部分是 <code>CONFIG_KALLSYMS</code> 的处理。这里存在一个经典的自引用依赖（“鸡生蛋”）问题：</p><ul><li><strong>问题</strong>: 内核需要将所有符号的地址嵌入到一个名为 <code>__kallsyms</code> 的数据段中。但是，<code>__kallsyms</code> 数据段本身的大小会影响其后所有符号的最终地址。这意味着，在不知道 <code>__kallsyms</code> 确切大小之前，无法计算出正确的符号地址；而在没有计算出所有符号地址之前，又无法确定 <code>__kallsyms</code> 的内容和大小。</li><li><strong>解决方案 (多遍链接)</strong>: 脚本通过一个迭代过程来解决这个问题：<br>a. <strong>第一遍</strong>: 首先链接一个不包含或只包含一个虚拟 <code>kallsyms</code> 段的临时内核 (<code>.tmp_vmlinux1</code>)。<br>b. <strong>生成符号表</strong>: 基于 <code>.tmp_vmlinux1</code> 生成一个近似的符号表 (<code>.tmp_vmlinux1.kallsyms.o</code>)。<br>c. <strong>第二遍</strong>: 将这个大小近似正确的符号表对象文件链接进去，生成一个新的临时内核 (<code>.tmp_vmlinux2</code>)。由于增加了 <code>kallsyms</code> 段，很多符号的地址发生了偏移。<br>d. <strong>再次生成符号表</strong>: 基于 <code>.tmp_vmlinux2</code> 生成一个更精确的符号表。<br>e. <strong>可选的第三遍</strong>: 脚本会比较两次生成的符号表大小。如果大小不同（意味着地址偏移导致了链接器需要增加新的 branch stubs，从而引入了新的符号），它会再进行一次链接，以确保符号表收敛并达到稳定状态。<br>f. <strong>最终链接</strong>: 最后，使用这个稳定、正确的符号表对象文件，链接生成最终的 <code>vmlinux</code> 文件。</li></ul></li><li><p><strong>生成辅助文件</strong>: 脚本不仅生成 <code>vmlinux</code>，还负责创建两个至关重要的调试文件：</p><ul><li><strong><code>System.map</code></strong>: 通过 <code>mksysmap</code> 函数（内部调用 <code>nm</code> 工具）生成。这是一个文本文件，列出了所有内核全局符号的名称及其对应的地址，是内核调试的“地图”。</li><li><strong><code>vmlinux.map</code></strong>: 如果配置了 <code>CONFIG_VMLINUX_MAP</code>，脚本会传递 <code>-Map=vmlinux.map</code> 标志给链接器，生成一个更详细的链接映射文件，包含所有符号（包括局部的）和内存段的详细布局信息。</li></ul></li></ol><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">SPDX-License-Identifier: GPL-2.0</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># 链接 vmlinux</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># vmlinux 由 vmlinux.a 和 $(KBUILD_VMLINUX_LIBS) 中的对象链接而成。</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">vmlinux.a 包含无条件链接的对象。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">$(KBUILD_VMLINUX_LIBS) 是有条件链接的归档文件（不在 --whole-archive 内）。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">... (注释描述了文件依赖关系)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">发生错误时立即退出</span></span><br><span class="line">set -e</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">=== 参数解析 ===</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从命令行接收由 make 传递的参数</span></span><br><span class="line">LD=&quot;$1&quot;               # 链接器程序 (如 arm-none-eabi-ld)</span><br><span class="line">KBUILD_LDFLAGS=&quot;$2&quot;   # Kbuild 定义的链接器标志</span><br><span class="line">LDFLAGS_vmlinux=&quot;$3&quot;  # 专门用于 vmlinux 链接的标志</span><br><span class="line">VMLINUX=&quot;$4&quot;            # 最终输出文件名 (如 vmlinux.unstripped)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">=== 辅助函数 ===</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查一个内核配置项是否被启用</span></span><br><span class="line">is_enabled() &#123;</span><br><span class="line">grep -q &quot;^$1=y&quot; include/config/auto.conf</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以 Kbuild 格式打印信息性输出</span></span><br><span class="line">info()</span><br><span class="line">&#123;</span><br><span class="line">printf &quot;  %-7s %s\n&quot; &quot;$&#123;1&#125;&quot; &quot;$&#123;2&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">=== 核心函数：vmlinux 链接 ===</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="variable">$&#123;1&#125;</span> - 输出文件名</span></span><br><span class="line">vmlinux_link()</span><br><span class="line">&#123;</span><br><span class="line">local output=$&#123;1&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">... (局部变量定义)</span></span><br><span class="line"></span><br><span class="line">info LD $&#123;output&#125; # 打印 &quot;LD vmlinux&quot; 等信息</span><br><span class="line">shift # 移出第一个参数 (输出文件名)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据配置选择输入文件</span></span><br><span class="line">if is_enabled CONFIG_LTO_CLANG || is_enabled CONFIG_X86_KERNEL_IBT; then</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果启用了LTO, 直接使用 vmlinux.o 以避免重复漫长的LTO链接</span></span><br><span class="line">objs=vmlinux.o</span><br><span class="line">libs=</span><br><span class="line">else</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">否则，使用包含所有内核对象的归档文件 vmlinux.a</span></span><br><span class="line">objs=vmlinux.a</span><br><span class="line">libs=&quot;$&#123;KBUILD_VMLINUX_LIBS&#125;&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果配置了内置DTB，则添加DTB对象文件</span></span><br><span class="line">if is_enabled CONFIG_GENERIC_BUILTIN_DTB; then</span><br><span class="line">objs=&quot;$&#123;objs&#125; .builtin-dtbs.o&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加必要的内核对象文件</span></span><br><span class="line">objs=&quot;$&#123;objs&#125; .vmlinux.export.o&quot;</span><br><span class="line">objs=&quot;$&#123;objs&#125; init/version-timestamp.o&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">针对不同架构设置链接器和标志</span></span><br><span class="line">if [ &quot;$&#123;SRCARCH&#125;&quot; = &quot;um&quot; ]; then # User-mode Linux 特殊处理</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">...</span></span><br><span class="line">else</span><br><span class="line">wl= # 用于传递给链接器的选项前缀, e.g., -Wl,</span><br><span class="line">ld=&quot;$&#123;LD&#125;&quot;</span><br><span class="line">ldflags=&quot;$&#123;KBUILD_LDFLAGS&#125; $&#123;LDFLAGS_vmlinux&#125;&quot;</span><br><span class="line">ldlibs=</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定链接器脚本，这是定义内存布局的关键！</span></span><br><span class="line">ldflags=&quot;$&#123;ldflags&#125; $&#123;wl&#125;--script=$&#123;objtree&#125;/$&#123;KBUILD_LDS&#125;&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果需要，添加剥离调试信息的标志</span></span><br><span class="line">if [ -n &quot;$&#123;strip_debug&#125;&quot; ] ; then</span><br><span class="line">ldflags=&quot;$&#123;ldflags&#125; $&#123;wl&#125;--strip-debug&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果需要，生成详细的链接映射文件</span></span><br><span class="line">if [ -n &quot;$&#123;generate_map&#125;&quot; ];  then</span><br><span class="line">ldflags=&quot;$&#123;ldflags&#125; $&#123;wl&#125;-Map=vmlinux.map&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">=== 执行最终的链接命令 ===</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;ld&#125; <span class="variable">$&#123;ldflags&#125;</span> -o <span class="variable">$&#123;output&#125;</span>\</span></span><br><span class="line"><span class="language-bash"><span class="variable">$&#123;wl&#125;</span>--whole-archive <span class="variable">$&#123;objs&#125;</span> <span class="variable">$&#123;wl&#125;</span>--no-whole-archive\</span></span><br><span class="line"><span class="language-bash"><span class="variable">$&#123;wl&#125;</span>--start-group <span class="variable">$&#123;libs&#125;</span> <span class="variable">$&#123;wl&#125;</span>--end-group\</span></span><br><span class="line"><span class="language-bash"><span class="variable">$&#123;kallsymso&#125;</span> <span class="variable">$&#123;btf_vmlinux_bin_o&#125;</span> <span class="variable">$&#123;arch_vmlinux_o&#125;</span> <span class="variable">$&#123;ldlibs&#125;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">=== 核心函数：生成 BTF (BPF Type Format) 信息 ===</span></span><br><span class="line">gen_btf()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">... (调用 pahole 和 objcopy 生成 BTF 数据)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">=== 脚本主执行流程 ===</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">确保 init/version-timestamp.o 是最新的</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;MAKE&#125; -f <span class="string">&quot;<span class="variable">$&#123;srctree&#125;</span>/scripts/Makefile.build&quot;</span> obj=init init/version-timestamp.o</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">... (初始化变量)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--- Kallsyms/BTF 多阶段链接 ---</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果启用了 KALLSYMS，先生成一个空的 kallsyms 对象文件</span></span><br><span class="line">if is_enabled CONFIG_KALLSYMS; then</span><br><span class="line">true &gt; .tmp_vmlinux0.syms</span><br><span class="line">kallsyms .tmp_vmlinux0.syms .tmp_vmlinux0.kallsyms</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果启用了 KALLSYMS 或 BTF，进行第一次链接</span></span><br><span class="line">if is_enabled CONFIG_KALLSYMS || is_enabled CONFIG_DEBUG_INFO_BTF; then</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果不需要BTF，则在链接时剥离调试信息以加快速度</span></span><br><span class="line">if ! is_enabled CONFIG_DEBUG_INFO_BTF; then</span><br><span class="line">strip_debug=1</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">[第一遍链接] 生成临时内核 .tmp_vmlinux1</span></span><br><span class="line">vmlinux_link .tmp_vmlinux1</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果启用了 BTF，基于 .tmp_vmlinux1 生成 BTF 数据</span></span><br><span class="line">if is_enabled CONFIG_DEBUG_INFO_BTF; then</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">...</span></span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果启用了 KALLSYMS，开始迭代链接过程</span></span><br><span class="line">if is_enabled CONFIG_KALLSYMS; then</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">... (注释解释了多遍链接的原因)</span></span><br><span class="line"></span><br><span class="line">strip_debug=1 # kallsyms 链接不需要调试信息</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">基于 .tmp_vmlinux1 生成符号表和 kallsyms 对象</span></span><br><span class="line">sysmap_and_kallsyms .tmp_vmlinux1</span><br><span class="line">size1=$($&#123;CONFIG_SHELL&#125; &quot;$&#123;srctree&#125;/scripts/file-size.sh&quot; $&#123;kallsymso&#125;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">[第二遍链接] 将第一次生成的 kallsyms 对象链接进去，生成 .tmp_vmlinux2</span></span><br><span class="line">vmlinux_link .tmp_vmlinux2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">基于 .tmp_vmlinux2 再次生成符号表</span></span><br><span class="line">sysmap_and_kallsyms .tmp_vmlinux2</span><br><span class="line">size2=$($&#123;CONFIG_SHELL&#125; &quot;$&#123;srctree&#125;/scripts/file-size.sh&quot; $&#123;kallsymso&#125;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查 kallsyms 大小是否稳定，如果不稳定或强制要求，则进行第三遍链接</span></span><br><span class="line">if [ $size1 -ne $size2 ] || [ -n &quot;$&#123;KALLSYMS_EXTRA_PASS&#125;&quot; ]; then</span><br><span class="line">vmlinux_link .tmp_vmlinux3</span><br><span class="line">sysmap_and_kallsyms .tmp_vmlinux3</span><br><span class="line">fi</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">strip_debug= # 清除标志，为最终链接做准备</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果配置了，则在最终链接时生成 vmlinux.map</span></span><br><span class="line">if is_enabled CONFIG_VMLINUX_MAP; then</span><br><span class="line">generate_map=1</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">=== 最终链接 ===</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用经过迭代后得到的、大小正确的 kallsymso，链接生成最终的 vmlinux 文件</span></span><br><span class="line">vmlinux_link &quot;$&#123;VMLINUX&#125;&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">... (最终的 BTF ID 解析、System.map 生成、表排序和一致性检查)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">=== 生成 System.map ===</span></span><br><span class="line">mksysmap &quot;$&#123;VMLINUX&#125;&quot; System.map</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">...</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查最终的 System.map 和 kallsyms 过程中的符号表是否一致</span></span><br><span class="line">if is_enabled CONFIG_KALLSYMS; then</span><br><span class="line">if ! cmp -s System.map &quot;$&#123;kallsyms_sysmap&#125;&quot;; then</span><br><span class="line">echo &gt;&amp;2 Inconsistent kallsyms data</span><br><span class="line">exit 1</span><br><span class="line">fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h2 id="mksysmap-与-kallsyms-内核符号表的提取与二进制化"><a href="#mksysmap-与-kallsyms-内核符号表的提取与二进制化" class="headerlink" title="mksysmap 与 kallsyms: 内核符号表的提取与二进制化"></a>mksysmap 与 kallsyms: 内核符号表的提取与二进制化</h2><p>本代码片段是 <code>link-vmlinux.sh</code> 脚本中的一组核心辅助函数，它们共同负责将一个链接好的内核 ELF 文件（如 <code>.tmp_vmlinux1</code>）中的符号信息，提取出来并转化为一个可被再次链接回内核的二进制对象文件（<code>.o</code> 文件）。<code>mksysmap</code> 负责第一步：从 ELF 文件中提取符号并生成一个人类可读的文本符号映射表（<code>System.map</code> 格式）。<code>kallsyms</code> 则负责第二步：读取这个文本映射表，并调用一个专门的工具将其转化为包含高度压缩的二进制符号数据的汇编代码，最后再将该汇编代码编译成一个标准的 <code>.o</code> 对象文件。</p><h3 id="实现原理分析-1"><a href="#实现原理分析-1" class="headerlink" title="实现原理分析"></a>实现原理分析</h3><p>此机制是一个经典的多阶段数据转换流水线，其核心是<strong>将链接器产生的符号信息，通过一系列转换，变成一种紧凑的、可被内核自身在运行时查询的二进制数据格式，并最终将其作为数据段链接回内核</strong>。</p><ol><li><p><strong>第一阶段：符号提取与格式化 (<code>mksysmap</code>)</strong></p><ul><li><strong>提取</strong>: 该函数的核心是 <code> ${NM} -n &quot;${1}&quot;</code> 命令。<code>nm</code> 是一个标准的二进制工具，用于列出对象文件中的符号。<code>-n</code> 选项告诉 <code>nm</code> 按地址对符号进行数字排序。</li><li><strong>格式化</strong>: <code>nm</code> 的原始输出包含了许多不必要的信息。因此，其输出被通过管道（<code>|</code>）传递给 <code>sed -f &quot;${srctree}/scripts/mksysmap&quot;</code>。<code>sed</code> 在这里使用一个名为 <code>mksysmap</code> 的脚本文件，该脚本包含了一系列复杂的文本替换和过滤规则，用于清除局部符号、调试符号，并最终将输出格式化为标准的 <code>地址 类型 符号名</code> 格式。这个最终的文本文件就是 <code>System.map</code> 的内容。</li></ul></li><li><p><strong>第二阶段：文本到二进制的转换 (<code>kallsyms</code>)</strong></p><ul><li><strong>转换</strong>: 该函数的核心是调用 <code>scripts/kallsyms ${kallsymopt} &quot;${1}&quot; &gt; &quot;${2}.S&quot;</code>。这里的 <code>scripts/kallsyms</code> <strong>不是 shell 函数，而是一个预先编译好的 C 语言可执行程序</strong>。这个程序是整个 <code>kallsyms</code> 机制的大脑。它读取 <code>mksysmap</code> 生成的纯文本符号列表，然后在内存中执行复杂的压缩算法（如前文分析的构建令牌表、压缩名称、计算相对偏移等），最后将这些压缩好的二进制数据，以汇编语言的数据定义指令（如 <code>.byte</code>, <code>.long</code>, <code>.asciz</code>）的形式，打印到标准输出。</li><li><strong>汇编</strong>: 该函数的下一步是 <code> ${CC} ... -c -o &quot;${2}.o&quot; &quot;${2}.S&quot;</code>。它使用 C 编译器（在这里实际上是调用其集成的汇编器 <code>as</code>）来将上一步生成的 <code>.S</code> 汇编文件，汇编成一个标准的 ELF 对象文件。这个对象文件现在包含了一个或多个数据段（如 <code>.rodata.__kallsyms_names</code>），其中就存放着完整的、压缩后的二进制内核符号表。</li></ul></li><li><p><strong>封装器 (<code>sysmap_and_kallsyms</code>)</strong>: 这个函数简单地将上述两个步骤串联起来，形成一个完整的“从 ELF 到可链接的符号表对象”的处理流程。这是在 <code>link-vmlinux.sh</code> 的迭代链接过程中反复调用的关键构建块。</p></li></ol><h3 id="代码分析-1"><a href="#代码分析-1" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @brief 将文本符号列表转换为包含二进制符号数据的汇编代码，并将其汇编成对象文件。</span><br><span class="line"> * @param $&#123;1&#125; 输入的文本符号列表文件 (例如 .tmp_vmlinux1.syms)。</span><br><span class="line"> * @param $&#123;2&#125; 输出的对象文件名前缀 (例如 .tmp_vmlinux1.kallsyms)。</span><br><span class="line"> */</span><br><span class="line">kallsyms()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">... (kallsymopt 变量设置)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印信息，例如 <span class="string">&quot;KSYMS .tmp_vmlinux1.kallsyms.S&quot;</span></span></span><br><span class="line">info KSYMS &quot;$&#123;2&#125;.S&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">调用 C 程序 <span class="string">&#x27;scripts/kallsyms&#x27;</span>，它读取文本符号列表 <span class="variable">$&#123;1&#125;</span>，</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">并生成包含压缩二进制符号表的汇编代码，输出到 <span class="variable">$&#123;2&#125;</span>.S 文件。</span></span><br><span class="line">scripts/kallsyms $&#123;kallsymopt&#125; &quot;$&#123;1&#125;&quot; &gt; &quot;$&#123;2&#125;.S&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印信息，例如 <span class="string">&quot;AS .tmp_vmlinux1.kallsyms.o&quot;</span></span></span><br><span class="line">info AS &quot;$&#123;2&#125;.o&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 C 编译器 (作为汇编器) 将生成的汇编文件 <span class="variable">$&#123;2&#125;</span>.S 编译成对象文件 <span class="variable">$&#123;2&#125;</span>.o。</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;CC&#125; ... -c -o <span class="string">&quot;<span class="variable">$&#123;2&#125;</span>.o&quot;</span> <span class="string">&quot;<span class="variable">$&#123;2&#125;</span>.S&quot;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将新生成的对象文件名保存在一个全局变量中，以供后续链接步骤使用。</span></span><br><span class="line">kallsymso=$&#123;2&#125;.o</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">... (其他辅助函数)</span></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @brief 从一个 ELF 文件中提取所有符号，并生成一个 System.map 格式的文本文件。</span><br><span class="line"> * @param $&#123;1&#125; 输入的 ELF 文件 (例如 .tmp_vmlinux1)。</span><br><span class="line"> * @param $&#123;2&#125; 输出的文本符号映射文件名。</span><br><span class="line"> */</span><br><span class="line">mksysmap()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印信息，例如 <span class="string">&quot;NM .tmp_vmlinux1.syms&quot;</span></span></span><br><span class="line">info NM $&#123;2&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 <span class="string">&#x27;nm&#x27;</span> 工具提取 <span class="variable">$&#123;1&#125;</span> 中的所有符号，并按地址排序 (-n)。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">然后通过管道将输出传递给 <span class="string">&#x27;sed&#x27;</span>，使用 <span class="string">&#x27;scripts/mksysmap&#x27;</span> 脚本</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">来过滤和格式化输出，最终结果重定向到 <span class="variable">$&#123;2&#125;</span>。</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;NM&#125; -n <span class="string">&quot;<span class="variable">$&#123;1&#125;</span>&quot;</span> | sed -f <span class="string">&quot;<span class="variable">$&#123;srctree&#125;</span>/scripts/mksysmap&quot;</span> &gt; <span class="string">&quot;<span class="variable">$&#123;2&#125;</span>&quot;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @brief 一个封装函数，用于对一个临时的vmlinux文件执行完整的符号表提取和二进制化过程。</span><br><span class="line"> * @param $&#123;1&#125; 输入的临时 vmlinux ELF 文件。</span><br><span class="line"> */</span><br><span class="line">sysmap_and_kallsyms()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第一步：从输入的 vmlinux 文件 <span class="variable">$&#123;1&#125;</span> 生成文本符号映射表 <span class="variable">$&#123;1&#125;</span>.syms。</span></span><br><span class="line">mksysmap &quot;$&#123;1&#125;&quot; &quot;$&#123;1&#125;.syms&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第二步：将文本符号映射表 <span class="variable">$&#123;1&#125;</span>.syms 转换为可链接的对象文件 <span class="variable">$&#123;1&#125;</span>.kallsyms.o。</span></span><br><span class="line">kallsyms &quot;$&#123;1&#125;.syms&quot; &quot;$&#123;1&#125;.kallsyms&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将生成的文本符号映射文件名保存在一个全局变量中，用于后续的一致性检查。</span></span><br><span class="line">kallsyms_sysmap=$&#123;1&#125;.syms</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="scripts-mksysmap-内核符号表的精炼过滤器"><a href="#scripts-mksysmap-内核符号表的精炼过滤器" class="headerlink" title="scripts&#x2F;mksysmap: 内核符号表的精炼过滤器"></a>scripts&#x2F;mksysmap: 内核符号表的精炼过滤器</h2><p>本代码是一个 <code>sed</code> (Stream EDitor) 脚本，在 Linux 内核的构建过程中扮演着一个至关重要的<strong>过滤器</strong>角色。当 <code>link-vmlinux.sh</code> 脚本执行 <code>mksysmap</code> 函数时，它会首先使用 <code>nm</code> 工具从链接好的 <code>vmlinux</code> ELF 文件中提取出原始的、包含所有符号的列表。然后，这个 <code>mksysmap</code> sed 脚本被用来处理这个原始列表，其核心功能是<strong>根据一系列预定义的规则，删除所有对于生成最终 <code>System.map</code> 文件和 <code>kallsyms</code> 符号表来说无用或不合适的符号</strong>，最终输出一个干净、精炼且有用的符号列表。</p><h3 id="实现原理分析-2"><a href="#实现原理分析-2" class="headerlink" title="实现原理分析"></a>实现原理分析</h3><p>此脚本的实现原理是<strong>基于正则表达式的行过滤</strong>。它遵循 <code>sed</code> 的基本工作模式，逐行读取由 <code>nm</code> 工具生成的 <code>地址 类型 符号名</code> 格式的文本流，并对每一行应用一系列 <code>/pattern/d</code> 命令。</p><ul><li><strong>工作模式</strong>: 整个脚本是一个“黑名单”或“排除列表”。它不定义要<em>保留</em>什么，而是精确地定义要<em>删除</em>什么。任何没有被脚本中的任何规则匹配到的行，都会被原样输出，从而构成了最终的干净符号列表。</li><li><strong>匹配命令 (<code>/pattern/d</code>)</strong>: 这是 <code>sed</code> 的一个核心命令。斜杠 <code>/</code> 包围的是一个正则表达式模式（pattern）。如果当前处理的行能够匹配这个模式，<code>d</code> 命令就会被执行，意味着“删除（delete）”当前行，并且 <code>sed</code> 会立即停止对该行的后续处理，开始读取下一行。</li><li><strong>精确匹配</strong>: 脚本中的模式经过精心设计，以确保精确匹配，避免误删。例如：<ul><li><code>/ [aNUw] /d</code>: 模式中的空格确保了它只匹配代表符号类型的单个字符，而不会意外匹配到地址或符号名中的相同字母。</li><li><code>/ \$/d</code>: 模式开头的空格和 <code>\</code> 转义的 <code>$</code> 符号，精确地匹配以 <code>$</code> 开头的局部符号名。</li><li><code>/_from_arm$/d</code>: 模式末尾的 <code>$</code> 是一个锚点，表示“行尾”，确保只删除以 <code>_from_arm</code> 结尾的符号。</li></ul></li></ul><p>通过组合这些精确的正则表达式，脚本能够像手术刀一样，从数以万计的符号中剔除所有编译器生成的内部标签、调试信息、模块版本数据以及其他对最终用户和调试工具无意义的“噪音”。</p><h3 id="代码分析-2"><a href="#代码分析-2" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sed -f</span></span><br><span class="line"><span class="comment"># SPDX-License-Identifier: GPL-2.0-only</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 用于过滤 System.map 和 kallsyms 不需要或不合适的符号的 sed 脚本。</span></span><br><span class="line"><span class="comment"># 输入应该是 &#x27;nm -n &lt;file&gt;&#x27; 的输出。</span></span><br><span class="line"><span class="comment"># ... (注释描述了 System.map 的用途)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># 1. 根据符号类型进行过滤</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># a: 局部绝对符号 (local absolute symbols)</span></span><br><span class="line"><span class="comment"># N: 调试符号 (debugging symbols)</span></span><br><span class="line"><span class="comment"># U: 未定义的全局符号 (undefined global symbols) - System.map只关心已定义的</span></span><br><span class="line"><span class="comment"># w: 局部的弱符号 (local weak symbols)</span></span><br><span class="line"><span class="comment"># 格式为 &quot;/ [类型] /d&quot;，匹配 &quot; 地址 类型 名称 &quot; 中的类型字段并删除该行</span></span><br><span class="line">/ [aNUw] /d</span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># 2. 根据符号名称的前缀进行过滤</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">#  (注意每个模式前的空格，以确保从符号名的开头开始匹配)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ARM, MIPS 等架构使用的局部符号，通常以 &#x27;$&#x27; 开头</span></span><br><span class="line">/ \$/d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译器生成的局部标签，用于内部跳转，对用户无意义。</span></span><br><span class="line"><span class="comment"># 如 .LBB, .Ltmpxxx, .L__unnamed_xx, .LASANPC 等</span></span><br><span class="line">/ \.L/d</span><br><span class="line"></span><br><span class="line"><span class="comment"># arm64 EFI stub 的命名空间下的符号</span></span><br><span class="line">/ __efistub_/d</span><br><span class="line"></span><br><span class="line"><span class="comment"># arm64 位置无关可执行文件 (PIE) 命名空间下的局部符号</span></span><br><span class="line">/ __pi_\\$/d</span><br><span class="line">/ __pi_\.L/d</span><br><span class="line"></span><br><span class="line"><span class="comment"># arm64 在非VHE模式下 KVM 的命名空间下的局部符号</span></span><br><span class="line">/ __kvm_nvhe_\$/d</span><br><span class="line">/ __kvm_nvhe_\.L/d</span><br><span class="line"></span><br><span class="line"><span class="comment"># lld 链接器为 arm/aarch64/mips 生成的 thunk 函数 (代码跳转存根)</span></span><br><span class="line">/ __[[:alnum:]]*Thunk_/d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 控制流完整性 (CFI) 的类型标识符</span></span><br><span class="line">/ __kcfi_typeid_/d</span><br><span class="line">/ __kvm_nvhe___kcfi_typeid_/d</span><br><span class="line">/ __pi___kcfi_typeid_/d</span><br><span class="line"></span><br><span class="line"><span class="comment"># modversions 功能生成的 CRC 校验和</span></span><br><span class="line">/ __crc_/d</span><br><span class="line"></span><br><span class="line"><span class="comment"># EXPORT_SYMBOL 宏生成的字符串表，存储符号的名称本身</span></span><br><span class="line">/ __kstrtab_/d</span><br><span class="line"></span><br><span class="line"><span class="comment"># EXPORT_SYMBOL 宏生成的命名空间字符串表</span></span><br><span class="line">/ __kstrtabns_/d</span><br><span class="line"></span><br><span class="line"><span class="comment"># MODULE_DEVICE_TABLE 宏生成的设备表符号</span></span><br><span class="line">/ __mod_device_table__/d</span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># 3. 根据符号名称的后缀进行过滤</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">#  (注意每个模式后的 &#x27;$&#x27;，它匹配行尾)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># arm 架构特有的符号，用于标记来自 ARM 或 Thumb 模式的代码</span></span><br><span class="line">/_from_arm$/d</span><br><span class="line">/_from_thumb$/d</span><br><span class="line"><span class="comment"># arm 链接器生成的 veneer (代码片段，用于长跳转或模式切换)</span></span><br><span class="line">/_veneer$/d</span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># 4. 根据精确匹配的符号名进行过滤</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">#  (注意模式前后的空格和 &#x27;$&#x27;，以确保完全匹配)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可能是 LoongArch 架构的特定标签</span></span><br><span class="line">/ L0$/d</span><br><span class="line"></span><br><span class="line"><span class="comment"># PowerPC 架构的特定基地址符号</span></span><br><span class="line">/ _SDA_BASE_$/d</span><br><span class="line">/ _SDA2_BASE_$/d</span><br><span class="line"></span><br><span class="line"><span class="comment"># MODULE_INFO() 宏生成的唯一ID符号</span></span><br><span class="line">/ __UNIQUE_ID_modinfo[0-9]*$/d</span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># 5. 根据包含的模式进行过滤</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">#  (只要符号名中包含该模式就会被忽略)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># PowerPC 架构的跳转桩 (stub)</span></span><br><span class="line">/\.long_branch\./d</span><br><span class="line">/\.plt_branch\./d</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;

&lt;p&gt;[toc]&lt;br&gt;&lt;img src=&quot;https://i-blog.csdnimg.cn/direct/3819fdf7df8847459710cba7186d6fc8.png&quot;</summary>
      
    
    
    
    <category term="linux" scheme="https://wdfk-prog.space/categories/linux/"/>
    
    <category term="scripts" scheme="https://wdfk-prog.space/categories/linux/scripts/"/>
    
    
    <category term="linux" scheme="https://wdfk-prog.space/tags/linux/"/>
    
    <category term="scripts" scheme="https://wdfk-prog.space/tags/scripts/"/>
    
  </entry>
  
  <entry>
    <title>kallsyms</title>
    <link href="https://wdfk-prog.space/posts/dd631879/"/>
    <id>https://wdfk-prog.space/posts/dd631879/</id>
    <published>2025-10-06T06:51:16.000Z</published>
    <updated>2025-10-06T10:53:12.908Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><img src="https://i-blog.csdnimg.cn/direct/de55958926e34a689da90ff76a86899a.png" alt="在这里插入图片描述"></p><p>[TOC]</p><h1 id="linux-gnu-bits-getopt-ext-h-getopt-long-GNU-命令行长选项解析接口"><a href="#linux-gnu-bits-getopt-ext-h-getopt-long-GNU-命令行长选项解析接口" class="headerlink" title="linux-gnu&#x2F;bits&#x2F;getopt_ext.h getopt_long: GNU 命令行长选项解析接口"></a>linux-gnu&#x2F;bits&#x2F;getopt_ext.h getopt_long: GNU 命令行长选项解析接口</h1><p>本代码片段是一个 C 语言头文件（<code>getopt_ext.h</code>，通常被 <code>getopt.h</code> 包含），它定义了 GNU C 库中用于解析命令行参数的 <code>getopt_long</code> 函数及其核心数据结构 <code>struct option</code>。其主要功能是为命令行程序提供一个强大且灵活的机制，使其能够支持并解析长格式的选项（例如，<code>--all-symbols</code>），而不仅仅是传统的单字母短格式选项（如 <code>-a</code>）。</p><h3 id="实现原理分析"><a href="#实现原理分析" class="headerlink" title="实现原理分析"></a>实现原理分析</h3><p>此机制的核心是<strong>通过一个描述符结构体数组，将命令行中的字符串与程序内部的变量和行为进行声明式映射</strong>。</p><ol><li><p><strong>选项描述符 (<code>struct option</code>)</strong>: 这是整个机制的核心数据结构。开发者需要创建一个 <code>struct option</code> 类型的数组，数组中的每一个元素都完整地描述了一个长选项：</p><ul><li><strong><code>const char *name</code></strong>: 定义了长选项的名称，即 <code>--</code> 后面的字符串，例如 <code>&quot;all-symbols&quot;</code>。</li><li><strong><code>int has_arg</code></strong>: 指定该选项是否需要参数。它有三个可能的值：<ul><li><code>no_argument</code> (0): 选项后面不跟任何参数 (例如, <code>--verbose</code>)。</li><li><code>required_argument</code> (1): 选项后面必须跟一个参数 (例如, <code>--output file.txt</code>)。</li><li><code>optional_argument</code> (2): 选项后面可以跟一个可选的参数。</li></ul></li><li><strong><code>int *flag</code></strong> 和 <strong><code>int val</code></strong>: 这两个字段共同决定了当 <code>getopt_long</code> 匹配到这个选项时所执行的动作，有两种主要模式：<ul><li><strong>标志模式 (<code>flag</code> 非 NULL)</strong>: 如果 <code>flag</code> 指向一个 <code>int</code> 变量，那么当该选项出现时，<code>getopt_long</code> 会自动将 <code>val</code> 字段的值赋给 <code>*flag</code> 指向的变量。这是一种“自动”模式，<code>getopt_long</code> 本身返回 0。<code>kallsyms.c</code> 中的 <code>{&quot;all-symbols&quot;, no_argument, &amp;all_symbols, 1}</code> 就是这种用法，它会在匹配到 <code>--all-symbols</code> 时，将全局变量 <code>all_symbols</code> 的值设置为 1。</li><li><strong>返回值模式 (<code>flag</code> 为 NULL)</strong>: 如果 <code>flag</code> 为 <code>NULL</code>，那么当该选项出现时，<code>getopt_long</code> 会直接返回 <code>val</code> 字段的值。这允许程序在 <code>switch</code> 语句中根据返回值来执行更复杂的逻辑。</li></ul></li></ul></li><li><p><strong>解析循环 (<code>getopt_long</code>)</strong>: 应用程序通常在一个 <code>while</code> 循环中反复调用 <code>getopt_long</code> 函数。<code>getopt_long</code> 会在每次调用时，解析命令行参数数组（<code>argv</code>）中的下一个选项。它会自动处理选项与参数的关联（例如 <code>--output file.txt</code> 中的 <code>file.txt</code> 会被存入全局变量 <code>optarg</code>），并更新一个内部索引来跟踪解析进度。当所有选项都解析完毕后，<code>getopt_long</code> 会返回 -1，循环随之结束。</p></li></ol><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* getopt_ext.h */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SPDX-License-Identifier: LGPL-2.1-or-later</span></span><br><span class="line"><span class="comment">// ... (版权和许可证信息)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _GETOPT_EXT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GETOPT_EXT_H 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">__BEGIN_DECLS</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @struct option</span></span><br><span class="line"><span class="comment"> * @brief 用于描述一个长选项的结构体。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * getopt_long 或 getopt_long_only 的 LONG_OPTIONS 参数是一个</span></span><br><span class="line"><span class="comment"> * 由 &#x27;struct option&#x27; 组成的数组，以一个 name 字段为零的元素作为结尾。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">option</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/** @brief 长选项的名称 (不含 &#x27;--&#x27;)。 */</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">   * @brief 指示选项是否需要参数。</span></span><br><span class="line"><span class="comment">   * @details</span></span><br><span class="line"><span class="comment">   * - no_argument (0): 选项不带参数。</span></span><br><span class="line"><span class="comment">   * - required_argument (1): 选项必须带一个参数。</span></span><br><span class="line"><span class="comment">   * - optional_argument (2): 选项可以带一个可选的参数。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">int</span> has_arg;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">   * @brief 行为模式选择标志。</span></span><br><span class="line"><span class="comment">   * @details</span></span><br><span class="line"><span class="comment">   * - 如果非 NULL, 它指向一个 int 变量。当找到该选项时，这个变量会被设置为 &#x27;val&#x27; 字段的值。</span></span><br><span class="line"><span class="comment">   * - 如果为 NULL, getopt_long 会返回 &#x27;val&#x27; 字段的值。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">int</span> *flag;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">   * @brief 选项的值。</span></span><br><span class="line"><span class="comment">   * @details</span></span><br><span class="line"><span class="comment">   * - 如果 &#x27;flag&#x27; 非 NULL，这是要赋给 *flag 的值。</span></span><br><span class="line"><span class="comment">   * - 如果 &#x27;flag&#x27; 为 NULL，这是 getopt_long 找到该选项时的返回值。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* &#x27;has_arg&#x27; 字段的推荐值名称。 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** @def no_argument</span></span><br><span class="line"><span class="comment"> *  @brief &#x27;has_arg&#x27; 的值，表示选项不带参数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> no_argument0</span></span><br><span class="line"><span class="comment">/** @def required_argument</span></span><br><span class="line"><span class="comment"> *  @brief &#x27;has_arg&#x27; 的值，表示选项必须带一个参数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> required_argument1</span></span><br><span class="line"><span class="comment">/** @def optional_argument</span></span><br><span class="line"><span class="comment"> *  @brief &#x27;has_arg&#x27; 的值，表示选项可以带一个可选参数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> optional_argument2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 解析命令行参数，支持长选项。</span></span><br><span class="line"><span class="comment"> * @param ___argc 参数计数 (来自 main)。</span></span><br><span class="line"><span class="comment"> * @param ___argv 参数数组 (来自 main)。</span></span><br><span class="line"><span class="comment"> * @param __shortopts 短选项字符串 (例如 &quot;ab:c:&quot;)。</span></span><br><span class="line"><span class="comment"> * @param __longopts 指向 &#x27;struct option&#x27; 数组的指针。</span></span><br><span class="line"><span class="comment"> * @param __longind 如果非 NULL，它指向一个变量，用于存储找到的长选项在 __longopts 数组中的索引。</span></span><br><span class="line"><span class="comment"> * @return 找到选项时，返回选项字符或 &#x27;val&#x27;；解析完毕返回 -1；出错返回 &#x27;?&#x27;。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">getopt_long</span> <span class="params">(<span class="type">int</span> ___argc, <span class="type">char</span> *__getopt_argv_const *___argv,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">char</span> *__shortopts,</span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="keyword">struct</span> option *__longopts, <span class="type">int</span> *__longind)</span></span><br><span class="line">       __THROW __<span class="title function_">nonnull</span> <span class="params">((<span class="number">2</span>, <span class="number">3</span>))</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 与 getopt_long 类似，但即使是非选项的参数（不以&#x27;-&#x27;开头）</span></span><br><span class="line"><span class="comment"> *        如果与某个长选项匹配，也会被当作该长选项处理。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">getopt_long_only</span> <span class="params">(<span class="type">int</span> ___argc, <span class="type">char</span> *__getopt_argv_const *___argv,</span></span><br><span class="line"><span class="params">     <span class="type">const</span> <span class="type">char</span> *__shortopts,</span></span><br><span class="line"><span class="params">             <span class="type">const</span> <span class="keyword">struct</span> option *__longopts, <span class="type">int</span> *__longind)</span></span><br><span class="line">       __THROW __<span class="title function_">nonnull</span> <span class="params">((<span class="number">2</span>, <span class="number">3</span>))</span>;</span><br><span class="line"></span><br><span class="line">__END_DECLS</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* getopt_ext.h */</span></span></span><br></pre></td></tr></table></figure><h1 id="scripts-kallsyms-c"><a href="#scripts-kallsyms-c" class="headerlink" title="scripts&#x2F;kallsyms.c"></a>scripts&#x2F;kallsyms.c</h1><h2 id="kallsyms-c-内核符号表的压缩与汇编代码生成"><a href="#kallsyms-c-内核符号表的压缩与汇编代码生成" class="headerlink" title="kallsyms.c: 内核符号表的压缩与汇编代码生成"></a>kallsyms.c: 内核符号表的压缩与汇编代码生成</h2><p>本代码是一个在<strong>主机（Host）编译环境</strong>上运行的 C 语言程序，它是 Linux 内核构建过程中的一个关键工具。它的核心功能是读取由 <code>nm</code> 工具生成的文本格式的内核符号列表（<code>System.map</code> 格式），然后执行一套复杂的<strong>字典压缩算法</strong>来减小符号名称数据所占用的空间，最后将这些压缩好的二进制数据以及符号地址（以相对偏移量存储）转换成一个汇编语言源文件（<code>.S</code> 文件）。这个最终生成的汇编文件随后会被编译并链接回内核，从而在内核映像中嵌入一个完整的、紧凑的、可在运行时查询的符号表。</p><h3 id="实现原理分析-1"><a href="#实现原理分析-1" class="headerlink" title="实现原理分析"></a>实现原理分析</h3><p>此程序是结合了高级数据压缩技术和底层二进制格式生成的典范。其实现原理可分为四个主要阶段：数据读取与过滤、地址相对化、字典压缩，以及最终的汇编代码生成。</p><ol><li><p><strong>数据读取与过滤 (<code>read_map</code>, <code>shrink_table</code>)</strong>:</p><ul><li>程序首先逐行读取 <code>nm</code> 工具生成的 <code>地址 类型 符号名</code> 格式的文本文件。</li><li>对于每一行，<code>read_symbol</code> 函数会将其解析并存储到一个 <code>sym_entry</code> 结构体中。</li><li>关键的过滤步骤在 <code>shrink_table</code> 函数中完成。它调用 <code>symbol_valid</code> 来决定每个符号是否应该被保留。默认情况下（没有 <code>--all-symbols</code> 选项），只有位于代码段 (<code>_stext</code> 到 <code>_etext</code>) 和初始化代码段 (<code>_sinittext</code> 到 <code>_einittext</code>) 内的符号，以及一些特殊的边界符号（如 <code>__start_...</code>）才会被保留。这极大地减小了最终符号表的规模，排除了数据段中的变量等。</li></ul></li><li><p><strong>地址相对化 (<code>sort_symbols</code>, <code>record_relative_base</code>)</strong>:</p><ul><li>这是一个重要的空间优化技术。在过滤后，<code>sort_symbols</code> 首先按地址对所有符号进行排序。</li><li><code>record_relative_base</code> 函数随后记录下排序后第一个符号的地址作为全局的 <code>relative_base</code>。</li><li>在最终生成代码时（<code>write_src</code>），每个符号的地址将不再存储为绝对值，而是存储为 <code>table[i]-&gt;addr - relative_base</code> 的 32 位偏移量。这在 64 位系统上可以为每个符号节省 4 个字节的存储空间。内核在运行时，只需将这个相对基地址加上符号的偏移量即可还原出其绝对地址。</li></ul></li><li><p><strong>字典-令牌压缩算法 (<code>optimize_token_table</code>)</strong>:</p><ul><li>这是整个程序中最核心、最精妙的部分，旨在将符号名称字符串的体积压缩约 50%。</li><li><strong>学习阶段</strong>: <code>build_initial_token_table</code> 函数会遍历所有符号名称，并统计所有<strong>连续两个字节</strong>（2-byte token）出现的频率，存入 <code>token_profit</code> 数组。</li><li><strong>初始化字典</strong>: <code>insert_real_symbols_in_table</code> 函数初始化一个 256 项的“最佳令牌表”（<code>best_table</code>）。最初，表中的每一项 <code>i</code> 都只代表它自己（即单个字节 <code>i</code>）。</li><li><strong>贪心迭代压缩</strong>: <code>optimize_result</code> 函数在一个循环中执行贪心算法。在每一步：<br>a. <code>find_best_token</code> 都会从 <code>token_profit</code> 中找出当前频率最高（“利润”最大）的 2 字节令牌。<br>b. 它会从 <code>best_table</code> 中找到一个尚未被用过的索引 <code>i</code>（从 255 向下查找）。<br>c. 它将这个利润最高的令牌（例如 “st”）存入 <code>best_table[i]</code>。现在，字节 <code>i</code> 就代表了字符串 “st”。<br>d. <code>compress_symbols</code> 函数会被调用，它会遍历<strong>所有</strong>符号，将其中所有的 “st” 字符串替换为单个字节 <code>i</code>。<br>e. 在替换后，<code>compress_symbols</code> 内部会调用 <code>forget_symbol</code> 和 <code>learn_symbol</code> 来<strong>动态更新</strong>所有受影响符号的令牌频率计数。</li><li>这个过程会不断重复，直到没有更多可用的索引或没有更多有利润的令牌为止。最终，<code>best_table</code> 就成了一个完整的“字典”，而 <code>table</code> 中存储的符号名称则被替换成了一系列代表原始字符或字典条目的“令牌”。</li></ul></li><li><p><strong>汇编代码生成 (<code>write_src</code>)</strong>:</p><ul><li>此函数负责将内存中处理好的所有数据结构，以汇编指令的形式输出。</li><li>它会依次生成多个数据段，包括：<ul><li><code>kallsyms_num_syms</code>: 符号总数。</li><li><code>kallsyms_names</code>: 所有符号名称的压缩后令牌序列，每个名称前都有一个变长的长度前缀。</li><li><code>kallsyms_markers</code>: 一个稀疏索引表，用于在运行时快速定位到 <code>kallsyms_names</code> 中的某个符号。</li><li><code>kallsyms_token_table</code> 和 <code>kallsyms_token_index</code>: 最终生成的“字典”本身，内核需要它来进行运行时的解压。</li><li><code>kallsyms_offsets</code>: 所有符号的 32 位相对地址偏移量。</li><li><code>kallsyms_relative_base</code>: 相对地址的基准值。</li></ul></li></ul></li></ol><h2 id="kallsyms-c-main-内核符号表处理流水线"><a href="#kallsyms-c-main-内核符号表处理流水线" class="headerlink" title="kallsyms.c main: 内核符号表处理流水线"></a>kallsyms.c <code>main</code>: 内核符号表处理流水线</h2><p>本代码片段是 <code>kallsyms.c</code> 这个主机端构建工具的 <code>main</code> 函数，即整个程序的入口点。其核心功能是<strong>作为一个总指挥（orchestrator），按照一个严格确定的顺序，调用一系列处理函数，形成一个完整的数据处理流水线</strong>。这个流水线将一个纯文本格式的内核符号列表作为输入，经过读取、过滤、排序、压缩和格式化等一系列步骤，最终生成一个包含高度压缩的二进制符号表的汇编语言源文件作为输出。</p><h3 id="实现原理分析-2"><a href="#实现原理分析-2" class="headerlink" title="实现原理分析"></a>实现原理分析</h3><p><code>main</code> 函数的实现原理是一个经典的<strong>确定性处理流水线（Deterministic Processing Pipeline）</strong>。流水线中的每一步都以上一步的输出作为输入，并为其后的一步准备好数据。这个顺序是经过精心设计的，至关重要，任何一步的顺序颠倒都将导致错误的结果。</p><ol><li><p><strong>参数解析 (<code>getopt_long</code>)</strong>: 程序首先处理命令行参数。它支持一个关键选项 <code>--all-symbols</code>，该选项通过设置一个全局标志 <code>all_symbols</code> 来改变后续过滤步骤的行为。</p></li><li><p><strong>处理流水线（The Pipeline）</strong>:</p><ul><li><strong><code>read_map(argv[optind])</code> (数据加载)</strong>: 这是流水线的第一步。它负责读取输入文件（<code>in.map</code>），将每一行文本解析成一个结构化的 <code>sym_entry</code>，并将它们加载到内存中的一个动态数组 <code>table</code> 中。</li><li><strong><code>shrink_table()</code> (数据过滤)</strong>: 第二步。它遍历内存中的 <code>table</code>，根据 <code>symbol_valid</code> 函数的规则（主要看符号是否在代码段内，除非 <code>--all-symbols</code> 被指定）移除不需要的符号。<strong>这一步必须在排序和压缩之前完成</strong>，以减少后续高开销操作需要处理的数据量。</li><li><strong><code>sort_symbols()</code> (数据排序)</strong>: 第三步。它使用 <code>qsort</code> 按符号的地址对 <code>table</code> 进行排序。<strong>排序是 <code>record_relative_base</code> 的绝对前提</strong>，因为下一步需要找到地址最低的符号。</li><li><strong><code>record_relative_base()</code> (基准化)</strong>: 第四步。在排序后的 <code>table</code> 中，它简单地取出第一个符号的地址，并将其记录为 <code>relative_base</code>。所有符号的地址稍后都将表示为相对于这个基地址的偏移量，这是一种关键的空间优化。</li><li><strong><code>optimize_token_table()</code> (核心处理&#x2F;压缩)</strong>: 第五步。这是整个流水线中最复杂和计算密集的一步。它对过滤和排序后的符号名称执行复杂的字典-令牌压缩算法，将字符串压缩为令牌序列，并构建用于解压的字典。</li><li><strong><code>write_src()</code> (数据生成&#x2F;输出)</strong>: 流水线的最后一步。它将内存中所有经过处理的数据结构——符号总数、压缩后的名称、用于快速查找的标记点、解压字典以及相对地址偏移量——格式化为汇编语言指令，并打印到标准输出。</li></ul></li></ol><p>这个严格的顺序确保了每一步操作都在其所需的数据已经准备好的前提下进行，最终高效、正确地完成了从文本到压缩二进制汇编的转换。</p><h3 id="代码分析-1"><a href="#代码分析-1" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief kallsyms 工具的主函数入口。</span></span><br><span class="line"><span class="comment"> * @param argc 命令行参数数量。</span></span><br><span class="line"><span class="comment"> * @param argv 命令行参数数组。</span></span><br><span class="line"><span class="comment"> * @return 成功返回0，失败则通过 exit() 退出。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 循环解析命令行长选项。</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// 定义长选项结构体。</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">option</span> <span class="title">long_options</span>[] =</span> &#123;</span><br><span class="line"><span class="comment">// &quot;--all-symbols&quot; 选项，不带参数，如果出现，则将全局变量 all_symbols 的地址设为1。</span></span><br><span class="line">&#123;<span class="string">&quot;all-symbols&quot;</span>,     no_argument, &amp;all_symbols,     <span class="number">1</span>&#125;,</span><br><span class="line">&#123;&#125;, <span class="comment">// 数组结束标记。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> c = getopt_long(argc, argv, <span class="string">&quot;&quot;</span>, long_options, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (c == <span class="number">-1</span>) <span class="comment">// 如果 getopt_long 返回-1，表示所有选项已解析完毕。</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (c != <span class="number">0</span>) <span class="comment">// 如果 getopt_long 设置了标志，它返回0；否则对于长选项返回非零值表示错误。</span></span><br><span class="line">usage(); <span class="comment">// 如果选项无效，打印用法并退出。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// optind 是 getopt 处理后，第一个非选项参数的索引。</span></span><br><span class="line"><span class="comment">// 检查是否提供了输入文件名。</span></span><br><span class="line"><span class="keyword">if</span> (optind &gt;= argc)</span><br><span class="line">usage(); <span class="comment">// 如果没有提供输入文件名，打印用法并退出。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// === 执行核心处理流水线 ===</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 读取并解析 in.map 文件，将符号加载到内存。</span></span><br><span class="line">read_map(argv[optind]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 根据规则过滤符号表，移除不需要的符号。</span></span><br><span class="line">shrink_table();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 按地址对符号表进行排序。</span></span><br><span class="line">sort_symbols();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 记录排序后第一个符号的地址，作为计算相对偏移的基准。</span></span><br><span class="line">record_relative_base();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 执行字典压缩算法，压缩符号名称并构建解压所需的令牌表。</span></span><br><span class="line">optimize_token_table();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 将处理好的所有数据结构（符号数、压缩名、地址偏移、令牌表等）生成为汇编代码，并输出到 stdout。</span></span><br><span class="line">write_src();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 成功退出。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="read-map-read-symbol-内核符号表的解析与内存加载"><a href="#read-map-read-symbol-内核符号表的解析与内存加载" class="headerlink" title="read_map &amp; read_symbol: 内核符号表的解析与内存加载"></a>read_map &amp; read_symbol: 内核符号表的解析与内存加载</h2><p>本代码片段是 <code>kallsyms.c</code> 这个主机端构建工具的核心输入和解析部分。其主要功能是读取由 <code>nm</code> 和 <code>sed</code> 预处理过的、格式为 <code>地址 类型 符号名</code> 的文本文件（<code>System.map</code> 格式），然后将每一行解析并转换成一个结构化的、便于后续处理的内存表示（<code>struct sym_entry</code>）。<code>read_map</code> 负责驱动整个文件读取过程并管理动态内存，而 <code>read_symbol</code> 则负责单行文本的精细解析和数据结构填充。</p><h3 id="实现原理分析-3"><a href="#实现原理分析-3" class="headerlink" title="实现原理分析"></a>实现原理分析</h3><p>此实现的核心是一种高效的<strong>行式文本流解析</strong>与<strong>内存数据结构化</strong>的流水线。它结合了标准的 C 库 I&#x2F;O 函数和手动的指针操作，以实现快速和精确的解析。</p><ol><li><p><strong>动态数组管理 (<code>read_map</code>)</strong>: <code>read_map</code> 函数负责打开文件并循环读取。由于符号的总数事先未知，它采用了一种经典的动态数组增长策略。全局指针数组 <code>table</code> 在需要时会通过 <code>xrealloc</code> 进行扩容（每次增加 10000 个条目），这避免了预先分配一个可能过大或过小的静态数组，实现了对内存的有效利用。</p></li><li><p><strong>高效行读取 (<code>getline</code>)</strong>: <code>read_symbol</code> 函数内部使用了 POSIX 的 <code>getline</code> 函数。相比于 <code>fgets</code>，<code>getline</code> 能够自动处理任意长度的行，并负责缓冲区的分配和再分配。这使得代码更加健壮，能够正确处理异常长的符号名，而无需编写复杂的缓冲区管理逻辑。</p></li><li><p><strong>精确的格式解析 (<code>read_symbol</code>)</strong>:</p><ul><li><strong>地址解析</strong>: 使用 <code>strtoull</code> 函数，以 16 为基数，将行首的十六进制字符串直接转换为 <code>unsigned long long</code> 类型的地址。</li><li><strong>格式验证</strong>: 通过 <code>*p++ != &#39; &#39;</code> 等一系列指针操作和检查，代码严格验证了输入行是否遵循 <code>地址&lt;空格&gt;类型&lt;空格&gt;名称</code> 的格式。这是一个简单但高效的手动状态机解析，任何格式错误都会导致程序中止。</li></ul></li><li><p><strong>关键的优化：类型与名称的融合 (<code>read_symbol</code>)</strong>:</p><ul><li>这是一个非常精妙的优化，旨在为后续的压缩阶段做准备。在分配 <code>sym_entry</code> 结构体时，它额外多分配了一个字节（<code>len++</code>）。</li><li>然后，它将符号的类型字符（如 ‘T’, ‘d’）存储在 <code>sym-&gt;sym[0]</code>，而将符号的名称字符串本身存储在从 <code>sym-&gt;sym[1]</code> 开始的位置（通过 <code>strcpy(sym_name(sym), name)</code> 实现，其中 <code>sym_name</code> 宏返回 <code>&amp;sym-&gt;sym[1]</code>）。</li><li>通过这种方式，类型信息被无缝地“嵌入”到了符号名称数据的前面。这使得后续的字典压缩算法可以<strong>将类型字符与名称的第一个字符组成的二元组，也视为一个潜在的、可以被压缩的“令牌”</strong>，从而可能获得更好的整体压缩率。</li></ul></li></ol><h3 id="代码分析-2"><a href="#代码分析-2" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 从指定的 map 文件中读取所有符号，并将其加载到全局的符号表中。</span></span><br><span class="line"><span class="comment"> * @param in 输入文件的路径字符串。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">read_map</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *in)</span></span><br><span class="line">&#123;</span><br><span class="line">FILE *fp;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sym_entry</span> *<span class="title">sym</span>;</span></span><br><span class="line"><span class="type">char</span> *buf = <span class="literal">NULL</span>; <span class="comment">// 指向 getline 使用的行缓冲区的指针。</span></span><br><span class="line"><span class="type">size_t</span> buflen = <span class="number">0</span>; <span class="comment">// 行缓冲区的大小。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以只读模式打开输入文件。</span></span><br><span class="line">fp = fopen(in, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!fp) &#123;</span><br><span class="line">perror(in); <span class="comment">// 如果打开失败，打印错误信息并退出。</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环读取文件，直到文件末尾。</span></span><br><span class="line"><span class="comment">// 注意：使用 feof() 作为循环条件是不完美的，但在这里与 getline 的行为结合是可行的。</span></span><br><span class="line"><span class="keyword">while</span> (!feof(fp)) &#123;</span><br><span class="line"><span class="comment">// 调用 read_symbol 来解析文件中的下一行。</span></span><br><span class="line">sym = read_symbol(fp, &amp;buf, &amp;buflen);</span><br><span class="line"><span class="comment">// 如果 read_symbol 返回 NULL (例如，空行、格式错误或被忽略的符号)，则继续下一轮循环。</span></span><br><span class="line"><span class="keyword">if</span> (!sym)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录该符号的原始顺序，这对于后续需要稳定排序的场景很重要。</span></span><br><span class="line">sym-&gt;seq = table_cnt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查全局符号表数组是否已满。</span></span><br><span class="line"><span class="keyword">if</span> (table_cnt &gt;= table_size) &#123;</span><br><span class="line"><span class="comment">// 如果已满，则将容量增加 10000。</span></span><br><span class="line">table_size += <span class="number">10000</span>;</span><br><span class="line"><span class="comment">// 重新分配内存，扩大数组。xrealloc 是一个带错误检查的 realloc 包装。</span></span><br><span class="line">table = xrealloc(table, <span class="keyword">sizeof</span>(*table) * table_size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将新解析出的符号条目指针存入数组，并增加计数器。</span></span><br><span class="line">table[table_cnt++] = sym;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(buf); <span class="comment">// 释放 getline 自动分配的行缓冲区。</span></span><br><span class="line">fclose(fp); <span class="comment">// 关闭文件。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 从文件流中读取并解析单行符号信息。</span></span><br><span class="line"><span class="comment"> * @param in 输入文件流指针。</span></span><br><span class="line"><span class="comment"> * @param buf 指向行缓冲指针的指针 (供 getline 使用)。</span></span><br><span class="line"><span class="comment"> * @param buf_len 指向行缓冲大小的指针 (供 getline 使用)。</span></span><br><span class="line"><span class="comment"> * @return 成功解析则返回一个新分配的 sym_entry 结构体指针，否则返回 NULL。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> sym_entry *<span class="title function_">read_symbol</span><span class="params">(FILE *in, <span class="type">char</span> **buf, <span class="type">size_t</span> *buf_len)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> *name, type, *p;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> addr;</span><br><span class="line"><span class="type">size_t</span> len;</span><br><span class="line"><span class="type">ssize_t</span> readlen;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sym_entry</span> *<span class="title">sym</span>;</span></span><br><span class="line"></span><br><span class="line">errno = <span class="number">0</span>; <span class="comment">// 清除旧的错误码。</span></span><br><span class="line"><span class="comment">// 从 &#x27;in&#x27; 读取一整行到 *buf，自动处理内存分配。</span></span><br><span class="line">readlen = getline(buf, buf_len, in);</span><br><span class="line"><span class="comment">// 如果 getline 返回负值，表示已到文件末尾或发生错误。</span></span><br><span class="line"><span class="keyword">if</span> (readlen &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (errno) &#123; <span class="comment">// 如果是 I/O 错误。</span></span><br><span class="line">perror(<span class="string">&quot;read_symbol&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 如果是文件末尾，正常返回 NULL。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除行尾的换行符。</span></span><br><span class="line"><span class="keyword">if</span> ((*buf)[readlen - <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">(*buf)[readlen - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析行首的十六进制地址。</span></span><br><span class="line">addr = strtoull(*buf, &amp;p, <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证行格式是否为 &quot;地址&lt;空格&gt;类型&lt;空格&gt;名称&quot;。</span></span><br><span class="line"><span class="keyword">if</span> (*buf == p || *p++ != <span class="string">&#x27; &#x27;</span> || !isascii((type = *p++)) || *p++ != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;line format error\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 剩余部分为符号名称。</span></span><br><span class="line">name = p;</span><br><span class="line">len = <span class="built_in">strlen</span>(name);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查符号名是否过长。</span></span><br><span class="line"><span class="keyword">if</span> (len &gt;= KSYM_NAME_LEN) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Symbol %s too long for kallsyms (%zu &gt;= %d).\n&quot;</span></span><br><span class="line"><span class="string">&quot;Please increase KSYM_NAME_LEN both in kernel and kallsyms.c\n&quot;</span>,</span><br><span class="line">name, len, KSYM_NAME_LEN);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特殊处理：记录 _text 符号的地址。</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(name, <span class="string">&quot;_text&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">_text = addr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据类型和名称进行初步过滤，忽略某些符号。</span></span><br><span class="line"><span class="keyword">if</span> (is_ignored_symbol(name, type))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查并记录特殊的文本段边界符号的地址。</span></span><br><span class="line">check_symbol_range(name, addr, text_ranges, ARRAY_SIZE(text_ranges));</span><br><span class="line"></span><br><span class="line"><span class="comment">// [关键优化] 增加长度以包含类型字符，以便一起进行压缩。</span></span><br><span class="line">len++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配内存：结构体大小 + 名称长度 + 类型字符(已计入len) + 字符串结束符。</span></span><br><span class="line">sym = xmalloc(<span class="keyword">sizeof</span>(*sym) + len + <span class="number">1</span>);</span><br><span class="line">sym-&gt;addr = addr;</span><br><span class="line">sym-&gt;len = len; <span class="comment">// 存储的是包含类型字符的长度。</span></span><br><span class="line">sym-&gt;sym[<span class="number">0</span>] = type; <span class="comment">// 将类型字符存为数据的第一个字节。</span></span><br><span class="line"><span class="comment">// 将名称字符串复制到类型字符之后的位置。</span></span><br><span class="line"><span class="built_in">strcpy</span>(sym_name(sym), name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sym;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="符号预过滤与边界检测-is-ignored-symbol-check-symbol-range"><a href="#符号预过滤与边界检测-is-ignored-symbol-check-symbol-range" class="headerlink" title="符号预过滤与边界检测 (is_ignored_symbol, check_symbol_range)"></a>符号预过滤与边界检测 (is_ignored_symbol, check_symbol_range)</h2><p>本代码片段是 <code>kallsyms.c</code> 主机端构建工具在解析符号表过程中的两个关键辅助函数。它们在 <code>read_symbol</code> 函数内部被调用，协同完成两个核心任务：<code>is_ignored_symbol</code> 扮演一个<strong>初步过滤器</strong>的角色，根据符号的类型和一小部分特例名称，快速剔除掉明显无用的符号；而 <code>check_symbol_range</code> 则扮演一个<strong>边界哨兵</strong>的角色，它在符号流中专门寻找并捕获标记内核关键内存区域（如代码段）起始和结束的特殊符号地址。</p><h3 id="实现原理分析-4"><a href="#实现原理分析-4" class="headerlink" title="实现原理分析"></a>实现原理分析</h3><p>这两个函数共同构成了解析阶段的“预处理”步骤，为后续更复杂的过滤和压缩算法准备好干净、有用的数据。</p><ol><li><p><strong>基于“黑名单”的快速过滤 (<code>is_ignored_symbol</code>)</strong>:</p><ul><li>该函数的逻辑是一个简单的“黑名单”机制，其目的是尽早地丢弃那些对最终 <code>kallsyms</code> 表毫无意义的符号，以减少内存占用和后续处理的开销。</li><li><strong>规则 1 (类型过滤)</strong>: <code>if (type == &#39;u&#39; || type == &#39;n&#39;)</code>。它直接丢弃两种类型的符号：<ul><li><code>&#39;u&#39;</code> (对应 <code>nm</code> 输出中的 <code>U</code>): 代表<strong>未定义 (Undefined)</strong> 的符号。这些是内核代码引用了但并未在内核主镜像中定义的符号（可能在模块中，或链接错误），它们没有地址，因此无用。</li><li><code>&#39;n&#39;</code>: 代表来自调试段（如 <code>.stab</code>）的调试符号，这些不属于运行时符号表。</li></ul></li><li><strong>规则 2 (特例处理)</strong>: <code>if (toupper(type) == &#39;A&#39;)</code>。<code>&#39;A&#39;</code> (或 <code>&#39;a&#39;</code>) 代表<strong>绝对地址 (Absolute)</strong> 符号，它们通常是常量或特殊地址，大部分对运行时地址解析无用。因此，该函数的默认行为是丢弃它们。</li><li><strong>白名单中的特例</strong>: 在丢弃绝对地址符号的规则内部，有一个 <code>if (strcmp(...) &amp;&amp; ...)</code> 的反向逻辑判断。这实际上构成了一个<strong>白名单</strong>，用于“拯救”几个虽然是绝对地址但对系统运行至关重要的符号，例如 <code>__kernel_syscall_via_*</code> (系统调用入口点)、<code>__kernel_sigtramp</code> (信号处理trampoline代码) 以及 <code>__gp</code> (某些架构上的全局指针)。</li></ul></li><li><p><strong>基于“标记”的范围捕获 (<code>check_symbol_range</code>)</strong>:</p><ul><li>该函数不进行任何过滤。它的唯一任务是在流经的符号中<strong>识别并记录</strong>特定的“边界标记”符号的地址。</li><li>它会遍历一个预定义的 <code>addr_range</code> 结构体数组（<code>text_ranges</code>），这个数组中包含了它所关心的边界符号对的名称，例如 <code>{&quot;_stext&quot;, &quot;_etext&quot;}</code>。</li><li>当它遇到一个符号，其名称与数组中某个 <code>start_sym</code> 或 <code>end_sym</code> 匹配时，它就会将该符号的地址 <code>addr</code> 捕获并存入 <code>addr_range</code> 结构体对应的 <code>start</code> 或 <code>end</code> 字段中。</li><li><strong>目的</strong>: 这一步至关重要，因为它动态地确定了内核代码段 <code>.text</code> 和初始化代码段 <code>.init.text</code> 在内存中的确切范围。这个范围信息将在后续的 <code>symbol_valid</code> 函数中被用作主要的过滤依据，以确保（在默认模式下）只有位于这些代码区域内的函数符号才会被最终保留下来。</li></ul></li></ol><h3 id="代码分析-3"><a href="#代码分析-3" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 判断一个符号是否应该被初步忽略。</span></span><br><span class="line"><span class="comment"> * @param name 符号的名称字符串。</span></span><br><span class="line"><span class="comment"> * @param type 符号的类型字符 (来自 nm 的输出)。</span></span><br><span class="line"><span class="comment"> * @return 如果符号应该被忽略则返回 true，否则返回 false。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">is_ignored_symbol</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">char</span> type)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 规则1：忽略未定义符号 (&#x27;u&#x27;) 和调试符号 (&#x27;n&#x27;)。</span></span><br><span class="line"><span class="keyword">if</span> (type == <span class="string">&#x27;u&#x27;</span> || type == <span class="string">&#x27;n&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 规则2：处理绝对地址符号 (&#x27;A&#x27; 或 &#x27;a&#x27;)。</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">toupper</span>(type) == <span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line"><span class="comment">/* 保留这些有用的绝对地址符号 (白名单)。*/</span></span><br><span class="line"><span class="comment">// 如果符号名不是以下任何一个，则它是一个应该被忽略的绝对地址符号。</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(name, <span class="string">&quot;__kernel_syscall_via_break&quot;</span>) &amp;&amp;</span><br><span class="line">    <span class="built_in">strcmp</span>(name, <span class="string">&quot;__kernel_syscall_via_epc&quot;</span>) &amp;&amp;</span><br><span class="line">    <span class="built_in">strcmp</span>(name, <span class="string">&quot;__kernel_sigtramp&quot;</span>) &amp;&amp;</span><br><span class="line">    <span class="built_in">strcmp</span>(name, <span class="string">&quot;__gp&quot;</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于所有其他情况，暂时不忽略该符号。</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 在符号流中检查是否存在预定义的边界符号，并记录它们的地址。</span></span><br><span class="line"><span class="comment"> * @param sym 待检查的符号的名称。</span></span><br><span class="line"><span class="comment"> * @param addr 待检查的符号的地址。</span></span><br><span class="line"><span class="comment"> * @param ranges 指向一个 addr_range 结构体数组，其中包含了要寻找的边界符号名称。</span></span><br><span class="line"><span class="comment"> * @param entries ranges 数组中的条目数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">check_symbol_range</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *sym, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> addr,</span></span><br><span class="line"><span class="params">       <span class="keyword">struct</span> addr_range *ranges, <span class="type">int</span> entries)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">size_t</span> i;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addr_range</span> *<span class="title">ar</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有需要寻找的边界范围。</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; entries; ++i) &#123;</span><br><span class="line">ar = &amp;ranges[i];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查当前符号是否是某个范围的起始符号。</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(sym, ar-&gt;start_sym) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 如果是，则记录其地址并返回。</span></span><br><span class="line">ar-&gt;start = addr;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// 检查当前符号是否是某个范围的结束符号。</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(sym, ar-&gt;end_sym) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 如果是，则记录其地址并返回。</span></span><br><span class="line">ar-&gt;end = addr;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="shrink-table-内核符号表的精炼：基于地址范围的核心符号过滤"><a href="#shrink-table-内核符号表的精炼：基于地址范围的核心符号过滤" class="headerlink" title="shrink_table 内核符号表的精炼：基于地址范围的核心符号过滤"></a>shrink_table 内核符号表的精炼：基于地址范围的核心符号过滤</h2><p>本代码片段是 <code>kallsyms.c</code> 主机端构建工具中的核心过滤模块。其主要功能是通过 <code>shrink_table</code> 函数，对从内核 ELF 文件中读取的原始符号列表进行一次决定性的“精炼”或“提纯”。它利用 <code>symbol_valid</code> 函数中定义的一套复杂的规则，主要依据符号的地址是否落在内核代码段（<code>.text</code> 和 <code>.init.text</code>）内，来精确地筛选出对运行时符号查找有用的核心符号（主要是函数），并丢弃所有其他无关的符号。</p><h3 id="实现原理分析-5"><a href="#实现原理分析-5" class="headerlink" title="实现原理分析"></a>实现原理分析</h3><p>此机制的核心是一种高效的<strong>基于规则的在位过滤（In-Place Filtering）算法</strong>，结合了一套精心设计的符号有效性判断策略。</p><ol><li><p><strong>在位过滤算法 (<code>shrink_table</code>)</strong>:</p><ul><li><code>shrink_table</code> 函数实现了一个经典的、高效的在位数组过滤算法。它使用两个索引（或称为“指针”）：<code>i</code> 作为“读取头”，它总是从头到尾遍历整个原始符号表；<code>pos</code> 作为“写入头”，它只在遇到一个有效的符号时才向前移动。</li><li><strong>工作流程</strong>:<br>a. 循环遍历 <code>table[i]</code>。<br>b. 对每个 <code>table[i]</code>，调用 <code>symbol_valid</code> 进行判断。<br>c. 如果 <code>symbol_valid</code> 返回 <code>true</code>，则将 <code>table[i]</code> 的指针复制到 <code>table[pos]</code> 的位置（<code>if (pos != i)</code> 是一个避免不必要自我复制的微优化），然后 <code>pos</code> 自增。<br>d. 如果 <code>symbol_valid</code> 返回 <code>false</code>，则 <code>free(table[i])</code> 释放该无效符号条目所占用的内存，但 <code>pos</code> 指针<strong>不移动</strong>。</li><li>循环结束后，<code>pos</code> 的值就是有效符号的总数。通过 <code>table_cnt = pos;</code>，数组的逻辑大小被“收缩”了，所有无效的条目都被有效地丢弃了。这种 O(n) 复杂度的算法避免了创建新数组的开销，非常高效。</li></ul></li><li><p><strong>符号有效性判断策略 (<code>symbol_valid</code>)</strong>:</p><ul><li>这是过滤的“策略引擎”，它定义了什么是一个“好”的符号。在默认模式下（即没有指定 <code>--all-symbols</code> 命令行选项），它遵循一个三层逻辑：</li><li><strong>规则 1 (白名单)</strong>: <code>if (string_starts_with(name, &quot;__start_&quot;) || ...)</code>。它无条件地保留所有以 <code>__start_</code> 或 <code>__stop_</code> 开头的符号。这些是链接器脚本定义的、用于标记内存区段边界的特殊符号，它们是后续地址范围判断的<strong>元数据</strong>，必须保留。</li><li><strong>规则 2 (核心地址范围过滤)</strong>: <code>if (symbol_in_range(...) == 0)</code>。这是最主要的过滤器。它要求一个符号的地址必须严格落在 <code>text_ranges</code> 数组所定义的范围之内（即 <code>.text</code> 或 <code>.init.text</code> 段）。<code>text_ranges</code> 的边界是在之前的 <code>check_symbol_range</code> 函数中动态捕获的。这个规则有效地将符号集限制为代码和初始化代码。</li><li><strong>规则 3 (边界稳定性特例)</strong>: <code>if ((s-&gt;addr == text_range_text-&gt;end &amp;&amp; ...))</code>。这是一个处理<strong>迭代链接</strong>过程中地址稳定性的关键特例。它会丢弃那些地址与 <code>_etext</code> 或 <code>_einittext</code> 完全相同，但名称却不是它们的符号。<strong>原因在于</strong>：在 <code>kallsyms</code> 的多遍链接过程中，添加 <code>kallsyms</code> 数据段本身可能会使其他符号的地址向后移动。一个在第一遍链接时恰好位于 <code>_etext</code> 地址的符号，在第二遍链接时可能会被挤到 <code>_etext</code> 之后，从而在第二遍的 <code>symbol_valid</code> 检查中被意外丢弃。这会破坏“符号集在迭代中只增不减”的规则。因此，此规则通过提前丢弃这些“不稳定的”边界符号来保证迭代过程的正确性。</li></ul></li></ol><h3 id="代码分析-4"><a href="#代码分析-4" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 获取符号条目中的名称字符串。</span></span><br><span class="line"><span class="comment"> * @param s 指向符号条目结构体的常量指针。</span></span><br><span class="line"><span class="comment"> * @return 指向符号名称字符串的指针。</span></span><br><span class="line"><span class="comment"> * @note 符号类型存储在 s-&gt;sym[0]，名称从 s-&gt;sym[1] 开始。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *<span class="title function_">sym_name</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sym_entry *s)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="type">char</span> *)s-&gt;sym + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 检查一个符号的地址是否落在给定的地址范围数组中的任何一个范围内。</span></span><br><span class="line"><span class="comment"> * @param s 指向待检查的符号条目结构体的常量指针。</span></span><br><span class="line"><span class="comment"> * @param ranges 指向地址范围结构体数组的常量指针。</span></span><br><span class="line"><span class="comment"> * @param entries ranges 数组中的条目数。</span></span><br><span class="line"><span class="comment"> * @return 如果地址在任何一个范围内则返回1，否则返回0。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">symbol_in_range</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sym_entry *s,</span></span><br><span class="line"><span class="params">   <span class="type">const</span> <span class="keyword">struct</span> addr_range *ranges, <span class="type">int</span> entries)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">size_t</span> i;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">addr_range</span> *<span class="title">ar</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有给定的地址范围。</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; entries; ++i) &#123;</span><br><span class="line">ar = &amp;ranges[i];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查符号地址是否在当前范围的起始和结束地址之间（包含边界）。</span></span><br><span class="line"><span class="keyword">if</span> (s-&gt;addr &gt;= ar-&gt;start &amp;&amp; s-&gt;addr &lt;= ar-&gt;end)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 检查一个字符串 &#x27;s&#x27; 是否以 &#x27;prefix&#x27; 开头。</span></span><br><span class="line"><span class="comment"> * @param s 待检查的字符串。</span></span><br><span class="line"><span class="comment"> * @param prefix 前缀字符串。</span></span><br><span class="line"><span class="comment"> * @return 如果 s 以 prefix 开头则返回 true，否则返回 false。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">string_starts_with</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">const</span> <span class="type">char</span> *prefix)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strncmp</span>(s, prefix, <span class="built_in">strlen</span>(prefix)) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">addr_range</span> <span class="title">text_ranges</span>[] =</span> &#123;</span><br><span class="line">&#123; <span class="string">&quot;_stext&quot;</span>,     <span class="string">&quot;_etext&quot;</span>     &#125;,</span><br><span class="line">&#123; <span class="string">&quot;_sinittext&quot;</span>, <span class="string">&quot;_einittext&quot;</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> text_range_text     (&amp;text_ranges[0])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> text_range_inittext (&amp;text_ranges[1])</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 判断一个符号是否应该被保留在最终的 kallsyms 表中。</span></span><br><span class="line"><span class="comment"> * @param s 指向待检查的符号条目结构体的常量指针。</span></span><br><span class="line"><span class="comment"> * @return 如果符号有效则返回1，否则返回0。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">symbol_valid</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sym_entry *s)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name = sym_name(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认情况下（没有 --all-symbols 选项），只保留代码段和特定边界符号。</span></span><br><span class="line"><span class="keyword">if</span> (!all_symbols) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 规则1 (白名单): 始终保留用于表示区段边界的 __start 和 __stop 符号。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (string_starts_with(name, <span class="string">&quot;__start_&quot;</span>) ||</span><br><span class="line">    string_starts_with(name, <span class="string">&quot;__stop_&quot;</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 规则2 (核心过滤): 符号必须位于 .text 或 .init.text 代码段内。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (symbol_in_range(s, text_ranges,</span><br><span class="line">    ARRAY_SIZE(text_ranges)) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 如果不在任何一个代码段范围内，则丢弃。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 规则3 (边界稳定性特例): 丢弃与 _etext 或 _einittext 地址相同但名称不同的符号。</span></span><br><span class="line"><span class="comment"> * 这是为了防止在多遍链接过程中，由于 kallsyms 数据段的加入导致地址偏移，</span></span><br><span class="line"><span class="comment"> * 从而使这些符号在后续遍中被错误地丢弃。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> ((s-&gt;addr == text_range_text-&gt;end &amp;&amp;</span><br><span class="line">     <span class="built_in">strcmp</span>(name, text_range_text-&gt;end_sym)) ||</span><br><span class="line">    (s-&gt;addr == text_range_inittext-&gt;end &amp;&amp;</span><br><span class="line">     <span class="built_in">strcmp</span>(name, text_range_inittext-&gt;end_sym)))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果指定了 --all-symbols，或者符号通过了以上所有检查，则保留该符号。</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 遍历全局符号表，移除所有无效的符号，实现表的“收缩”。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">shrink_table</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i, pos;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pos 是“写入”指针，i 是“读取”指针。</span></span><br><span class="line">pos = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; table_cnt; i++) &#123;</span><br><span class="line"><span class="comment">// 使用 symbol_valid() 作为判断条件。</span></span><br><span class="line"><span class="keyword">if</span> (symbol_valid(table[i])) &#123;</span><br><span class="line"><span class="comment">// 如果符号有效，则将其移动到“写入”指针的位置。</span></span><br><span class="line"><span class="keyword">if</span> (pos != i) <span class="comment">// 避免不必要的自我复制。</span></span><br><span class="line">table[pos] = table[i];</span><br><span class="line">pos++; <span class="comment">// “写入”指针前进。</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果符号无效，则释放其内存。</span></span><br><span class="line"><span class="built_in">free</span>(table[i]);</span><br><span class="line"><span class="comment">// “写入”指针不前进，该位置将被下一个有效符号覆盖。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新符号表的逻辑大小为有效符号的数量。</span></span><br><span class="line">table_cnt = pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sort-symbols-内核符号表的稳定排序与歧义消解"><a href="#sort-symbols-内核符号表的稳定排序与歧义消解" class="headerlink" title="sort_symbols 内核符号表的稳定排序与歧义消解"></a>sort_symbols 内核符号表的稳定排序与歧义消解</h2><p>本代码片段是 <code>kallsyms.c</code> 主机端构建工具中负责对内核符号表进行最终排序的核心模块。其主要功能是通过 <code>sort_symbols</code> 函数调用 C 标准库的 <code>qsort</code>，并提供一个高度定制化的比较函数 <code>compare_symbols</code>。这个比较函数实现了一个复杂的多级排序策略，其首要目标是按地址对所有符号进行排序，但更重要的是，它定义了一套精确的规则，用于处理多个不同符号恰好位于<strong>同一内存地址</strong>时的歧义问题，确保最终的符号表在逻辑上是正确和可预测的。</p><h3 id="实现原理分析-6"><a href="#实现原理分析-6" class="headerlink" title="实现原理分析"></a>实现原理分析</h3><p>此机制的核心是一种<strong>带歧义消解的多级稳定排序（Multi-level Stable Sort with Ambiguity Resolution）</strong>。<code>compare_symbols</code> 函数是这一原理的精髓，它建立了一个清晰的优先级层次结构来处理地址冲突的符号。</p><ol><li><p><strong>主排序键：地址 (<code>sa-&gt;addr</code> vs <code>sb-&gt;addr</code>)</strong>: 这是最优先的排序规则。所有符号都必须首先按照它们的内存地址从小到大进行排列。这是生成 <code>System.map</code> 和后续 <code>kallsyms</code> 数据结构的基础要求，也是 <code>record_relative_base</code> 函数能正确找到最低地址符号的前提。</p></li><li><p><strong>次级排序键（Tie-breakers for Address Collisions）</strong>: 当两个或多个符号地址相同时 (<code>sa-&gt;addr == sb-&gt;addr</code>)，比较函数会依次应用以下规则来决定它们的相对顺序：</p><ul><li><strong>a. 强弱符号 (<code>Weakness</code>)</strong>: <code>wa = (sa-&gt;sym[0] == &#39;w&#39;) || (sa-&gt;sym[0] == &#39;W&#39;);</code>。它会优先排列强符号（类型不是 ‘w’ 或 ‘W’）在弱符号之前。这是因为在链接时，如果一个强符号和一个弱符号同名，强符号会覆盖弱符号。在符号表中也反映这一优先级是符合逻辑的。</li><li><strong>b. 符号类型（代码 vs. 边界）</strong>: <code>wa = may_be_linker_script_provide_symbol(sa);</code>。<code>may_be_linker_script_provide_symbol</code> 函数通过启发式规则（检查 <code>__start_</code>, <code>__stop_</code> 等模式）来识别那些由链接器脚本生成的、用于标记内存区段边界的符号。此排序规则会优先排列“真正的”代码&#x2F;数据符号，而将这些边界标记符号排在后面。这确保了当一个函数的地址与一个区段的起始地址完全相同时，地址查找会优先返回函数名，而不是边界名。</li><li><strong>c. 命名约定（公共 vs. 内部）</strong>: <code>wa = strspn(sym_name(sa), &quot;_&quot;);</code>。此规则计算符号名前导下划线的数量。它会优先排列前导下划线较少的符号。这是基于一个普遍的编码约定，即前导下划线越多的符号，其内部性越强。这有助于将更“公开”的符号名排在前面。</li><li><strong>d. 稳定性（原始顺序）</strong>: <code>return sa-&gt;seq - sb-&gt;seq;</code>。这是最后的杀手锏。如果经过以上所有规则比较后，两个符号仍然无法区分，此规则将依据它们在输入文件中出现的原始顺序（<code>seq</code>）进行排序。这保证了整个排序过程是<strong>稳定</strong>的，即对于等价的元素，它们的相对顺序在排序后保持不变。这对于构建过程的可复现性至关重要。</li></ul></li></ol><h3 id="代码分析-5"><a href="#代码分析-5" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 通过启发式规则猜测一个符号是否是由链接器脚本提供的边界符号。</span></span><br><span class="line"><span class="comment"> * @param se 指向待检查的符号条目结构体的指针。</span></span><br><span class="line"><span class="comment"> * @return 如果猜测是边界符号则返回1，否则返回0。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">may_be_linker_script_provide_symbol</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sym_entry *se)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *symbol = sym_name(se);</span><br><span class="line"><span class="type">int</span> len = se-&gt;len - <span class="number">1</span>; <span class="comment">// 获取真实的符号名长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (len &lt; <span class="number">8</span>) <span class="comment">// 边界符号通常较长</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (symbol[<span class="number">0</span>] != <span class="string">&#x27;_&#x27;</span> || symbol[<span class="number">1</span>] != <span class="string">&#x27;_&#x27;</span>) <span class="comment">// 通常以 &quot;__&quot; 开头</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否匹配 &quot;__start_XXXXX&quot; 模式</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">memcmp</span>(symbol + <span class="number">2</span>, <span class="string">&quot;start_&quot;</span>, <span class="number">6</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否匹配 &quot;__stop_XXXXX&quot; 模式</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">memcmp</span>(symbol + <span class="number">2</span>, <span class="string">&quot;stop_&quot;</span>, <span class="number">5</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否匹配 &quot;__end_XXXXX&quot; 模式</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">memcmp</span>(symbol + <span class="number">2</span>, <span class="string">&quot;end_&quot;</span>, <span class="number">4</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否匹配 &quot;__XXXXX_start&quot; 模式</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">memcmp</span>(symbol + len - <span class="number">6</span>, <span class="string">&quot;_start&quot;</span>, <span class="number">6</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否匹配 &quot;__XXXXX_end&quot; 模式</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">memcmp</span>(symbol + len - <span class="number">4</span>, <span class="string">&quot;_end&quot;</span>, <span class="number">4</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief qsort 的比较函数，用于对符号表进行多级稳定排序。</span></span><br><span class="line"><span class="comment"> * @param a 指向第一个待比较元素的指针 (实际是 struct sym_entry**)。</span></span><br><span class="line"><span class="comment"> * @param b 指向第二个待比较元素的指针 (实际是 struct sym_entry**)。</span></span><br><span class="line"><span class="comment"> * @return -1 (a &lt; b), 0 (a == b), 1 (a &gt; b)。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">compare_symbols</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sym_entry</span> *<span class="title">sa</span> =</span> *(<span class="type">const</span> <span class="keyword">struct</span> sym_entry **)a;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sym_entry</span> *<span class="title">sb</span> =</span> *(<span class="type">const</span> <span class="keyword">struct</span> sym_entry **)b;</span><br><span class="line"><span class="type">int</span> wa, wb;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 规则1: 首先按地址排序 */</span></span><br><span class="line"><span class="keyword">if</span> (sa-&gt;addr &gt; sb-&gt;addr)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (sa-&gt;addr &lt; sb-&gt;addr)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 地址相同，进入歧义消解流程 --- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 规则2: 按“弱符号”类型排序 (强符号优先) */</span></span><br><span class="line">wa = (sa-&gt;sym[<span class="number">0</span>] == <span class="string">&#x27;w&#x27;</span>) || (sa-&gt;sym[<span class="number">0</span>] == <span class="string">&#x27;W&#x27;</span>); <span class="comment">// wa=1 if weak</span></span><br><span class="line">wb = (sb-&gt;sym[<span class="number">0</span>] == <span class="string">&#x27;w&#x27;</span>) || (sb-&gt;sym[<span class="number">0</span>] == <span class="string">&#x27;W&#x27;</span>); <span class="comment">// wb=1 if weak</span></span><br><span class="line"><span class="keyword">if</span> (wa != wb)</span><br><span class="line"><span class="keyword">return</span> wa - wb; <span class="comment">// 强符号(0)会排在弱符号(1)之前</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 规则3: 按“链接器脚本提供”的符号类型排序 (真实符号优先) */</span></span><br><span class="line">wa = may_be_linker_script_provide_symbol(sa); <span class="comment">// wa=1 if linker symbol</span></span><br><span class="line">wb = may_be_linker_script_provide_symbol(sb); <span class="comment">// wb=1 if linker symbol</span></span><br><span class="line"><span class="keyword">if</span> (wa != wb)</span><br><span class="line"><span class="keyword">return</span> wa - wb; <span class="comment">// 真实符号(0)会排在边界符号(1)之前</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 规则4: 按前导下划线的数量排序 (下划线少的优先) */</span></span><br><span class="line">wa = <span class="built_in">strspn</span>(sym_name(sa), <span class="string">&quot;_&quot;</span>); <span class="comment">// 计算前导 &#x27;_&#x27; 数量</span></span><br><span class="line">wb = <span class="built_in">strspn</span>(sym_name(sb), <span class="string">&quot;_&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (wa != wb)</span><br><span class="line"><span class="keyword">return</span> wa - wb; <span class="comment">// 下划线少的排在前面</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 规则5: 按原始顺序排序 (保证稳定性) */</span></span><br><span class="line"><span class="comment">// 如果以上所有规则都相同，则保持它们在输入文件中的原始相对顺序。</span></span><br><span class="line"><span class="keyword">return</span> sa-&gt;seq - sb-&gt;seq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 调用 qsort 对全局符号表进行排序。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sort_symbols</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">qsort(table, table_cnt, <span class="keyword">sizeof</span>(table[<span class="number">0</span>]), compare_symbols);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="optimize-token-table-与内核符号表压缩算法"><a href="#optimize-token-table-与内核符号表压缩算法" class="headerlink" title="optimize_token_table 与内核符号表压缩算法"></a>optimize_token_table 与内核符号表压缩算法</h2><p>本代码片段是Linux内核构建过程中的主机端工具代码（通常位于 <code>scripts/kallsyms.c</code>），其核心功能是对内核符号表（kallsyms）中的符号名称进行压缩。它采用了一种基于统计的贪婪算法，类似于字节对编码（Byte Pair Encoding, BPE）。其目的是通过将频繁出现的字符对（tokens）替换为未在原始符号中使用的单字节索引，从而减小最终内核镜像的大小。</p><h3 id="实现原理分析-7"><a href="#实现原理分析-7" class="headerlink" title="实现原理分析"></a>实现原理分析</h3><p>该算法属于基于字典的压缩算法。它通过多次迭代，构建一个将单字节索引映射到一至两个字节字符序列的“最佳表”（<code>best_table</code>）。</p><ol><li><p><strong>相对基地址记录 (<code>record_relative_base</code>)</strong>:<br>为了进一步压缩符号地址，内核通常存储相对于某个基地址的偏移量而非绝对地址。此函数假定符号表已按地址排序，并记录第一个符号的地址作为基准。这是一种差分编码（Delta Encoding）的预处理步骤。</p></li><li><p><strong>频率统计与动态更新 (<code>learn_symbol</code>, <code>forget_symbol</code>, <code>build_initial_token_table</code>)</strong>:<br>算法的核心依赖于对所有符号名中相邻字符对（bigrams）出现频率的精确统计。</p><ul><li>统计空间被映射为一个大小为 $256 \times 256 &#x3D; 65536$ (<code>0x10000</code>) 的数组 <code>token_profit</code>。字符对 $(c_1, c_2)$ 的索引计算为 $c_1 + (c_2 \times 256)$。</li><li><code>build_initial_token_table</code> 初始化全局频率直方图。</li><li>关键在于动态性：当执行压缩替换时，原有的字符对消失，新的字符对（包含压缩索引）产生。<code>forget_symbol</code> 和 <code>learn_symbol</code> 分别用于在替换前后减少旧对和增加新对的计数，维持统计的实时准确性。</li></ul></li><li><p><strong>贪婪选择与全局替换 (<code>find_best_token</code>, <code>compress_symbols</code>)</strong>:</p><ul><li><strong>贪婪策略</strong>: <code>find_best_token</code> 遍历整个 <code>token_profit</code> 数组，找到当前出现频率最高（”收益”最大）的字符对。</li><li><strong>全局替换</strong>: <code>compress_symbols</code> 负责执行实际的压缩动作。它遍历所有符号，找到目标字符对，将其替换为指定的单字节索引，并利用 <code>memmove</code> 处理字符串缩短后的内存移动。最重要的是，它在替换前后调用 <code>forget</code>&#x2F;<code>learn</code> 来更新全局频率表，确保后续迭代基于最新的数据。</li></ul></li><li><p><strong>优化驱动流程 (<code>optimize_result</code>, <code>insert_real_symbols_in_table</code>)</strong>:<br>这是算法的主循环。</p><ul><li>首先，<code>insert_real_symbols_in_table</code> 标记出所有在原始符号名中实际存在的单字节字符。这些字符对应的索引不能被用作压缩代号。</li><li><code>optimize_result</code> 从 255 到 0 逆向遍历所有可能的单字节槽位。如果某个槽位未被原始字符占用，则它是一个可用的“压缩槽”。</li><li>对于每个可用槽，算法找到当前最佳的字符对，将其存入解压字典 (<code>best_table</code>)，并在所有符号中用该槽位的索引替换该字符对。</li><li>该过程持续进行，直到没有可用槽位或没有值得压缩的字符对（收益为0）。</li></ul></li></ol><h3 id="代码分析-6"><a href="#代码分析-6" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 寻找最小的非绝对符号地址，用作相对寻址的基地址 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">record_relative_base</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 符号表已经按地址进行了排序。</span></span><br><span class="line"><span class="comment"> * 取第一个符号的地址作为基地址。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (table_cnt)</span><br><span class="line">relative_base = table[<span class="number">0</span>]-&gt;addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 表查找压缩函数集 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> token_profit[<span class="number">0x10000</span>];</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief learn_symbol - 统计一个符号中所有可能的字符对（token）的出现次数</span></span><br><span class="line"><span class="comment"> * @param symbol: 指向符号名字符串的指针</span></span><br><span class="line"><span class="comment"> * @param len: 符号名的长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">learn_symbol</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *symbol, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历字符串，处理每一对相邻的字符</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line"><span class="comment">// 计算字符对的索引：symbol[i] 为低字节，symbol[i+1] 为高字节。</span></span><br><span class="line"><span class="comment">// 增加该字符对在全局收益表中的计数值。</span></span><br><span class="line">token_profit[ symbol[i] + (symbol[i + <span class="number">1</span>] &lt;&lt; <span class="number">8</span>) ]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief forget_symbol - 减少一个符号中所有字符对的出现次数</span></span><br><span class="line"><span class="comment"> * @param symbol: 指向符号名字符串的指针</span></span><br><span class="line"><span class="comment"> * @param len: 符号名的长度</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 此函数用于在符号被压缩（修改）之前，从全局统计中移除其旧的贡献。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">forget_symbol</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *symbol, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历字符串，处理每一对相邻的字符</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line"><span class="comment">// 减少该字符对在全局收益表中的计数值。</span></span><br><span class="line">token_profit[ symbol[i] + (symbol[i + <span class="number">1</span>] &lt;&lt; <span class="number">8</span>) ]--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief build_initial_token_table - 执行初始的字符对统计</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 遍历整个当前的符号表，建立初始的频率直方图。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">build_initial_token_table</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有符号</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; table_cnt; i++)</span><br><span class="line"><span class="comment">// 对每个符号调用 learn_symbol 进行统计</span></span><br><span class="line">learn_symbol(table[i]-&gt;sym, table[i]-&gt;len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief find_token - 在字符串中查找指定的二字节 token</span></span><br><span class="line"><span class="comment"> * @param str: 要搜索的字符串</span></span><br><span class="line"><span class="comment"> * @param len: 字符串长度</span></span><br><span class="line"><span class="comment"> * @param token: 要查找的二字节序列</span></span><br><span class="line"><span class="comment"> * @return 指向找到的 token 在 str 中首次出现位置的指针，未找到则返回 NULL。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">find_token</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *str, <span class="type">int</span> len,</span></span><br><span class="line"><span class="params"> <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *token)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线性搜索匹配的字符对</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (str[i] == token[<span class="number">0</span>] &amp;&amp; str[i+<span class="number">1</span>] == token[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">return</span> &amp;str[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief compress_symbols - 在所有有效符号中替换给定的 token</span></span><br><span class="line"><span class="comment"> * @param str: 要被替换掉的二字节 token</span></span><br><span class="line"><span class="comment"> * @param idx: 用于替换的新单字节索引值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 此函数使用采样的符号来动态更新计数。它执行贪婪替换并维护统计一致性。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">compress_symbols</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *str, <span class="type">int</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i, len, size;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *p1, *p2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历整个符号表</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; table_cnt; i++) &#123;</span><br><span class="line"></span><br><span class="line">len = table[i]-&gt;len;</span><br><span class="line">p1 = table[i]-&gt;sym;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在当前符号中查找该 token */</span></span><br><span class="line">p2 = find_token(p1, len, str);</span><br><span class="line"><span class="keyword">if</span> (!p2) <span class="keyword">continue</span>; <span class="comment">// 如果没有找到，处理下一个符号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在修改前，减少此符号中当前所有 token 的计数 */</span></span><br><span class="line">forget_symbol(table[i]-&gt;sym, len);</span><br><span class="line"></span><br><span class="line">size = len;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环替换符号中出现的所有目标 token</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">// 将 token 的第一个字节替换为压缩索引</span></span><br><span class="line">*p2 = idx;</span><br><span class="line">p2++;</span><br><span class="line"><span class="comment">// 计算剩余部分的长度（减去 token 的第二个字节）</span></span><br><span class="line">size -= (p2 - p1);</span><br><span class="line"><span class="comment">// 使用 memmove 将剩余字符串前移一个字节，覆盖 token 的第二个字节</span></span><br><span class="line">memmove(p2, p2 + <span class="number">1</span>, size);</span><br><span class="line"><span class="comment">// 更新当前处理位置指针</span></span><br><span class="line">p1 = p2;</span><br><span class="line"><span class="comment">// 符号总长度减 1</span></span><br><span class="line">len--;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果剩余长度小于2，无法再包含 token，退出内循环</span></span><br><span class="line"><span class="keyword">if</span> (size &lt; <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在剩余部分继续查找 token */</span></span><br><span class="line">p2 = find_token(p1, size, str);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (p2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新符号结构体中的长度</span></span><br><span class="line">table[i]-&gt;len = len;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 增加此符号被压缩后产生的新 token 的计数 */</span></span><br><span class="line">learn_symbol(table[i]-&gt;sym, len);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief find_best_token - 搜索具有最大收益（出现频率最高）的 token</span></span><br><span class="line"><span class="comment"> * @return 最佳 token 的 16 位组合值（byte1 + (byte2 &lt;&lt; 8)）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">find_best_token</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i, best, bestprofit;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化最佳收益为一个负值</span></span><br><span class="line">bestprofit = <span class="number">-10000</span>;</span><br><span class="line">best = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有可能的 65536 种字符对组合</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">0x10000</span>; i++) &#123;</span><br><span class="line"><span class="comment">// 如果当前 token 的收益高于已知最佳收益</span></span><br><span class="line"><span class="keyword">if</span> (token_profit[i] &gt; bestprofit) &#123;</span><br><span class="line">best = i;</span><br><span class="line">bestprofit = token_profit[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> best;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* the table that holds the result of the compression */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> best_table[<span class="number">256</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> best_table_len[<span class="number">256</span>];</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief optimize_result - 算法核心：计算“最佳”压缩表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 驱动整个压缩过程，填充 best_table 并执行替换。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">optimize_result</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i, best;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从 255 倒序遍历到 0。</span></span><br><span class="line"><span class="comment"> * 这种顺序不是绝对必要的，但可能将较低的索引留给原始 ASCII 字符。</span></span><br><span class="line"><span class="comment"> * 重要的是填满所有未使用的槽位。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">255</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果这个表项槽位是空的（它没有被原始符号中的实际字符使用） */</span></span><br><span class="line"><span class="keyword">if</span> (!best_table_len[i]) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 找到当前具有最佳收益值的 token */</span></span><br><span class="line">best = find_best_token();</span><br><span class="line"><span class="comment">// 如果最佳收益为 0，说明没有更多重复的二字节组可压缩，退出。</span></span><br><span class="line"><span class="keyword">if</span> (token_profit[best] == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将该 token 放入“最佳”表中对应的槽位 i */</span></span><br><span class="line">best_table_len[i] = <span class="number">2</span>; <span class="comment">// 标记该槽位扩展为 2 个字节</span></span><br><span class="line">best_table[i][<span class="number">0</span>] = best &amp; <span class="number">0xFF</span>; <span class="comment">// 低字节</span></span><br><span class="line">best_table[i][<span class="number">1</span>] = (best &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>; <span class="comment">// 高字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在所有有效符号中用索引 i 替换此 token */</span></span><br><span class="line">compress_symbols(best_table[i], i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief insert_real_symbols_in_table - 标记原始符号中实际使用的字符</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 防止压缩算法使用这些字符作为压缩索引，造成冲突。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">insert_real_symbols_in_table</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i, j, c;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有符号</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; table_cnt; i++) &#123;</span><br><span class="line"><span class="comment">// 遍历符号中的每个字符</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; table[i]-&gt;len; j++) &#123;</span><br><span class="line">c = table[i]-&gt;sym[j];</span><br><span class="line"><span class="comment">// 在 best_table 中将该字符映射为自身</span></span><br><span class="line">best_table[c][<span class="number">0</span>] = c;</span><br><span class="line"><span class="comment">// 标记该槽位已被占用，长度为 1</span></span><br><span class="line">best_table_len[c] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief optimize_token_table - 优化符号表的顶层函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 协调整个压缩流程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">optimize_token_table</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 步骤 1: 建立初始的 token 频率表</span></span><br><span class="line">build_initial_token_table();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤 2: 识别并锁定原始符号中存在的单字节字符</span></span><br><span class="line">insert_real_symbols_in_table();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤 3: 执行贪婪压缩循环</span></span><br><span class="line">optimize_result();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="output-label-与-expand-symbol-汇编生成与符号解压"><a href="#output-label-与-expand-symbol-汇编生成与符号解压" class="headerlink" title="output_label 与 expand_symbol 汇编生成与符号解压"></a>output_label 与 expand_symbol 汇编生成与符号解压</h2><p>本代码片段包含两个独立的函数。第一个是 <code>output_label</code>，一个用于在 <code>kallsyms</code> 生成的汇编文件中输出标准、对齐的全局符号标签的辅助工具。第二个是 <code>expand_symbol</code>，它是 <code>kallsyms</code> 压缩算法的核心解压引擎，负责在编译时将一个压缩后的符号名递归地展开为其原始的、人类可读的字符串形式。</p><h3 id="实现原理分析-8"><a href="#实现原理分析-8" class="headerlink" title="实现原理分析"></a>实现原理分析</h3><ol><li><p><strong>汇编标签生成 (<code>output_label</code>)</strong>:</p><ul><li>此函数是一个简单的代码生成器，它将一个常见的汇编模式封装成一个函数调用。</li><li><code>globl</code>: 这是一个汇编器伪指令，用于将一个符号的可见性声明为“全局”。这意味着该符号在链接阶段可以被其他目标文件引用。在这里，它使得 C 代码可以引用 <code>kallsyms_names</code>、<code>kallsyms_offsets</code> 等在汇编中定义的数据表。</li><li><code>ALGN</code>: 这是一个宏，根据目标平台的指针大小，被定义为相应的对齐伪指令（例如，对于32位平台是 <code>.balign 4</code>）。它的作用是确保紧随其后的标签地址是特定字节数的倍数。这对于性能至关重要，因为许多CPU架构（包括ARMv7-M）在访问自然对齐的数据时效率最高。</li><li><code>label:</code>: 这是标准的汇编语法，用于定义一个标签，即把当前地址与一个符号名称关联起来。</li></ul></li><li><p><strong>递归符号解压 (<code>expand_symbol</code>)</strong>:</p><ul><li>该函数的核心原理是<strong>递归查表</strong>。<code>kallsyms</code> 的压缩算法可能产生嵌套的压缩。例如，一个高频出现的字符对 “ab” 可能首先被替换为索引 <code>255</code>；随后，”255c” 这个序列本身也可能因为高频出现而被替换为索引 <code>254</code>。因此，<code>best_table[254]</code> 中存储的不是 “abc”，而是压缩后的序列 <code>{255, &#39;c&#39;}</code>。</li><li><strong>递归终止条件（Base Case）</strong>: 当函数遇到的一个字节 <code>c</code> 在解压表 <code>best_table</code> 中对应的条目是一个单字节且映射到其自身的字符时（<code>best_table[c][0]==c &amp;&amp; best_table_len[c]==1</code>），这个字符就是原始的、未被压缩的“原子”字符。这是递归的最底层，直接将该字符输出。</li><li><strong>递归步骤（Recursive Step）</strong>: 如果遇到的字节 <code>c</code> 对应的条目不是原子字符，说明 <code>c</code> 是一个压缩标记。函数必须对 <code>best_table[c]</code> 中存储的序列进行解压，这是通过<strong>调用自身</strong>来完成的。函数将 <code>best_table[c]</code> 的内容作为新的输入，进行递归展开，直到所有遇到的字节都最终分解为原子字符。</li><li>由于压缩过程保证了不会出现循环定义（例如 A-&gt;B, B-&gt;A），这个递归过程保证是有限的，最终会终止。</li></ul></li></ol><h3 id="代码分析-7"><a href="#代码分析-7" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief output_label - 在汇编文件中输出一个全局的、对齐的标签。</span></span><br><span class="line"><span class="comment"> * @param label: 要输出的标签字符串。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这是一个辅助函数，用于生成标准的汇编标签定义。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">output_label</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *label)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// .globl 伪指令使标签对于链接器是全局可见的，允许其他文件引用它。</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;.globl %s\n&quot;</span>, label);</span><br><span class="line"><span class="comment">// ALGN 是一个宏，会展开为 .balign 4 (对于32位系统)，确保标签地址4字节对齐。</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\tALGN\n&quot;</span>);</span><br><span class="line"><span class="comment">// 定义标签本身。</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s:\n&quot;</span>, label);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief expand_symbol - 递归地解压一个压缩的符号。</span></span><br><span class="line"><span class="comment"> * @param data: 指向压缩符号名数据的指针。</span></span><br><span class="line"><span class="comment"> * @param len: 压缩数据的长度。</span></span><br><span class="line"><span class="comment"> * @param result: 用于存放解压后结果字符串的缓冲区。</span></span><br><span class="line"><span class="comment"> * @return 解压后字符串的实际长度。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 当此函数被调用时，解压字典（best_table）本身可能也包含压缩的条目，</span></span><br><span class="line"><span class="comment"> * 因此函数必须是递归的才能完全展开符号。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">expand_symbol</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *data, <span class="type">int</span> len, <span class="type">char</span> *result)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> c, rlen, total=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环处理压缩数据中的每一个字节</span></span><br><span class="line"><span class="keyword">while</span> (len) &#123;</span><br><span class="line">c = *data; <span class="comment">// 获取当前字节作为索引</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如果解压表中该索引对应的条目是一个单字节，且就是其自身，</span></span><br><span class="line"><span class="comment"> * 这说明它是一个“原子”字符，不是一个压缩标记。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (best_table[c][<span class="number">0</span>]==c &amp;&amp; best_table_len[c]==<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// 将原子字符直接写入结果缓冲区</span></span><br><span class="line">*result++ = c;</span><br><span class="line">total++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 否则，该索引是一个压缩标记，需要递归地展开其所代表的序列。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">rlen = expand_symbol(best_table[c], best_table_len[c], result);</span><br><span class="line"><span class="comment">// 累加递归解压出的字符串长度</span></span><br><span class="line">total += rlen;</span><br><span class="line"><span class="comment">// 将结果缓冲区的指针向后移动相应的长度</span></span><br><span class="line">result += rlen;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 处理下一个压缩数据字节</span></span><br><span class="line">data++;</span><br><span class="line">len--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在解压后的字符串末尾添加空终止符</span></span><br><span class="line">*result=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="稀疏索引加速-kallsyms-markers-机制的原理"><a href="#稀疏索引加速-kallsyms-markers-机制的原理" class="headerlink" title="稀疏索引加速 (kallsyms_markers) 机制的原理"></a><strong>稀疏索引加速 (<code>kallsyms_markers</code>)</strong> 机制的原理</h2><p>这是一种典型的二级索引（Two-Level Indexing）策略，旨在解决在大型、连续但非定长的数据流中进行高效查找的问题。</p><h3 id="1-问题陈述：没有-kallsyms-markers-的世界"><a href="#1-问题陈述：没有-kallsyms-markers-的世界" class="headerlink" title="1. 问题陈述：没有 kallsyms_markers 的世界"></a>1. 问题陈述：没有 <code>kallsyms_markers</code> 的世界</h3><p>首先，我们必须理解它要解决的根本问题。内核符号数据在 <code>kallsyms_names</code> 中是这样存储的：</p><p><code>[len1][name1][len2][name2][len3][name3] ... [len_N][name_N]</code></p><p>其中：</p><ul><li><code>[lenX]</code> 是符号 <code>nameX</code> 的长度，采用 1 或 2 字节的 ULEB128 编码。</li><li><code>[nameX]</code> 是压缩后的符号名称字节序列。</li></ul><p>假设内核需要查找<strong>第 <code>i</code> 个符号</strong>的名称（例如，在打印堆栈回溯时，通过地址找到了第 <code>i</code> 个符号的偏移，现在需要它的名字）。如果没有 <code>kallsyms_markers</code>，查找过程将是这样的：</p><ol><li><strong>从头开始</strong>：将指针指向 <code>kallsyms_names</code> 的起始位置。</li><li><strong>顺序解码和跳过</strong>：<ul><li>读取第一个符号的长度 <code>len1</code>（需要解码 ULEB128，可能是1或2字节）。</li><li>将指针向后移动 <code>len1</code> 个字节，跳过第一个符号的名称。</li><li>现在指针位于第二个符号的长度 <code>len2</code> 处。</li></ul></li><li><strong>重复</strong>：重复第 2 步 <code>i-1</code> 次。每次都要解码一个长度，然后根据该长度进行一次指针移动。</li><li><strong>找到目标</strong>：在重复 <code>i-1</code> 次后，指针最终会停在第 <code>i</code> 个符号的长度 <code>len_i</code> 处。此时，内核才能读取并解压第 <code>i</code> 个符号的名称。</li></ol><p>这个过程的<strong>时间复杂度是 O(i)</strong>，即与要查找的符号序号成正比。如果要查找的符号在列表的末尾（例如，第 60000 个符号），内核就必须对前面的 59999 个符号逐一进行“解码长度-跳过名称”的操作。这在运行时，尤其是在需要快速响应的内核 panic 期间，是无法接受的低效。</p><h3 id="2-解决方案：kallsyms-markers-的二级索引机制"><a href="#2-解决方案：kallsyms-markers-的二级索引机制" class="headerlink" title="2. 解决方案：kallsyms_markers 的二级索引机制"></a>2. 解决方案：<code>kallsyms_markers</code> 的二级索引机制</h3><p><code>kallsyms_markers</code> 表就像一本书的“章节起始页码表”。它并不记录每一页的页码，而只记录每章第一页的页码，从而允许你快速翻到任何一章。</p><h4 id="构建过程（在编译时）"><a href="#构建过程（在编译时）" class="headerlink" title="构建过程（在编译时）"></a>构建过程（在编译时）</h4><p>如代码所示，在生成 <code>kallsyms_names</code> 流的同时，会创建一个 <code>markers</code> 数组。</p><ul><li>一个计数器 <code>off</code> 持续追踪当前在 <code>kallsyms_names</code> 流中的字节偏移量。</li><li><code>for (i = 0; i &lt; table_cnt; i++)</code> 循环每处理一个符号，<code>off</code> 就会增加。</li><li><code>if ((i &amp; 0xFF) == 0)</code> 这个条件判断 <code>i</code> 是否是 256 的整数倍（<code>i % 256 == 0</code>）。</li><li>当条件成立时（即处理第 0、256、512 … 个符号时），就执行 <code>markers[i &gt;&gt; 8] = off;</code>，将当前的偏移量 <code>off</code> 存入 <code>markers</code> 数组的相应位置。<code>i &gt;&gt; 8</code> 等价于 <code>i / 256</code>。</li></ul><p>最终，<code>markers</code> 数组看起来像这样：</p><ul><li><code>markers[0]</code> &#x3D; 第 0 个符号在 <code>kallsyms_names</code> 中的起始偏移。</li><li><code>markers[1]</code> &#x3D; 第 256 个符号在 <code>kallsyms_names</code> 中的起始偏移。</li><li><code>markers[2]</code> &#x3D; 第 512 个符号在 <code>kallsyms_names</code> 中的起始偏移。</li><li>…</li></ul><h4 id="查找过程（在运行时）"><a href="#查找过程（在运行时）" class="headerlink" title="查找过程（在运行时）"></a>查找过程（在运行时）</h4><p>现在，当内核需要查找<strong>第 <code>i</code> 个符号</strong>的名称时，过程被优化为：</p><ol><li><strong>计算标记点索引</strong>：计算 <code>marker_idx = i &gt;&gt; 8</code> (即 <code>i / 256</code>)。这能立刻告诉内核应该使用哪个标记点。</li><li><strong>快速跳转（粗定位）</strong>：直接从 <code>kallsyms_markers</code> 表中读取 <code>start_offset = markers[marker_idx]</code>。然后将文件流指针直接设置为 <code>kallsyms_names + start_offset</code>。<strong>这一步是 O(1) 的</strong>，它代替了之前可能需要成千上万次的解码-跳过操作。</li><li><strong>计算块内起始符号</strong>：计算出这个标记点对应的符号序号 <code>start_symbol_idx = marker_idx &lt;&lt; 8</code> (即 <code>(i / 256) * 256</code>)。</li><li><strong>小范围线性扫描（精定位）</strong>：从 <code>start_symbol_idx</code> 开始，执行前述的“解码长度-跳过名称”操作，总共执行 <code>i - start_symbol_idx</code> 次。由于 <code>0 &lt;= (i - start_symbol_idx) &lt; 256</code>，这个线性扫描的次数<strong>最多不超过 255 次</strong>。</li></ol><p>这个新过程的时间复杂度变成了 <strong>O(1) + O(k)</strong>，其中 O(1) 是查表跳转的开销，k 是一个固定的小常数（最大为255）。因此，无论要查找的符号在列表中的位置有多靠后，查找时间都基本是恒定的，效率得到了极大的提升。</p><h3 id="3-“空间换时间”的权衡分析"><a href="#3-“空间换时间”的权衡分析" class="headerlink" title="3. “空间换时间”的权衡分析"></a>3. “空间换时间”的权衡分析</h3><p>这是一种经典的工程权衡。</p><ul><li><p><strong>付出的空间 (Space)</strong>：我们需要额外存储 <code>kallsyms_markers</code> 这个数组。其大小为 <code>(符号总数 / 256) * 4</code> 字节（在32位系统上）。假设内核有 60,000 个符号，那么这个表的大小约为 <code>(60000 / 256) * 4 ≈ 235 * 4 = 940</code> 字节。对于一个数MB大小的内核镜像来说，增加不足 1KB 的只读数据来换取性能的巨大提升，是非常划算的。</p></li><li><p><strong>赢得的时间 (Time)</strong>：将一个 O(N) 的查找操作，优化为了一个近似 O(1) 的操作。这对于系统的实时响应性，尤其是在进行调试和故障诊断时，是至关重要的。</p></li></ul><h2 id="write-src-序列化压缩后的内核符号表"><a href="#write-src-序列化压缩后的内核符号表" class="headerlink" title="write_src: 序列化压缩后的内核符号表"></a>write_src: 序列化压缩后的内核符号表</h2><p>本代码片段是 Linux 内核构建工具链的一部分，其核心功能是将经过压缩算法处理后的内核符号表（kallsyms）数据，序列化为汇编语言源文件。它负责生成一系列定义好的数据表，包括压缩后的符号名称流、用于快速查找的标记、解压字典、以及相对编码的符号地址。这些数据表最终会被汇编器和链接器处理，成为内核镜像中 <code>.rodata</code> 只读数据段的一部分。</p><h3 id="实现原理分析-9"><a href="#实现原理分析-9" class="headerlink" title="实现原理分析"></a>实现原理分析</h3><p>该函数将内存中的压缩数据结构，通过一系列精心设计的格式，转换为静态的、可链接的汇编数据。其设计目标是在保证运行时查找效率的同时，最大限度地减小存储占用。</p><ol><li><p><strong>可变长数据编码 (ULEB128)</strong>:</p><ul><li>在输出压缩的符号名称 (<code>kallsyms_names</code>) 时，每个名称的长度不是用固定的4字节整数存储，而是采用了 ULEB128 (Unsigned Little Endian Base 128) 编码。</li><li>对于长度小于等于127 (<code>0x7F</code>) 的符号，长度只用1个字节表示。</li><li>对于更长的符号，第一个字节的最高位被置1，用于表示后续还有字节，而低7位存储长度的低7位。第二个字节存储长度的高位。这种编码方式使得绝大多数短符号名能节省3个字节的长度存储开销。</li></ul></li><li><p><strong>稀疏索引加速 (<code>kallsyms_markers</code>)</strong>:</p><ul><li>线性扫描整个压缩的符号名称流 (<code>kallsyms_names</code>) 来查找第 N 个符号会非常慢。为了加速这个过程，代码每隔256个符号，就记录下当前在名称流中的偏移量，并存入 <code>kallsyms_markers</code> 表。</li><li>在运行时，要查找第 <code>i</code> 个符号的名称，内核可以先通过 <code>markers[i &gt;&gt; 8]</code> (即 <code>markers[i / 256]</code>) 快速跳转到附近的位置，然后再从此位置开始线性扫描最多255个符号，极大地提高了查找效率。这是一种典型的空间换时间优化。</li></ul></li><li><p><strong>解压字典的序列化 (<code>kallsyms_token_table</code>, <code>kallsyms_token_index</code>)</strong>:</p><ul><li><code>kallsyms_token_table</code> 存储了从压缩索引（0-255）到原始字符串（1或2字节）的映射。它被输出为一个由多个 <code>\0</code> 结尾的字符串拼接而成的大字符串。</li><li><code>kallsyms_token_index</code> 是一个辅助表，存储了 <code>kallsyms_token_table</code> 中每个字符串的起始偏移量。运行时，当解压器遇到一个压缩索引 <code>c</code> 时，可以直接通过 <code>kallsyms_token_index[c]</code> 获得对应字符串的地址，实现了 O(1) 复杂度的字典查询。</li></ul></li><li><p><strong>地址的相对编码 (<code>kallsyms_offsets</code>, <code>kallsyms_relative_base</code>)</strong>:</p><ul><li>为了使符号表与内核代码的位置无关（position-independent），所有符号的地址不存储绝对值，而是存储相对于一个基准地址 (<code>relative_base</code>) 的32位偏移量。</li><li>这个基准地址本身，又被存储为相对于内核代码段起始符号 <code>_text</code> 的偏移。运行时，内核的符号查找代码首先获取 <code>_text</code> 的绝对地址，然后加上 <code>kallsyms_relative_base</code> 的值，计算出符号表的绝对基地址，最后才能通过 <code>kallsyms_offsets</code> 中的偏移量解析出任意符号的绝对地址。</li></ul></li></ol><h3 id="代码分析-8"><a href="#代码分析-8" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief write_src - 将所有处理过的符号表数据写入到标准输出，格式为汇编源文件。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">write_src</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i, k, off;</span><br><span class="line"><span class="comment">// 用于存储解压字典中每个字符串的偏移量</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> best_idx[<span class="number">256</span>];</span><br><span class="line"><span class="comment">// 指向标记表的指针，该表用于加速符号名称的查找</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> *markers;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> markers_cnt;</span><br><span class="line"><span class="comment">// 临时缓冲区，用于存储解压后的符号名</span></span><br><span class="line"><span class="type">char</span> buf[KSYM_NAME_LEN];</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 汇编文件头 ---</span></span><br><span class="line"><span class="comment">// 打印预处理指令，根据目标平台的字长（32位或64位）定义指针和对齐伪指令。</span></span><br><span class="line"><span class="comment">// 对于STM32H750 (ARMv7-M)，BITS_PER_LONG 为 32。</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;#include &lt;asm/bitsperlong.h&gt;\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;#if BITS_PER_LONG == 64\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;#define PTR .quad\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;#define ALGN .balign 8\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;#else\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;#define PTR .long\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;#define ALGN .balign 4\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;#endif\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数据放入 .rodata (只读数据) 段</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t.section .rodata, \&quot;a\&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 符号总数 ---</span></span><br><span class="line">output_label(<span class="string">&quot;kallsyms_num_syms&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t.long\t%u\n&quot;</span>, table_cnt);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 压缩的符号名称流 (kallsyms_names) ---</span></span><br><span class="line"><span class="comment">// 计算标记点的数量，每256个符号一个标记点</span></span><br><span class="line">markers_cnt = (table_cnt + <span class="number">255</span>) / <span class="number">256</span>;</span><br><span class="line">markers = xmalloc(<span class="keyword">sizeof</span>(*markers) * markers_cnt);</span><br><span class="line"></span><br><span class="line">output_label(<span class="string">&quot;kallsyms_names&quot;</span>);</span><br><span class="line">off = <span class="number">0</span>; <span class="comment">// 当前在名称流中的偏移量</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; table_cnt; i++) &#123;</span><br><span class="line"><span class="comment">// 每256个符号，记录一次当前偏移量到 markers 数组</span></span><br><span class="line"><span class="keyword">if</span> ((i &amp; <span class="number">0xFF</span>) == <span class="number">0</span>)</span><br><span class="line">markers[i &gt;&gt; <span class="number">8</span>] = off;</span><br><span class="line"><span class="comment">// 记录符号在地址排序表中的原始序号</span></span><br><span class="line">table[i]-&gt;seq = i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查并确保符号长度不为零</span></span><br><span class="line"><span class="keyword">if</span> (table[i]-&gt;len == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;kallsyms failure: &quot;</span></span><br><span class="line"><span class="string">&quot;unexpected zero symbol length\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检查符号长度是否超出 ULEB128 两字节编码的最大范围 (16383)</span></span><br><span class="line"><span class="keyword">if</span> (table[i]-&gt;len &gt; <span class="number">0x3FFF</span>) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;kallsyms failure: &quot;</span></span><br><span class="line"><span class="string">&quot;unexpected huge symbol length\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 ULEB128 编码符号长度</span></span><br><span class="line"><span class="keyword">if</span> (table[i]-&gt;len &lt;= <span class="number">0x7F</span>) &#123;</span><br><span class="line"><span class="comment">// 长度小于等于127，用单字节编码</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t.byte 0x%02x&quot;</span>, table[i]-&gt;len);</span><br><span class="line">off += table[i]-&gt;len + <span class="number">1</span>; <span class="comment">// 偏移增加：长度(1) + 符号本身</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 长度大于127，用双字节编码</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t.byte 0x%02x, 0x%02x&quot;</span>,</span><br><span class="line">(table[i]-&gt;len &amp; <span class="number">0x7F</span>) | <span class="number">0x80</span>, <span class="comment">// 低7位，最高位置1</span></span><br><span class="line">(table[i]-&gt;len &gt;&gt; <span class="number">7</span>) &amp; <span class="number">0x7F</span>);  <span class="comment">// 高7位</span></span><br><span class="line">off += table[i]-&gt;len + <span class="number">2</span>; <span class="comment">// 偏移增加：长度(2) + 符号本身</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 逐字节输出压缩后的符号名</span></span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; table[i]-&gt;len; k++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;, 0x%02x&quot;</span>, table[i]-&gt;sym[k]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了汇编文件的可读性，将符号解压回原名并作为注释打印</span></span><br><span class="line">expand_symbol(table[i]-&gt;sym, table[i]-&gt;len, buf);</span><br><span class="line"><span class="built_in">strcpy</span>((<span class="type">char</span> *)table[i]-&gt;sym, buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t/* %s */\n&quot;</span>, table[i]-&gt;sym);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 名称流标记表 (kallsyms_markers) ---</span></span><br><span class="line">output_label(<span class="string">&quot;kallsyms_markers&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; markers_cnt; i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t.long\t%u\n&quot;</span>, markers[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(markers);</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 解压字典字符串表 (kallsyms_token_table) ---</span></span><br><span class="line">output_label(<span class="string">&quot;kallsyms_token_table&quot;</span>);</span><br><span class="line">off = <span class="number">0</span>; <span class="comment">// 当前在 token_table 中的偏移量</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">best_idx[i] = off; <span class="comment">// 记录第i个 token 字符串的起始偏移</span></span><br><span class="line"><span class="comment">// 将 token (可能为1或2字节) 解压为原始字符串</span></span><br><span class="line">expand_symbol(best_table[i], best_table_len[i], buf);</span><br><span class="line"><span class="comment">// 以.asciz伪指令输出，自动添加&#x27;\0&#x27;结尾</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t.asciz\t\&quot;%s\&quot;\n&quot;</span>, buf);</span><br><span class="line">off += <span class="built_in">strlen</span>(buf) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 解压字典索引表 (kallsyms_token_index) ---</span></span><br><span class="line">output_label(<span class="string">&quot;kallsyms_token_index&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t.short\t%d\n&quot;</span>, best_idx[i]); <span class="comment">// 输出每个 token 字符串的偏移</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 符号地址偏移量表 (kallsyms_offsets) ---</span></span><br><span class="line">output_label(<span class="string">&quot;kallsyms_offsets&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; table_cnt; i++) &#123;</span><br><span class="line"><span class="comment">// 计算符号地址相对于基地址的偏移</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> offset = table[i]-&gt;addr - relative_base;</span><br><span class="line"><span class="comment">// 检查偏移量是否在无符号32位整数范围内</span></span><br><span class="line"><span class="keyword">if</span> (offset &lt; <span class="number">0</span> || offset &gt; UINT_MAX) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;kallsyms failure: &quot;</span></span><br><span class="line"><span class="string">&quot;relative symbol value %#llx out of range\n&quot;</span>,</span><br><span class="line">table[i]-&gt;addr);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t.long\t%#x\t/* %s */\n&quot;</span>, (<span class="type">int</span>)offset, table[i]-&gt;sym);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 相对基地址本身 (kallsyms_relative_base) ---</span></span><br><span class="line">output_label(<span class="string">&quot;kallsyms_relative_base&quot;</span>);</span><br><span class="line"><span class="comment">// 将基地址表示为相对于内核代码段起始 (_text) 的偏移，以实现位置无关</span></span><br><span class="line"><span class="keyword">if</span> (_text &lt;= relative_base)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\tPTR\t_text + %#llx\n&quot;</span>, relative_base - _text);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\tPTR\t_text - %#llx\n&quot;</span>, _text - relative_base);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 按名称排序的序号表 (kallsyms_seqs_of_names) ---</span></span><br><span class="line"><span class="comment">// 此表用于按名称查找符号</span></span><br><span class="line">sort_symbols_by_name();</span><br><span class="line">output_label(<span class="string">&quot;kallsyms_seqs_of_names&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; table_cnt; i++)</span><br><span class="line"><span class="comment">// 输出该符号在地址排序表中的原始序号（seq），使用3个字节存储</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t.byte 0x%02x, 0x%02x, 0x%02x\t/* %s */\n&quot;</span>,</span><br><span class="line">(<span class="type">unsigned</span> <span class="type">char</span>)(table[i]-&gt;seq &gt;&gt; <span class="number">16</span>),</span><br><span class="line">(<span class="type">unsigned</span> <span class="type">char</span>)(table[i]-&gt;seq &gt;&gt; <span class="number">8</span>),</span><br><span class="line">(<span class="type">unsigned</span> <span class="type">char</span>)(table[i]-&gt;seq &gt;&gt; <span class="number">0</span>),</span><br><span class="line">       table[i]-&gt;sym);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;

&lt;p&gt;&lt;img src=&quot;https://i-blog.csdnimg.cn/direct/de55958926e34a689da90ff76a86899a.png&quot; alt=&quot;在这里</summary>
      
    
    
    
    <category term="linux" scheme="https://wdfk-prog.space/categories/linux/"/>
    
    <category term="scripts" scheme="https://wdfk-prog.space/categories/linux/scripts/"/>
    
    
    <category term="linux" scheme="https://wdfk-prog.space/tags/linux/"/>
    
    <category term="scripts" scheme="https://wdfk-prog.space/tags/scripts/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核kallsyms符号压缩与解压机制</title>
    <link href="https://wdfk-prog.space/posts/1f4147b7/"/>
    <id>https://wdfk-prog.space/posts/1f4147b7/</id>
    <published>2025-10-06T06:43:36.000Z</published>
    <updated>2025-10-06T07:26:11.002Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>@[toc]</p><h3 id="Linux内核kallsyms符号压缩与解压机制"><a href="#Linux内核kallsyms符号压缩与解压机制" class="headerlink" title="Linux内核kallsyms符号压缩与解压机制"></a><strong>Linux内核kallsyms符号压缩与解压机制</strong></h3><p><img src="https://i-blog.csdnimg.cn/direct/baee84b1da374690b616e7ea0009a1bb.png" alt="在这里插入图片描述"></p><h4 id="1-引言：为何需要kallsyms？"><a href="#1-引言：为何需要kallsyms？" class="headerlink" title="1. 引言：为何需要kallsyms？"></a><strong>1. 引言：为何需要kallsyms？</strong></h4><p>在Linux内核的运行过程中，当发生错误（Oops）、进行性能剖析（Profiling）或使用调试器（Debugger）时，系统需要将内存中的函数地址转换为人类可读的符号名称。例如，将地址<code>0xffffffff810a43c0</code>转换为<code>printk</code>。这个地址到符号的映射表就是<code>kallsyms</code>（Kernel All Symbols）。</p><p>然而，内核包含数以万计的符号，如果将所有符号名称作为原始字符串直接存储在内核镜像中，会占用数兆字节的宝贵内存。为了解决这个问题，内核在编译时采用了一种高效的**“查表压缩”**方案，将符号名称字符串压缩成紧凑的字节序列。本文将深入剖析这一压缩数据的结构以及内核在运行时如何对其进行解压，还原出原始的符号名称。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    subgraph &quot;内核编译时&quot;</span><br><span class="line">        A[&quot;所有符号名称&quot;] --&gt; B(&quot;scripts/kallsyms&quot;);</span><br><span class="line">        B --&gt; C&#123;&quot;符号压缩&quot;&#125;;</span><br><span class="line">        C --&gt; D[&quot;生成压缩数据表&quot;];</span><br><span class="line">    end</span><br><span class="line">    subgraph &quot;内核运行时&quot;</span><br><span class="line">        E[&quot;内存地址, e.g., 0xffffffff810a43c0&quot;] --&gt; F(&quot;kallsyms子系统&quot;);</span><br><span class="line">        F --&gt; G&#123;&quot;符号解压&quot;&#125;;</span><br><span class="line">        G --&gt; H[&quot;符号名称, e.g., &#x27;printk&#x27;&quot;];</span><br><span class="line">    end</span><br><span class="line">    D --&gt; F;</span><br></pre></td></tr></table></figure><h4 id="2-压缩数据的“蓝图”：核心数据结构"><a href="#2-压缩数据的“蓝图”：核心数据结构" class="headerlink" title="2. 压缩数据的“蓝图”：核心数据结构"></a><strong>2. 压缩数据的“蓝图”：核心数据结构</strong></h4><p>要理解解压过程，首先必须了解压缩数据的存储格式。<code>kallsyms</code>的核心由多个紧密相关的数据表构成，它们在内核编译链接后被静态地嵌入到内核镜像中。</p><ul><li><code>kallsyms_offsets</code> 和 <code>kallsyms_relative_base</code>: 这两者共同构成了符号地址表。<code>kallsyms_offsets</code>是一个32位无符号整数数组，存储了每个符号相对于基地址<code>kallsyms_relative_base</code>的偏移。通过<code>kallsyms_sym_address(index)</code>函数（其实现为 <code>kallsyms_relative_base + kallsyms_offsets[index]</code>），我们可以得到一个<strong>按地址排序</strong>的符号地址列表，这是实现快速地址查找（二分查找）的基础。</li><li><code>kallsyms_names</code>: 核心的<strong>压缩符号数据</strong>。这是一个巨大的字节数组，所有符号的名称信息经过压缩后都存储在这里。</li><li><code>kallsyms_token_table</code>: <strong>“字典表”</strong>。这是一个包含数千个常见符号片段（如<code>&quot;irq&quot;</code>, <code>&quot;lock&quot;</code>, <code>&quot;__&quot;</code>, <code>&quot;init&quot;</code>等）的巨大字符串，每个片段以<code>\0</code>结尾。</li><li><code>kallsyms_token_index</code>: <strong>“字典索引表”</strong>。这是一个整数数组，<code>kallsyms_token_index[i]</code>存储了第<code>i</code>个片段在<code>kallsyms_token_table</code>中的起始偏移量。</li><li><code>kallsyms_markers</code>: <strong>“标记表”</strong>。用于加速在<code>kallsyms_names</code>中的查找。<code>kallsyms_markers[i]</code>存储了第 <code>i * 256</code> 个符号在<code>kallsyms_names</code>中的起始偏移量。</li></ul><p>它们之间的关系如下图所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    subgraph &quot;压缩符号数据 (kallsyms_names)&quot;</span><br><span class="line">        A(&quot;符号A: [len, T1, T2, T3, ...]&quot;);</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    subgraph &quot;字典索引 (kallsyms_token_index)&quot;</span><br><span class="line">        B[&quot;...&quot;];</span><br><span class="line">        C[&quot;index[T1] = offset1&quot;];</span><br><span class="line">        D[&quot;index[T2] = offset2&quot;];</span><br><span class="line">        E[&quot;...&quot;];</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    subgraph &quot;字典表 (kallsyms_token_table)&quot;</span><br><span class="line">        F[&quot;... \0 token_x \0 ...&quot;];</span><br><span class="line">        G[&quot;... \0 token_1 \0 ...&quot;];</span><br><span class="line">        H[&quot;... \0 token_2 \0 ...&quot;];</span><br><span class="line">        I[&quot;...&quot;];</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    A -- &quot;使用索引T1&quot; --&gt; C;</span><br><span class="line">    A -- &quot;使用索引T2&quot; --&gt; D;</span><br><span class="line">    C -- &quot;得到偏移offset1&quot; --&gt; G;</span><br><span class="line">    D -- &quot;得到偏移offset2&quot; --&gt; H;</span><br><span class="line"></span><br><span class="line">    style A fill:#f9f,stroke:#333,stroke-width:2px</span><br><span class="line">    style C fill:#ccf,stroke:#333,stroke-width:2px</span><br><span class="line">    style G fill:#cfc,stroke:#333,stroke-width:2px</span><br></pre></td></tr></table></figure><h4 id="3-解压核心：kallsyms-expand-symbol"><a href="#3-解压核心：kallsyms-expand-symbol" class="headerlink" title="3. 解压核心：kallsyms_expand_symbol"></a><strong>3. 解压核心：<code>kallsyms_expand_symbol</code></strong></h4><p>此函数是整个机制的核心，负责将<code>kallsyms_names</code>中的一段压缩数据还原成一个完整的符号字符串。</p><h5 id="完整代码与Doxygen注释"><a href="#完整代码与Doxygen注释" class="headerlink" title="完整代码与Doxygen注释"></a><strong>完整代码与Doxygen注释</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief kallsyms_expand_symbol - 将一段压缩的符号数据解压成字符串。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 此函数根据“查表压缩”算法，将存储在kallsyms_names中的符号数据展开。</span></span><br><span class="line"><span class="comment"> * 压缩的数据格式为：[长度][Token 1][Token 2]...</span></span><br><span class="line"><span class="comment"> * 长度本身是变长的，如果最高位为1，则需要两个字节表示。</span></span><br><span class="line"><span class="comment"> * 每个Token是一个索引，用于在kallsyms_token_table中查找对应的字符串片段。</span></span><br><span class="line"><span class="comment"> * 所有片段（除了第一个片段的首字符，即符号类型）拼接起来构成最终的符号名。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param off       待解压符号在全局kallsyms_names数组中的起始偏移量。</span></span><br><span class="line"><span class="comment"> * @param result    用于存放解压后字符串的输出缓冲区。</span></span><br><span class="line"><span class="comment"> * @param maxlen    输出缓冲区的最大长度，防止溢出。</span></span><br><span class="line"><span class="comment"> * @return          下一个符号在kallsyms_names中的起始偏移量。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">kallsyms_expand_symbol</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> off,</span></span><br><span class="line"><span class="params">   <span class="type">char</span> *result, <span class="type">size_t</span> maxlen)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> len, skipped_first = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *tptr;</span><br><span class="line"><span class="type">const</span> u8 *data;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从第一个字节获取压缩后的长度（即Token的数量） */</span></span><br><span class="line">data = &amp;kallsyms_names[off];</span><br><span class="line">len = *data;</span><br><span class="line">data++;</span><br><span class="line">off++;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果长度的最高位(MSB)为1，说明这是一个“大符号”，</span></span><br><span class="line"><span class="comment">     * 长度由两个字节编码而成（低7位 + 第二个字节左移7位）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">if</span> ((len &amp; <span class="number">0x80</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">len = (len &amp; <span class="number">0x7F</span>) | (*data &lt;&lt; <span class="number">7</span>);</span><br><span class="line">data++;</span><br><span class="line">off++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 更新偏移量，使其指向下一个符号的起始位置，作为返回值。*/</span></span><br><span class="line">off += len;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 循环len次，每次处理一个Token。*/</span></span><br><span class="line"><span class="keyword">while</span> (len) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * *data 是一个Token索引。</span></span><br><span class="line"><span class="comment"> * 1. kallsyms_token_index[*data] 找到该Token在字典表中的偏移。</span></span><br><span class="line"><span class="comment"> * 2. &amp;kallsyms_token_table[...] 获取该Token字符串的指针。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">tptr = &amp;kallsyms_token_table[kallsyms_token_index[*data]];</span><br><span class="line">data++;</span><br><span class="line">len--;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将获取到的Token字符串追加到result缓冲区。*/</span></span><br><span class="line"><span class="keyword">while</span> (*tptr) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 特殊处理：第一个Token的第一个字符是符号类型（如&#x27;T&#x27;, &#x27;t&#x27;），</span></span><br><span class="line"><span class="comment"> * 不属于符号名称，必须跳过。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (skipped_first) &#123;</span><br><span class="line"><span class="keyword">if</span> (maxlen &lt;= <span class="number">1</span>)</span><br><span class="line"><span class="keyword">goto</span> tail;</span><br><span class="line">*result = *tptr;</span><br><span class="line">result++;</span><br><span class="line">maxlen--;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">skipped_first = <span class="number">1</span>;</span><br><span class="line">tptr++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tail:</span><br><span class="line"><span class="keyword">if</span> (maxlen)</span><br><span class="line">*result = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回下一个符号的起始偏移量。*/</span></span><br><span class="line"><span class="keyword">return</span> off;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="执行流程图"><a href="#执行流程图" class="headerlink" title="执行流程图"></a><strong>执行流程图</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    S[&quot;开始: kallsyms_expand_symbol(off, ...)&quot;] --&gt; A&#123;&quot;读取第一个字节: 压缩长度(len)&quot;&#125;;</span><br><span class="line">    A --&gt; B&#123;&quot;len的最高位(MSB)是否为1?&quot;&#125;;</span><br><span class="line">    B -- &quot;是 (大符号)&quot; --&gt; C[&quot;读取第二个字节, 计算真实长度: len = (len &amp; 0x7F) | (byte2 &lt;&lt; 7)&quot;];</span><br><span class="line">    B -- &quot;否 (普通符号)&quot; --&gt; D[&quot;len即为压缩长度&quot;];</span><br><span class="line">    C --&gt; E[&quot;进入解压循环&quot;];</span><br><span class="line">    D --&gt; E;</span><br><span class="line">    E --&gt; F&#123;&quot;循环 len 次&quot;&#125;;</span><br><span class="line">    F -- &quot;循环中&quot; --&gt; G[&quot;从数据流中读取一个字节(token_index)&quot;];</span><br><span class="line">    G --&gt; H[&quot;在 kallsyms_token_index 中查找: offset = kallsyms_token_index[token_index]&quot;];</span><br><span class="line">    H --&gt; I[&quot;在 kallsyms_token_table 中定位: token_ptr = &amp;kallsyms_token_table[offset]&quot;];</span><br><span class="line">    I --&gt; J&#123;&quot;是否为第一个Token的第一个字符?&quot;&#125;;</span><br><span class="line">    J -- &quot;是&quot; --&gt; K[&quot;跳过 (该字符为符号类型)&quot;];</span><br><span class="line">    J -- &quot;否&quot; --&gt; L[&quot;将 token_ptr 指向的字符串追加到 result 缓冲区&quot;];</span><br><span class="line">    K --&gt; M&#123;&quot;循环结束?&quot;&#125;;</span><br><span class="line">    L --&gt; M;</span><br><span class="line">    M -- &quot;否&quot; --&gt; F;</span><br><span class="line">    M -- &quot;是&quot; --&gt; N[&quot;在 result 缓冲区末尾添加 &#x27;\0&#x27;&quot;];</span><br><span class="line">    N --&gt; O[&quot;返回下一个符号的偏移量&quot;];</span><br><span class="line">    O --&gt; E_END[&quot;结束&quot;];</span><br></pre></td></tr></table></figure><h4 id="4-定位压缩数据：get-symbol-offset"><a href="#4-定位压缩数据：get-symbol-offset" class="headerlink" title="4. 定位压缩数据：get_symbol_offset"></a><strong>4. 定位压缩数据：<code>get_symbol_offset</code></strong></h4><p>当内核需要查找第<code>pos</code>个符号时，此函数用于在<code>kallsyms_names</code>中快速定位其压缩数据的起始偏移。</p><h5 id="完整代码与Doxygen注释-1"><a href="#完整代码与Doxygen注释-1" class="headerlink" title="完整代码与Doxygen注释"></a><strong>完整代码与Doxygen注释</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief get_symbol_offset - 根据符号的全局索引，获取其在压缩数据流中的偏移量。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 为了避免从头线性扫描整个kallsyms_names表，该函数使用kallsyms_markers</span></span><br><span class="line"><span class="comment"> * 进行加速。kallsyms_markers是一个标记数组，每隔256个符号记录一个偏移量。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 查找过程分两步：</span></span><br><span class="line"><span class="comment"> * 1. 大步跳转：利用 markers 表直接跳转到离目标位置不远的地方。</span></span><br><span class="line"><span class="comment"> * 2. 短程扫描：从标记位置开始，线性扫描最多255个符号，找到精确位置。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param pos 要查找的符号的全局索引 (0 to kallsyms_num_syms-1)。</span></span><br><span class="line"><span class="comment"> * @return 该符号在kallsyms_names中的起始偏移量。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">get_symbol_offset</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> pos)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> u8 *name;</span><br><span class="line"><span class="type">int</span> i, len;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用最近的标记。标记每256个位置有一个，这已经足够近了。</span></span><br><span class="line"><span class="comment"> * pos &gt;&gt; 8 相当于 pos / 256，用于在markers数组中找到正确的起点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">name = &amp;kallsyms_names[kallsyms_markers[pos &gt;&gt; <span class="number">8</span>]];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 从标记位置开始，顺序扫描剩余的符号，直到目标位置。</span></span><br><span class="line"><span class="comment"> * pos &amp; 0xFF 相当于 pos % 256，即需要扫描的符号数量。</span></span><br><span class="line"><span class="comment"> * 每个符号的格式是 [&lt;len&gt;][&lt;len&gt; bytes of data]，我们只需读取长度</span></span><br><span class="line"><span class="comment"> * 并跳过相应字节即可，无需解压。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (pos &amp; <span class="number">0xFF</span>); i++) &#123;</span><br><span class="line">len = *name;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如果是“大符号”（MSB为1），长度由两个字节构成，</span></span><br><span class="line"><span class="comment"> * 所以总跳跃长度要额外加1。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> ((len &amp; <span class="number">0x80</span>) != <span class="number">0</span>)</span><br><span class="line">len = ((len &amp; <span class="number">0x7F</span>) | (name[<span class="number">1</span>] &lt;&lt; <span class="number">7</span>)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">name = name + len + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> name - kallsyms_names;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="执行流程图-1"><a href="#执行流程图-1" class="headerlink" title="执行流程图"></a><strong>执行流程图</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    subgraph &quot;kallsyms_names (巨大的字节数组)&quot;</span><br><span class="line">        direction LR</span><br><span class="line">        S(Start) -- &quot;符号0..255&quot; --&gt; M1(&quot;Marker[0]指向的位置&quot;);</span><br><span class="line">        M1 -- &quot;符号256..511&quot; --&gt; M2(&quot;Marker[1]指向的位置&quot;);</span><br><span class="line">        M2 -- &quot;...&quot; --&gt; END(...);</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    subgraph &quot;查找第600个符号 (pos=600)&quot;</span><br><span class="line">        A[&quot;开始: get_symbol_offset(600)&quot;] --&gt; B&#123;&quot;计算marker索引: 600 / 256 = 2&quot;&#125;;</span><br><span class="line">        B --&gt; C[&quot;跳转到 kallsyms_names[kallsyms_markers[2]]&quot;];</span><br><span class="line">        C --&gt; D&#123;&quot;计算剩余扫描次数: 600 % 256 = 88&quot;&#125;;</span><br><span class="line">        D --&gt; E[&quot;从Marker[2]位置开始, 向后线性扫描88个符号&quot;];</span><br><span class="line">        F[&quot;扫描时仅读取长度并跳跃, 不解压&quot;];</span><br><span class="line">        E --&gt; F;</span><br><span class="line">        F --&gt; G[&quot;最终指针位置即为第600个符号的偏移&quot;];</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    style M1 fill:#add,stroke:#333,stroke-width:2px</span><br><span class="line">    style M2 fill:#add,stroke:#333,stroke-width:2px</span><br></pre></td></tr></table></figure><h4 id="5-地址到符号的桥梁：get-symbol-pos"><a href="#5-地址到符号的桥梁：get-symbol-pos" class="headerlink" title="5. 地址到符号的桥梁：get_symbol_pos"></a><strong>5. 地址到符号的桥梁：<code>get_symbol_pos</code></strong></h4><p>此函数负责根据一个给定的内存地址，反向查找出它属于哪个符号。</p><h5 id="完整代码与Doxygen注释-2"><a href="#完整代码与Doxygen注释-2" class="headerlink" title="完整代码与Doxygen注释"></a><strong>完整代码与Doxygen注释</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief get_symbol_pos - 根据内存地址查找对应的符号索引。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 此函数在一个按地址排序的符号列表中，查找包含给定地址`addr`的符号。</span></span><br><span class="line"><span class="comment"> * 它返回该符号的全局索引`pos`。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 核心操作是二分查找，作用于通过kallsyms_sym_address()动态计算出的</span></span><br><span class="line"><span class="comment"> * 地址列表上。这非常高效。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param addr          要查找的内存地址。</span></span><br><span class="line"><span class="comment"> * @param symbolsize    (输出) 用于存储找到的符号的大小。</span></span><br><span class="line"><span class="comment"> * @param offset        (输出) 用于存储`addr`相对于符号起始地址的偏移量。</span></span><br><span class="line"><span class="comment"> * @return              找到的符号的全局索引`pos`。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">get_symbol_pos</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> addr,</span></span><br><span class="line"><span class="params">    <span class="type">unsigned</span> <span class="type">long</span> *symbolsize,</span></span><br><span class="line"><span class="params">    <span class="type">unsigned</span> <span class="type">long</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> symbol_start = <span class="number">0</span>, symbol_end = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> i, low, high, mid;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在kallsyms_offsets数组上进行二分查找。*/</span></span><br><span class="line">low = <span class="number">0</span>;</span><br><span class="line">high = kallsyms_num_syms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (high - low &gt; <span class="number">1</span>) &#123;</span><br><span class="line">mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (kallsyms_sym_address(mid) &lt;= addr)</span><br><span class="line">low = mid;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">high = mid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * low现在是最后一个地址 &lt;= addr 的符号索引。</span></span><br><span class="line"><span class="comment"> * 但可能存在多个符号地址相同（别名），我们需要找到第一个。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">while</span> (low &amp;&amp; kallsyms_sym_address(low<span class="number">-1</span>) == kallsyms_sym_address(low))</span><br><span class="line">--low;</span><br><span class="line"></span><br><span class="line">symbol_start = kallsyms_sym_address(low);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查找下一个不同地址的符号，以确定当前符号的大小。*/</span></span><br><span class="line"><span class="keyword">for</span> (i = low + <span class="number">1</span>; i &lt; kallsyms_num_syms; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (kallsyms_sym_address(i) &gt; symbol_start) &#123;</span><br><span class="line">symbol_end = kallsyms_sym_address(i);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果没找到下一个符号，使用内核代码段的末尾地址。*/</span></span><br><span class="line"><span class="keyword">if</span> (!symbol_end) &#123;</span><br><span class="line"><span class="keyword">if</span> (is_kernel_inittext(addr))</span><br><span class="line">symbol_end = (<span class="type">unsigned</span> <span class="type">long</span>)_einittext;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (IS_ENABLED(CONFIG_KALLSYMS_ALL))</span><br><span class="line">symbol_end = (<span class="type">unsigned</span> <span class="type">long</span>)_end;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">symbol_end = (<span class="type">unsigned</span> <span class="type">long</span>)_etext;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (symbolsize)</span><br><span class="line">*symbolsize = symbol_end - symbol_start;</span><br><span class="line"><span class="keyword">if</span> (offset)</span><br><span class="line">*offset = addr - symbol_start;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-全流程回顾"><a href="#6-全流程回顾" class="headerlink" title="6. 全流程回顾"></a><strong>6. 全流程回顾</strong></h4><p>当内核需要为一个地址（<code>addr</code>）查找符号名时，整个过程被完美地串联起来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[&quot;输入: 内存地址 addr&quot;] --&gt; B(&quot;get_symbol_pos&quot;);</span><br><span class="line">    B -- &quot;在符号地址列表上进行二分查找&quot; --&gt; C[&quot;输出: 符号索引 pos&quot;];</span><br><span class="line">    C --&gt; D(&quot;get_symbol_offset&quot;);</span><br><span class="line">    D -- &quot;使用 markers 跳转 + 短程扫描&quot; --&gt; E[&quot;输出: 压缩数据偏移 off&quot;];</span><br><span class="line">    E --&gt; F(&quot;kallsyms_expand_symbol&quot;);</span><br><span class="line">    F -- &quot;查字典表并拼接&quot; --&gt; G[&quot;输出: 原始符号字符串&quot;];</span><br></pre></td></tr></table></figure><ol start="7"><li>结论<br>Linux内核的kallsyms机制是一个精巧的空间换时间设计典范。它通过基于字典的查表压缩算法，极大地减小了符号表在内核镜像中的体积。同时，借助markers等辅助索引结构，它又保证了在需要反向查找符号时，能够以可接受的性能开销（二分查找 + 大步跳转 + 短程扫描）高效地完成解压任务，为内核的调试和可观测性提供了坚实的基础。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;

&lt;p&gt;@[toc]&lt;/p&gt;
&lt;h3 id=&quot;Linux内核kallsyms符号压缩与解压机制&quot;&gt;&lt;a href=&quot;#Linux内核kallsyms符号压缩与解压机制&quot; class=&quot;h</summary>
      
    
    
    
    <category term="linux" scheme="https://wdfk-prog.space/categories/linux/"/>
    
    <category term="other" scheme="https://wdfk-prog.space/categories/linux/other/"/>
    
    
    <category term="linux" scheme="https://wdfk-prog.space/tags/linux/"/>
    
    <category term="other" scheme="https://wdfk-prog.space/tags/other/"/>
    
  </entry>
  
  <entry>
    <title>commoncap</title>
    <link href="https://wdfk-prog.space/posts/72ce1476/"/>
    <id>https://wdfk-prog.space/posts/72ce1476/</id>
    <published>2025-10-06T05:45:28.000Z</published>
    <updated>2025-10-07T01:12:48.904Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>[TOC]</p><p><img src="https://i-blog.csdnimg.cn/direct/1fbf788ecf2745018a9f7a1a52a1191e.png" alt="在这里插入图片描述"></p><h1 id="include-linux-security-h"><a href="#include-linux-security-h" class="headerlink" title="include&#x2F;linux&#x2F;security.h"></a>include&#x2F;linux&#x2F;security.h</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief security_capable - 检查凭证是否拥有特定能力（LSM钩子包装）。</span></span><br><span class="line"><span class="comment"> * @param cred 待检查的进程凭证。</span></span><br><span class="line"><span class="comment"> * @param ns 目标资源所属的用户命名空间。</span></span><br><span class="line"><span class="comment"> * @param cap 要检查的能力编号。</span></span><br><span class="line"><span class="comment"> * @param opts 附加选项。</span></span><br><span class="line"><span class="comment"> * @return 0 表示拥有能力，-EPERM 表示没有。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">security_capable</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> cred *cred,</span></span><br><span class="line"><span class="params">   <span class="keyword">struct</span> user_namespace *ns,</span></span><br><span class="line"><span class="params">   <span class="type">int</span> cap,</span></span><br><span class="line"><span class="params">   <span class="type">unsigned</span> <span class="type">int</span> opts)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 这是一个内联包装函数，直接调用底层的能力检查核心函数。</span></span><br><span class="line"><span class="keyword">return</span> cap_capable(cred, ns, cap, opts);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="security-commoncap-c-Linux权能-Linux-Capabilities-打破root特权的细粒度权限控制"><a href="#security-commoncap-c-Linux权能-Linux-Capabilities-打破root特权的细粒度权限控制" class="headerlink" title="security&#x2F;commoncap.c Linux权能(Linux Capabilities) 打破root特权的细粒度权限控制"></a>security&#x2F;commoncap.c Linux权能(Linux Capabilities) 打破root特权的细粒度权限控制</h1><h3 id="历史与背景"><a href="#历史与背景" class="headerlink" title="历史与背景"></a>历史与背景</h3><h4 id="这项技术是为了解决什么特定问题而诞生的？"><a href="#这项技术是为了解决什么特定问题而诞生的？" class="headerlink" title="这项技术是为了解决什么特定问题而诞生的？"></a>这项技术是为了解决什么特定问题而诞生的？</h4><p>Linux权能（Capabilities）机制的诞生是为了解决传统UNIX系统中一个根本性的安全设计缺陷：<strong>“全有或全无”的root特权模型</strong>。 在此模型下，进程分为两类：特权进程（有效UID为0，即root）和非特权进程。 特权进程可以绕过内核的所有权限检查，而非特权进程则受到严格的凭证（UID、GID等）限制。 这种二元模型带来了严重的安全风险：一个程序哪怕只需要一项特权操作（例如，Web服务器需要绑定到小于1024的端口），也必须以完整的root权限运行。 一旦该程序存在漏洞，攻击者就能利用它获得整个系统的控制权。</p><p>Capabilities技术通过将历史上与超级用户关联的庞大特权分解为一组组独立的、细粒度的权限单元，从根本上解决了这个问题。 这种机制允许系统遵循<strong>最小权限原则</strong>，即只授予一个进程执行其任务所必需的最小权限集，从而显著减小攻击面。</p><h4 id="它的发展经历了哪些重要的里程碑或版本迭代？"><a href="#它的发展经历了哪些重要的里程碑或版本迭代？" class="headerlink" title="它的发展经历了哪些重要的里程碑或版本迭代？"></a>它的发展经历了哪些重要的里程碑或版本迭代？</h4><p>Linux Capabilities的发展历程反映了其从一个基础概念到成熟安全框架的演进：</p><ul><li><strong>早期引入</strong>：Capabilities的概念早在Linux 2.2内核（约1999年）中就被引入，最初只作用于进程。</li><li><strong>文件权能</strong>：一个重要的里程碑是在2008年（大约在内核2.6.24之后），引入了对<strong>文件权能</strong>的支持。 这项技术允许将权能附加到可执行文件上，当该文件被执行时，进程可以获得这些特定的权能，这成为替代高风险的<code>setuid-root</code>二进制程序的现代化方案。 文件权能通过扩展属性（extended attribute）<code>security.capability</code>实现。</li><li><strong>权能集（Capability Sets）的演进</strong>：随着需求的明确，权能被划分为多个集合进行管理，包括<code>Effective</code>（当前生效的）、<code>Permitted</code>（允许拥有的）、<code>Inheritable</code>（可被子进程继承的）等。</li><li><strong>权能边界集（Bounding Set）</strong>：引入了边界集（Bounding Set）的概念，作为一个进程及其子进程所能拥有的权能的上限，提供了一个额外的安全约束。</li><li><strong>环境权能（Ambient Capabilities）</strong>：在Linux 4.3中引入了环境权能集，解决了在<code>execve()</code>之后，非<code>setuid</code>程序如何安全地继承和保持权能的问题，这对于容器和脚本化环境尤为重要。</li></ul><h4 id="目前该技术的社区活跃度和主流应用情况如何？"><a href="#目前该技术的社区活跃度和主流应用情况如何？" class="headerlink" title="目前该技术的社区活跃度和主流应用情况如何？"></a>目前该技术的社区活跃度和主流应用情况如何？</h4><p>Capabilities是一项非常成熟且被广泛应用的核心内核安全机制。它已成为现代Linux系统安全体系的基石：</p><ul><li><strong>容器化技术</strong>：Docker、Kubernetes等容器平台严重依赖Capabilities机制来加固容器安全。默认情况下，容器仅被授予一个有限的权能子集，并丢弃了许多高风险权能。</li><li><strong>系统服务</strong>：现代系统服务（如systemd管理的服务）越来越多地使用Capabilities来限制自身权限，而不是以完整的root身份运行。</li><li><strong>网络工具</strong>：像<code>ping</code>这样的网络工具，过去依赖<code>setuid-root</code>来创建原始套接字（raw socket），现在则通过赋予<code>CAP_NET_RAW</code>文件权能来实现相同功能，同时安全性更高。</li></ul><h3 id="核心原理与设计"><a href="#核心原理与设计" class="headerlink" title="核心原理与设计"></a>核心原理与设计</h3><h4 id="它的核心工作原理是什么？"><a href="#它的核心工作原理是什么？" class="headerlink" title="它的核心工作原理是什么？"></a>它的核心工作原理是什么？</h4><p><code>security/commoncap.c</code> 提供了Linux权能检查的核心逻辑。它作为Linux安全模块（LSM）框架的一部分，通过在内核的关键代码路径上注册钩子（hooks）来工作。</p><ol><li><strong>权能检查点</strong>：在内核代码中，任何需要特权的操作（如<code>chown()</code>, <code>socket()</code>, <code>settimeofday()</code>）在执行前，都会调用一个通用的权限检查函数，如<code>capable()</code>。</li><li><strong>LSM钩子触发</strong>：<code>capable()</code>函数会触发LSM框架中的<code>capable</code>钩子。</li><li><strong><code>cap_capable()</code>的执行</strong>：<code>security/commoncap.c</code>中实现的<code>cap_capable()</code>函数被注册到了这个钩子上。因此，每次权限检查都会最终调用到<code>cap_capable()</code>。</li><li><strong>权能集验证</strong>：<code>cap_capable()</code>函数的核心逻辑是检查当前进程的**有效权能集（Effective Capability Set）**中是否包含了执行该操作所必需的特定权能位。 例如，要绑定到80端口，进程的有效权能集中必须包含<code>CAP_NET_BIND_SERVICE</code>。</li><li><strong>裁决</strong>：如果检查通过（即进程拥有所需权能），函数返回0，内核继续执行该操作。如果检查失败，函数返回一个错误码（如<code>-EPERM</code>），内核则会拒绝该操作。</li></ol><p><code>commoncap.c</code>不仅实现了这个核心检查逻辑，还包含了管理进程权能集（通过<code>capset()</code>系统调用）和处理文件权能在<code>execve()</code>期间如何传递给新进程的复杂计算逻辑。</p><h4 id="它的主要优势体现在哪些方面？"><a href="#它的主要优势体现在哪些方面？" class="headerlink" title="它的主要优势体现在哪些方面？"></a>它的主要优势体现在哪些方面？</h4><ul><li><strong>细粒度权限</strong>：将root的权力分解为近40个独立的权能，实现了精确的权限控制。</li><li><strong>遵循最小权限原则</strong>：使得程序可以只被授予其功能所必需的最小权限，极大地降低了潜在漏洞的危害。</li><li><strong>替代<code>setuid</code></strong>：提供了一种比<code>setuid</code>二进制程序更安全的替代方案，避免了因<code>setuid</code>程序漏洞导致整个系统被攻陷的风险。</li><li><strong>提升容器安全</strong>：是实现容器隔离和安全加固的关键技术之一，有效防止容器逃逸。</li></ul><h4 id="它存在哪些已知的劣势、局限性或在特定场景下的不适用性？"><a href="#它存在哪些已知的劣势、局限性或在特定场景下的不适用性？" class="headerlink" title="它存在哪些已知的劣势、局限性或在特定场景下的不适用性？"></a>它存在哪些已知的劣势、局限性或在特定场景下的不适用性？</h4><ul><li><strong>复杂性</strong>：管理和理解近40个不同的权能以及它们之间的交互，比传统的UID&#x2F;GID模型要复杂得多。</li><li><strong><code>CAP_SYS_ADMIN</code>的过载</strong>：历史上，许多新的特权操作都被归入了<code>CAP_SYS_ADMIN</code>权能，使其成为一个“包罗万象”的超级权能，违背了细粒度分离的初衷。尽管后续内核版本在努力拆分它，但这个问题依然存在。</li><li><strong>并非所有操作都被转换</strong>：内核中仍有一些遗留的特权检查直接判断<code>UID == 0</code>，而没有被转换为特定的权能检查，这意味着在某些情况下，仅有权能而没有root身份仍然无法完成操作。</li><li><strong>管理工具的依赖</strong>：需要用户空间工具（如<code>setcap</code>, <code>getcap</code>, <code>capsh</code>）来管理和查看权能，需要一定的学习成本。</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><h4 id="在哪些具体的业务或技术场景下，它是首选解决方案？请举例说明。"><a href="#在哪些具体的业务或技术场景下，它是首选解决方案？请举例说明。" class="headerlink" title="在哪些具体的业务或技术场景下，它是首选解决方案？请举例说明。"></a>在哪些具体的业务或技术场景下，它是首选解决方案？请举例说明。</h4><ul><li><strong>网络服务绑定低位端口</strong>：一个Web服务器（如Nginx）需要监听80或443端口。传统上需要以root身份启动，然后再降权。使用Capabilities，只需给Nginx可执行文件赋予<code>CAP_NET_BIND_SERVICE</code>权能，它就可以由一个非root用户直接启动并成功绑定端口。<ul><li>命令示例：<code>sudo setcap &#39;cap_net_bind_service=+ep&#39; /usr/sbin/nginx</code></li></ul></li><li><strong>网络数据包捕获</strong>：网络分析工具（如<code>tcpdump</code>或<code>wireshark</code>）需要访问网络接口以捕获数据包。这需要创建原始套接字，对应<code>CAP_NET_RAW</code>权能。<ul><li>命令示例：<code>sudo setcap cap_net_raw+ep /usr/sbin/tcpdump</code></li></ul></li><li><strong>容器权限管理</strong>：在Docker或Kubernetes中，当一个容器需要执行特定特权操作但又不应给予<code>--privileged</code>（完全特权）时，精确地添加所需权能是最佳实践。例如，一个需要修改网络路由表的容器可以被授予<code>CAP_NET_ADMIN</code>。<ul><li>Docker命令示例：<code>docker run --cap-drop=ALL --cap-add=NET_ADMIN my_image</code></li></ul></li></ul><h4 id="是否有不推荐使用该技术的场景？为什么？"><a href="#是否有不推荐使用该技术的场景？为什么？" class="headerlink" title="是否有不推荐使用该技术的场景？为什么？"></a>是否有不推荐使用该技术的场景？为什么？</h4><ul><li><strong>需要完整系统管理权限的场景</strong>：对于像<code>sshd</code>这样需要进行用户会话管理、修改系统配置等广泛管理任务的程序，试图用一组有限的权能来替代root权限会变得极其复杂甚至不可能。</li><li><strong>简单的、无特权要求的应用</strong>：对于绝大多数不需要任何特权的普通应用程序（如文本编辑器、计算器），根本无需涉及Capabilities。传统的用户和文件权限模型已经足够。</li></ul><h3 id="对比分析"><a href="#对比分析" class="headerlink" title="对比分析"></a>对比分析</h3><h4 id="请将其-与-其他相似技术-进行详细对比。"><a href="#请将其-与-其他相似技术-进行详细对比。" class="headerlink" title="请将其 与 其他相似技术 进行详细对比。"></a>请将其 与 其他相似技术 进行详细对比。</h4><p>Capabilities与传统的UID模型以及其他LSM（如SELinux&#x2F;AppArmor）共同构成了Linux的权限控制体系，但它们的侧重点和机制各不相同。</p><table><thead><tr><th align="left">特性</th><th align="left">Linux Capabilities</th><th align="left">传统UID模型 (root&#x2F;non-root)</th><th align="left">SELinux &#x2F; AppArmor (LSM)</th></tr></thead><tbody><tr><td align="left"><strong>功能概述</strong></td><td align="left">将root特权分解为细粒度的、可独立授予的权限单元。</td><td align="left">一个二元的“全有或全无”模型，基于用户身份（UID 0 vs 非0）进行权限检查。</td><td align="left">提供强制访问控制（MAC），基于安全策略规则（标签或路径）来控制主体（进程）对客体（文件、套接字等）的访问。</td></tr><tr><td align="left"><strong>控制粒度</strong></td><td align="left"><strong>中等</strong>。基于“操作”或“能力”，如“能否绑定低位端口”。</td><td align="left"><strong>粗糙</strong>。只有“能”或“不能”两种状态。</td><td align="left"><strong>非常精细</strong>。可以控制到具体文件、具体操作类型（读、写、执行、追加等）。</td></tr><tr><td align="left"><strong>安全目标</strong></td><td align="left"><strong>最小权限原则</strong>，减少进程的潜在攻击面。</td><td align="left"><strong>用户隔离</strong>，区分系统管理员和普通用户。</td><td align="left"><strong>强制访问控制</strong>，即使是root用户也要受到策略的严格限制，防止权限滥用和未知漏洞利用。</td></tr><tr><td align="left"><strong>实现方式</strong></td><td align="left">通过LSM钩子在内核中检查进程的有效权能集。</td><td align="left">在内核代码中直接检查进程的有效UID是否为0。</td><td align="left">通过LSM钩子，根据预定义的策略规则匹配主体和客体的安全上下文（标签）或路径名。</td></tr><tr><td align="left"><strong>易用性</strong></td><td align="left"><strong>中等</strong>。概念相对直观，但管理和调试有一定学习曲线。</td><td align="left"><strong>非常简单</strong>。易于理解和使用。</td><td align="left"><strong>复杂</strong>（特别是SELinux）。策略编写和维护非常困难，需要专业知识。</td></tr><tr><td align="left"><strong>结合关系</strong></td><td align="left"><strong>互补</strong>。Capabilities检查通常发生在LSM检查之前。一个操作需要同时通过Capabilities和SELinux&#x2F;AppArmor的检查才能被允许。</td><td align="left">Capabilities旨在打破传统UID模型的局限性。一个非root用户可以拥有权能，一个root用户也可以被剥夺权能。</td><td align="left"></td></tr></tbody></table><h2 id="cap-capable-跨用户命名空间的能力检查机制"><a href="#cap-capable-跨用户命名空间的能力检查机制" class="headerlink" title="cap_capable: 跨用户命名空间的能力检查机制"></a>cap_capable: 跨用户命名空间的能力检查机制</h2><p>本代码片段是 Linux 内核安全子系统的基石之一，提供了核心函数 <code>cap_capable</code>，用于精确地判断一个进程（由其凭证 <code>cred</code> 代表）是否拥有某个特定的能力（Capability），并且这个判断过程完全支持并正确处理了复杂的用户命名空间（User Namespace）层次结构。当内核的其他部分需要进行权限检查时（例如，判断一个进程是否可以重启系统），它们最终都会调用这个函数。</p><h3 id="实现原理分析"><a href="#实现原理分析" class="headerlink" title="实现原理分析"></a>实现原理分析</h3><p>此机制的核心原理是基于<strong>用户命名空间（User Namespace）的层次化能力模型</strong>。一个进程的能力不再是一个简单的全局属性，而是与其所属的用户命名空间相关联。<code>cap_capable_helper</code> 函数中的 <code>for(;;)</code> 循环通过向上遍历命名空间树，实现了这一复杂的检查逻辑。</p><ol><li><p><strong>向上遍历（Upward Traversal）</strong>: 检查的起点是目标资源所属的命名空间 <code>target_ns</code>。循环通过 <code>ns = ns-&gt;parent</code> 不断向上移动，直至根命名空间（<code>init_user_ns</code>）。</p></li><li><p><strong>能力检查的三个关键规则</strong>: 在循环的每一层，代码会依次应用以下规则：</p><ul><li><strong>规则一：同命名空间内的直接检查</strong>。<code>if (likely(ns == cred_ns))</code>：这是最常见和最高效的情况。如果当前检查的命名空间 <code>ns</code> 正是进程凭证所属的命名空间 <code>cred_ns</code>，那么就直接检查该进程的有效能力集（<code>cred-&gt;cap_effective</code>）中是否包含所需的能力位。这是通过位掩码操作 <code>cap_raised</code> 实现的。</li><li><strong>规则二：命名空间所有者特权</strong>。<code>if ((ns-&gt;parent == cred_ns) &amp;&amp; uid_eq(ns-&gt;owner, cred-&gt;euid))</code>：这是用户命名空间的一个核心特性。一个用户在一个父命名空间中创建了一个新的子命名空间，那么该用户（<code>ns-&gt;owner</code>）在这个新的子命名空间内自动获得全部能力。此规则检查的就是这种情况：如果当前检查的命名空间 <code>ns</code> 的父命名空间正好是进程所在的命名空间，并且该进程的有效用户ID（<code>cred-&gt;euid</code>）与 <code>ns</code> 的所有者ID 匹配，那么就授予权限。</li><li><strong>规则三：父命名空间能力继承</strong>。循环本身 <code>ns = ns-&gt;parent</code> 体现了继承原则。如果一个进程在某个父命名空间中拥有某项能力，那么它自动对该父命名空间下的所有子孙命名空间都拥有该项能力。循环会持续向上，直到在某个父命名空间中通过了规则一的直接检查。</li></ul></li><li><p><strong>提前终止优化</strong>: <code>if (ns-&gt;level &lt;= cred_ns-&gt;level)</code> 检查是一个重要的优化。<code>level</code> 代表命名空间的嵌套深度。如果向上遍历的过程中，<code>ns</code> 的深度已经小于或等于进程凭证 <code>cred_ns</code> 的深度，但 <code>ns</code> 却不等于 <code>cred_ns</code>，这说明它们处于不同的分支， 沿着这条路继续前进是没有意义的。</p></li></ol><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief cap_capable - 判断一个任务是否拥有特定的有效能力。</span></span><br><span class="line"><span class="comment"> * @param cred 要使用的凭证。</span></span><br><span class="line"><span class="comment"> * @param target_ns 被访问资源所属的用户命名空间。</span></span><br><span class="line"><span class="comment"> * @param cap 要检查的能力。</span></span><br><span class="line"><span class="comment"> * @param opts 在 include/linux/security.h 中定义的选项位掩码（在此函数中未使用）。</span></span><br><span class="line"><span class="comment"> * @return 成功（拥有能力）返回0，失败（没有能力）返回负数错误码。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @note 与 capable() 等函数相反，cap_capable() 在任务拥有能力时返回0，</span></span><br><span class="line"><span class="comment"> *       而 capable() 及其变体在这种情况下返回布尔值true(1)。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">cap_capable</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> cred *cred, <span class="keyword">struct</span> user_namespace *target_ns,</span></span><br><span class="line"><span class="params"><span class="type">int</span> cap, <span class="type">unsigned</span> <span class="type">int</span> opts)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 获取凭证自身所属的用户命名空间。</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">cred_ns</span> =</span> cred-&gt;user_ns;</span><br><span class="line"><span class="comment">// 调用辅助函数执行实际的检查逻辑。</span></span><br><span class="line"><span class="type">int</span> ret = cap_capable_helper(cred, target_ns, cred_ns, cap);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录一次能力检查的追踪事件，用于调试和审计。</span></span><br><span class="line">trace_cap_capable(cred, target_ns, cred_ns, cap, ret);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief cap_capable_helper - 判断任务是否拥有特定有效能力的辅助函数。</span></span><br><span class="line"><span class="comment"> * @param cred 要使用的凭证。</span></span><br><span class="line"><span class="comment"> * @param target_ns 被访问资源所属的用户命名空间。</span></span><br><span class="line"><span class="comment"> * @param cred_ns 凭证所属的用户命名空间。</span></span><br><span class="line"><span class="comment"> * @param cap 要检查的能力。</span></span><br><span class="line"><span class="comment"> * @return 成功返回0，失败返回负数错误码。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">cap_capable_helper</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> cred *cred,</span></span><br><span class="line"><span class="params">     <span class="keyword">struct</span> user_namespace *target_ns,</span></span><br><span class="line"><span class="params">     <span class="type">const</span> <span class="keyword">struct</span> user_namespace *cred_ns,</span></span><br><span class="line"><span class="params">     <span class="type">int</span> cap)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 从目标命名空间开始向上遍历。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">ns</span> =</span> target_ns;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 通过检查目标用户命名空间及其所有父命名空间，</span></span><br><span class="line"><span class="comment"> * 来判断cred是否在目标用户命名空间中拥有该能力。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="comment">// 我们是否拥有必要的能力？</span></span><br><span class="line"><span class="comment">// [规则一] 如果当前检查的命名空间就是凭证自己的命名空间...</span></span><br><span class="line"><span class="keyword">if</span> (likely(ns == cred_ns))</span><br><span class="line"><span class="comment">// ...那么直接检查凭证的有效能力集中是否包含该能力。</span></span><br><span class="line"><span class="keyword">return</span> cap_raised(cred-&gt;cap_effective, cap) ? <span class="number">0</span> : -EPERM;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如果我们已经到达了比我们凭证所在层级更低或相同的层级</span></span><br><span class="line"><span class="comment"> * （但ns != cred_ns），那么搜索结束，肯定没有权限。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (ns-&gt;level &lt;= cred_ns-&gt;level)</span><br><span class="line"><span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * [规则二] 用户命名空间的创建者在其父命名空间中，</span></span><br><span class="line"><span class="comment"> * 对其创建的子命名空间拥有全部能力。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> ((ns-&gt;parent == cred_ns) &amp;&amp; uid_eq(ns-&gt;owner, cred-&gt;euid))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * [规则三] 如果你在一个父用户命名空间中拥有某项能力，</span></span><br><span class="line"><span class="comment"> * 那么你对它所有的子用户命名空间也拥有该能力。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 移动到父命名空间，继续下一轮检查。</span></span><br><span class="line">ns = ns-&gt;parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 我们永远不会执行到这里 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;

&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i-blog.csdnimg.cn/direct/1fbf788ecf2745018a9f7a1a52a1191e.</summary>
      
    
    
    
    <category term="linux" scheme="https://wdfk-prog.space/categories/linux/"/>
    
    <category term="security" scheme="https://wdfk-prog.space/categories/linux/security/"/>
    
    
    <category term="linux" scheme="https://wdfk-prog.space/tags/linux/"/>
    
    <category term="security" scheme="https://wdfk-prog.space/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>kallsyms</title>
    <link href="https://wdfk-prog.space/posts/dd631879/"/>
    <id>https://wdfk-prog.space/posts/dd631879/</id>
    <published>2025-10-06T03:49:09.000Z</published>
    <updated>2025-10-07T01:12:04.239Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>[TOC]</p><h1 id="kernel-kallsyms-c-内核符号表-Kernel-Symbols-运行时内核符号解析"><a href="#kernel-kallsyms-c-内核符号表-Kernel-Symbols-运行时内核符号解析" class="headerlink" title="kernel&#x2F;kallsyms.c 内核符号表(Kernel Symbols) 运行时内核符号解析"></a>kernel&#x2F;kallsyms.c 内核符号表(Kernel Symbols) 运行时内核符号解析</h1><p><img src="https://i-blog.csdnimg.cn/direct/8e1d951619fc4393a032df5887ff24a2.png" alt="在这里插入图片描述"></p><h3 id="历史与背景"><a href="#历史与背景" class="headerlink" title="历史与背景"></a>历史与背景</h3><h4 id="这项技术是为了解决什么特定问题而诞生的？"><a href="#这项技术是为了解决什么特定问题而诞生的？" class="headerlink" title="这项技术是为了解决什么特定问题而诞生的？"></a>这项技术是为了解决什么特定问题而诞生的？</h4><p><code>kallsyms</code>（Kernel All Symbols）机制的诞生是为了解决在内核运行时<strong>动态解析符号地址</strong>的核心需求。一个符号（Symbol）是程序中的一个构建块，通常指代一个函数名或变量名。内核在运行时，更倾向于直接使用内存地址（如 <code>0xffffffff81c33580</code>）而不是符号名（如 <code>schedule</code>）。 然而，在很多场景下，将地址转换回人类可读的符号名是至关重要的：</p><ul><li><strong>内核调试与错误分析</strong>：当内核发生严重错误（Kernel Panic）或“oops”时，它会打印出当时的寄存器状态和函数调用栈（Call Trace）。 如果调用栈仅仅是一串十六进制地址，那么对于开发者来说几乎是无用的。<code>kallsyms</code> 机制使得内核能够在崩溃时，当场将这些地址解析成具体的函数名和偏移量，极大地简化了调试过程。</li><li><strong>动态模块加载</strong>：内核模块（Loadable Kernel Modules, LKM）在加载时需要链接到内核主镜像中的函数和变量。 <code>kallsyms</code> 提供了一个运行时接口，让模块加载器可以查找这些符号的地址，从而完成动态链接。</li><li><strong>性能分析与追踪</strong>：高级的内核追踪工具，如 ftrace 和 kprobes，允许开发者在指定的内核函数入口或特定地址设置探测点。 <code>kallsyms</code> 使得这些工具可以通过函数名（而不是写死的地址）来动态设置追踪点，增强了灵活性和易用性。</li></ul><h4 id="它的发展经历了哪些重要的里程碑或版本迭代？"><a href="#它的发展经历了哪些重要的里程碑或版本迭代？" class="headerlink" title="它的发展经历了哪些重要的里程碑或版本迭代？"></a>它的发展经历了哪些重要的里程碑或版本迭代？</h4><p>内核符号表的实现在历史上经历了重要的演进：</p><ol><li><strong>早期的 <code>ksyms</code></strong>：在Linux 2.5.47版本之前，内核通过 <code>/proc/ksyms</code> 文件导出一个符号列表。 这个列表通常只包含被明确使用 <code>EXPORT_SYMBOL</code> 宏导出的符号，主要用于满足模块加载的需求。</li><li><strong><code>kallsyms</code> 的引入</strong>：为了提供更全面的符号信息以支持更强大的调试功能，<code>kallsyms</code> 机制被引入。与 <code>ksyms</code> 不同，<code>kallsyms</code> 旨在包含内核中<strong>所有</strong>的非栈符号，而不仅仅是导出的符号。</li><li><strong><code>/proc/kallsyms</code> 的出现</strong>：从Linux 2.5.71开始，<code>/proc/kallsyms</code> 取代了 <code>/proc/ksyms</code>，成为了在用户空间查看运行时内核符号表的标准接口。 它不仅包含了内核主镜像的符号，还能动态地反映已加载模块的符号信息。</li><li><strong>压缩与优化</strong>：为了减小符号表在内核镜像中占用的空间，内核引入了多种压缩技术。<code>kallsyms.c</code> 中的代码实现了对这些压缩符号表的解压和查找逻辑。</li></ol><h4 id="目前该技术的社区活跃度和主流应用情况如何？"><a href="#目前该技术的社区活跃度和主流应用情况如何？" class="headerlink" title="目前该技术的社区活跃度和主流应用情况如何？"></a>目前该技术的社区活跃度和主流应用情况如何？</h4><p><code>kallsyms</code> 是Linux内核中一项非常基础、成熟且不可或缺的技术。它是内核可观察性（Observability）和可调试性的基石。所有主流的Linux发行版都会在内核编译时启用 <code>CONFIG_KALLSYMS</code> 选项。它被以下工具和子系统广泛依赖：</p><ul><li><strong>内核错误报告</strong>（Oops&#x2F;Panic）。</li><li><strong>模块加载器</strong>。</li><li><strong>性能分析工具</strong>：<code>perf</code>、<code>ftrace</code>、<code>eBPF</code>。</li><li><strong>动态探测工具</strong>：<code>kprobes</code>、<code>jprobes</code>、<code>uprobes</code>。</li></ul><h3 id="核心原理与设计"><a href="#核心原理与设计" class="headerlink" title="核心原理与设计"></a>核心原理与设计</h3><h4 id="它的核心工作原理是什么？"><a href="#它的核心工作原理是什么？" class="headerlink" title="它的核心工作原理是什么？"></a>它的核心工作原理是什么？</h4><p><code>kernel/kallsyms.c</code> 的核心是在内核中实现了一套高效的符号查找机制，并向外提供接口。</p><ol><li><strong>构建时的数据准备</strong>：在内核编译的最后阶段，一个名为 <code>kallsyms</code> 的主机程序（<code>scripts/kallsyms.c</code>）会扫描 <code>vmlinux</code> 文件，提取出所有的符号（地址、类型、名称）。然后，它将这些符号信息处理成一个紧凑的、经过压缩的数据块，并将其链接到最终的内核镜像中，成为一个名为 <code>__kallsyms</code> 的特殊数据段（section）。 这个数据块包含了多个数组，如 <code>kallsyms_addresses</code>（符号地址数组）、<code>kallsyms_names</code>（压缩后的符号名数组）等。</li><li><strong>运行时的数据访问</strong>：当内核启动后，这个 <code>__kallsyms</code> 数据段就位于内核的内存空间中。<code>kernel/kallsyms.c</code> 中的函数就是用来操作这片内存区域的。</li><li><strong>地址到符号的转换</strong>：当需要将一个地址（例如，指令指针寄存器的值）转换为符号名时，内核会调用 <code>kallsyms_lookup()</code> 等内部函数。这个函数会在已排序的 <code>kallsyms_addresses</code> 数组中进行高效的二分查找，找到小于或等于给定地址的最近的一个符号地址。然后，它会计算出偏移量，并从 <code>kallsyms_names</code> 中解压出对应的符号名称。</li><li><strong>符号到地址的转换</strong>：当需要将一个符号名转换为地址时（例如，<code>kprobes</code> 需要在 <code>schedule</code> 函数上设置探测点），内核会调用 <code>kallsyms_lookup_name()</code> 函数。 这个函数会遍历压缩的符号名列表，逐个解压并与目标名称进行比较，直到找到匹配的符号，然后返回其对应的地址。</li><li><strong>通过 <code>/proc/kallsyms</code> 导出</strong>：当用户空间的程序读取 <code>/proc/kallsyms</code> 文件时，会触发 <code>kallsyms.c</code> 中实现的 <code>seq_file</code> 接口。 这些接口函数会遍历内核主镜像和所有已加载模块的符号表，并将它们格式化为“地址 类型 名称 [模块名]”的文本行，输出给用户。</li></ol><h4 id="它的主要优势体现在哪些方面？"><a href="#它的主要优势体现在哪些方面？" class="headerlink" title="它的主要优势体现在哪些方面？"></a>它的主要优势体现在哪些方面？</h4><ul><li><strong>运行时可用性</strong>：无需外部文件（如 <code>System.map</code>），内核自身就具备了解析符号的能力，这使得在任何正在运行的系统上进行调试和追踪都成为可能。</li><li><strong>动态性</strong>：能够实时反映内核模块加载和卸载带来的符号变化，这是静态文件无法做到的。</li><li><strong>完整性</strong>：可以包含内核中几乎所有的全局符号，而不仅仅是导出的符号，为深度调试和性能分析提供了更全面的信息。</li><li><strong>空间效率</strong>：通过复杂的压缩算法，显著减小了符号表在内核镜像中所占的空间。</li></ul><h4 id="它存在哪些已知的劣势、局限性或在特定场景下的不适用性？"><a href="#它存在哪些已知的劣势、局限性或在特定场景下的不适用性？" class="headerlink" title="它存在哪些已知的劣势、局限性或在特定场景下的不适用性？"></a>它存在哪些已知的劣势、局限性或在特定场景下的不适用性？</h4><ul><li><strong>安全风险</strong>：暴露详细的内核符号地址信息会给攻击者提供便利，尤其是在绕过KASLR（内核地址空间布局随机化）等安全机制时。 为了缓解这个问题，大多数系统默认配置 <code>kernel.kptr_restrict=1</code>，使得非特权用户读取 <code>/proc/kallsyms</code> 时看到的地址都是零。</li><li><strong>性能开销</strong>：虽然查找算法已经高度优化，但在运行时进行符号查找仍然存在一定的CPU开销。此外，在内核镜像中嵌入符号表会增加其体积。</li><li><strong>编译时依赖</strong>：该功能需要在内核编译时启用（<code>CONFIG_KALLSYMS=y</code>），如果一个内核在编译时未开启此选项，那么它在运行时将完全丧失符号解析能力。</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><h4 id="在哪些具体的业务或技术场景下，它是首选解决方案？请举例说明。"><a href="#在哪些具体的业务或技术场景下，它是首选解决方案？请举例说明。" class="headerlink" title="在哪些具体的业务或技术场景下，它是首选解决方案？请举例说明。"></a>在哪些具体的业务或技术场景下，它是首选解决方案？请举例说明。</h4><ul><li><strong>内核崩溃分析</strong>：当服务器出现内核panic时，运维人员从 <code>dmesg</code> 或 <code>kdump</code> 的日志中看到的第一件事就是一个带有符号名的调用栈。这是<code>kallsyms</code>最直接、最关键的应用。</li><li><strong>动态内核追踪</strong>：一个性能工程师想要分析某个特定内核函数的行为，他可以使用<code>perf</code>工具：<code>perf probe schedule</code>。<code>perf</code>在底层通过<code>kallsyms</code>机制找到<code>schedule</code>函数的地址，并设置一个kprobe探测点。</li><li><strong>编写内核模块</strong>：一个驱动开发者需要调用一个非导出的内核函数（通常不推荐，但有时为了调试或特定目的需要）。他可以在模块中调用<code>kallsyms_lookup_name(&quot;function_name&quot;)</code>来动态获取该函数的地址。</li><li><strong>安全审计</strong>：安全研究人员可以通过分析<code>/proc/kallsyms</code>的输出来了解内核的内存布局，并验证KASLR是否有效工作。</li></ul><h4 id="是否有不推荐使用该技术的场景？为什么？"><a href="#是否有不推荐使用该技术的场景？为什么？" class="headerlink" title="是否有不推荐使用该技术的场景？为什么？"></a>是否有不推荐使用该技术的场景？为什么？</h4><p>在绝大多数情况下，启用 <code>kallsyms</code> 是利远大于弊的。不推荐禁用它的主要原因是，一旦禁用，将极大地增加内核故障排查的难度。唯一的考虑可能是：</p><ul><li><strong>极度资源受限的嵌入式系统</strong>：在内存（RAM&#x2F;ROM）极其有限（例如，只有几百KB）的微控制器上，内核符号表所占用的空间可能无法承受。</li><li><strong>安全要求极高的“安全内核”</strong>：在某些需要最大化“攻击面”最小化的安全操作系统中，可能会选择禁用<code>kallsyms</code>，以防止任何形式的内核内存布局信息泄露，并配合使用其他离线调试手段。</li></ul><h3 id="对比分析"><a href="#对比分析" class="headerlink" title="对比分析"></a>对比分析</h3><h4 id="请将其-与-其他相似技术-进行详细对比。"><a href="#请将其-与-其他相似技术-进行详细对比。" class="headerlink" title="请将其 与 其他相似技术 进行详细对比。"></a>请将其 与 其他相似技术 进行详细对比。</h4><p><code>kallsyms</code> 的主要对比对象是静态的 <code>System.map</code> 文件。</p><table><thead><tr><th align="left">特性</th><th align="left">&#x2F;proc&#x2F;kallsyms (由 kallsyms.c 提供)</th><th align="left">System.map 文件</th></tr></thead><tbody><tr><td align="left"><strong>功能概述</strong></td><td align="left">一个<strong>运行时</strong>、<strong>动态</strong>的内核符号表接口，反映了当前正在运行的内核的<strong>真实</strong>状态。</td><td align="left">一个在内核<strong>编译时</strong>生成的<strong>静态</strong>文本文件，记录了该次编译出的内核镜像的符号表。</td></tr><tr><td align="left"><strong>实现方式</strong></td><td align="left">符号数据被压缩并链接到内核镜像中，由<code>kallsyms.c</code>中的代码在运行时解析和提供。</td><td align="left">在编译内核后，通过<code>nm</code>等工具从<code>vmlinux</code>文件中提取符号信息并保存为一个普通的文本文件。</td></tr><tr><td align="left"><strong>数据来源</strong></td><td align="left">内核自身内存中的 <code>__kallsyms</code> 数据段，以及已加载模块的动态符号信息。</td><td align="left">编译时生成的 <code>vmlinux</code> ELF 文件。</td></tr><tr><td align="left"><strong>动态性</strong></td><td align="left"><strong>高</strong>。当内核模块被加载或卸载时，其符号会动态地出现在&#x2F;proc&#x2F;kallsyms中或从中消失。</td><td align="left"><strong>无</strong>。完全静态，无法反映内核模块的加载情况。</td></tr><tr><td align="left"><strong>准确性</strong></td><td align="left"><strong>高</strong>。它总是准确反映当前运行内核的符号信息。即使KASLR开启，它也显示随机化后的真实地址。</td><td align="left"><strong>可能不准确</strong>。如果<code>System.map</code>文件与当前运行的内核版本不匹配，其信息就是错误的。 此外，它不反映KASLR导致的地址随机化，其地址是编译时的链接地址。</td></tr><tr><td align="left"><strong>可用性</strong></td><td align="left"><strong>高</strong>。只要内核在运行且配置开启，它就一定可用。</td><td align="left"><strong>不确定</strong>。文件可能不存在，或者版本不匹配。 在内核无法启动的场景下，它是唯一可用的符号参考。</td></tr><tr><td align="left"><strong>主要用途</strong></td><td align="left">运行时调试、动态追踪、模块加载、内核错误自诊断。</td><td align="left">内核启动失败时的早期调试、交叉引用、以及为一些老旧工具提供符号信息。</td></tr></tbody></table><h2 id="kallsyms-init-内核符号表-proc-接口创建"><a href="#kallsyms-init-内核符号表-proc-接口创建" class="headerlink" title="kallsyms_init: 内核符号表 &#x2F;proc 接口创建"></a>kallsyms_init: 内核符号表 &#x2F;proc 接口创建</h2><p>本代码片段的核心功能是在 Linux 内核初始化期间，通过 <code>/proc</code> 虚拟文件系统，创建一个名为 <code>kallsyms</code> 的只读文件。这个文件（<code>/proc/kallsyms</code>）向用户空间提供了一个内核符号表的实时视图，其中包含了内核中所有非静态函数和全局变量的名称及其在内存中的地址。这是内核调试、性能分析（profiling）和动态追踪（tracing）等高级功能的基石。</p><h3 id="实现原理分析"><a href="#实现原理分析" class="headerlink" title="实现原理分析"></a>实现原理分析</h3><p>该机制的实现完全建立在 Linux 的 <code>/proc</code> 文件系统框架之上，这是一种在内存中动态生成文件内容的机制。</p><ol><li><p><strong>Proc 文件注册 (<code>proc_create</code>)</strong>: <code>kallsyms_init</code> 函数的核心是调用 <code>proc_create</code>。这个函数向 <code>/proc</code> 文件系统注册一个新的文件节点。</p><ul><li><strong><code>&quot;kallsyms&quot;</code></strong>: 指定了在 <code>/proc</code> 根目录下创建的文件名。</li><li><strong><code>0444</code></strong>: 定义了文件的访问权限为八进制的 <code>0444</code>，即对所有用户（属主、属组、其他）都只有读取权限。这是一种安全措施，防止用户空间程序意外或恶意地修改内核符号信息。</li><li><strong><code>NULL</code></strong>: 表示该文件直接创建在 <code>/proc</code> 的根目录下。</li><li><strong><code>&amp;kallsyms_proc_ops</code></strong>: 这是最关键的参数。它是一个指向 <code>proc_ops</code> 结构体的指针。该结构体包含了一系列函数指针，它们定义了当用户空间进程对此文件执行各种操作（如 <code>open</code>, <code>read</code>, <code>lseek</code>, <code>release</code>）时，内核应该调用哪些具体的处理函数。</li></ul></li><li><p><strong>Sequence File 接口</strong>: <code>kallsyms_proc_ops</code> 结构体将文件的读操作（<code>.proc_read</code>）指向了 <code>seq_read</code>。<code>seq_read</code> 是内核提供的一个通用函数，它与 <code>seq_file</code>（Sequence File）接口协同工作。<code>seq_file</code> 是一种为生成内容可能很大的虚拟文件而设计的优化机制。当 <code>kallsyms_open</code> 被调用时，它会初始化一个 <code>seq_file</code> 实例，并提供一组迭代器函数，<code>seq_read</code> 则利用这些迭代器函数逐条（sequence by sequence）地遍历内核的符号表，并将其格式化输出到用户缓冲区，从而避免了一次性在内核中分配巨大缓冲区来存储整个符号表的开销。</p></li></ol><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个常量 proc_ops 结构体，用于关联 /proc/kallsyms 文件的操作。</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_ops</span> <span class="title">kallsyms_proc_ops</span> =</span> &#123;</span><br><span class="line"><span class="comment">// 当文件被打开时，调用 kallsyms_open 函数。</span></span><br><span class="line">.proc_open= kallsyms_open,</span><br><span class="line"><span class="comment">// 当文件被读取时，调用通用的 seq_read 函数（配合seq_file接口）。</span></span><br><span class="line">.proc_read= seq_read,</span><br><span class="line"><span class="comment">// 当对文件进行定位（lseek）时，调用通用的 seq_lseek 函数。</span></span><br><span class="line">.proc_lseek= seq_lseek,</span><br><span class="line"><span class="comment">// 当文件被关闭/释放时，调用 seq_release_private 函数来释放私有数据。</span></span><br><span class="line">.proc_release= seq_release_private,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kallsyms_init: /proc/kallsyms 接口的初始化函数。</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">kallsyms_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 在/proc文件系统的根目录下创建一个名为&quot;kallsyms&quot;的文件。</span></span><br><span class="line"><span class="comment">// - &quot;kallsyms&quot;: 文件名。</span></span><br><span class="line"><span class="comment">// - 0444: 文件的权限为只读（所有者、组、其他用户均为只读）。</span></span><br><span class="line"><span class="comment">// - NULL: 父目录为/proc的根。</span></span><br><span class="line"><span class="comment">// - &amp;kallsyms_proc_ops: 指定与此文件关联的操作函数集。</span></span><br><span class="line">proc_create(<span class="string">&quot;kallsyms&quot;</span>, <span class="number">0444</span>, <span class="literal">NULL</span>, &amp;kallsyms_proc_ops);</span><br><span class="line"><span class="comment">// 返回0表示初始化成功。</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将 kallsyms_init 注册为一个设备初始化调用。</span></span><br><span class="line"><span class="comment">// 这使得该函数会在内核启动过程中的一个较早阶段被自动执行。</span></span><br><span class="line">device_initcall(kallsyms_init);</span><br></pre></td></tr></table></figure><h2 id="内核符号表-proc-接口的实现与高效迭代-kallsyms-open-get-symbol-offset"><a href="#内核符号表-proc-接口的实现与高效迭代-kallsyms-open-get-symbol-offset" class="headerlink" title="内核符号表 &#x2F;proc 接口的实现与高效迭代 (kallsyms_open, get_symbol_offset)"></a>内核符号表 &#x2F;proc 接口的实现与高效迭代 (kallsyms_open, get_symbol_offset)</h2><p>本代码片段展示了当用户空间程序打开 <code>/proc/kallsyms</code> 文件时，内核如何初始化一个高效的迭代器来遍历内核符号表。其核心功能是利用一种经过优化的两级查找算法（<code>get_symbol_offset</code>），在经过特殊压缩的符号名称数据流中快速定位到任意指定的符号，为 <code>seq_file</code> 框架提供了高效的遍历能力。</p><h3 id="实现原理分析-1"><a href="#实现原理分析-1" class="headerlink" title="实现原理分析"></a>实现原理分析</h3><p>该实现中最关键和精妙的部分是 <code>get_symbol_offset</code> 函数所采用的符号查找算法，它旨在以空间换时间，大幅优化遍历性能。</p><ol><li><p><strong><code>seq_file</code> 与私有迭代器 (<code>kallsyms_open</code>)</strong>: <code>kallsyms_open</code> 函数遵循了 <code>seq_file</code> 框架的标准实践。它调用 <code>__seq_open_private</code> 来分配一个私有的 <code>kallsym_iter</code> 结构体。这个结构体将作为此特定文件句柄的“游标”，保存当前遍历的位置（<code>pos</code>）、在压缩数据流中的字节偏移量（<code>nameoff</code>）等状态。这种方式使得每个打开 <code>/proc/kallsyms</code> 的进程都有自己独立的遍历状态。</p></li><li><p><strong>压缩的符号名称流</strong>: 内核为了节省空间，并不会以简单的 C 字符串数组来存储所有符号名。相反，<code>kallsyms_names</code> 是一个连续的字节数组，其中的每个符号都以 <code>[&lt;长度&gt;][&lt;名称数据&gt;]</code> 的格式紧凑地存储。</p></li><li><p><strong>两级查找优化 (<code>get_symbol_offset</code>)</strong>: 直接从头开始扫描这个压缩流来查找第 <code>N</code> 个符号会非常慢。<code>get_symbol_offset</code> 通过一个两级查找策略来解决这个问题：</p><ul><li><strong>一级查找（粗粒度定位）</strong>: 内核在编译时会额外生成一个 <code>kallsyms_markers</code> 数组。这个数组是一个标记点索引，<code>kallsyms_markers[i]</code> 存储了第 <code>i * 256</code> 个符号在 <code>kallsyms_names</code> 压缩流中的起始字节偏移量。因此，<code>get_symbol_offset</code> 函数首先通过 <code>pos &gt;&gt; 8</code>（即 <code>pos / 256</code>）计算出应该使用哪个标记点，直接跳转到距离目标位置最近的一个检查点，从而跳过前面大量的符号。</li><li><strong>二级查找（细粒度扫描）</strong>: 从标记点位置开始，函数再通过一个循环，对剩余的最多 255 个符号（由 <code>pos &amp; 0xFF</code> 即 <code>pos % 256</code> 决定）进行逐个扫描。它读取每个符号的长度字节，然后向后跳转“长度+1”个字节，直到到达目标符号。</li></ul></li><li><p><strong>可变长度编码</strong>: 为了进一步节省空间，符号的长度使用了可变长编码。如果长度小于 128，就用一个字节表示。如果长度大于等于 128，第一个字节的最高位（MSB）会被置 1 作为标志，而真正的长度值（减去 1）则由第一个字节的低 7 位和第二个字节的 8 位共同组成一个 15 位的数值。这是一种针对大量短符号名进行的有效空间优化。</p></li></ol><h3 id="代码分析-1"><a href="#代码分析-1" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kallsyms_open: 当 /proc/kallsyms 文件被打开时，内核调用的函数。</span></span><br><span class="line"><span class="comment">// @inode: 文件的inode对象。</span></span><br><span class="line"><span class="comment">// @file: 打开的文件对象。</span></span><br><span class="line"><span class="comment">// 返回值: 成功返回0，失败返回负数错误码。</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">kallsyms_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 我们将迭代器保存在 m-&gt;private 中，因为通常情况下是从上次</span></span><br><span class="line"><span class="comment"> * 离开的位置继续 s_start，这样可以避免对每个符号都</span></span><br><span class="line"><span class="comment"> * 调用 get_symbol_offset。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kallsym_iter</span> *<span class="title">iter</span>;</span></span><br><span class="line"><span class="comment">// 调用 seq_file 框架的辅助函数来打开一个私有序列文件。</span></span><br><span class="line"><span class="comment">// 这会为本次文件打开分配一个 kallsym_iter 结构体，并将其地址存放在 file-&gt;private_data 中。</span></span><br><span class="line">iter = __seq_open_private(file, &amp;kallsyms_op, <span class="keyword">sizeof</span>(*iter));</span><br><span class="line"><span class="comment">// 如果内存分配失败，返回错误。</span></span><br><span class="line"><span class="keyword">if</span> (!iter)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"><span class="comment">// 重置迭代器，使其从符号表的起始位置（位置0）开始。</span></span><br><span class="line">reset_iter(iter, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 与其在每次调用 s_show() 时都进行检查，不如在打开文件时</span></span><br><span class="line"><span class="comment"> * 就把结果缓存起来。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 根据当前进程的凭证，判断是否应该显示符号的地址值，并将结果缓存。</span></span><br><span class="line">iter-&gt;show_value = kallsyms_show_value(file-&gt;f_cred);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reset_iter: 重置或初始化一个 kallsyms 迭代器到新的位置。</span></span><br><span class="line"><span class="comment">// @iter: 指向要重置的迭代器结构体。</span></span><br><span class="line"><span class="comment">// @new_pos: 新的逻辑位置（即第 new_pos 个符号）。</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">reset_iter</span><span class="params">(<span class="keyword">struct</span> kallsym_iter *iter, <span class="type">loff_t</span> new_pos)</span></span><br><span class="line">&#123;</span><br><span class="line">iter-&gt;name[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 清空当前符号名称的缓存。</span></span><br><span class="line"><span class="comment">// 调用 get_symbol_offset 计算新位置在压缩符号流中的字节偏移量。</span></span><br><span class="line">iter-&gt;nameoff = get_symbol_offset(new_pos);</span><br><span class="line">iter-&gt;pos = new_pos; <span class="comment">// 更新迭代器的逻辑位置。</span></span><br><span class="line"><span class="comment">// 如果重置到起始位置0，则也重置其他模块（如 ftrace、bpf）的符号位置计数器。</span></span><br><span class="line"><span class="keyword">if</span> (new_pos == <span class="number">0</span>) &#123;</span><br><span class="line">iter-&gt;pos_mod_end = <span class="number">0</span>;</span><br><span class="line">iter-&gt;pos_ftrace_mod_end = <span class="number">0</span>;</span><br><span class="line">iter-&gt;pos_bpf_end = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get_symbol_offset: 根据符号的逻辑索引号，计算其在压缩符号名称流中的字节偏移量。</span></span><br><span class="line"><span class="comment">// @pos: 符号的逻辑索引号（例如，第 1000 个符号）。</span></span><br><span class="line"><span class="comment">// 返回值: 该符号在 kallsyms_names 数组中的字节偏移量。</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">get_symbol_offset</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> pos)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> u8 *name;</span><br><span class="line"><span class="type">int</span> i, len;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用我们拥有的最近的标记点。我们每隔256个位置就有一个标记点，</span></span><br><span class="line"><span class="comment"> * 这应该足够近了。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 第一级查找：通过 pos &gt;&gt; 8（即 pos / 256）找到对应的标记点，</span></span><br><span class="line"><span class="comment">// 直接跳转到 kallsyms_names 数组中的一个粗略位置。</span></span><br><span class="line">name = &amp;kallsyms_names[kallsyms_markers[pos &gt;&gt; <span class="number">8</span>]];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 顺序扫描所有符号，直到我们搜索的点。每个符号都以</span></span><br><span class="line"><span class="comment"> * [&lt;长度&gt;][&lt;长度对应的数据字节&gt;] 的格式存储，所以我们只需</span></span><br><span class="line"><span class="comment"> * 对每个希望跳过的符号，将长度加到当前指针上即可。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 第二级查找：从标记点开始，顺序扫描余下的符号（最多255个）。</span></span><br><span class="line"><span class="comment">// pos &amp; 0xFF 即 pos % 256。</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (pos &amp; <span class="number">0xFF</span>); i++) &#123;</span><br><span class="line">len = *name; <span class="comment">// 第一个字节是长度。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如果最高有效位（MSB）为1，它是一个“大”符号，所以我们需要</span></span><br><span class="line"><span class="comment"> * 查看下一个字节（并且也要跳过它）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 检查是否为大符号（长度超过127）。</span></span><br><span class="line"><span class="keyword">if</span> ((len &amp; <span class="number">0x80</span>) != <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 如果是，则长度由2个字节共同编码。</span></span><br><span class="line"><span class="comment">// 第一个字节的低7位是低位，第二个字节构成高位。</span></span><br><span class="line">len = ((len &amp; <span class="number">0x7F</span>) | (name[<span class="number">1</span>] &lt;&lt; <span class="number">7</span>)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将指针移动到下一个符号的长度字节。</span></span><br><span class="line">name = name + len + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回最终计算出的指针相对于 kallsyms_names 起始地址的偏移量。</span></span><br><span class="line"><span class="keyword">return</span> name - kallsyms_names;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内核符号表-seq-file-接口实现与动态内容生成"><a href="#内核符号表-seq-file-接口实现与动态内容生成" class="headerlink" title="内核符号表 seq_file 接口实现与动态内容生成"></a>内核符号表 <code>seq_file</code> 接口实现与动态内容生成</h2><p>本代码片段是 Linux 内核 <code>/proc/kallsyms</code> 文件内容生成机制的核心。它通过实现标准的 <code>seq_file</code>（Sequence File）接口，定义了一套完整的迭代器操作 (<code>kallsyms_op</code>)，用于遍历并格式化输出系统内的所有符号。这不仅包括内核主体的静态符号，还动态地涵盖了已加载模块、Ftrace、BPF 程序以及 Kprobes 探针等多种来源的符号，最终将它们统一、有序地呈现给用户空间。</p><h3 id="实现原理分析-2"><a href="#实现原理分析-2" class="headerlink" title="实现原理分析"></a>实现原理分析</h3><p>此机制的核心是 <code>seq_file</code> 框架的标准化应用，它将一个可能非常庞大的、动态生成的数据集（内核符号表）抽象为一个可顺序读取的文件。</p><ol><li><p><strong>迭代器模型 (<code>s_start</code>, <code>s_next</code>, <code>s_stop</code>)</strong>:</p><ul><li><code>s_start</code>: 当读取操作开始或发生文件定位（<code>lseek</code>）时被调用。它的职责是根据请求的起始位置 <code>pos</code>，通过调用 <code>update_iter</code> 来正确地“定位”迭代器 <code>iter</code>。</li><li><code>s_next</code>: 当 <code>seq_file</code> 框架需要下一条记录时调用。它简单地将逻辑位置 <code>pos</code> 加一，然后再次调用 <code>update_iter</code> 来获取下一个符号的信息并更新迭代器状态。</li><li><code>s_stop</code>: 在读取会话结束时调用，用于清理。在此实现中，由于迭代器资源由 <code>seq_file</code> 的私有数据机制管理，故此函数为空。</li></ul></li><li><p><strong>分层更新逻辑 (<code>update_iter</code>, <code>update_iter_mod</code>)</strong>:</p><ul><li><strong><code>update_iter</code></strong>: 这是一个顶层分发函数。它首先判断请求的位置 <code>pos</code> 是否在核心内核符号的范围内 (<code>kallsyms_num_syms</code>)。<ul><li><strong>核心符号处理</strong>: 如果是，它会进行一次关键的性能优化：检查请求的位置是否恰好是上一次位置的下一个 (<code>pos != iter-&gt;pos</code>)。如果是连续读取，它只需调用 <code>get_ksymbol_core</code> 来解析压缩流中的下一个符号即可，效率极高。如果不是（发生了 <code>lseek</code>），则必须调用 <code>reset_iter</code> 来执行一次代价较高的两级查找以重新定位。</li><li><strong>扩展符号处理</strong>: 如果 <code>pos</code> 超出了核心符号范围，它将调用 <code>update_iter_mod</code> 来处理来自其他来源的符号。</li></ul></li><li><strong><code>update_iter_mod</code></strong>: 这个函数负责处理模块、Ftrace、BPF 等动态添加的符号。它像一个责任链一样工作：按顺序检查当前 <code>pos</code> 是否落在某个扩展符号区域内（通过与 <code>iter-&gt;pos_..._end</code> 边界变量比较）。一旦找到所属区域，就调用相应的 <code>get_ksymbol_...()</code> 函数来填充迭代器，并返回。这种设计使得向 <code>kallsyms</code> 添加新的符号源变得模块化和可扩展。</li></ul></li><li><p><strong>格式化输出 (<code>s_show</code>)</strong>: 这是最终将迭代器中的数据转换为用户可见文本的函数。它会检查迭代器中的 <code>iter-&gt;name</code> 是否有效，然后根据符号的类型（是否来自模块、是否为导出的全局符号）选择不同的格式化字符串，通过 <code>seq_printf</code> 输出。</p></li></ol><h3 id="代码分析-2"><a href="#代码分析-2" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// update_iter_mod: 当遍历位置超出核心内核符号范围后，更新迭代器以处理扩展符号（模块、Ftrace等）。</span></span><br><span class="line"><span class="comment">// @iter: 指向kallsyms迭代器的指针。</span></span><br><span class="line"><span class="comment">// @pos: 当前的逻辑遍历位置。</span></span><br><span class="line"><span class="comment">// 返回值: 如果成功获取到一个符号则返回1，否则返回0或负值。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 每个附加的kallsyms段的结束位置（最后一个+1）会在段被添加时</span></span><br><span class="line"><span class="comment"> * 记录在 iter-&gt;pos_..._end 中，因此可以用来决定接下来</span></span><br><span class="line"><span class="comment"> * 应该调用哪个 get_ksymbol_...() 函数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">update_iter_mod</span><span class="params">(<span class="keyword">struct</span> kallsym_iter *iter, <span class="type">loff_t</span> pos)</span></span><br><span class="line">&#123;</span><br><span class="line">iter-&gt;pos = pos;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查当前位置是否在模块符号范围内，并尝试获取一个模块符号。</span></span><br><span class="line"><span class="keyword">if</span> ((!iter-&gt;pos_mod_end || iter-&gt;pos_mod_end &gt; pos) &amp;&amp;</span><br><span class="line">    get_ksymbol_mod(iter))</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查当前位置是否在Ftrace模块符号范围内，并尝试获取一个符号。</span></span><br><span class="line"><span class="keyword">if</span> ((!iter-&gt;pos_ftrace_mod_end || iter-&gt;pos_ftrace_mod_end &gt; pos) &amp;&amp;</span><br><span class="line">    get_ksymbol_ftrace_mod(iter))</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查当前位置是否在BPF符号范围内，并尝试获取一个符号。</span></span><br><span class="line"><span class="keyword">if</span> ((!iter-&gt;pos_bpf_end || iter-&gt;pos_bpf_end &gt; pos) &amp;&amp;</span><br><span class="line">    get_ksymbol_bpf(iter))</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后尝试获取一个kprobe符号。</span></span><br><span class="line"><span class="keyword">return</span> get_ksymbol_kprobe(iter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// update_iter: 更新迭代器到指定的位置。</span></span><br><span class="line"><span class="comment">// @iter: 指向kallsyms迭代器的指针。</span></span><br><span class="line"><span class="comment">// @pos: 目标逻辑位置。</span></span><br><span class="line"><span class="comment">// 返回值: 如果位置有效且成功更新则返回1，否则返回0。</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">update_iter</span><span class="params">(<span class="keyword">struct</span> kallsym_iter *iter, <span class="type">loff_t</span> pos)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 检查位置是否超出了核心内核符号的范围。</span></span><br><span class="line"><span class="keyword">if</span> (pos &gt;= kallsyms_num_syms)</span><br><span class="line"><span class="comment">// 如果是，则调用专门处理模块等扩展符号的函数。</span></span><br><span class="line"><span class="keyword">return</span> update_iter_mod(iter, pos);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果请求的位置不是迭代器当前的位置（发生了seek），则重置迭代器。</span></span><br><span class="line"><span class="keyword">if</span> (pos != iter-&gt;pos)</span><br><span class="line">reset_iter(iter, pos);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用get_ksymbol_core来解析并获取核心符号的信息，更新nameoff。</span></span><br><span class="line">iter-&gt;nameoff += get_ksymbol_core(iter);</span><br><span class="line"><span class="comment">// 将迭代器的逻辑位置加1。</span></span><br><span class="line">iter-&gt;pos++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// s_next: seq_file的next回调，用于移动到序列中的下一个元素。</span></span><br><span class="line"><span class="comment">// @m: 指向seq_file对象的指针。</span></span><br><span class="line"><span class="comment">// @p: 当前位置的内部表示（此处未使用）。</span></span><br><span class="line"><span class="comment">// @pos: 指向当前逻辑位置的指针。</span></span><br><span class="line"><span class="comment">// 返回值: 成功则返回非NULL（通常是m-&gt;private），到达末尾则返回NULL。</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">s_next</span><span class="params">(<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *p, <span class="type">loff_t</span> *pos)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 将逻辑位置加1。</span></span><br><span class="line">(*pos)++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新迭代器到新的位置，如果到达文件末尾，则返回NULL。</span></span><br><span class="line"><span class="keyword">if</span> (!update_iter(m-&gt;private, *pos))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// s_start: seq_file的start回调，用于开始一个序列或定位到指定位置。</span></span><br><span class="line"><span class="comment">// @m: 指向seq_file对象的指针。</span></span><br><span class="line"><span class="comment">// @pos: 指向目标逻辑位置的指针。</span></span><br><span class="line"><span class="comment">// 返回值: 成功则返回非NULL，失败或到达末尾则返回NULL。</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">s_start</span><span class="params">(<span class="keyword">struct</span> seq_file *m, <span class="type">loff_t</span> *pos)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 更新迭代器到指定位置，如果位置无效，则返回NULL。</span></span><br><span class="line"><span class="keyword">if</span> (!update_iter(m-&gt;private, *pos))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// 返回迭代器对象作为后续操作的句柄。</span></span><br><span class="line"><span class="keyword">return</span> m-&gt;private;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// s_stop: seq_file的stop回调，在序列遍历结束时调用。</span></span><br><span class="line"><span class="comment">// @m: 指向seq_file对象的指针。</span></span><br><span class="line"><span class="comment">// @p: 句柄（此处未使用）。</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">s_stop</span><span class="params">(<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 无需特殊清理，资源由seq_file私有数据机制管理。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// s_show: seq_file的show回调，用于格式化输出当前元素。</span></span><br><span class="line"><span class="comment">// @m: 指向seq_file对象的指针。</span></span><br><span class="line"><span class="comment">// @p: 句柄（此处未使用，直接使用m-&gt;private）。</span></span><br><span class="line"><span class="comment">// 返回值: 成功返回0，失败返回错误码。</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">s_show</span><span class="params">(<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">void</span> *value;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kallsym_iter</span> *<span class="title">iter</span> =</span> m-&gt;private;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 某些调试符号可能没有名称，忽略它们。</span></span><br><span class="line"><span class="keyword">if</span> (!iter-&gt;name[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据打开文件时缓存的权限决定是否显示符号地址。</span></span><br><span class="line">value = iter-&gt;show_value ? (<span class="type">void</span> *)iter-&gt;value : <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查符号是否来自一个内核模块。</span></span><br><span class="line"><span class="keyword">if</span> (iter-&gt;module_name[<span class="number">0</span>]) &#123;</span><br><span class="line"><span class="type">char</span> type;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果符号是导出的，则类型字符大写（全局）；否则小写（局部）。</span></span><br><span class="line">type = iter-&gt;exported ? <span class="built_in">toupper</span>(iter-&gt;type) :</span><br><span class="line"><span class="built_in">tolower</span>(iter-&gt;type);</span><br><span class="line"><span class="comment">// 按“地址 类型 名称 [模块名]”的格式输出。</span></span><br><span class="line">seq_printf(m, <span class="string">&quot;%px %c %s\t[%s]\n&quot;</span>, value,</span><br><span class="line">   type, iter-&gt;name, iter-&gt;module_name);</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line"><span class="comment">// 如果是核心内核符号，则按“地址 类型 名称”的格式输出。</span></span><br><span class="line">seq_printf(m, <span class="string">&quot;%px %c %s\n&quot;</span>, value,</span><br><span class="line">   iter-&gt;type, iter-&gt;name);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义kallsyms的seq_operations结构体，将回调函数与操作关联起来。</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> <span class="title">kallsyms_op</span> =</span> &#123;</span><br><span class="line">.start = s_start,</span><br><span class="line">.next = s_next,</span><br><span class="line">.stop = s_stop,</span><br><span class="line">.show = s_show</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="kallsyms-迭代器实现：模块化符号源的获取"><a href="#kallsyms-迭代器实现：模块化符号源的获取" class="headerlink" title="kallsyms 迭代器实现：模块化符号源的获取"></a>kallsyms 迭代器实现：模块化符号源的获取</h2><p>本代码片段是 Linux 内核 <code>/proc/kallsyms</code> 功能的核心实现部分，它展示了系统如何从多个不同的、动态的符号源中获取符号信息。每个 <code>get_ksymbol_...</code> 函数都专门负责一个特定的符号“域”（如内核模块、Ftrace、BPF 等）。它们共同构成了一个可扩展的责任链，使得 <code>kallsyms</code> 能够将来自不同内核子系统的符号，统一、无缝地整合到同一个符号表中，呈现给用户。</p><h3 id="实现原理分析-3"><a href="#实现原理分析-3" class="headerlink" title="实现原理分析"></a>实现原理分析</h3><p>此机制的核心是一种<strong>基于相对索引的模块化迭代器填充</strong>策略。<code>/proc/kallsyms</code> 的迭代器在遍历时使用一个全局的、连续递增的位置索引 (<code>iter-&gt;pos</code>)。当这个索引超出了核心内核符号的范围后，系统会按预定顺序调用本片段中的函数，每个函数都尝试将这个全局索引映射到自己内部的符号列表。</p><ol><li><p><strong>责任链与边界标记</strong>:</p><ul><li>调用逻辑（在上一段分析的 <code>update_iter_mod</code> 中）形成了一条责任链：先尝试从内核模块获取符号，失败后再尝试 Ftrace，再 BPF，依此类推。</li><li>每个函数在无法找到更多符号时（即其内部接口返回错误），会执行一个关键操作：<code>iter-&gt;pos_..._end = iter-&gt;pos;</code>。它将当前的全局位置 <code>pos</code> 记录为自己这个符号域的“末端边界”。这个边界标记会通知上层调用者，下次处理更大的 <code>pos</code> 值时，可以直接跳过对这个已遍历完毕的域的查询，从而高效地转向下一个符号域。</li></ul></li><li><p><strong>相对索引计算</strong>:</p><ul><li>每个 <code>get_ksymbol_...</code> 函数在调用其后端的符号获取接口时，都使用了<strong>相对索引</strong>。例如，<code>get_ksymbol_mod</code> 使用 <code>iter-&gt;pos - kallsyms_num_syms</code> 作为传递给 <code>module_get_kallsym</code> 的索引。这意味着它请求的是“模块符号列表中的第 N 个符号”，而不是全局 <code>kallsyms</code> 列表中的第 <code>pos</code> 个。同样，<code>get_ksymbol_bpf</code> 使用 <code>iter-&gt;pos - iter-&gt;pos_ftrace_mod_end</code>，是基于上一个符号域的结束位置来计算自己在 BPF 符号列表中的相对索引。</li><li>这种设计极大地解耦了各个符号源。每个子系统（模块、BPF等）只需提供一个能通过从 0 开始的索引来查找其内部符号的接口，而无需关心全局的符号布局。</li></ul></li><li><p><strong>统一的迭代器接口</strong>: 所有这些函数都操作于同一个 <code>struct kallsym_iter *iter</code> 结构体。它们成功获取到符号后，会将符号的地址、类型、名称、所属模块名等信息填充到这个迭代器的相应字段中。这使得上层的 <code>s_show</code> 函数可以用统一的方式来格式化并输出来自任何源的符号。</p></li></ol><h3 id="代码分析-3"><a href="#代码分析-3" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 从已加载的内核模块中获取一个符号。</span></span><br><span class="line"><span class="comment"> * @param iter 指向kallsyms迭代器的指针。</span></span><br><span class="line"><span class="comment"> * @return 成功获取符号则返回1，否则返回0。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_ksymbol_mod</span><span class="params">(<span class="keyword">struct</span> kallsym_iter *iter)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 调用模块子系统的接口来获取符号。</span></span><br><span class="line"><span class="comment">// 使用全局位置减去核心符号总数，得到在模块符号列表中的相对索引。</span></span><br><span class="line"><span class="type">int</span> ret = module_get_kallsym(iter-&gt;pos - kallsyms_num_syms,</span><br><span class="line">     &amp;iter-&gt;value, &amp;iter-&gt;type,</span><br><span class="line">     iter-&gt;name, iter-&gt;module_name,</span><br><span class="line">     &amp;iter-&gt;exported);</span><br><span class="line"><span class="comment">// 如果获取失败（已到达模块符号列表的末尾）。</span></span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 将当前位置记录为模块符号域的结束边界。</span></span><br><span class="line">iter-&gt;pos_mod_end = iter-&gt;pos;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 从Ftrace的动态符号中获取一个符号。</span></span><br><span class="line"><span class="comment"> * @param iter 指向kallsyms迭代器的指针。</span></span><br><span class="line"><span class="comment"> * @return 成功获取符号则返回1，否则返回0。</span></span><br><span class="line"><span class="comment"> * @note ftrace_mod_get_kallsym() 也可能获取为ftrace目的分配的页面中的符号。</span></span><br><span class="line"><span class="comment"> *       在这种情况下，&quot;__builtin__ftrace&quot;被用作模块名，尽管它并非一个真正的模块。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_ksymbol_ftrace_mod</span><span class="params">(<span class="keyword">struct</span> kallsym_iter *iter)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 调用Ftrace子系统的接口来获取符号。</span></span><br><span class="line"><span class="comment">// 使用全局位置减去上一个域（模块）的结束位置，得到相对索引。</span></span><br><span class="line"><span class="type">int</span> ret = ftrace_mod_get_kallsym(iter-&gt;pos - iter-&gt;pos_mod_end,</span><br><span class="line"> &amp;iter-&gt;value, &amp;iter-&gt;type,</span><br><span class="line"> iter-&gt;name, iter-&gt;module_name,</span><br><span class="line"> &amp;iter-&gt;exported);</span><br><span class="line"><span class="comment">// 如果获取失败。</span></span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 将当前位置记录为Ftrace符号域的结束边界。</span></span><br><span class="line">iter-&gt;pos_ftrace_mod_end = iter-&gt;pos;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 从BPF程序中获取一个符号。</span></span><br><span class="line"><span class="comment"> * @param iter 指向kallsyms迭代器的指针。</span></span><br><span class="line"><span class="comment"> * @return 成功获取符号则返回1，否则返回0。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_ksymbol_bpf</span><span class="params">(<span class="keyword">struct</span> kallsym_iter *iter)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BPF符号统一属于&quot;bpf&quot;伪模块。</span></span><br><span class="line">strscpy(iter-&gt;module_name, <span class="string">&quot;bpf&quot;</span>, MODULE_NAME_LEN);</span><br><span class="line"><span class="comment">// BPF符号默认不是导出的。</span></span><br><span class="line">iter-&gt;exported = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 调用BPF子系统的接口来获取符号。</span></span><br><span class="line"><span class="comment">// 使用全局位置减去上一个域（Ftrace）的结束位置，得到相对索引。</span></span><br><span class="line">ret = bpf_get_kallsym(iter-&gt;pos - iter-&gt;pos_ftrace_mod_end,</span><br><span class="line">      &amp;iter-&gt;value, &amp;iter-&gt;type,</span><br><span class="line">      iter-&gt;name);</span><br><span class="line"><span class="comment">// 如果获取失败。</span></span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 将当前位置记录为BPF符号域的结束边界。</span></span><br><span class="line">iter-&gt;pos_bpf_end = iter-&gt;pos;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 从Kprobes中获取一个符号。</span></span><br><span class="line"><span class="comment"> * @param iter 指向kallsyms迭代器的指针。</span></span><br><span class="line"><span class="comment"> * @return 成功获取符号则返回1，否则返回0。</span></span><br><span class="line"><span class="comment"> * @note 这会使用&quot;__builtin__kprobes&quot;作为模块名，尽管它不是一个真正的模块。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_ksymbol_kprobe</span><span class="params">(<span class="keyword">struct</span> kallsym_iter *iter)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Kprobe符号统一属于&quot;__builtin__kprobes&quot;伪模块。</span></span><br><span class="line">strscpy(iter-&gt;module_name, <span class="string">&quot;__builtin__kprobes&quot;</span>, MODULE_NAME_LEN);</span><br><span class="line">iter-&gt;exported = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 调用Kprobe子系统的接口来获取符号，并直接判断返回值。</span></span><br><span class="line"><span class="comment">// 使用全局位置减去上一个域（BPF）的结束位置，得到相对索引。</span></span><br><span class="line"><span class="keyword">return</span> kprobe_get_kallsym(iter-&gt;pos - iter-&gt;pos_bpf_end,</span><br><span class="line">  &amp;iter-&gt;value, &amp;iter-&gt;type,</span><br><span class="line">  iter-&gt;name) &lt; <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 从核心内核的静态符号表中获取一个符号。</span></span><br><span class="line"><span class="comment"> * @param iter 指向kallsyms迭代器的指针。</span></span><br><span class="line"><span class="comment"> * @return 在压缩符号流中处理过的字节数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">get_ksymbol_core</span><span class="params">(<span class="keyword">struct</span> kallsym_iter *iter)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> off = iter-&gt;nameoff; <span class="comment">// 获取当前在压缩流中的偏移量。</span></span><br><span class="line"></span><br><span class="line">iter-&gt;module_name[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 核心符号没有模块名。</span></span><br><span class="line"><span class="comment">// 根据逻辑位置（行号）获取符号的地址。</span></span><br><span class="line">iter-&gt;value = kallsyms_sym_address(iter-&gt;pos);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据压缩流偏移量获取符号的类型字符。</span></span><br><span class="line">iter-&gt;type = kallsyms_get_symbol_type(off);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从压缩流中解压出符号的名称。</span></span><br><span class="line">off = kallsyms_expand_symbol(off, iter-&gt;name, ARRAY_SIZE(iter-&gt;name));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回本次解析消耗的字节数，用于更新下一次的偏移量。</span></span><br><span class="line"><span class="keyword">return</span> off - iter-&gt;nameoff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="kallsyms-符号解压与地址查找"><a href="#kallsyms-符号解压与地址查找" class="headerlink" title="kallsyms 符号解压与地址查找"></a>kallsyms 符号解压与地址查找</h2><p>本代码片段揭示了 Linux 内核 <code>kallsyms</code> 子系统为节省内存而采用的一套复杂而高效的符号信息存储与检索机制。其核心功能是：通过 <code>get_symbol_offset</code> 在一个预排序的符号列表中进行两级快速查找；通过 <code>kallsyms_sym_address</code> 计算出符号的运行时地址；并通过 <code>kallsyms_expand_symbol</code> 将一种基于“字典-令牌”的高度压缩的名称数据解压为人类可读的字符串。</p><h3 id="实现原理分析-4"><a href="#实现原理分析-4" class="headerlink" title="实现原理分析"></a>实现原理分析</h3><p>此机制通过多种数据压缩和空间换时间的技巧，实现了在有限内存中存储大量符号信息的目标。</p><ol><li><p><strong>符号地址的相对存储 (<code>kallsyms_sym_address</code>)</strong>: 内核并不为每个符号存储一个完整的 32 位或 64 位地址。相反，它存储一个全局的 <code>kallsyms_relative_base</code> 基地址，以及一个 <code>kallsyms_offsets</code> 数组，其中每个元素都是一个相对于该基地址的 32 位偏移量。这在 64 位系统上尤其能节省大量空间。<code>kallsyms_sym_address</code> 的工作就是简单地将基地址与指定索引的偏移量相加，得到最终的符号地址。</p></li><li><p><strong>符号名称的两级查找定位 (<code>get_symbol_offset</code>)</strong>: 内核所有符号的名称被压缩后存放在一个巨大的字节数组 <code>kallsyms_names</code> 中。为了能快速定位到第 N 个符号的压缩数据，内核采用了一个两级查找策略：</p><ul><li><strong>一级索引（Markers）</strong>: <code>kallsyms_markers</code> 数组是一个稀疏索引。<code>kallsyms_markers[i]</code> 存储了第 <code>i * 256</code> 个符号在 <code>kallsyms_names</code> 中的起始偏移量。这允许函数通过 <code>pos &gt;&gt; 8</code> 立即跳转到离目标非常近的位置，跳过大量不相关的符号。</li><li><strong>二级扫描</strong>: 从标记点开始，函数再对最多 255 个符号（<code>pos &amp; 0xFF</code>）进行线性扫描，通过解析每个符号的变长长度字段来逐个跳过，最终精确定位到目标符号。</li></ul></li><li><p><strong>名称的字典-令牌压缩与解压 (<code>kallsyms_expand_symbol</code>)</strong>: 这是最精妙的部分。符号名称本身并非以 ASCII 码存储，而是被高度压缩了：</p><ul><li><strong>字典（Token Table）</strong>: 内核在编译时会分析所有符号名，并抽取出最高频出现的字符串片段（如 “spin_lock”, “<em>irq”, “device</em>“)，形成一个 <code>kallsyms_token_table</code>。</li><li><strong>令牌（Tokens）</strong>: <code>kallsyms_names</code> 中存储的不再是字符，而是一系列“令牌索引”。</li><li><strong>解压过程</strong>: <code>kallsyms_expand_symbol</code> 在解压时，会读取这些令牌索引，然后用这些索引去 <code>kallsyms_token_index</code> 和 <code>kallsyms_token_table</code> 中查找对应的字符串片段，最后将这些片段拼接起来，还原出原始的符号名。</li></ul></li><li><p><strong>符号类型的嵌入式存储 (<code>kallsyms_get_symbol_type</code>)</strong>: 为了进一步节省空间，符号的类型字符（如 ‘T’, ‘t’, ‘d’）并没有被单独存储。它被巧妙地编码为符号名称的<strong>第一个令牌的第一个字符</strong>。<code>kallsyms_get_symbol_type</code> 函数正是利用了这一点，它只解压第一个令牌并返回其首字符，从而以极低的成本获取到符号类型。</p></li></ol><h3 id="代码分析-4"><a href="#代码分析-4" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 将一个压缩的符号数据解压成未压缩的字符串。</span></span><br><span class="line"><span class="comment"> * @param off 符号在压缩流 kallsyms_names 中的起始偏移量。</span></span><br><span class="line"><span class="comment"> * @param result 用于存储解压后字符串的缓冲区。</span></span><br><span class="line"><span class="comment"> * @param maxlen 结果缓冲区的最大长度。</span></span><br><span class="line"><span class="comment"> * @return 压缩流中下一个符号的起始偏移量。</span></span><br><span class="line"><span class="comment"> * @note 如果解压后的字符串超过maxlen，它将被截断。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">kallsyms_expand_symbol</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> off,</span></span><br><span class="line"><span class="params">   <span class="type">char</span> *result, <span class="type">size_t</span> maxlen)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> len, skipped_first = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *tptr;</span><br><span class="line"><span class="type">const</span> u8 *data;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从第一个字节获取压缩符号的长度。</span></span><br><span class="line">data = &amp;kallsyms_names[off];</span><br><span class="line">len = *data;</span><br><span class="line">data++;</span><br><span class="line">off++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果最高有效位(MSB)为1，表示这是一个&quot;大&quot;符号，需要一个额外的字节来表示长度。</span></span><br><span class="line"><span class="keyword">if</span> ((len &amp; <span class="number">0x80</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">len = (len &amp; <span class="number">0x7F</span>) | (*data &lt;&lt; <span class="number">7</span>);</span><br><span class="line">data++;</span><br><span class="line">off++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新偏移量，使其指向压缩流中下一个符号的开始位置。</span></span><br><span class="line">off += len;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历压缩符号数据中的每一个字节（令牌索引）。</span></span><br><span class="line"><span class="keyword">while</span> (len) &#123;</span><br><span class="line"><span class="comment">// 使用令牌索引从令牌表中间接找到对应的字符串片段。</span></span><br><span class="line">tptr = &amp;kallsyms_token_table[kallsyms_token_index[*data]];</span><br><span class="line">data++;</span><br><span class="line">len--;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历字符串片段中的每个字符。</span></span><br><span class="line"><span class="keyword">while</span> (*tptr) &#123;</span><br><span class="line"><span class="comment">// 第一个令牌的第一个字符是符号类型，需要跳过。</span></span><br><span class="line"><span class="keyword">if</span> (skipped_first) &#123;</span><br><span class="line"><span class="keyword">if</span> (maxlen &lt;= <span class="number">1</span>)</span><br><span class="line"><span class="keyword">goto</span> tail; <span class="comment">// 缓冲区不足，跳转到末尾处理。</span></span><br><span class="line">*result = *tptr;</span><br><span class="line">result++;</span><br><span class="line">maxlen--;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">skipped_first = <span class="number">1</span>;</span><br><span class="line">tptr++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tail:</span><br><span class="line"><span class="comment">// 为结果字符串添加空终止符。</span></span><br><span class="line"><span class="keyword">if</span> (maxlen)</span><br><span class="line">*result = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回下一个符号的偏移量。</span></span><br><span class="line"><span class="keyword">return</span> off;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 获取符号的类型信息。</span></span><br><span class="line"><span class="comment"> * @param off 符号在压缩流中的起始偏移量。</span></span><br><span class="line"><span class="comment"> * @return 符号的类型字符（如 &#x27;T&#x27;, &#x27;t&#x27; 等）。</span></span><br><span class="line"><span class="comment"> * @note 类型被编码为符号名称的第一个令牌的第一个字符。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> <span class="title function_">kallsyms_get_symbol_type</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> off)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 只获取第一个编码字节，在令牌表中查找它，</span></span><br><span class="line"><span class="comment"> * 然后返回该令牌的第一个字符。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">return</span> kallsyms_token_table[kallsyms_token_index[kallsyms_names[off + <span class="number">1</span>]]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 根据符号的逻辑索引号，计算其在压缩符号名称流中的字节偏移量。</span></span><br><span class="line"><span class="comment"> * @param pos 符号的逻辑索引号（例如，第1000个符号）。</span></span><br><span class="line"><span class="comment"> * @return 该符号在 kallsyms_names 数组中的字节偏移量。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">get_symbol_offset</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> pos)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> u8 *name;</span><br><span class="line"><span class="type">int</span> i, len;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [一级查找] 使用 markers 数组进行粗粒度定位，快速跳转到附近。</span></span><br><span class="line">name = &amp;kallsyms_names[kallsyms_markers[pos &gt;&gt; <span class="number">8</span>]];</span><br><span class="line"></span><br><span class="line"><span class="comment">// [二级查找] 从标记点开始，顺序扫描余下的符号（最多255个）。</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (pos &amp; <span class="number">0xFF</span>); i++) &#123;</span><br><span class="line">len = *name; <span class="comment">// 第一个字节是长度。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理可变长度编码。</span></span><br><span class="line"><span class="keyword">if</span> ((len &amp; <span class="number">0x80</span>) != <span class="number">0</span>)</span><br><span class="line">len = ((len &amp; <span class="number">0x7F</span>) | (name[<span class="number">1</span>] &lt;&lt; <span class="number">7</span>)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将指针移动到下一个符号的起始处。</span></span><br><span class="line">name = name + len + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回最终计算出的精确偏移量。</span></span><br><span class="line"><span class="keyword">return</span> name - kallsyms_names;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 获取指定索引号的符号的运行时内存地址。</span></span><br><span class="line"><span class="comment"> * @param idx 符号的逻辑索引号。</span></span><br><span class="line"><span class="comment"> * @return 符号的绝对内存地址。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">kallsyms_sym_address</span><span class="params">(<span class="type">int</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 地址 = 内核相对基地址 + 符号的32位偏移量。</span></span><br><span class="line"><span class="keyword">return</span> kallsyms_relative_base + (u32)kallsyms_offsets[idx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="kernel-ksyms-common-c"><a href="#kernel-ksyms-common-c" class="headerlink" title="kernel&#x2F;ksyms_common.c"></a>kernel&#x2F;ksyms_common.c</h1><h2 id="kallsyms-show-value-内核符号地址的权限控制"><a href="#kallsyms-show-value-内核符号地址的权限控制" class="headerlink" title="kallsyms_show_value: 内核符号地址的权限控制"></a>kallsyms_show_value: 内核符号地址的权限控制</h2><p>本代码片段定义了决定是否在 <code>/proc/kallsyms</code> 的输出中显示内核符号地址（即内存地址值）的核心安全策略。其主要功能是通过 <code>kallsyms_show_value</code> 函数，根据系统范围的配置参数（<code>kptr_restrict</code> 和 <code>sysctl_perf_event_paranoid</code>）以及发起读取请求的进程所拥有的能力（<code>CAP_SYSLOG</code>），来动态地决定是否向该进程暴露内核指针。</p><h3 id="实现原理分析-5"><a href="#实现原理分析-5" class="headerlink" title="实现原理分析"></a>实现原理分析</h3><p>此安全策略的实现是一种典型的、分层级的权限检查模型，它允许系统管理员根据安全需求在不同的严格等级之间进行选择。</p><ol><li><p><strong>核心控制旋钮 (<code>kptr_restrict</code>)</strong>: <code>kallsyms_show_value</code> 函数的行为主要由 <code>kptr_restrict</code> 这个 <code>sysctl</code> 参数驱动，它定义了三种不同的策略：</p><ul><li><strong><code>kptr_restrict = 2</code> (最严格)</strong>: 这是 <code>switch</code> 语句的 <code>default</code> 情况。在此模式下，函数总是返回 <code>false</code>，即使用户是 <code>root</code>（拥有所有能力），也无法看到内核地址。地址会被显示为 <code>0000000000000000</code>。</li><li><strong><code>kptr_restrict = 1</code> (默认)</strong>: 在此模式下，函数会通过 <code>security_capable</code> 检查当前进程是否拥有 <code>CAP_SYSLOG</code> 能力。通常只有 <code>root</code> 用户或被特意授权的进程才拥有此能力。检查通过则返回 <code>true</code>，允许显示地址。</li><li><strong><code>kptr_restrict = 0</code> (最宽松)</strong>: 在此模式下，权限检查的逻辑通过 <code>fallthrough</code> 关键字被扩展了。它首先调用 <code>kallsyms_for_perf()</code> 进行一个额外的检查。</li></ul></li><li><p><strong>为性能分析工具开放特例 (<code>kallsyms_for_perf</code>)</strong>: 这个辅助函数是为了方便 <code>perf</code> 等性能分析工具的使用而设计的。这些工具需要内核符号地址来进行正确的符号解析，但运行它们的用户可能不是 <code>root</code>。此函数会检查另一个 <code>sysctl</code> 参数 <code>sysctl_perf_event_paranoid</code>。</p><ul><li>如果 <code>sysctl_perf_event_paranoid &lt;= 1</code>，意味着系统管理员允许非特权用户进行性能分析，此时函数返回 <code>true</code>。</li><li>结合 <code>kptr_restrict = 0</code>，这意味着即使用户没有 <code>CAP_SYSLOG</code>，只要 <code>perf</code> 的偏执等级设置得足够低，他也能看到内核符号地址。</li><li>如果 <code>kallsyms_for_perf()</code> 返回 <code>false</code>，<code>switch</code> 语句会因为 <code>fallthrough</code> 而继续执行 <code>case 1</code> 的逻辑，即退回到检查 <code>CAP_SYSLOG</code>。</li></ul></li></ol><p>综上，整个决策流程是：首先看 <code>kptr_restrict</code> 的等级，如果等级允许，再根据具体情况检查 <code>perf</code> 配置或 <code>CAP_SYSLOG</code> 能力。</p><h3 id="代码分析-5"><a href="#代码分析-5" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-2.0-only</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ksyms_common.c: 从 kernel/kallsyms.c 中分离出的部分</span></span><br><span class="line"><span class="comment"> * 包含一些独立于 KALLSYMS 配置的通用函数定义。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kallsyms.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/security.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// kallsyms_for_perf: 检查系统配置是否允许为性能分析工具（如perf）显示符号。</span></span><br><span class="line"><span class="comment">// 返回值: 1 表示允许, 0 表示不允许。</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">kallsyms_for_perf</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 仅在内核编译时配置了PERF_EVENTS时，此逻辑才有效。</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PERF_EVENTS</span></span><br><span class="line"><span class="comment">// 引用在别处定义的perf事件偏执等级sysctl变量。</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> sysctl_perf_event_paranoid;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果perf的偏执等级小于等于1（即允许用户进行内核分析），则返回1。</span></span><br><span class="line"><span class="keyword">if</span> (sysctl_perf_event_paranoid &lt;= <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">// 默认或在更高偏执等级下，返回0。</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如果我们已经启用了内核分析并且明确地不处于偏执状态（即kptr_restrict</span></span><br><span class="line"><span class="comment"> * 已清除，并且sysctl_perf_event_paranoid未设置），我们甚至向普通用户</span></span><br><span class="line"><span class="comment"> * 显示kallsyms信息。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 否则，要求拥有CAP_SYSLOG能力（假设kptr_restrict没有设置到</span></span><br><span class="line"><span class="comment"> * 连这也阻止的程度）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// kallsyms_show_value: 判断是否应该向特定进程显示内核符号的地址值。</span></span><br><span class="line"><span class="comment">// @cred: 指向当前进程凭证结构体的常量指针。</span></span><br><span class="line"><span class="comment">// 返回值: true 表示应该显示, false 表示不应显示（显示为0）。</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">kallsyms_show_value</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> cred *cred)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 根据系统sysctl参数kptr_restrict的值来决定策略。</span></span><br><span class="line"><span class="keyword">switch</span> (kptr_restrict) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// 最宽松的模式。</span></span><br><span class="line"><span class="comment">// 检查是否满足为perf工具显示的条件。</span></span><br><span class="line"><span class="keyword">if</span> (kallsyms_for_perf())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 如果满足，则直接允许。</span></span><br><span class="line">fallthrough; <span class="comment">// 否则，继续执行case 1的检查逻辑。</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// 默认模式。</span></span><br><span class="line"><span class="comment">// 检查当前进程是否拥有CAP_SYSLOG能力。</span></span><br><span class="line"><span class="comment">// security_capable返回0表示拥有该能力。</span></span><br><span class="line"><span class="keyword">if</span> (security_capable(cred, &amp;init_user_ns, CAP_SYSLOG,</span><br><span class="line">     CAP_OPT_NOAUDIT) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 如果拥有，则允许。</span></span><br><span class="line">fallthrough; <span class="comment">// 否则，继续执行default的逻辑。</span></span><br><span class="line"><span class="keyword">default</span>: <span class="comment">// 包括case 2及以上，最严格的模式。</span></span><br><span class="line"><span class="comment">// 总是拒绝显示地址。</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;

&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;kernel-kallsyms-c-内核符号表-Kernel-Symbols-运行时内核符号解析&quot;&gt;&lt;a href=&quot;#kernel-kall</summary>
      
    
    
    
    <category term="linux" scheme="https://wdfk-prog.space/categories/linux/"/>
    
    <category term="kernel" scheme="https://wdfk-prog.space/categories/linux/kernel/"/>
    
    
    <category term="linux" scheme="https://wdfk-prog.space/tags/linux/"/>
    
    <category term="kernel" scheme="https://wdfk-prog.space/tags/kernel/"/>
    
  </entry>
  
  <entry>
    <title>clockevents</title>
    <link href="https://wdfk-prog.space/posts/df20a2f0/"/>
    <id>https://wdfk-prog.space/posts/df20a2f0/</id>
    <published>2025-10-06T03:28:50.000Z</published>
    <updated>2025-10-06T03:31:43.465Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="kernel-time-clockevents-c"><a href="#kernel-time-clockevents-c" class="headerlink" title="kernel&#x2F;time&#x2F;clockevents.c"></a>kernel&#x2F;time&#x2F;clockevents.c</h1><h2 id="clockevents-switch-state-设置时钟事件设备的运行状态"><a href="#clockevents-switch-state-设置时钟事件设备的运行状态" class="headerlink" title="clockevents_switch_state - 设置时钟事件设备的运行状态"></a>clockevents_switch_state - 设置时钟事件设备的运行状态</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __clockevents_switch_state(<span class="keyword">struct</span> clock_event_device *dev,</span><br><span class="line">      <span class="keyword">enum</span> clock_event_state state)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (dev-&gt;features &amp; CLOCK_EVT_FEAT_DUMMY)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Transition with new state-specific callbacks */</span></span><br><span class="line"><span class="keyword">switch</span> (state) &#123;</span><br><span class="line"><span class="keyword">case</span> CLOCK_EVT_STATE_DETACHED:</span><br><span class="line"><span class="comment">/* The clockevent device is getting replaced. Shut it down. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> CLOCK_EVT_STATE_SHUTDOWN:</span><br><span class="line"><span class="keyword">if</span> (dev-&gt;set_state_shutdown)</span><br><span class="line"><span class="keyword">return</span> dev-&gt;set_state_shutdown(dev);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> CLOCK_EVT_STATE_PERIODIC:</span><br><span class="line"><span class="comment">/* Core internal bug */</span></span><br><span class="line"><span class="keyword">if</span> (!(dev-&gt;features &amp; CLOCK_EVT_FEAT_PERIODIC))</span><br><span class="line"><span class="keyword">return</span> -ENOSYS;</span><br><span class="line"><span class="keyword">if</span> (dev-&gt;set_state_periodic)</span><br><span class="line"><span class="keyword">return</span> dev-&gt;set_state_periodic(dev);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> CLOCK_EVT_STATE_ONESHOT:</span><br><span class="line"><span class="comment">/* Core internal bug */</span></span><br><span class="line"><span class="keyword">if</span> (!(dev-&gt;features &amp; CLOCK_EVT_FEAT_ONESHOT))</span><br><span class="line"><span class="keyword">return</span> -ENOSYS;</span><br><span class="line"><span class="keyword">if</span> (dev-&gt;set_state_oneshot)</span><br><span class="line"><span class="keyword">return</span> dev-&gt;set_state_oneshot(dev);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> CLOCK_EVT_STATE_ONESHOT_STOPPED:</span><br><span class="line"><span class="comment">/* Core internal bug */</span></span><br><span class="line"><span class="keyword">if</span> (WARN_ONCE(!clockevent_state_oneshot(dev),</span><br><span class="line">      <span class="string">&quot;Current state: %d\n&quot;</span>,</span><br><span class="line">      clockevent_get_state(dev)))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dev-&gt;set_state_oneshot_stopped)</span><br><span class="line"><span class="keyword">return</span> dev-&gt;set_state_oneshot_stopped(dev);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> -ENOSYS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> -ENOSYS;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * clockevents_switch_state - 设置时钟事件设备的运行状态</span></span><br><span class="line"><span class="comment"> * @dev：设备修改</span></span><br><span class="line"><span class="comment"> * @state：新状态</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 必须在禁用中断的情况下调用！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clockevents_switch_state</span><span class="params">(<span class="keyword">struct</span> clock_event_device *dev,</span></span><br><span class="line"><span class="params">      <span class="keyword">enum</span> clock_event_state state)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (clockevent_get_state(dev) != state) &#123;</span><br><span class="line"><span class="keyword">if</span> (__clockevents_switch_state(dev, state))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">clockevent_set_state(dev, state);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A nsec2cyc multiplicator of 0 is invalid and we&#x27;d crash</span></span><br><span class="line"><span class="comment"> * on it, so fix it up and emit a warning:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (clockevent_state_oneshot(dev)) &#123;</span><br><span class="line"><span class="keyword">if</span> (WARN_ON(!dev-&gt;mult))</span><br><span class="line">dev-&gt;mult = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="clockevents-config-Clockevents-配置"><a href="#clockevents-config-Clockevents-配置" class="headerlink" title="clockevents_config Clockevents 配置"></a>clockevents_config Clockevents 配置</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">clockevents_config</span><span class="params">(<span class="keyword">struct</span> clock_event_device *dev, u32 freq)</span></span><br><span class="line">&#123;</span><br><span class="line">u64 sec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(dev-&gt;features &amp; CLOCK_EVT_FEAT_ONESHOT))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 计算我们可以睡觉的最大秒数。</span></span><br><span class="line"><span class="comment"> * 对于可以编程超过 32 位时钟周期的硬件，限制为 10 分钟，</span></span><br><span class="line"><span class="comment"> * 因此我们仍然可以获得合理的转换值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">sec = dev-&gt;max_delta_ticks;</span><br><span class="line">do_div(sec, freq);</span><br><span class="line"><span class="keyword">if</span> (!sec)</span><br><span class="line">sec = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sec &gt; <span class="number">600</span> &amp;&amp; dev-&gt;max_delta_ticks &gt; UINT_MAX)</span><br><span class="line">sec = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line">clockevents_calc_mult_shift(dev, freq, sec);</span><br><span class="line">dev-&gt;min_delta_ns = cev_delta2ns(dev-&gt;min_delta_ticks, dev, <span class="literal">false</span>);</span><br><span class="line">dev-&gt;max_delta_ns = cev_delta2ns(dev-&gt;max_delta_ticks, dev, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="clockevents-register-device-注册一个时钟事件设备"><a href="#clockevents-register-device-注册一个时钟事件设备" class="headerlink" title="clockevents_register_device 注册一个时钟事件设备"></a>clockevents_register_device 注册一个时钟事件设备</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * clockevents_register_device - 注册一个时钟事件设备</span></span><br><span class="line"><span class="comment"> * @dev：要注册的设备</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clockevents_register_device</span><span class="params">(<span class="keyword">struct</span> clock_event_device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将状态初始化为 DETACHED */</span></span><br><span class="line">clockevent_set_state(dev, CLOCK_EVT_STATE_DETACHED);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!dev-&gt;cpumask) &#123;</span><br><span class="line">WARN_ON(num_possible_cpus() &gt; <span class="number">1</span>);</span><br><span class="line">dev-&gt;cpumask = cpumask_of(smp_processor_id());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dev-&gt;cpumask == cpu_all_mask) &#123;</span><br><span class="line">WARN(<span class="number">1</span>, <span class="string">&quot;%s cpumask == cpu_all_mask, using cpu_possible_mask instead\n&quot;</span>,</span><br><span class="line">     dev-&gt;name);</span><br><span class="line">dev-&gt;cpumask = cpu_possible_mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">raw_spin_lock_irqsave(&amp;clockevents_lock, flags);</span><br><span class="line"><span class="comment">/* 添加设备到全局列表 */</span></span><br><span class="line">list_add(&amp;dev-&gt;<span class="built_in">list</span>, &amp;clockevent_devices);</span><br><span class="line"><span class="comment">/*  检查新注册的设备是否可以用于当前的时钟事件管理 */</span></span><br><span class="line">tick_check_new_device(dev);</span><br><span class="line"><span class="comment">/* 通知系统释放的时钟事件设备，可能用于重新分配或更新设备状态 */</span></span><br><span class="line">clockevents_notify_released();</span><br><span class="line"></span><br><span class="line">raw_spin_unlock_irqrestore(&amp;clockevents_lock, flags);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(clockevents_register_device);</span><br></pre></td></tr></table></figure><h2 id="clockevents-init-配置和注册时钟事件设备"><a href="#clockevents-init-配置和注册时钟事件设备" class="headerlink" title="clockevents_init 配置和注册时钟事件设备"></a>clockevents_init 配置和注册时钟事件设备</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * clockevents_config_and_register - 配置和注册时钟事件设备</span></span><br><span class="line"><span class="comment"> * @dev：要注册的设备</span></span><br><span class="line"><span class="comment"> * @freq：时钟频率</span></span><br><span class="line"><span class="comment"> * @min_delta：在 oneshot 模式下编程的最小时钟滴答声</span></span><br><span class="line"><span class="comment"> * @max_delta：在 oneshot 模式下编程的最大时钟滴答声</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * min/max_delta 对于不支持 oneshot 模式的设备，可以是 0。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clockevents_config_and_register</span><span class="params">(<span class="keyword">struct</span> clock_event_device *dev,</span></span><br><span class="line"><span class="params">     u32 freq, <span class="type">unsigned</span> <span class="type">long</span> min_delta,</span></span><br><span class="line"><span class="params">     <span class="type">unsigned</span> <span class="type">long</span> max_delta)</span></span><br><span class="line">&#123;</span><br><span class="line">dev-&gt;min_delta_ticks = min_delta;</span><br><span class="line">dev-&gt;max_delta_ticks = max_delta;</span><br><span class="line">clockevents_config(dev, freq);</span><br><span class="line">clockevents_register_device(dev);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(clockevents_config_and_register);</span><br></pre></td></tr></table></figure><h2 id="clockevents-shutdown-关闭设备并清除next-event"><a href="#clockevents-shutdown-关闭设备并清除next-event" class="headerlink" title="clockevents_shutdown 关闭设备并清除next_event"></a>clockevents_shutdown 关闭设备并清除next_event</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* clockevents_shutdown - 关闭设备并清除next_event</span></span><br><span class="line"><span class="comment"> * @dev：设备关机</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clockevents_shutdown</span><span class="params">(<span class="keyword">struct</span> clock_event_device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">clockevents_switch_state(dev, CLOCK_EVT_STATE_SHUTDOWN);</span><br><span class="line">dev-&gt;next_event = KTIME_MAX;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="clockevents-exchange-device-释放和请求时钟设备"><a href="#clockevents-exchange-device-释放和请求时钟设备" class="headerlink" title="clockevents_exchange_device 释放和请求时钟设备"></a>clockevents_exchange_device 释放和请求时钟设备</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * clockevents_exchange_device - 释放和请求时钟设备</span></span><br><span class="line"><span class="comment"> * @old：要释放的设备（可以是 NULL）</span></span><br><span class="line"><span class="comment"> * @new：要请求的设备（可以为 NULL）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 从各种 tick 函数中调用，同时保持 clockevents_lock 并禁用中断。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clockevents_exchange_device</span><span class="params">(<span class="keyword">struct</span> clock_event_device *old,</span></span><br><span class="line"><span class="params"> <span class="keyword">struct</span> clock_event_device *new)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 调用方释放一个 clock event device。我们将其排入 released 列表中，并在稍后执行通知添加。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (old) &#123;</span><br><span class="line">module_put(old-&gt;owner);</span><br><span class="line">clockevents_switch_state(old, CLOCK_EVT_STATE_DETACHED);</span><br><span class="line">list_move(&amp;old-&gt;<span class="built_in">list</span>, &amp;clockevents_released);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (new) &#123;</span><br><span class="line">BUG_ON(!clockevent_state_detached(new));</span><br><span class="line">clockevents_shutdown(new);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="clockevents-program-event-重新编程-clock-event-device"><a href="#clockevents-program-event-重新编程-clock-event-device" class="headerlink" title="clockevents_program_event 重新编程 clock event device"></a>clockevents_program_event 重新编程 clock event device</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * clockevents_program_event - 重新编程 clock event device。</span></span><br><span class="line"><span class="comment"> * @dev：设备到程序</span></span><br><span class="line"><span class="comment"> * @expires：绝对到期时间（单调时钟）</span></span><br><span class="line"><span class="comment"> * @force：如果过期时程序最小延迟无法设置</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 成功时返回 0，如果事件过去，则返回 -ETIME。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">clockevents_program_event</span><span class="params">(<span class="keyword">struct</span> clock_event_device *dev, <span class="type">ktime_t</span> expires,</span></span><br><span class="line"><span class="params">      <span class="type">bool</span> force)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> clc;</span><br><span class="line"><span class="type">int64_t</span> delta;</span><br><span class="line"><span class="type">int</span> rc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (WARN_ON_ONCE(expires &lt; <span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span> -ETIME;</span><br><span class="line"></span><br><span class="line">dev-&gt;next_event = expires;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (clockevent_state_shutdown(dev))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 我们这里必须处于 ONESHOT 状态*/</span></span><br><span class="line">WARN_ONCE(!clockevent_state_oneshot(dev), <span class="string">&quot;Current state: %d\n&quot;</span>,</span><br><span class="line">  clockevent_get_state(dev));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 可以处理 ktime 的 clockevent 设备的快捷方式。*/</span></span><br><span class="line"><span class="keyword">if</span> (dev-&gt;features &amp; CLOCK_EVT_FEAT_KTIME)</span><br><span class="line"><span class="keyword">return</span> dev-&gt;set_next_ktime(expires, dev);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 计算当前时间与到期时间之间的时间增量 delta（以纳秒为单位 */</span></span><br><span class="line">delta = ktime_to_ns(ktime_sub(expires, ktime_get()));</span><br><span class="line"><span class="keyword">if</span> (delta &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="comment">/* 如果增量小于等于零，表示事件已经过期。</span></span><br><span class="line"><span class="comment"> * 如果 force 标志为真，则调用 clockevents_program_min_delta </span></span><br><span class="line"><span class="comment"> * 设置最小延迟； */</span></span><br><span class="line"><span class="keyword">return</span> force ? clockevents_program_min_delta(dev) : -ETIME;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 限制时间增量范围 */</span></span><br><span class="line">delta = min(delta, (<span class="type">int64_t</span>) dev-&gt;max_delta_ns);</span><br><span class="line">delta = max(delta, (<span class="type">int64_t</span>) dev-&gt;min_delta_ns);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 转换为设备周期数 */</span></span><br><span class="line">clc = ((<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) delta * dev-&gt;mult) &gt;&gt; dev-&gt;shift;</span><br><span class="line"><span class="comment">/* 调用设备的 set_next_event 方法设置下一个事件 */</span></span><br><span class="line">rc = dev-&gt;set_next_event((<span class="type">unsigned</span> <span class="type">long</span>) clc, dev);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (rc &amp;&amp; force) ? clockevents_program_min_delta(dev)<span class="comment">/* 设置最小延迟 */</span></span><br><span class="line"> : rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="clockevents-program-event-重新编程-clock-event-device-1"><a href="#clockevents-program-event-重新编程-clock-event-device-1" class="headerlink" title="clockevents_program_event 重新编程 clock event device"></a>clockevents_program_event 重新编程 clock event device</h2><ul><li>它的核心作用是：接收一个未来的、绝对的到期时间expires，计算出从“现在”到这个未来时间点的时间差，并将这个时间差转换为底层硬件定时器可以理解的“周期计数值（cycle&#x2F;count）”，然后调用硬件驱动提供的回调函数，将这个计数值编程到硬件中，以使硬件在精确的时刻触发一次中断。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * clockevents_program_event - 重新编程时钟事件设备。</span></span><br><span class="line"><span class="comment"> * @dev:需要被编程的设备。</span></span><br><span class="line"><span class="comment"> * @expires:绝对的到期时间（基于monotonic时钟）。</span></span><br><span class="line"><span class="comment"> * @force:如果expires无法被设置，是否强制编程一个最小延迟。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值: 成功时返回0，当事件已在过去时返回-ETIME。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">clockevents_program_event</span><span class="params">(<span class="keyword">struct</span> clock_event_device *dev, <span class="type">ktime_t</span> expires,</span></span><br><span class="line"><span class="params">      <span class="type">bool</span> force)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* clc: &quot;cycles&quot;, 64位无符号整型，用于存储转换后的硬件周期计数值。*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> clc;</span><br><span class="line"><span class="comment">/* delta: 64位有符号整型，用于存储从现在到expires的纳秒级时间差。*/</span></span><br><span class="line"><span class="type">int64_t</span> delta;</span><br><span class="line"><span class="comment">/* rc: 用于存储驱动回调函数的返回值。*/</span></span><br><span class="line"><span class="type">int</span> rc;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这是一个健壮性检查。到期时间不应为负数。如果为负，则触发一次性警告并返回错误。*/</span></span><br><span class="line"><span class="keyword">if</span> (WARN_ON_ONCE(expires &lt; <span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span> -ETIME;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将目标到期时间保存到设备结构体的next_event字段中。*/</span></span><br><span class="line">dev-&gt;next_event = expires;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果设备当前处于“关闭”状态，则无需编程，直接返回成功。*/</span></span><br><span class="line"><span class="keyword">if</span> (clockevent_state_shutdown(dev))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 我们在这里必须处于ONESHOT状态。这是一个断言，如果不是，则打印警告。*/</span></span><br><span class="line">WARN_ONCE(!clockevent_state_oneshot(dev), <span class="string">&quot;Current state: %d\n&quot;</span>,</span><br><span class="line">  clockevent_get_state(dev));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对那些能直接处理ktime的硬件设备，提供一条快速路径。*/</span></span><br><span class="line"><span class="keyword">if</span> (dev-&gt;features &amp; CLOCK_EVT_FEAT_KTIME)</span><br><span class="line"><span class="comment">/* 直接调用驱动提供的set_next_ktime回调，将绝对到期时间传递给它。*/</span></span><br><span class="line"><span class="keyword">return</span> dev-&gt;set_next_ktime(expires, dev);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * --- 常规路径：手动进行时间转换 ---</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* 计算从现在(ktime_get())到目标时间expires之间的时间差（单位：纳秒）。*/</span></span><br><span class="line">delta = ktime_to_ns(ktime_sub(expires, ktime_get()));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果delta小于等于0，说明expires已经是一个过去或现在的时刻。*/</span></span><br><span class="line"><span class="keyword">if</span> (delta &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="comment">/* 如果force为true，则尝试用最小延迟编程一次中断；否则返回-ETIME错误。*/</span></span><br><span class="line"><span class="keyword">return</span> force ? clockevents_program_min_delta(dev) : -ETIME;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将delta限制在硬件支持的最大和最小延迟范围内。*/</span></span><br><span class="line">delta = min(delta, (<span class="type">int64_t</span>) dev-&gt;max_delta_ns);</span><br><span class="line">delta = max(delta, (<span class="type">int64_t</span>) dev-&gt;min_delta_ns);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 核心转换：使用预先计算好的乘数(mult)和移位数(shift)，</span></span><br><span class="line"><span class="comment"> * 将纳秒级的时间差delta，转换为硬件定时器需要的周期计数值clc。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">clc = ((<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) delta * dev-&gt;mult) &gt;&gt; dev-&gt;shift;</span><br><span class="line"><span class="comment">/* 调用驱动提供的set_next_event回调，将计算出的周期数clc编程到硬件中。*/</span></span><br><span class="line">rc = dev-&gt;set_next_event((<span class="type">unsigned</span> <span class="type">long</span>) clc, dev);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果驱动回调返回错误，并且force为true，则再次尝试以最小延迟编程。*/</span></span><br><span class="line"><span class="keyword">return</span> (rc &amp;&amp; force) ? clockevents_program_min_delta(dev) : rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Clockevents-跨CPU解绑与替换-clockevents-try-unbind-clockevents-unbind"><a href="#Clockevents-跨CPU解绑与替换-clockevents-try-unbind-clockevents-unbind" class="headerlink" title="Clockevents 跨CPU解绑与替换 (__clockevents_try_unbind, clockevents_unbind)"></a>Clockevents 跨CPU解绑与替换 (__clockevents_try_unbind, clockevents_unbind)</h2><p>本代码片段是 Linux 内核 <code>clockevents</code>（时钟事件）子系统中实现硬件定时器与 CPU 解绑的核心逻辑，特别针对多核（SMP）环境设计。其主要功能是通过跨 CPU 调用（IPI - Inter-Processor Interrupt），安全地在指定的 CPU 上执行解绑操作。<code>clockevents_unbind</code> 负责发起请求，<code>__clockevents_unbind</code> 是在目标 CPU 上执行的函数，而 <code>__clockevents_try_unbind</code> 则是实际执行解绑或替换逻辑的内部核心。</p><h3 id="实现原理分析"><a href="#实现原理分析" class="headerlink" title="实现原理分析"></a>实现原理分析</h3><p>此代码段的实现原理是 SMP 环境下安全修改 per-CPU 硬件资源的典范，其核心技术是 <strong>远程过程调用</strong> 和 <strong>状态驱动的原子替换</strong>。</p><ol><li><p><strong>跨CPU执行的必要性 (<code>smp_call_function_single</code>)</strong>: <code>clockevents_unbind</code> 的核心是调用 <code>smp_call_function_single</code>。这是因为用于内核节拍（tick）的 <code>clock_event_device</code> 通常是 per-CPU 的硬件资源（例如，每个核心独立的 Local APIC 定时器或 ARM architected timer）。对这些硬件的任何操作，如停止、重新编程或禁用中断，都<strong>必须</strong>在它们所属的那个 CPU 核心上执行，直接操作其他核心的定时器硬件是不可能或不安全的。<code>smp_call_function_single</code> 通过向目标 <code>cpu</code> 发送一个 IPI，强制该 CPU 中断当前工作，转而执行指定的函数（<code>__clockevents_unbind</code>），从而实现了在正确的“地点”执行关键代码。</p></li><li><p><strong>两阶段解绑与替换 (<code>__clockevents_try_unbind</code>)</strong>: 此函数体现了对不同设备状态的精确处理：</p><ul><li><strong>快速路径</strong>: 如果设备已经是 <code>detached</code>（分离）状态，意味着它当前未被使用。此时可以直接从全局链表中移除（<code>list_del_init</code>），操作非常迅速。</li><li><strong>慢速路径 (替换)</strong>: 如果设备正被当前 CPU 用于内核节拍 (<code>ced == per_cpu(tick_cpu_device, cpu).evtdev</code>)，直接移除是不行的，会导致系统失去心跳。此时，函数返回 <code>-EAGAIN</code>，通知上层调用者（<code>__clockevents_unbind</code>）必须执行一个更复杂的操作——<code>clockevents_replace</code>。<code>clockevents_replace</code> 会原子地在系统中寻找一个合适的替代定时器，将内核节拍切换到新定时器上，然后才安全地将旧设备置于 <code>detached</code> 状态。</li><li><strong>繁忙状态</strong>: 如果设备正在被使用，但不是用于当前 CPU 的内核节拍（例如，它可能是一个共享的定时器，或被用于 <code>hrtimers</code>），则返回 <code>-EBUSY</code>，表示当前无法解绑。</li></ul></li></ol><h3 id="特定场景分析：单核、无MMU的STM32H750平台"><a href="#特定场景分析：单核、无MMU的STM32H750平台" class="headerlink" title="特定场景分析：单核、无MMU的STM32H750平台"></a>特定场景分析：单核、无MMU的STM32H750平台</h3><h4 id="硬件交互"><a href="#硬件交互" class="headerlink" title="硬件交互"></a>硬件交互</h4><p>在 STM32H750 平台上，一个 <code>clock_event_device</code> 实例通常代表 ARMv7-M 架构的 <code>SysTick</code> 定时器，或者是 STM32 的某个通用定时器（TIM）。当 <code>clockevents_unbind</code> 被调用试图解绑 <code>SysTick</code> 时：</p><ul><li><code>__clockevents_unbind</code> 会在 STM32H750 的唯一核心上被执行。</li><li><code>__clockevents_try_unbind</code> 会发现 <code>SysTick</code> 正被用作内核节拍，返回 <code>-EAGAIN</code>。</li><li><code>clockevents_replace</code> 会被调用。它会尝试寻找系统中的其他可用定时器（例如，一个配置为时钟事件模式的 TIM）。如果找到，它会停止并禁用 <code>SysTick</code> 的中断，然后启动并使能新 TIM 的中断来接管内核节拍。如果找不到替代者，操作将失败。</li></ul><h4 id="单核环境影响"><a href="#单核环境影响" class="headerlink" title="单核环境影响"></a>单核环境影响</h4><p>这组函数虽然为 SMP 设计，但在单核系统上依然能够正确工作，只是其行为被极大地简化了：</p><ul><li><strong><code>smp_call_function_single</code> 的退化</strong>: 在单核配置下，<code>smp_call_function_single</code> 不会发送任何 IPI。它会退化为一个简单的本地函数调用。内核会通过禁用本地中断来模拟一个“原子”的执行环境，然后直接调用 <code>__clockevents_unbind</code> 函数。所有复杂的跨核同步和等待逻辑都被绕过。</li><li><strong>CPU ID</strong>: <code>smp_processor_id()</code> 将始终返回 0。</li></ul><p>因此，在 STM32H750 上，这个流程变成了一个纯粹的本地操作：<code>clockevents_unbind</code> 通过一个简单的函数调用（带有中断屏蔽）来执行 <code>__clockevents_unbind</code>，后者再根据设备状态决定是直接移除还是进行替换。</p><h4 id="无MMU影响"><a href="#无MMU影响" class="headerlink" title="无MMU影响"></a>无MMU影响</h4><p>本代码片段的功能完全位于内核核心调度和时间管理层，其所有操作——包括链表操作、per-CPU 变量访问、函数调用——都与内存管理单元（MMU）无关。它在内核的平坦地址空间中工作，不依赖任何虚拟内存机制，因此在无 MMU 的 STM32H750 系统上可以无差别地正确执行。</p><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// __clockevents_try_unbind: 在持有锁的情况下，尝试解绑一个时钟事件设备。</span></span><br><span class="line"><span class="comment">// @ced: 指向待解绑的时钟事件设备（clock_event_device）的指针。</span></span><br><span class="line"><span class="comment">// @cpu: 目标CPU的ID。</span></span><br><span class="line"><span class="comment">// 返回值: 0 表示成功解绑；-EAGAIN 表示需要执行替换操作；-EBUSY 表示设备正忙。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 该函数必须在持有 clockevents_mutex 和 clockevents_lock 的情况下被调用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __clockevents_try_unbind(<span class="keyword">struct</span> clock_event_device *ced, <span class="type">int</span> cpu)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 快速路径：检查设备是否处于“分离”（detached）状态。</span></span><br><span class="line"><span class="keyword">if</span> (clockevent_state_detached(ced)) &#123;</span><br><span class="line"><span class="comment">// 如果设备未使用，直接从全局设备链表中移除它。</span></span><br><span class="line">list_del_init(&amp;ced-&gt;<span class="built_in">list</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回成功。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查该设备是否正是当前目标CPU正在使用的内核节拍（tick）设备。</span></span><br><span class="line"><span class="comment">// 如果是，则不能直接移除，必须先找到替代者。返回 -EAGAIN 表示“请重试”（并执行替换）。</span></span><br><span class="line"><span class="comment">// 如果不是，则意味着设备可能被用于其他目的（如高精度定时器），正处于繁忙状态，返回 -EBUSY。</span></span><br><span class="line"><span class="keyword">return</span> ced == per_cpu(tick_cpu_device, cpu).evtdev ? -EAGAIN : -EBUSY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// __clockevents_unbind: 在目标CPU上实际执行解绑操作的函数。</span></span><br><span class="line"><span class="comment">// @arg: 一个void指针，指向包含解绑信息的 ce_unbind 结构体。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这是一个通过SMP函数调用（IPI）在指定CPU上执行的函数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __clockevents_unbind(<span class="type">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ce_unbind</span> *<span class="title">cu</span> =</span> arg; <span class="comment">// 将void指针转换为 ce_unbind 结构体指针。</span></span><br><span class="line"><span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取本地CPU的 clockevents_lock 锁（这是一个原始自旋锁）。</span></span><br><span class="line">raw_spin_lock(&amp;clockevents_lock);</span><br><span class="line"><span class="comment">// 尝试解绑。</span></span><br><span class="line">res = __clockevents_try_unbind(cu-&gt;ce, smp_processor_id());</span><br><span class="line"><span class="comment">// 如果 __clockevents_try_unbind 返回 -EAGAIN，说明需要执行替换操作。</span></span><br><span class="line"><span class="keyword">if</span> (res == -EAGAIN)</span><br><span class="line"><span class="comment">// clockevents_replace 会寻找一个新的定时器来接管内核节拍，然后才将旧设备置为分离状态。</span></span><br><span class="line">res = clockevents_replace(cu-&gt;ce);</span><br><span class="line"><span class="comment">// 将操作结果存入传入的结构体中，以便发起者可以获取。</span></span><br><span class="line">cu-&gt;res = res;</span><br><span class="line"><span class="comment">// 释放锁。</span></span><br><span class="line">raw_spin_unlock(&amp;clockevents_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// clockevents_unbind: 发起一个对指定CPU上时钟事件设备的解绑请求。</span></span><br><span class="line"><span class="comment">// @ced: 指向待解绑的时钟事件设备的指针。</span></span><br><span class="line"><span class="comment">// @cpu: 目标CPU的ID。</span></span><br><span class="line"><span class="comment">// 返回值: 解绑操作的最终结果。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 该函数在调用时必须持有 clockevents_mutex 互斥锁。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">clockevents_unbind</span><span class="params">(<span class="keyword">struct</span> clock_event_device *ced, <span class="type">int</span> cpu)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 定义一个 ce_unbind 结构体在栈上，用于传递参数和接收返回值。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ce_unbind</span> <span class="title">cu</span> =</span> &#123; .ce = ced, .res = -ENODEV &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发起一个SMP调用：请求在目标CPU（cpu）上执行 __clockevents_unbind 函数，</span></span><br><span class="line"><span class="comment">// 参数为 cu 的地址，最后的 &#x27;1&#x27; 表示这是一个同步调用，即本函数会等待目标CPU执行完毕。</span></span><br><span class="line">smp_call_function_single(cpu, __clockevents_unbind, &amp;cu, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 返回从目标CPU上获取的操作结果。</span></span><br><span class="line"><span class="keyword">return</span> cu.res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Clockevents-Sysfs-接口初始化-clockevents-init-sysfs-tick-init-sysfs"><a href="#Clockevents-Sysfs-接口初始化-clockevents-init-sysfs-tick-init-sysfs" class="headerlink" title="Clockevents Sysfs 接口初始化 (clockevents_init_sysfs, tick_init_sysfs)"></a>Clockevents Sysfs 接口初始化 (clockevents_init_sysfs, tick_init_sysfs)</h2><p>本代码片段的核心功能是为 Linux 内核的 <code>clockevents</code>（时钟事件）子系统创建一套 sysfs 接口。它通过标准的 Linux 设备模型，在 <code>/sys/bus/clockevents/</code> 目录下注册一个总线，并为系统中的每个 CPU（以及可能的广播通道）创建一个对应的逻辑设备。这些逻辑设备下又包含属性文件（如 <code>current_device</code>），允许用户空间程序查看当前哪个硬件定时器正被用于该 CPU 的内核节拍（tick），并提供了在特定条件下手动解绑定时器的调试能力。</p><h3 id="实现原理分析-1"><a href="#实现原理分析-1" class="headerlink" title="实现原理分析"></a>实现原理分析</h3><p>此代码是 Linux 内核“一切皆文件”思想的典型体现，其实现原理基于对内核设备模型的深度集成。</p><ol><li><p><strong>设备模型抽象</strong>: 代码并未直接创建文件，而是将 <code>clockevents</code> 子系统的内部组件抽象为设备模型的标准元素：</p><ul><li><strong>总线 (<code>bus_type</code>)</strong>: <code>clockevents_subsys</code> 定义了一个名为 “clockevents” 的总线类型。这会在 sysfs 中创建 <code>/sys/bus/clockevents/</code> 目录，作为所有相关设备的容器。</li><li><strong>设备 (<code>device</code>)</strong>: 系统中的每个 CPU 核心都被视为一个独立的“节拍设备”，代码为此定义了一个 <code>per-CPU</code> 的 <code>struct device</code> 实例 (<code>tick_percpu_dev</code>)。在初始化时，<code>tick_init_sysfs</code> 函数会遍历所有 CPU，为每一个注册一个设备实例，从而在 sysfs 中创建出如 <code>/sys/bus/clockevents/devices/clockevent0</code>, <code>/sys/bus/clockevents/devices/clockevent1</code> 等目录。</li><li><strong>属性 (<code>device_attribute</code>)</strong>: <code>DEVICE_ATTR_RO(current_device)</code> 和 <code>DEVICE_ATTR_WO(unbind_device)</code> 这两个宏定义了设备的属性，它们分别对应 sysfs 中的一个文件。当用户读写这些文件时，内核会调用其对应的 <code>_show</code> 或 <code>_store</code> 函数（如 <code>current_device_show</code>）。</li></ul></li><li><p><strong>两阶段解绑的同步技巧 (<code>unbind_device_store</code>)</strong>: 解绑设备的操作展示了一种复杂的同步策略。它首先在持有轻量级的 <code>raw_spin_lock_irq</code> 的情况下，调用 <code>__clockevents_try_unbind</code> 尝试快速解绑。自旋锁下禁止睡眠，因此 <code>__clockevents_try_unbind</code> 如果遇到需要等待或可能导致睡眠的情况，会立即返回 <code>-EAGAIN</code>。<code>unbind_device_store</code> 捕捉到这个返回值后，会释放自旋锁，并调用允许睡眠的 <code>clockevents_unbind</code> 函数来完成这个慢速路径的操作。在此期间，它持有 <code>clockevents_mutex</code> 互斥锁，以防止目标设备 <code>ce</code> 在此过程中被销毁。</p></li></ol><h3 id="代码分析-1"><a href="#代码分析-1" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SYSFS <span class="comment">// 仅在内核配置了SYSFS文件系统支持时，以下代码才会被编译。</span></span></span><br><span class="line"><span class="comment">// 定义一个名为 &quot;clockevents&quot; 的总线（bus）类型。</span></span><br><span class="line"><span class="comment">// 这将在 /sys/bus/ 目录下创建一个名为 &quot;clockevents&quot; 的子目录。</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> <span class="title">clockevents_subsys</span> =</span> &#123;</span><br><span class="line">.name= <span class="string">&quot;clockevents&quot;</span>,</span><br><span class="line">.dev_name       = <span class="string">&quot;clockevent&quot;</span>, <span class="comment">// 设备的基础名称</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为每个CPU定义一个独立的 device 结构体实例。</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">DEFINE_PER_CPU</span><span class="params">(<span class="keyword">struct</span> device, tick_percpu_dev)</span>;</span><br><span class="line"><span class="comment">// 声明一个辅助函数，用于从通用的 device 结构体指针找到对应的 tick_device 结构体。</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> tick_device *<span class="title function_">tick_get_tick_dev</span><span class="params">(<span class="keyword">struct</span> device *dev)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;current_device&quot; sysfs 属性文件的 &quot;show&quot; (读) 操作实现函数。</span></span><br><span class="line"><span class="comment">// @dev: 指向此属性所属的设备结构体。</span></span><br><span class="line"><span class="comment">// @attr: 指向设备属性结构体。</span></span><br><span class="line"><span class="comment">// @buf: 用于存储输出字符串的缓冲区。</span></span><br><span class="line"><span class="comment">// 返回值: 写入缓冲区的字节数。</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">current_device_show</span><span class="params">(<span class="keyword">struct</span> device *dev,</span></span><br><span class="line"><span class="params">   <span class="keyword">struct</span> device_attribute *attr,</span></span><br><span class="line"><span class="params">   <span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tick_device</span> *<span class="title">td</span>;</span></span><br><span class="line"><span class="type">ssize_t</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取保护 clockevents 子系统的自旋锁，并禁用中断。</span></span><br><span class="line">raw_spin_lock_irq(&amp;clockevents_lock);</span><br><span class="line"><span class="comment">// 根据 dev 指针找到对应的 tick_device。</span></span><br><span class="line">td = tick_get_tick_dev(dev);</span><br><span class="line"><span class="comment">// 如果 tick_device 存在并且已经关联了一个时钟事件设备(evtdev)。</span></span><br><span class="line"><span class="keyword">if</span> (td &amp;&amp; td-&gt;evtdev)</span><br><span class="line"><span class="comment">// 使用 sysfs_emit 格式化输出当前时钟事件设备的名称到缓冲区。</span></span><br><span class="line">count = sysfs_emit(buf, <span class="string">&quot;%s\n&quot;</span>, td-&gt;evtdev-&gt;name);</span><br><span class="line"><span class="comment">// 释放自旋锁，并恢复中断。</span></span><br><span class="line">raw_spin_unlock_irq(&amp;clockevents_lock);</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用宏定义一个只读的 &quot;current_device&quot; 设备属性。</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">DEVICE_ATTR_RO</span><span class="params">(current_device)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;unbind_device&quot; sysfs 属性文件的 &quot;store&quot; (写) 操作实现函数。</span></span><br><span class="line"><span class="comment">// @dev: 指向此属性所属的设备结构体。</span></span><br><span class="line"><span class="comment">// @attr: 指向设备属性结构体。</span></span><br><span class="line"><span class="comment">// @buf: 指向用户空间写入的数据。</span></span><br><span class="line"><span class="comment">// @count: 写入数据的字节数。</span></span><br><span class="line"><span class="comment">// 返回值: 成功则为写入的字节数，失败则为负数错误码。</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">unbind_device_store</span><span class="params">(<span class="keyword">struct</span> device *dev,</span></span><br><span class="line"><span class="params">   <span class="keyword">struct</span> device_attribute *attr,</span></span><br><span class="line"><span class="params">   <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">size_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> name[CS_NAME_LEN]; <span class="comment">// 缓冲区，用于存储从用户输入中提取的设备名。</span></span><br><span class="line"><span class="type">ssize_t</span> ret = sysfs_get_uname(buf, name, count); <span class="comment">// 从buf中解析出设备名。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clock_event_device</span> *<span class="title">ce</span> =</span> <span class="literal">NULL</span>, *iter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">ret = -ENODEV; <span class="comment">// 默认返回“无此设备”错误。</span></span><br><span class="line"><span class="comment">// 获取互斥锁，用于保护可能引起睡眠的解绑操作。</span></span><br><span class="line">mutex_lock(&amp;clockevents_mutex);</span><br><span class="line"><span class="comment">// 获取自旋锁，用于保护对 clockevent_devices 链表的遍历。</span></span><br><span class="line">raw_spin_lock_irq(&amp;clockevents_lock);</span><br><span class="line"><span class="comment">// 遍历全局的时钟事件设备链表。</span></span><br><span class="line">list_for_each_entry(iter, &amp;clockevent_devices, <span class="built_in">list</span>) &#123;</span><br><span class="line"><span class="comment">// 比较名称以找到目标设备。</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strcmp</span>(iter-&gt;name, name)) &#123;</span><br><span class="line"><span class="comment">// 尝试在持有自旋锁的情况下进行解绑（快速路径）。</span></span><br><span class="line">ret = __clockevents_try_unbind(iter, dev-&gt;id);</span><br><span class="line">ce = iter; <span class="comment">// 保存找到的设备指针。</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 释放自旋锁。</span></span><br><span class="line">raw_spin_unlock_irq(&amp;clockevents_lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时仍然持有 clockevents_mutex 互斥锁，所以 ce 指针是安全的。</span></span><br><span class="line"><span class="comment">// 如果快速路径解绑失败并返回 -EAGAIN，说明需要执行可能睡眠的慢速路径。</span></span><br><span class="line"><span class="keyword">if</span> (ret == -EAGAIN)</span><br><span class="line">ret = clockevents_unbind(ce, dev-&gt;id);</span><br><span class="line"><span class="comment">// 释放互斥锁。</span></span><br><span class="line">mutex_unlock(&amp;clockevents_mutex);</span><br><span class="line"><span class="comment">// 如果操作成功(ret=0)，则返回用户写入的字节数，否则返回错误码。</span></span><br><span class="line"><span class="keyword">return</span> ret ? ret : count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用宏定义一个只写的 &quot;unbind_device&quot; 设备属性。</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">DEVICE_ATTR_WO</span><span class="params">(unbind_device)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_CLOCKEVENTS_BROADCAST <span class="comment">// 如果配置了广播时钟事件。</span></span></span><br><span class="line"><span class="comment">// 为广播时钟事件定义一个全局的 device 结构体。</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">tick_bc_dev</span> =</span> &#123;</span><br><span class="line">.init_name= <span class="string">&quot;broadcast&quot;</span>,</span><br><span class="line">.id= <span class="number">0</span>, <span class="comment">// ID 为0，但通过与 per-cpu 设备的指针比较来区分。</span></span><br><span class="line">.bus= &amp;clockevents_subsys, <span class="comment">// 关联到 clockevents 总线。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数，根据 dev 指针找到对应的 tick_device。</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> tick_device *<span class="title function_">tick_get_tick_dev</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 如果是广播设备，则获取广播 tick_device；否则，获取与 dev-&gt;id 对应的 per-cpu tick_device。</span></span><br><span class="line"><span class="keyword">return</span> dev == &amp;tick_bc_dev ? tick_get_broadcast_device() :</span><br><span class="line">&amp;per_cpu(tick_cpu_device, dev-&gt;id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化广播时钟事件的 sysfs 接口。</span></span><br><span class="line"><span class="type">static</span> __init <span class="type">int</span> <span class="title function_">tick_broadcast_init_sysfs</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> err = device_register(&amp;tick_bc_dev); <span class="comment">// 注册广播设备。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!err)</span><br><span class="line"><span class="comment">// 为广播设备创建 &quot;current_device&quot; 属性文件。</span></span><br><span class="line">err = device_create_file(&amp;tick_bc_dev, &amp;dev_attr_current_device);</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">// 如果没有配置广播时钟事件。</span></span></span><br><span class="line"><span class="comment">// 辅助函数，直接获取与 dev-&gt;id 对应的 per-cpu tick_device。</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> tick_device *<span class="title function_">tick_get_tick_dev</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> &amp;per_cpu(tick_cpu_device, dev-&gt;id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义一个空的内联函数作为存根。</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">tick_broadcast_init_sysfs</span><span class="params">(<span class="type">void</span>)</span> &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 per-cpu tick 设备的 sysfs 接口。</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">tick_init_sysfs</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> cpu;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历系统中所有可能存在的CPU。</span></span><br><span class="line">for_each_possible_cpu(cpu) &#123;</span><br><span class="line"><span class="comment">// 获取该CPU对应的 per-cpu device 结构体指针。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> =</span> &amp;per_cpu(tick_percpu_dev, cpu);</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">dev-&gt;id = cpu; <span class="comment">// 设置设备的ID为CPU号。</span></span><br><span class="line">dev-&gt;bus = &amp;clockevents_subsys; <span class="comment">// 关联到 clockevents 总线。</span></span><br><span class="line"><span class="comment">// 注册这个 per-cpu 设备。</span></span><br><span class="line">err = device_register(dev);</span><br><span class="line"><span class="keyword">if</span> (!err)</span><br><span class="line"><span class="comment">// 为设备创建 &quot;current_device&quot; 属性文件。</span></span><br><span class="line">err = device_create_file(dev, &amp;dev_attr_current_device);</span><br><span class="line"><span class="keyword">if</span> (!err)</span><br><span class="line"><span class="comment">// 为设备创建 &quot;unbind_device&quot; 属性文件。</span></span><br><span class="line">err = device_create_file(dev, &amp;dev_attr_unbind_device);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">return</span> err; <span class="comment">// 如果任何一步失败，则返回错误。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化广播设备的 sysfs 接口。</span></span><br><span class="line"><span class="keyword">return</span> tick_broadcast_init_sysfs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// clockevents 子系统 sysfs 接口的总初始化函数。</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">clockevents_init_sysfs</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 注册 &quot;clockevents&quot; 总线。</span></span><br><span class="line"><span class="type">int</span> err = subsys_system_register(&amp;clockevents_subsys, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!err)</span><br><span class="line"><span class="comment">// 如果总线注册成功，则继续初始化 tick 设备的 sysfs 接口。</span></span><br><span class="line">err = tick_init_sysfs();</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将 clockevents_init_sysfs 注册为一个设备初始化调用，在内核启动的相应阶段执行。</span></span><br><span class="line">device_initcall(clockevents_init_sysfs);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* SYSFS */</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;kernel-time-clockevents-c&quot;&gt;&lt;a href=&quot;#kernel-time-clockevents-c&quot; class=&quot;headerlink&quot; title=&quot;kernel&amp;#x2F;time&amp;#x2F;clockev</summary>
      
    
    
    
    <category term="linux" scheme="https://wdfk-prog.space/categories/linux/"/>
    
    <category term="kernel" scheme="https://wdfk-prog.space/categories/linux/kernel/"/>
    
    <category term="time" scheme="https://wdfk-prog.space/categories/linux/kernel/time/"/>
    
    
    <category term="linux" scheme="https://wdfk-prog.space/tags/linux/"/>
    
    <category term="kernel" scheme="https://wdfk-prog.space/tags/kernel/"/>
    
    <category term="time" scheme="https://wdfk-prog.space/tags/time/"/>
    
  </entry>
  
  <entry>
    <title>Linux 学习笔记</title>
    <link href="https://wdfk-prog.space/posts/77cd4175/"/>
    <id>https://wdfk-prog.space/posts/77cd4175/</id>
    <published>2025-10-06T00:07:07.000Z</published>
    <updated>2025-10-06T00:07:45.533Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-学习笔记"><a href="#Linux-学习笔记" class="headerlink" title="Linux 学习笔记"></a>Linux 学习笔记</h1><ul><li><ol><li><a href="arch/">arch</a></li></ol><ul><li>1.1. <a href="arch/arm/">arm</a><ul><li><a href="arch/arm/assembly.md">1.1.1. assembly.md</a></li><li><a href="arch/arm/boot.md">1.1.2. boot.md</a></li><li><a href="arch/arm/debug.md">1.1.3. debug.md</a></li><li><a href="arch/arm/include.md">1.1.4. include.md</a></li><li><a href="arch/arm/kernel.md">1.1.5. kernel.md</a></li><li><a href="arch/arm/lds.md">1.1.6. lds.md</a></li><li><a href="arch/arm/lib.md">1.1.7. lib.md</a></li><li><a href="arch/arm/mm.md">1.1.8. mm.md</a></li><li><a href="arch/arm/process.md">1.1.9. process.md</a></li><li><a href="arch/arm/syscall_table%E7%94%9F%E6%88%90%E6%B5%81%E7%A8%8B.md">1.1.10. syscall_table生成流程.md</a></li></ul></li></ul></li><li><ol start="2"><li><a href="block/">block</a></li></ol><ul><li><a href="block/bio.md">2.1. bio.md</a></li><li><a href="block/blk-ioc.md">2.2. blk-ioc.md</a></li><li><a href="block/blk-mq.md">2.3. blk-mq.md</a></li><li><a href="block/block.md">2.4. block.md</a></li><li><a href="block/genhd.md">2.5. genhd.md</a></li></ul></li><li><ol start="3"><li><a href="drivers/">drivers</a></li></ol><ul><li>3.1. <a href="drivers/base/">base</a><ul><li><a href="drivers/base/base.md">3.1.1. base.md</a></li><li><a href="drivers/base/bus.md">3.1.2. bus.md</a></li><li><a href="drivers/base/class.md">3.1.3. class.md</a></li><li><a href="drivers/base/container.md">3.1.4. container.md</a></li><li><a href="drivers/base/cpu.md">3.1.5. cpu.md</a></li><li><a href="drivers/base/dd.md">3.1.6. dd.md</a></li><li><a href="drivers/base/devres.md">3.1.7. devres.md</a></li><li><a href="drivers/base/devtmpfs.md">3.1.8. devtmpfs.md</a></li><li><a href="drivers/base/faux.md">3.1.9. faux.md</a></li><li><a href="drivers/base/firmware.md">3.1.10. firmware.md</a></li><li><a href="drivers/base/platform.md">3.1.11. platform.md</a></li><li><a href="drivers/base/regmap.md">3.1.12. regmap.md</a></li><li><a href="drivers/base/syscore.md">3.1.13. syscore.md</a></li><li><a href="drivers/base/topology.md">3.1.14. topology.md</a></li></ul></li><li>3.2. <a href="drivers/clk/">clk</a><ul><li><a href="drivers/clk/clk.md">3.2.1. clk.md</a></li><li><a href="drivers/clk/clk-bulk.md">3.2.2. clk-bulk.md</a></li></ul></li><li>3.3. <a href="drivers/tty/">tty</a><ul><li><a href="drivers/tty/serial.md">3.3.1. serial.md</a></li><li><a href="drivers/tty/tty.md">3.3.2. tty.md</a></li></ul></li><li><a href="drivers/amba.md">3.4. amba.md</a></li><li><a href="drivers/char.md">3.5. char.md</a></li><li><a href="drivers/clocksource.md">3.6. clocksource.md</a></li><li><a href="drivers/dma.md">3.7. dma.md</a></li><li><a href="drivers/dma-buf.md">3.8. dma-buf.md</a></li><li><a href="drivers/fdt.md">3.9. fdt.md</a></li><li><a href="drivers/gpio.md">3.10. gpio.md</a></li><li><a href="drivers/i2c.md">3.11. i2c.md</a></li><li><a href="drivers/iio.md">3.12. iio.md</a></li><li><a href="drivers/input.md">3.13. input.md</a></li><li><a href="drivers/leds.md">3.14. leds.md</a></li><li><a href="drivers/mfd.md">3.15. mfd.md</a></li><li><a href="drivers/mmc.md">3.16. mmc.md</a></li><li><a href="drivers/nvmem.md">3.17. nvmem.md</a></li><li><a href="drivers/of.md">3.18. of.md</a></li><li><a href="drivers/pinctrl.md">3.19. pinctrl.md</a></li><li><a href="drivers/regmap.md">3.20. regmap.md</a></li><li><a href="drivers/regulator.md">3.21. regulator.md</a></li><li><a href="drivers/reset.md">3.22. reset.md</a></li><li><a href="drivers/rtc.md">3.23. rtc.md</a></li><li><a href="drivers/watchdog.md">3.24. watchdog.md</a></li></ul></li><li><ol start="4"><li><a href="fs/">fs</a></li></ol><ul><li><a href="fs/anon_inodes.md">4.1. anon_inodes.md</a></li><li><a href="fs/binfmt_script.md">4.2. binfmt_script.md</a></li><li><a href="fs/buffer.md">4.3. buffer.md</a></li><li><a href="fs/dcache.md">4.4. dcache.md</a></li><li><a href="fs/drop_caches.md">4.5. drop_caches.md</a></li><li><a href="fs/exec.md">4.6. exec.md</a></li><li><a href="fs/file.md">4.7. file.md</a></li><li><a href="fs/file_table.md">4.8. file_table.md</a></li><li><a href="fs/filesystems.md">4.9. filesystems.md</a></li><li><a href="fs/fs_context.md">4.10. fs_context.md</a></li><li><a href="fs/fs_parser.md">4.11. fs_parser.md</a></li><li><a href="fs/fs_struct.md">4.12. fs_struct.md</a></li><li><a href="fs/fs-writeback.md">4.13. fs-writeback.md</a></li><li><a href="fs/initramfs.md">4.14. initramfs.md</a></li><li><a href="fs/inode.md">4.15. inode.md</a></li><li><a href="fs/iomap.md">4.16. iomap.md</a></li><li><a href="fs/kernfs.md">4.17. kernfs.md</a></li><li><a href="fs/libfs.md">4.18. libfs.md</a></li><li><a href="fs/locks.md">4.19. locks.md</a></li><li><a href="fs/mnt_idmapping.md">4.20. mnt_idmapping.md</a></li><li><a href="fs/namei.md">4.21. namei.md</a></li><li><a href="fs/namespace.md">4.22. namespace.md</a></li><li><a href="fs/nsfs.md">4.23. nsfs.md</a></li><li><a href="fs/open.md">4.24. open.md</a></li><li><a href="fs/pidfs.md">4.25. pidfs.md</a></li><li><a href="fs/pipe.md">4.26. pipe.md</a></li><li><a href="fs/proc.md">4.27. proc.md</a></li><li><a href="fs/ramfs.md">4.28. ramfs.md</a></li><li><a href="fs/read_write.md">4.29. read_write.md</a></li><li><a href="fs/seq_file.md">4.30. seq_file.md</a></li><li><a href="fs/stat.md">4.31. stat.md</a></li><li><a href="fs/super.md">4.32. super.md</a></li><li><a href="fs/sync.md">4.33. sync.md</a></li><li><a href="fs/sysfs.md">4.34. sysfs.md</a></li></ul></li><li><ol start="5"><li><a href="include/">include</a></li></ol><ul><li><a href="include/atomic.md">5.1. atomic.md</a></li><li><a href="include/bits.md">5.2. bits.md</a></li><li><a href="include/compiler.md">5.3. compiler.md</a></li><li><a href="include/hashtable.md">5.4. hashtable.md</a></li><li><a href="include/%E4%BB%A3%E7%A0%81%E8%A1%A5%E4%B8%81.md">5.5. 代码补丁.md</a></li><li><a href="include/%E5%BA%95%E5%B1%82CPU%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%AE%8F.md">5.6. 底层CPU与体系结构宏.md</a></li><li><a href="include/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E8%AE%BF%E9%97%AE.md">5.7. 内存管理与访问.md</a></li><li><a href="include/%E5%86%85%E6%A0%B8%E6%94%AF%E6%8C%81%E4%B8%8E%E6%95%B0%E6%8D%AE.md">5.8. 内核支持与数据.md</a></li><li><a href="include/%E9%80%9A%E7%94%A8%E5%B7%A5%E5%85%B7%E4%B8%8E%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E5%AE%8F.md">5.9. 通用工具与错误处理宏.md</a></li><li><a href="include/%E9%80%9A%E7%94%A8%E6%95%B0%E5%AD%A6%E4%B8%8E%E4%BD%8D%E6%93%8D%E4%BD%9C%E5%AE%8F.md">5.10. 通用数学与位操作宏.md</a></li></ul></li><li><ol start="6"><li><a href="kernel/">kernel</a></li></ol><ul><li>6.1. <a href="kernel/irq/">irq</a><ul><li><a href="kernel/irq/chip.md">6.1.1. chip.md</a></li><li><a href="kernel/irq/drivers.md">6.1.2. drivers.md</a></li><li><a href="kernel/irq/irq.md">6.1.3. irq.md</a></li><li><a href="kernel/irq/irq_work.md">6.1.4. irq_work.md</a></li><li><a href="kernel/irq/softirq.md">6.1.5. softirq.md</a></li></ul></li><li>6.2. <a href="kernel/lock/">lock</a><ul><li><a href="kernel/lock/debug_lock.md">6.2.1. debug_lock.md</a></li><li><a href="kernel/lock/local_lock.md">6.2.2. local_lock.md</a></li><li><a href="kernel/lock/mutex.md">6.2.3. mutex.md</a></li><li><a href="kernel/lock/rwlock.md">6.2.4. rwlock.md</a></li><li><a href="kernel/lock/rwsem.md">6.2.5. rwsem.md</a></li><li><a href="kernel/lock/seqlock.md">6.2.6. seqlock.md</a></li><li><a href="kernel/lock/spinlock.md">6.2.7. spinlock.md</a></li></ul></li><li>6.3. <a href="kernel/rcu/">rcu</a><ul><li><a href="kernel/rcu/RCU.md">6.3.1. RCU.md</a></li><li><a href="kernel/rcu/SRCU.md">6.3.2. SRCU.md</a></li><li><a href="kernel/rcu/tree.md">6.3.3. tree.md</a></li></ul></li><li>6.4. <a href="kernel/sched/">sched</a><ul><li><a href="kernel/sched/deadline.md">6.4.1. deadline.md</a></li><li><a href="kernel/sched/fair.md">6.4.2. fair.md</a></li><li><a href="kernel/sched/idle.md">6.4.3. idle.md</a></li><li><a href="kernel/sched/preempt.md">6.4.4. preempt.md</a></li><li><a href="kernel/sched/rt.md">6.4.5. rt.md</a></li><li><a href="kernel/sched/sched.md">6.4.6. sched.md</a></li><li><a href="kernel/sched/syscalls.md">6.4.7. syscalls.md</a></li></ul></li><li>6.5. <a href="kernel/time/">time</a><ul><li><a href="kernel/time/alarmtimer.md">6.5.1. alarmtimer.md</a></li><li><a href="kernel/time/clocksource.md">6.5.2. clocksource.md</a></li><li><a href="kernel/time/hrtimer.md">6.5.3. hrtimer.md</a></li><li><a href="kernel/time/jiffies.md">6.5.4. jiffies.md</a></li><li><a href="kernel/time/sched_clock.md">6.5.5. sched_clock.md</a></li><li><a href="kernel/time/tick.md">6.5.6. tick.md</a></li><li><a href="kernel/time/time.md">6.5.7. time.md</a></li><li><a href="kernel/time/timekeeping.md">6.5.8. timekeeping.md</a></li><li><a href="kernel/time/timer.md">6.5.9. timer.md</a></li></ul></li><li><a href="kernel/async.md">6.6. async.md</a></li><li><a href="kernel/bounds.md">6.7. bounds.md</a></li><li><a href="kernel/completion.md">6.8. completion.md</a></li><li><a href="kernel/cpu.md">6.9. cpu.md</a></li><li><a href="kernel/cred.md">6.10. cred.md</a></li><li><a href="kernel/dma.md">6.11. dma.md</a></li><li><a href="kernel/exit.md">6.12. exit.md</a></li><li><a href="kernel/fork.md">6.13. fork.md</a></li><li><a href="kernel/iomem.md">6.14. iomem.md</a></li><li><a href="kernel/ksysfs.md">6.15. ksysfs.md</a></li><li><a href="kernel/kthread.md">6.16. kthread.md</a></li><li><a href="kernel/memory_barrier.md">6.17. memory_barrier.md</a></li><li><a href="kernel/notifier.md">6.18. notifier.md</a></li><li><a href="kernel/nsproxy.md">6.19. nsproxy.md</a></li><li><a href="kernel/params.md">6.20. params.md</a></li><li><a href="kernel/pid.md">6.21. pid.md</a></li><li><a href="kernel/power.md">6.22. power.md</a></li><li><a href="kernel/printk.md">6.23. printk.md</a></li><li><a href="kernel/reboot.md">6.24. reboot.md</a></li><li><a href="kernel/resource.md">6.25. resource.md</a></li><li><a href="kernel/signal.md">6.26. signal.md</a></li><li><a href="kernel/sysctl.md">6.27. sysctl.md</a></li><li><a href="kernel/trace.md">6.28. trace.md</a></li><li><a href="kernel/umh.md">6.29. umh.md</a></li><li><a href="kernel/wait.md">6.30. wait.md</a></li><li><a href="kernel/workqueue.md">6.31. workqueue.md</a></li></ul></li><li><ol start="7"><li><a href="lib/">lib</a></li></ol><ul><li><a href="lib/crc32.md">7.1. crc32.md</a></li><li><a href="lib/dump_stack.md">7.2. dump_stack.md</a></li><li><a href="lib/hash.md">7.3. hash.md</a></li><li><a href="lib/idr.md">7.4. idr.md</a></li><li><a href="lib/iov_iter.md">7.5. iov_iter.md</a></li><li><a href="lib/kfifo.md">7.6. kfifo.md</a></li><li><a href="lib/kobject.md">7.7. kobject.md</a></li><li><a href="lib/list.md">7.8. list.md</a></li><li><a href="lib/maple_tree.md">7.9. maple_tree.md</a></li><li><a href="lib/radix-tree.md">7.10. radix-tree.md</a></li><li><a href="lib/rbtree.md">7.11. rbtree.md</a></li><li><a href="lib/refcount.md">7.12. refcount.md</a></li><li><a href="lib/search.md">7.13. search.md</a></li><li><a href="lib/sort.md">7.14. sort.md</a></li><li><a href="lib/string.md">7.15. string.md</a></li><li><a href="lib/timerqueue.md">7.16. timerqueue.md</a></li><li><a href="lib/xarray.md">7.17. xarray.md</a></li><li><a href="lib/zlib.md">7.18. zlib.md</a></li></ul></li><li><ol start="8"><li><a href="mm/">mm</a></li></ol><ul><li><a href="mm/backing-dev.md">8.1. backing-dev.md</a></li><li><a href="mm/filemap.md">8.2. filemap.md</a></li><li><a href="mm/list_lru.md">8.3. list_lru.md</a></li><li><a href="mm/memblock.md">8.4. memblock.md</a></li><li><a href="mm/mm_init.md">8.5. mm_init.md</a></li><li><a href="mm/mmzone.md">8.6. mmzone.md</a></li><li><a href="mm/nommu.md">8.7. nommu.md</a></li><li><a href="mm/page_alloc.md">8.8. page_alloc.md</a></li><li><a href="mm/page-writeback.md">8.9. page-writeback.md</a></li><li><a href="mm/percpu.md">8.10. percpu.md</a></li><li><a href="mm/shmem.md">8.11. shmem.md</a></li><li><a href="mm/shrinker.md">8.12. shrinker.md</a></li><li><a href="mm/slub.md">8.13. slub.md</a></li><li><a href="mm/swap.md">8.14. swap.md</a></li><li><a href="mm/truncate.md">8.15. truncate.md</a></li><li><a href="mm/util.md">8.16. util.md</a></li><li><a href="mm/vmstat.md">8.17. vmstat.md</a></li></ul></li><li><ol start="9"><li><a href="other/">other</a></li></ol><ul><li>[9.1. [Linux][ARM][asm bug]BUG宏的理解.md](other&#x2F;[Linux][ARM][asm bug]BUG宏的理解.md)</li><li><a href="other/%5BLinux%5D%5BARM%5D%5Bdecompress%5Ddecompress%E4%BD%BF%E7%94%A8%E7%9A%84malloc%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90.md">9.2. [Linux][ARM][decompress]decompress使用的malloc函数分析.md</a></li><li><a href="other/%5BLinux%5D%5BPR%5D%E4%BD%BF%E7%94%A8B4%E5%90%91linux%E5%86%85%E6%A0%B8%E6%8F%90%E4%BA%A4%E8%A1%A5%E4%B8%81.md">9.3. [Linux][PR]使用B4向linux内核提交补丁.md</a></li><li><a href="other/%5Blinux%5D%5Brtos%5D%E6%96%B0%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E5%92%8C%E9%80%80%E5%87%BA%E7%9A%84%E5%BC%82%E5%90%8C%E7%82%B9%E8%A7%A3%E6%9E%90.md">9.4. [linux][rtos]新线程创建和退出的异同点解析.md</a></li><li><a href="other/%5Blinux%5D%5Bstm32%5D%E6%97%A9%E6%9C%9F%E8%B0%83%E8%AF%95%E5%90%AF%E7%94%A8(DEBUG_LL)%E6%95%99%E7%A8%8B.md">9.5. [linux][stm32]早期调试启用(DEBUG_LL)教程.md</a></li><li><a href="other/%5BLinux%5D%5BSTM32H7%5D%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%EF%BC%9A%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F%E6%BA%90%E4%B8%BA%E4%BD%95%E8%A2%AB%E6%97%A0%E6%95%85%E4%BF%AE%E6%94%B9.md">9.6. [Linux][STM32H7]深入解析：系统时钟源为何被无故修改.md</a></li><li>[9.7. Linux 内核 <code>jiffies</code> 更新机制解析：周期性Tick模型和动态时钟.md](other&#x2F;Linux 内核 <code>jiffies</code> 更新机制解析：周期性Tick模型和动态时钟.md)</li><li>[9.8. Linux 内核 <code>kthread_stop</code> 完成量等待是如何被唤醒.md](other&#x2F;Linux 内核 <code>kthread_stop</code> 完成量等待是如何被唤醒.md)</li><li>[9.9. Linux 内核 API 设计哲学：<code>NULL</code> 指针语义的上下文依赖性分析.md](other&#x2F;Linux 内核 API 设计哲学：<code>NULL</code> 指针语义的上下文依赖性分析.md)</li><li>[9.10. Linux 内核调度、内存管理与并发的交汇点：<code>membarrier</code> 与 <code>finish_task_switch</code> 深度解析.md](other&#x2F;Linux 内核调度、内存管理与并发的交汇点：<code>membarrier</code> 与 <code>finish_task_switch</code> 深度解析.md)</li><li>[9.11. Linux 内核中断与时间子系统深度解析：从硬件到<code>jiffies</code>的完整生命周期.md](other&#x2F;Linux 内核中断与时间子系统深度解析：从硬件到<code>jiffies</code>的完整生命周期.md)</li><li><a href="other/Linux%E5%86%85%E6%A0%B8ARM%E6%9E%B6%E6%9E%84%E4%B8%8B%60sys_call_table%60%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E7%94%9F%E6%88%90%E6%9C%BA%E5%88%B6%E5%89%96%E6%9E%90.md">9.12. Linux内核ARM架构下<code>sys_call_table</code>的自动化生成机制剖析.md</a></li><li><a href="other/%E5%86%85%E6%A0%B8%E2%80%9C%E5%88%9B%E4%B8%96%E7%BA%AA%E2%80%9D%EF%BC%9A%E6%96%B0%E4%BB%BB%E5%8A%A1%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%91%BC%E5%90%B8%E6%98%AF%E5%A6%82%E4%BD%95%E4%BC%AA%E9%80%A0%E7%9A%84%EF%BC%9F.md">9.13. 内核“创世纪”：新任务的第一次呼吸是如何伪造的？.md</a></li><li><a href="other/%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%E4%BC%98%E5%85%88%E7%BA%A7%E7%BB%A7%E6%89%BF%EF%BC%9A%E4%BB%8E%E9%97%AE%E9%A2%98%E6%A0%B9%E6%BA%90%E5%88%B0Linux%E4%B8%8ERTOS%E5%AE%9E%E7%8E%B0.md">9.14. 深度解析优先级继承：从问题根源到Linux与RTOS实现.md</a></li><li><a href="other/%E6%B7%B1%E5%85%A5%E5%86%85%E6%A0%B8%EF%BC%9AARMv7-M%E4%B8%8A%E7%9A%84Linux%E8%B0%83%E5%BA%A6%E9%AD%94%E6%B3%95%E4%B8%8EPendSV%E7%9A%84%E2%80%9C%E5%BB%B6%E8%BF%9F%E8%89%BA%E6%9C%AF%E2%80%9D.md">9.15. 深入内核：ARMv7-M上的Linux调度魔法与PendSV的“延迟艺术”.md</a></li></ul></li><li><a href="GCC.md">10. GCC.md</a></li><li><a href="init.md">11. init.md</a></li><li><a href="linux_makefile.md">12. linux_makefile.md</a></li><li><a href="Makefile.md">13. Makefile.md</a></li><li><a href="README.md">14. README.md</a></li><li><a href="shell%E5%91%BD%E4%BB%A4.md">15. shell命令.md</a></li><li><a href="%E6%9E%84%E5%BB%BA%E8%AF%B4%E6%98%8E.md">16. 构建说明.md</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux-学习笔记&quot;&gt;&lt;a href=&quot;#Linux-学习笔记&quot; class=&quot;headerlink&quot; title=&quot;Linux 学习笔记&quot;&gt;&lt;/a&gt;Linux 学习笔记&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;arch/&quot;&gt;arch&lt;/a</summary>
      
    
    
    
    <category term="linux" scheme="https://wdfk-prog.space/categories/linux/"/>
    
    
    <category term="linux" scheme="https://wdfk-prog.space/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>alarmtimer</title>
    <link href="https://wdfk-prog.space/posts/18d6212c/"/>
    <id>https://wdfk-prog.space/posts/18d6212c/</id>
    <published>2025-10-06T00:07:07.000Z</published>
    <updated>2025-10-06T00:44:32.726Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="kernel-time-alarmtimer-c"><a href="#kernel-time-alarmtimer-c" class="headerlink" title="kernel&#x2F;time&#x2F;alarmtimer.c"></a>kernel&#x2F;time&#x2F;alarmtimer.c</h1><h2 id="闹钟定时器-Alarm-Timer-初始化：构建可挂起的定时器基础框架"><a href="#闹钟定时器-Alarm-Timer-初始化：构建可挂起的定时器基础框架" class="headerlink" title="闹钟定时器(Alarm Timer)初始化：构建可挂起的定时器基础框架"></a>闹钟定时器(Alarm Timer)初始化：构建可挂起的定时器基础框架</h2><p>本代码片段的核心功能是初始化Linux内核中的闹钟定时器（Alarm Timer）子系统。闹钟定时器的主要特点是它们能够在系统进入挂起（suspend）等低功耗状态后，依然能够到期并唤醒系统。此初始化函数负责建立管理这些定时器的核心数据结构，将它们与具体的时钟源（如<code>CLOCK_REALTIME</code>和<code>CLOCK_BOOTTIME</code>）关联起来，并注册相应的驱动以等待与硬件设备绑定。</p><h3 id="实现原理分析"><a href="#实现原理分析" class="headerlink" title="实现原理分析"></a>实现原理分析</h3><p>此初始化过程是闹钟定时器框架能够工作的基础，它通过配置一个预定义的<code>alarm_bases</code>全局数组来为不同类型的闹钟定时器提供统一的管理接口。</p><ol><li><strong>配置时钟源</strong>: 函数首先为<code>REALTIME</code>和<code>BOOTTIME</code>两个闹钟“基地”（<code>alarm_bases</code>数组的元素）分别配置其<code>clockid</code>和获取时间的函数指针。这使得上层代码可以通过<code>ALARM_REALTIME</code>类型来设置一个基于“墙上时间”（wall-clock time）的定时器，或通过<code>ALARM_BOOTTIME</code>类型设置一个基于系统启动时间的单调递增定时器。</li><li><strong>通用初始化</strong>: 通过一个循环，为每一个闹钟基地初始化其定时器队列头（<code>timerqueue_init_head</code>）和自旋锁（<code>spin_lock_init</code>）。定时器队列是一种高效的数据结构（通常是红黑树），用于按唤醒时间的先后顺序来组织所有的定时器事件。</li><li><strong>硬件接口建立</strong>: 调用<code>alarmtimer_rtc_interface_setup</code>。这是一个关键步骤，它负责在闹钟定时器框架与底层的RTC（Real-Time Clock，实时时钟）设备之间建立联系。RTC是能够在CPU休眠时依然保持计时的硬件，是实现唤醒功能的物理基础。</li><li><strong>驱动注册</strong>: 调用<code>platform_driver_register</code>将<code>alarmtimer_driver</code>注册为一个平台驱动。这意味着闹钟定时器功能被实现为一个等待与平台设备（platform device）进行绑定的驱动程序。这个平台设备通常由底层的RTC驱动或者专门的定时器硬件驱动来注册，代表了能够提供闹钟功能的物理硬件。</li><li><strong>错误处理</strong>: 函数包含了<code>goto</code>跳转的错误处理机制。如果在注册平台驱动时失败，程序会跳转到<code>out_if</code>标签，执行<code>alarmtimer_rtc_interface_remove</code>来撤销之前建立的RTC接口，保证系统状态的一致性。</li></ol><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// alarmtimer_init: 闹钟定时器代码的初始化函数。</span></span><br><span class="line"><span class="comment">// 描述: 此函数初始化闹钟基地并注册POSIX时钟ID。</span></span><br><span class="line"><span class="comment">// __init 标记表示该函数仅在内核初始化期间使用，之后其占用的内存可以被回收。</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">alarmtimer_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> error;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化RTC相关的定时器部分。</span></span><br><span class="line">alarmtimer_rtc_timer_init();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化闹钟基地 */</span></span><br><span class="line"><span class="comment">// 配置实时闹钟（ALARM_REALTIME）。</span></span><br><span class="line">alarm_bases[ALARM_REALTIME].base_clockid = CLOCK_REALTIME;</span><br><span class="line">alarm_bases[ALARM_REALTIME].get_ktime = &amp;ktime_get_real;</span><br><span class="line">alarm_bases[ALARM_REALTIME].get_timespec = ktime_get_real_ts64;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置启动时间闹钟（ALARM_BOOTTIME）。</span></span><br><span class="line">alarm_bases[ALARM_BOOTTIME].base_clockid = CLOCK_BOOTTIME;</span><br><span class="line">alarm_bases[ALARM_BOOTTIME].get_ktime = &amp;ktime_get_boottime;</span><br><span class="line">alarm_bases[ALARM_BOOTTIME].get_timespec = get_boottime_timespec;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环遍历所有类型的闹钟基地，进行通用部分的初始化。</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ALARM_NUMTYPE; i++) &#123;</span><br><span class="line"><span class="comment">// 初始化定时器队列头。</span></span><br><span class="line">timerqueue_init_head(&amp;alarm_bases[i].timerqueue);</span><br><span class="line"><span class="comment">// 初始化自旋锁。</span></span><br><span class="line">spin_lock_init(&amp;alarm_bases[i].lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立闹钟定时器与底层RTC设备的接口。</span></span><br><span class="line">error = alarmtimer_rtc_interface_setup();</span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将alarmtimer_driver注册为一个平台驱动，等待与硬件设备匹配。</span></span><br><span class="line">error = platform_driver_register(&amp;alarmtimer_driver);</span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line"><span class="keyword">goto</span> out_if; <span class="comment">// 如果注册失败，跳转到清理代码。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 初始化成功。</span></span><br><span class="line">out_if:</span><br><span class="line"><span class="comment">// 初始化出错时的清理路径：移除之前建立的RTC接口。</span></span><br><span class="line">alarmtimer_rtc_interface_remove();</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用device_initcall宏，将此初始化函数注册在设备驱动初始化阶段执行。</span></span><br><span class="line">device_initcall(alarmtimer_init);</span><br></pre></td></tr></table></figure><h2 id="闹钟定时器硬件后端发现与绑定"><a href="#闹钟定时器硬件后端发现与绑定" class="headerlink" title="闹钟定时器硬件后端发现与绑定"></a>闹钟定时器硬件后端发现与绑定</h2><p>本代码片段展示了闹钟定时器（Alarm Timer）框架如何动态地发现并绑定一个合适的实时时钟（RTC）设备作为其硬件后端。其核心功能是创建一个“类接口”（class interface），监听系统中所有RTC设备的注册事件。一旦一个具备唤醒能力的RTC设备出现，此代码就会尝试获取该设备，并注册一个名为”alarmtimer”的平台设备，从而将通用的闹钟定时器服务与具体的物理硬件连接起来。</p><h3 id="实现原理分析-1"><a href="#实现原理分析-1" class="headerlink" title="实现原理分析"></a>实现原理分析</h3><p>该机制是Linux设备模型中“胶水层”代码的典型范例，它利用<code>class_interface</code>机制来解耦通用子系统与具体设备驱动。</p><ol><li><p><strong>类接口注册 (<code>alarmtimer_rtc_interface_setup</code>)</strong>:</p><ul><li>此函数是整个机制的入口。它初始化一个<code>class_interface</code>结构体，将其与<code>rtc_class</code>（所有RTC设备都属于这个类）进行关联。</li><li>通过调用<code>class_interface_register</code>，它向内核设备模型注册一个回调。其效果是：每当系统中有一个属于<code>rtc_class</code>的设备被添加时，内核就会自动调用该接口中指定的<code>.add_dev</code>函数，即<code>alarmtimer_rtc_add_device</code>。</li></ul></li><li><p><strong>设备添加处理 (<code>alarmtimer_rtc_add_device</code>)</strong>:</p><ul><li>这是回调的核心逻辑，当一个新的RTC设备被注册时，此函数被调用。</li><li><strong>单例检查</strong>: 首先检查全局指针<code>rtcdev</code>是否已经被赋值。闹钟定时器框架设计为只使用一个RTC设备作为后端，因此如果已经绑定了一个，则直接返回<code>-EBUSY</code>。</li><li><strong>能力检查</strong>: 对传入的RTC设备进行严格的能力验证。<br>a. <code>test_bit(RTC_FEATURE_ALARM, rtc-&gt;features)</code>: 检查该RTC设备是否声称支持硬件闹钟功能。<br>b. <code>device_may_wakeup(rtc-&gt;dev.parent)</code>: 检查该RTC设备是否有能力唤醒系统。这是实现可挂起定时器的物理前提。<br>任何一项检查失败，都表示此RTC不适合作为闹钟定时器的后端。</li><li><strong>平台设备注册</strong>: 如果能力检查通过，它会调用<code>platform_device_register_data</code>注册一个<strong>新的平台设备</strong>，名称为”alarmtimer”。这一步是关键的抽象转换：它将一个具体的RTC设备（如<code>rtc0</code>）的存在，转化为了一个更通用的”alarmtimer”设备的存在。这个新创建的”alarmtimer”平台设备随后就可以与上一段代码分析中注册的<code>alarmtimer_driver</code>平台驱动进行匹配和绑定。</li><li><strong>独占式获取</strong>: 在一个自旋锁的保护下，它再次检查<code>rtcdev</code>，并尝试获取RTC驱动模块和设备的引用计数（<code>try_module_get</code>, <code>get_device</code>）。这确保了在闹钟定时器使用期间，底层的RTC驱动不会被卸载。成功后，将全局<code>rtcdev</code>指向该RTC设备。</li></ul></li><li><p><strong>接口注销 (<code>alarmtimer_rtc_interface_remove</code>)</strong>:</p><ul><li>这是一个清理函数，它调用<code>class_interface_unregister</code>来移除之前注册的回调，停止监听新的RTC设备事件。</li></ul></li></ol><h3 id="代码分析-1"><a href="#代码分析-1" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// alarmtimer_rtc_add_device: 当一个RTC设备被添加到系统时，此回调函数被调用。</span></span><br><span class="line"><span class="comment">// @dev: 指向新添加设备的通用 device 结构体指针。</span></span><br><span class="line"><span class="comment">// 返回值: 成功绑定则为0，否则为负数错误码。</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">alarmtimer_rtc_add_device</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 将通用的device指针转换为rtc_device指针。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtc_device</span> *<span class="title">rtc</span> =</span> to_rtc_device(dev);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">pdev</span>;</span></span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果已经有一个RTC设备被用作闹钟定时器，则返回忙碌。</span></span><br><span class="line"><span class="keyword">if</span> (rtcdev)</span><br><span class="line"><span class="keyword">return</span> -EBUSY;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查RTC设备是否支持闹钟功能。如果不支持，则返回错误。</span></span><br><span class="line"><span class="keyword">if</span> (!test_bit(RTC_FEATURE_ALARM, rtc-&gt;features))</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="comment">// 检查RTC设备是否能够唤醒系统。如果不能，则返回错误。</span></span><br><span class="line"><span class="keyword">if</span> (!device_may_wakeup(rtc-&gt;dev.parent))</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册一个名为&quot;alarmtimer&quot;的平台设备。这个新设备将与alarmtimer_driver匹配。</span></span><br><span class="line">pdev = platform_device_register_data(dev, <span class="string">&quot;alarmtimer&quot;</span>,</span><br><span class="line">     PLATFORM_DEVID_AUTO, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 如果平台设备注册成功，则将其标记为可唤醒设备。</span></span><br><span class="line"><span class="keyword">if</span> (!IS_ERR(pdev))</span><br><span class="line">device_init_wakeup(&amp;pdev-&gt;dev, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用一个带自动解锁功能的锁保护对全局变量rtcdev的访问。</span></span><br><span class="line"><span class="comment">// spinlock_irqsave 会在加锁时禁用中断。</span></span><br><span class="line">scoped_guard(spinlock_irqsave, &amp;rtcdev_lock) &#123;</span><br><span class="line"><span class="comment">// 在锁内再次检查，并确保可以获取RTC驱动模块的引用。</span></span><br><span class="line"><span class="keyword">if</span> (!IS_ERR(pdev) &amp;&amp; !rtcdev &amp;&amp; try_module_get(rtc-&gt;owner)) &#123;</span><br><span class="line"><span class="comment">// 将此RTC设备设为全局唯一的闹钟定时器后端。</span></span><br><span class="line">rtcdev = rtc;</span><br><span class="line"><span class="comment">/* 持有一个设备引用，防止其在使用过程中被释放。 */</span></span><br><span class="line">get_device(dev);</span><br><span class="line"><span class="comment">// pdev指针置为NULL，防止在函数末尾被错误地注销。</span></span><br><span class="line">pdev = <span class="literal">NULL</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果获取失败，设置返回值为错误。</span></span><br><span class="line">ret = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果pdev不为NULL（意味着上面的独占获取失败了），则注销之前注册的平台设备。</span></span><br><span class="line">platform_device_unregister(pdev);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// alarmtimer_rtc_timer_init: 初始化一个rtc_timer结构体。</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">alarmtimer_rtc_timer_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 这是一个简单的包装函数，用于初始化rtctimer。</span></span><br><span class="line">rtc_timer_init(&amp;rtctimer, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个类接口，指定当有设备添加到rtc_class时要调用的函数。</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">class_interface</span> <span class="title">alarmtimer_rtc_interface</span> =</span> &#123;</span><br><span class="line">.add_dev = &amp;alarmtimer_rtc_add_device,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// alarmtimer_rtc_interface_setup: 设置并注册上述的类接口。</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">alarmtimer_rtc_interface_setup</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 指定接口要监听的设备类别为rtc_class。</span></span><br><span class="line">alarmtimer_rtc_interface.class = &amp;rtc_class;</span><br><span class="line"><span class="comment">// 向内核注册此接口。</span></span><br><span class="line"><span class="keyword">return</span> class_interface_register(&amp;alarmtimer_rtc_interface);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// alarmtimer_rtc_interface_remove: 注销类接口。</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">alarmtimer_rtc_interface_remove</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 从内核中注销此接口，停止监听RTC设备事件。</span></span><br><span class="line">class_interface_unregister(&amp;alarmtimer_rtc_interface);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="系统挂起处理与唤醒闹钟设置"><a href="#系统挂起处理与唤醒闹钟设置" class="headerlink" title="系统挂起处理与唤醒闹钟设置"></a>系统挂起处理与唤醒闹钟设置</h2><p>本代码片段是 Linux 内核闹钟定时器（alarmtimer）子系统的电源管理核心。其主要功能是在系统进入挂起（suspend）状态前，通过注册的 <code>alarmtimer_suspend</code> 回调函数，精确计算出下一次需要唤醒系统的时间点，并利用绑定的硬件实时时钟（RTC）设置一个物理唤醒闹钟。在系统恢复（resume）时，通过 <code>alarmtimer_resume</code> 回调函数清理该闹钟。这套机制确保了基于闹钟定时器的定时任务（如 <code>CLOCK_REALTIME_ALARM</code>）能够在系统深度睡眠时依然被准确唤醒和执行。</p><h3 id="实现原理分析-2"><a href="#实现原理分析-2" class="headerlink" title="实现原理分析"></a>实现原理分析</h3><p>该功能通过标准的平台驱动（platform_driver）模型，将闹钟定时器的逻辑与内核的电源管理（Power Management, PM）框架进行挂钩。</p><ol><li><p><strong>驱动与设备绑定</strong>:</p><ul><li><code>alarmtimer_driver</code> 是一个平台驱动，其名称为 <code>&quot;alarmtimer&quot;</code>。在系统初始化阶段，当 <code>alarmtimer_rtc_add_device</code> 函数成功发现并绑定一个合适的 RTC 设备后，会创建一个同名为 <code>&quot;alarmtimer&quot;</code> 的平台设备。内核的设备模型会自动将此驱动与该设备进行匹配。</li><li>匹配成功后，<code>alarmtimer_driver</code> 中定义的 <code>dev_pm_ops</code>（设备电源管理操作集）即被激活。</li></ul></li><li><p><strong>系统挂起处理 (<code>alarmtimer_suspend</code>)</strong>:</p><ul><li>当系统准备进入挂起状态时，内核的 PM 核心会调用所有已注册驱动的 <code>.suspend</code> 回调，<code>alarmtimer_suspend</code> 随之被执行。</li><li><strong>获取最早到期时间</strong>: 函数的核心任务是找出所有已注册的闹钟中，最先到期的那一个。它会遍历 <code>alarm_bases</code> 数组中所有的闹钟类型（<code>ALARM_REALTIME</code> 和 <code>ALARM_BOOTTIME</code>）。</li><li><strong>查询定时器队列</strong>: 对于每种闹钟类型，它会持有该基座的自旋锁，并调用 <code>timerqueue_getnext</code> 从其红黑树实现的定时器队列中，获取到期时间最早的节点。</li><li><strong>计算最小时间差</strong>: 它计算出每个队列中最早到期时间与当前时间的差值（delta），并与一个全局最小值 <code>min</code> 进行比较，持续更新 <code>min</code> 以保存全局最小的时间差。</li><li><strong>安全边界检查</strong>: 如果计算出的最小时间差 <code>min</code> 小于2秒，这意味着有一个闹钟即将到期。为了确保该闹钟能够被精确处理，函数会调用 <code>pm_wakeup_event</code> 来短暂地阻止系统挂起，并返回 <code>-EBUSY</code>。这使得系统有时间在活动状态下处理这个即将到期的软件定时器。</li><li><strong>硬件闹钟编程</strong>: 如果 <code>min</code> 大于安全边界，函数将执行以下步骤来设置硬件唤醒：<br>a.  <code>rtc_timer_cancel</code>: 首先取消任何可能存在的旧的 RTC 闹钟。<br>b.  <code>rtc_read_time</code>: 读取当前 RTC 硬件的精确时间。<br>c.  <code>rtc_bound_alarmtime</code>: 考虑到某些 RTC 硬件可能不支持设置过长时间的闹钟，此函数会将 <code>min</code> 调整到硬件支持的最大范围内。<br>d.  <code>rtc_timer_start</code>: 将当前 RTC 时间与调整后的 <code>min</code> 相加，得到未来的绝对唤醒时间，并调用此函数将该时间编程到 RTC 硬件的闹钟寄存器中。</li></ul></li><li><p><strong>系统恢复处理 (<code>alarmtimer_resume</code>)</strong>:</p><ul><li>当系统从挂起状态被唤醒后（无论是由 RTC 闹钟还是其他唤醒源），PM 核心会调用 <code>.resume</code> 回调。</li><li><code>alarmtimer_resume</code> 的逻辑非常简单：它会调用 <code>rtc_timer_cancel</code> 来无条件地取消之前设置的 RTC 硬件闹钟。这是一个必要的清理步骤，因为系统已经被唤醒，后续的定时将重新由高精度的软件定时器（hrtimer）接管。</li></ul></li></ol><h3 id="代码分析-2"><a href="#代码分析-2" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// alarmtimer_get_rtcdev: 获取并返回当前被选定用于唤醒闹钟的rtc_device结构体指针。</span></span><br><span class="line"><span class="comment">// 该函数是线程和中断安全的。</span></span><br><span class="line"><span class="keyword">struct</span> rtc_device *<span class="title function_">alarmtimer_get_rtcdev</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 声明一个用于存储返回值的rtc_device指针。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtc_device</span> *<span class="title">ret</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用guard宏和spinlock_irqsave来保护对全局变量rtcdev的访问。</span></span><br><span class="line"><span class="comment">// 这会获取rtcdev_lock自旋锁，并在期间禁用本地中断，以保证操作的原子性。</span></span><br><span class="line">guard(spinlock_irqsave)(&amp;rtcdev_lock);</span><br><span class="line"><span class="comment">// 读取全局的rtcdev指针。</span></span><br><span class="line">ret = rtcdev;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回获取到的rtcdev指针。guard宏会在作用域结束时自动释放锁并恢复中断。</span></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将alarmtimer_get_rtcdev函数导出，使其可以被其他内核模块调用。</span></span><br><span class="line">EXPORT_SYMBOL_GPL(alarmtimer_get_rtcdev);</span><br><span class="line"></span><br><span class="line"><span class="comment">// alarmtimer_suspend: 系统进入挂起状态时的回调函数。</span></span><br><span class="line"><span class="comment">// @dev: 指向与此驱动关联的设备结构体指针（此处未使用）。</span></span><br><span class="line"><span class="comment">// 返回值: 成功设置唤醒闹钟则为0，若短暂阻止挂起则为-EBUSY，其他错误则为负值。</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">alarmtimer_suspend</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 声明用于时间计算的ktime_t类型的变量。</span></span><br><span class="line"><span class="type">ktime_t</span> min, now, expires;</span><br><span class="line"><span class="comment">// 声明一个指向RTC设备结构体的指针。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtc_device</span> *<span class="title">rtc</span>;</span></span><br><span class="line"><span class="comment">// 声明一个用于读取RTC时间的rtc_time结构体。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtc_time</span> <span class="title">tm</span>;</span></span><br><span class="line"><span class="comment">// 声明循环计数器、返回值和闹钟类型变量。</span></span><br><span class="line"><span class="type">int</span> i, ret, type;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用scoped_guard宏保护对freezer相关全局变量的访问。</span></span><br><span class="line"><span class="comment">// 这是一个原子操作，用于获取与进程冻结相关的预设闹钟信息。</span></span><br><span class="line">scoped_guard(spinlock_irqsave, &amp;freezer_delta_lock) &#123;</span><br><span class="line">min = freezer_delta;</span><br><span class="line">expires = freezer_expires;</span><br><span class="line">type = freezer_alarmtype;</span><br><span class="line"><span class="comment">// 读取后立即清零，确保只处理一次。</span></span><br><span class="line">freezer_delta = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前绑定的RTC设备。</span></span><br><span class="line">rtc = alarmtimer_get_rtcdev();</span><br><span class="line"><span class="comment">// 如果没有绑定的RTC设备，则无法设置唤醒闹钟，直接返回0表示成功（无事可做）。</span></span><br><span class="line"><span class="keyword">if</span> (!rtc)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有闹钟类型（REALTIME, BOOTTIME），以找出最早到期的那一个。</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ALARM_NUMTYPE; i++) &#123;</span><br><span class="line"><span class="comment">// 获取当前类型的闹钟基准。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alarm_base</span> *<span class="title">base</span> =</span> &amp;alarm_bases[i];</span><br><span class="line"><span class="comment">// 声明一个指向定时器队列节点的指针。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timerqueue_node</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="comment">// 声明一个用于存储时间差的变量。</span></span><br><span class="line"><span class="type">ktime_t</span> delta;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在锁保护下，从定时器队列中获取下一个（即最早）到期的节点。</span></span><br><span class="line">scoped_guard(spinlock_irqsave, &amp;base-&gt;lock)</span><br><span class="line">next = timerqueue_getnext(&amp;base-&gt;timerqueue);</span><br><span class="line"><span class="comment">// 如果该类型的队列为空，则继续检查下一种类型。</span></span><br><span class="line"><span class="keyword">if</span> (!next)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">// 计算该闹钟的到期时间与当前时间的差值。</span></span><br><span class="line">delta = ktime_sub(next-&gt;expires, base-&gt;get_ktime());</span><br><span class="line"><span class="comment">// 如果min为0（尚未初始化）或者当前delta更小，则更新全局最早到期信息。</span></span><br><span class="line"><span class="keyword">if</span> (!min || (delta &lt; min)) &#123;</span><br><span class="line">expires = next-&gt;expires;</span><br><span class="line">min = delta;</span><br><span class="line">type = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果遍历完所有闹钟后，min仍为0，表示没有活动的唤醒闹钟，直接返回。</span></span><br><span class="line"><span class="keyword">if</span> (min == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果最早的闹钟在2秒内就要到期，则阻止系统挂起。</span></span><br><span class="line"><span class="comment">// 这样做是为了让即将到期的软件定时器能在系统活动状态下被精确处理。</span></span><br><span class="line"><span class="keyword">if</span> (ktime_to_ns(min) &lt; <span class="number">2</span> * NSEC_PER_SEC) &#123;</span><br><span class="line"><span class="comment">// 发送一个唤醒事件，推迟挂起过程。</span></span><br><span class="line">pm_wakeup_event(dev, <span class="number">2</span> * MSEC_PER_SEC);</span><br><span class="line"><span class="comment">// 返回-EBUSY，通知电源管理核心当前无法挂起。</span></span><br><span class="line"><span class="keyword">return</span> -EBUSY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录将要设置的唤醒闹钟的追踪信息。</span></span><br><span class="line">trace_alarmtimer_suspend(expires, type);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消任何可能已存在的由本模块设置的RTC定时器。</span></span><br><span class="line">rtc_timer_cancel(rtc, &amp;rtctimer);</span><br><span class="line"><span class="comment">// 从RTC硬件读取当前的日历时间。</span></span><br><span class="line">rtc_read_time(rtc, &amp;tm);</span><br><span class="line"><span class="comment">// 将读取到的rtc_time格式转换为内核通用的ktime_t格式。</span></span><br><span class="line">now = rtc_tm_to_ktime(tm);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 考虑到RTC硬件可能对可设置的闹钟时间范围有限制，</span></span><br><span class="line"><span class="comment">// 调用rtc_bound_alarmtime将min调整到硬件支持的最大值以内。</span></span><br><span class="line">min = rtc_bound_alarmtime(rtc, min);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算出绝对的唤醒时间点（当前时间 + 相对时间差）。</span></span><br><span class="line">now = ktime_add(now, min);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用计算出的绝对时间，启动RTC硬件闹钟。</span></span><br><span class="line"><span class="comment">// 如果设置的唤醒时间已经过去，该函数会返回错误。</span></span><br><span class="line">ret = rtc_timer_start(rtc, &amp;rtctimer, now, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 如果rtc_timer_start返回错误（例如时间已过去），则发送一个唤醒事件。</span></span><br><span class="line"><span class="comment">// 这会短暂地阻止挂起，让系统有机会处理这个错过的事件。</span></span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">pm_wakeup_event(dev, MSEC_PER_SEC);</span><br><span class="line"><span class="comment">// 返回rtc_timer_start的结果。</span></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// alarmtimer_resume: 系统从挂起状态恢复时的回调函数。</span></span><br><span class="line"><span class="comment">// @dev: 指向与此驱动关联的设备结构体指针（此处未使用）。</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">alarmtimer_resume</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 声明一个指向RTC设备结构体的指针。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtc_device</span> *<span class="title">rtc</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前绑定的RTC设备。</span></span><br><span class="line">rtc = alarmtimer_get_rtcdev();</span><br><span class="line"><span class="comment">// 如果存在绑定的RTC设备，则取消之前在suspend期间设置的硬件闹钟。</span></span><br><span class="line"><span class="comment">// 这是一个必要的清理步骤，因为系统已被唤醒，软件定时器将接管。</span></span><br><span class="line"><span class="keyword">if</span> (rtc)</span><br><span class="line">rtc_timer_cancel(rtc, &amp;rtctimer);</span><br><span class="line"><span class="comment">// 返回0表示成功。</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个设备电源管理操作集结构体。</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_ops</span> <span class="title">alarmtimer_pm_ops</span> =</span> &#123;</span><br><span class="line"><span class="comment">// 将.suspend回调指向alarmtimer_suspend函数。</span></span><br><span class="line">.suspend = alarmtimer_suspend,</span><br><span class="line"><span class="comment">// 将.resume回调指向alarmtimer_resume函数。</span></span><br><span class="line">.resume = alarmtimer_resume,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个平台驱动结构体。</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">alarmtimer_driver</span> =</span> &#123;</span><br><span class="line">.driver = &#123;</span><br><span class="line"><span class="comment">// 设置驱动的名称为&quot;alarmtimer&quot;。</span></span><br><span class="line"><span class="comment">// 这个名称将用于与由alarmtimer_rtc_add_device创建的平台设备进行匹配。</span></span><br><span class="line">.name = <span class="string">&quot;alarmtimer&quot;</span>,</span><br><span class="line"><span class="comment">// 将驱动的电源管理操作集指向上面定义的alarmtimer_pm_ops。</span></span><br><span class="line">.pm = &amp;alarmtimer_pm_ops,</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;kernel-time-alarmtimer-c&quot;&gt;&lt;a href=&quot;#kernel-time-alarmtimer-c&quot; class=&quot;headerlink&quot; title=&quot;kernel&amp;#x2F;time&amp;#x2F;alarmtime</summary>
      
    
    
    
    <category term="linux" scheme="https://wdfk-prog.space/categories/linux/"/>
    
    <category term="kernel" scheme="https://wdfk-prog.space/categories/linux/kernel/"/>
    
    <category term="time" scheme="https://wdfk-prog.space/categories/linux/kernel/time/"/>
    
    
    <category term="linux" scheme="https://wdfk-prog.space/tags/linux/"/>
    
    <category term="kernel" scheme="https://wdfk-prog.space/tags/kernel/"/>
    
    <category term="time" scheme="https://wdfk-prog.space/tags/time/"/>
    
  </entry>
  
  <entry>
    <title>hpatch 学习笔记</title>
    <link href="https://wdfk-prog.space/posts/873586f3/"/>
    <id>https://wdfk-prog.space/posts/873586f3/</id>
    <published>2025-10-04T14:23:04.000Z</published>
    <updated>2025-10-04T14:26:33.490Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hpatch-学习笔记"><a href="#hpatch-学习笔记" class="headerlink" title="hpatch 学习笔记"></a>hpatch 学习笔记</h1><ul><li><ol><li><a href="libdivsufsort/">libdivsufsort</a></li></ol><ul><li><a href="libdivsufsort/divsufsort.md">1.1. divsufsort.md</a></li><li><a href="libdivsufsort/sssort.md">1.2. sssort.md</a></li><li><a href="libdivsufsort/trsort.md">1.3. trsort.md</a></li></ul></li><li><ol start="2"><li><a href="SA-IS/">SA-IS</a></li></ol><ul><li><a href="SA-IS/SA-IS.md">2.1. SA-IS.md</a></li></ul></li><li><a href="hdiffpatch.md">3. hdiffpatch.md</a></li><li><a href="HPatch.md">4. HPatch.md</a></li><li><a href="hpatch_lite.md">5. hpatch_lite.md</a></li><li><a href="readme.md">6. readme.md</a></li><li><a href="SuffixString.md">7. SuffixString.md</a></li><li><a href="tinyuz.md">8. tinyuz.md</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;hpatch-学习笔记&quot;&gt;&lt;a href=&quot;#hpatch-学习笔记&quot; class=&quot;headerlink&quot; title=&quot;hpatch 学习笔记&quot;&gt;&lt;/a&gt;hpatch 学习笔记&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;libdivsufs</summary>
      
    
    
    
    <category term="hpatch" scheme="https://wdfk-prog.space/categories/hpatch/"/>
    
    
    <category term="hpatch" scheme="https://wdfk-prog.space/tags/hpatch/"/>
    
  </entry>
  
  <entry>
    <title>HPatch</title>
    <link href="https://wdfk-prog.space/posts/b701678d/"/>
    <id>https://wdfk-prog.space/posts/b701678d/</id>
    <published>2025-10-04T10:57:17.000Z</published>
    <updated>2025-10-07T00:22:02.640Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>[TOC]</p><p><img src="https://i-blog.csdnimg.cn/direct/72a0f919146843cba861601b64feb07c.png" alt="在这里插入图片描述"></p><h1 id="HDiffPatch-libHDiffPatch-HPatch-patch-c"><a href="#HDiffPatch-libHDiffPatch-HPatch-patch-c" class="headerlink" title="HDiffPatch\libHDiffPatch\HPatch\patch.c"></a>HDiffPatch\libHDiffPatch\HPatch\patch.c</h1><h2 id="packUInt-hpatch-packUIntWithTag-可变长度整数编码"><a href="#packUInt-hpatch-packUIntWithTag-可变长度整数编码" class="headerlink" title="packUInt &amp; hpatch_packUIntWithTag 可变长度整数编码"></a>packUInt &amp; hpatch_packUIntWithTag <strong>可变长度整数编码</strong></h2><p>这组函数实现了一种高效的、类似于 <strong>LEB128 (Little-Endian Base 128)</strong> 或 <strong>VLQ (Variable-length quantity)</strong> 的整数编码方案。其核心目标是：<strong>用更少的字节来表示小数值，用更多的字节来表示大数值</strong>，从而在数据流中实现对数值本身的压缩。</p><h3 id="原理与设计思路解析"><a href="#原理与设计思路解析" class="headerlink" title="原理与设计思路解析"></a><strong>原理与设计思路解析</strong></h3><p>您提供的注释已经非常精彩地概括了其编码方案，我将在此基础上做更详细的解析。</p><ul><li><p><strong>编码规则 (Encoding Scheme):</strong><br>算法将一个整数 <code>uValue</code> 拆分成多个字节进行存储。每个字节都由两部分组成：</p><ol><li><strong>数据位 (Data Bits):</strong> 每个字节的<strong>低7位</strong>用于存储 <code>uValue</code> 的一部分数据。</li><li><strong>连续标志位 (Continuation Bit):</strong> 每个字节的<strong>最高位 (MSB)</strong> 作为标志位。<ul><li>如果 MSB 是 <code>1</code>，表示后面<strong>还有</strong>字节属于这个整数。</li><li>如果 MSB 是 <code>0</code>，表示这是这个整数的<strong>最后一个</strong>字节。</li></ul></li></ol></li><li><p><strong>带标签的编码 (<code>hpatch_packUIntWithTag</code>)</strong><br>HDiffPatch 的实现比标准的 LEB128 更进一步，它允许在第一个字节中<strong>嵌入额外的标志位 (tag)</strong>。</p><ul><li><p><strong>第一个字节的结构:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Bit:  | 7 | 6 ... (8-kTagBit) | (7-kTagBit) | (6-kTagBit) ... 0 |</span><br><span class="line">Desc: | C |      highTag      |      C&#x27;     |    uValue_part1   |</span><br></pre></td></tr></table></figure><ul><li><strong><code>C&#39;</code> (Bit <code>7-kTagBit</code>):</strong> 这是<strong>主连续标志位</strong>。如果为 <code>1</code>，表示后面还有字节。</li><li><strong><code>highTag</code> (Bits <code>(8-kTagBit)</code> to <code>6</code>):</strong> 这是用户可以自定义的 <code>kTagBit</code> 个标志位，用于在上层协议中传递额外信息（例如 <code>isNullSubDiff</code> 标志）。</li><li><strong><code>uValue_part1</code>:</strong> 第一个字节中用于存储数值本身的数据位。</li></ul></li><li><p><strong>后续字节的结构:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Bit:  |   7   | 6 ... 0 |</span><br><span class="line">Desc: |   C   | uValue_partN |</span><br></pre></td></tr></table></figure><ul><li><strong><code>C</code> (Bit 7):</strong> <strong>连续标志位</strong>。</li><li><strong><code>uValue_partN</code>:</strong> 后续字节用于存储数值的数据位。</li></ul></li></ul></li><li><p><strong><code>hpatch_packUIntWithTag</code> 的实现逻辑 (大端序输出)</strong><br>这个函数的实现非常巧妙，它生成的是一个<strong>大端序 (Big-Endian)</strong> 的可变长度整数，这意味着数值的<strong>最高有效位</strong>被编码在第一个字节中。</p><ol><li><p><strong>分解 (Decomposition):</strong></p><ul><li><code>while (uValue &gt; kMaxValueWithTag)</code>: 循环不断地从 <code>uValue</code> 中取出<strong>低7位</strong> (<code>uValue &amp; ((1&lt;&lt;7)-1)</code>)，并将其<strong>逆序</strong>存入一个临时的 <code>codeBuf</code> 缓冲区中。</li><li><code>uValue &gt;&gt;= 7</code>: 将 <code>uValue</code> 右移7位，准备处理下一部分。</li><li>这个循环结束后，<code>uValue</code> 中只剩下最高的一部分数据，而 <code>codeBuf</code> 中则逆序存储了所有低位部分。</li></ul></li><li><p><strong>编码第一个字节 (Head Byte):</strong></p><ul><li><code>*pcode = (TByte)( (TByte)uValue | (highTag&lt;&lt;(8-kTagBit)) | ... );</code></li><li>将 <code>uValue</code> 的剩余高位部分，与 <code>highTag</code> 和主连续标志位 <code>C&#39;</code> 通过位运算组合起来，形成第一个字节。</li></ul></li><li><p><strong>编码后续字节 (Tail Bytes):</strong></p><ul><li><code>while (codeBuf != codeEnd)</code>: 循环<strong>从后向前</strong>遍历 <code>codeBuf</code>（即按正确的顺序）。</li><li><code>*pcode = (*codeEnd) | (TByte)(((codeBuf!=codeEnd)?1:0)&lt;&lt;7);</code></li><li>将 <code>codeBuf</code> 中的7位数据与连续标志位 <code>C</code> 组合起来，形成后续的字节。</li></ul></li></ol></li><li><p><strong>C++ 包装器 (<code>packUIntWithTag</code>, <code>packUInt</code>)</strong></p><ul><li><code>pack_uint.h</code> 中的 <code>packUInt...</code> 函数是对底层C函数 <code>hpatch_packUIntWithTag</code> 的C++风格<strong>包装器</strong>。</li><li>它们负责处理 <code>std::vector</code> 的内存管理，使得调用者可以方便地将编码后的字节流追加到 <code>vector</code> 的末尾，而无需手动管理缓冲区指针和大小。<code>packUInt</code> 是 <code>packUIntWithTag</code> 的一个特例，它默认 <code>tag</code> 和 <code>kTagBit</code> 都为0。</li></ul></li></ul><h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a><strong>代码解析</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Variable-length positive integer encoding scheme ...</span></span><br><span class="line"><span class="comment">// (注释详细描述了编码格式)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 将一个64位无符号整数 uValue 进行可变长度编码，并允许在第一个字节中嵌入 kTagBit 个高位标志。</span></span><br><span class="line"><span class="comment"> * @param out_code         输入输出参数，指向用于写入的缓冲区指针，函数会推进此指针。</span></span><br><span class="line"><span class="comment"> * @param out_code_end     缓冲区的结束边界，用于安全检查。</span></span><br><span class="line"><span class="comment"> * @param uValue           待编码的整数。</span></span><br><span class="line"><span class="comment"> * @param highTag          要嵌入的高位标志值。</span></span><br><span class="line"><span class="comment"> * @param kTagBit          标志位的数量。</span></span><br><span class="line"><span class="comment"> * @return hpatch_BOOL     成功返回 hpatch_TRUE。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">hpatch_BOOL <span class="title function_">hpatch_packUIntWithTag</span><span class="params">(TByte** out_code,TByte* out_code_end,</span></span><br><span class="line"><span class="params">                                   hpatch_StreamPos_t uValue,hpatch_uint highTag,</span></span><br><span class="line"><span class="params">                                   <span class="type">const</span> hpatch_uint kTagBit)</span>&#123;</span><br><span class="line">    TByte*          pcode=*out_code;</span><br><span class="line">    <span class="comment">// 计算第一个字节能容纳的最大数值</span></span><br><span class="line">    <span class="type">const</span> hpatch_StreamPos_t kMaxValueWithTag=((hpatch_StreamPos_t)<span class="number">1</span>&lt;&lt;(<span class="number">7</span>-kTagBit))<span class="number">-1</span>;</span><br><span class="line">    TByte           codeBuf[hpatch_kMaxPackedUIntBytes]; <span class="comment">// 临时缓冲区</span></span><br><span class="line">    TByte*          codeEnd=codeBuf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 1. 分解阶段 ---</span></span><br><span class="line">    <span class="comment">// 只要 uValue 还大于第一个字节的容量</span></span><br><span class="line">    <span class="keyword">while</span> (uValue&gt;kMaxValueWithTag) &#123;</span><br><span class="line">        <span class="comment">// 取出 uValue 的低7位，存入临时缓冲区</span></span><br><span class="line">        *codeEnd=uValue&amp;((<span class="number">1</span>&lt;&lt;<span class="number">7</span>)<span class="number">-1</span>); ++codeEnd;</span><br><span class="line">        <span class="comment">// uValue 右移7位</span></span><br><span class="line">        uValue&gt;&gt;=<span class="number">7</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查输出缓冲区是否足够大</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __RUN_MEM_SAFE_CHECK</span></span><br><span class="line">    <span class="keyword">if</span> ((out_code_end-pcode)&lt;(<span class="number">1</span>+(codeEnd-codeBuf))) <span class="keyword">return</span> _hpatch_FALSE;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 2. 编码第一个字节 ---</span></span><br><span class="line">    <span class="comment">// 组合：uValue的剩余高位 | 用户自定义的tag | 主连续标志位</span></span><br><span class="line">    *pcode=(TByte)( (TByte)uValue | (highTag&lt;&lt;(<span class="number">8</span>-kTagBit))</span><br><span class="line">                   | (((codeBuf!=codeEnd)?<span class="number">1</span>:<span class="number">0</span>)&lt;&lt;(<span class="number">7</span>-kTagBit))  );</span><br><span class="line">    ++pcode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 3. 编码后续字节 ---</span></span><br><span class="line">    <span class="comment">// 从后向前遍历临时缓冲区（即按正序处理数值的低位部分）</span></span><br><span class="line">    <span class="keyword">while</span> (codeBuf!=codeEnd) &#123;</span><br><span class="line">        --codeEnd;</span><br><span class="line">        <span class="comment">// 组合：7位数据 | 连续标志位</span></span><br><span class="line">        *pcode=(*codeEnd) | (TByte)(((codeBuf!=codeEnd)?<span class="number">1</span>:<span class="number">0</span>)&lt;&lt;<span class="number">7</span>);</span><br><span class="line">        ++pcode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *out_code=pcode; <span class="comment">// 更新外部指针</span></span><br><span class="line">    <span class="keyword">return</span> hpatch_TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;

&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i-blog.csdnimg.cn/direct/72a0f919146843cba861601b64feb07c.</summary>
      
    
    
    
    <category term="hpatch" scheme="https://wdfk-prog.space/categories/hpatch/"/>
    
    
    <category term="hpatch" scheme="https://wdfk-prog.space/tags/hpatch/"/>
    
  </entry>
  
  <entry>
    <title>tinyuz</title>
    <link href="https://wdfk-prog.space/posts/d7123d36/"/>
    <id>https://wdfk-prog.space/posts/d7123d36/</id>
    <published>2025-10-04T10:57:17.000Z</published>
    <updated>2025-10-06T00:02:42.423Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="tinyuz-compress-tuz-enc-cpp"><a href="#tinyuz-compress-tuz-enc-cpp" class="headerlink" title="tinyuz\compress\tuz_enc.cpp"></a>tinyuz\compress\tuz_enc.cpp</h1><h2 id="tuz-compress-Tuz-数据压缩核心实现"><a href="#tuz-compress-Tuz-数据压缩核心实现" class="headerlink" title="tuz_compress Tuz 数据压缩核心实现"></a>tuz_compress <strong>Tuz 数据压缩核心实现</strong></h2><ul><li>负责执行 Tuz 无损压缩算法，将输入数据流 (<code>data</code>) 压缩后写入输出数据流 (<code>out_code</code>)。该实现同时支持高效的单线程和多线程压缩模式。</li></ul><h3 id="原理与设计思路解析"><a href="#原理与设计思路解析" class="headerlink" title="原理与设计思路解析"></a><strong>原理与设计思路解析</strong></h3><p><code>tuz_compress</code> 函数是 Tuz 压缩器的核心，它负责编排整个压缩流程。其设计思想围绕着<strong>分块处理 (Clipping)</strong> 和<strong>并行计算</strong>，以在处理大规模数据时兼顾内存效率和执行速度。</p><ul><li><p><strong>核心压缩策略</strong></p><ol><li><strong>写入文件头 (Header First):</strong> 压缩开始时，首先会向输出流写入一个头部。这个头部包含了后续解压所必需的元数据，最主要的是<strong>字典大小 (Dictionary Size)</strong>。</li><li><strong>数据分块 (Clipping):</strong> 为了有效管理内存并为并行化创造条件，输入数据不会被一次性加载。相反，它会被切分成连续的、大小适中的数据块，称为 “clip”。每个 clip 的大小会根据字典大小进行策略性计算，以平衡压缩率和处理开销。</li><li><strong>分块压缩:</strong> 真正的压缩逻辑由 <code>compress_clip</code> 函数（在本代码片段中被调用，但其定义在别处）执行。该函数对每一个 clip 进行处理，利用一个滑动字典来查找重复数据序列，并将其编码为 (长度, 距离) 对。</li><li><strong>写入控制码:</strong> 在每个 clip 压缩完成后，会向输出流中写入一个特殊的<strong>控制码</strong> (<code>outCtrl_clipEnd</code>)，用于标记数据块的结束。当所有数据都处理完毕后，则写入一个流结束控制码 (<code>outCtrl_streamEnd</code>)。</li><li><strong>动态字典大小优化:</strong> 一个精巧的设计是，在整个压缩过程结束后，函数会检查实际使用的最大字典大小 (<code>curDictSizeMax</code>)。如果这个值小于最初设定的字典大小，它会重写文件头，将字典大小更新为这个更精确、更小的值。这可以在不影响解压的前提下，节省几个字节的头部空间。</li></ol></li><li><p><strong>多线程设计 (Producer-Consumer 模型)</strong><br>当用户指定使用多个线程时，代码会切换到一套精心设计的并行处理模型：</p><ul><li><strong>任务分发与执行:</strong> 主线程将整个数据流划分为多个 clips，并将这些 clips 作为独立的任务。然后启动一个工作线程池，每个线程从任务池中领取一个 clip 进行压缩。</li><li><strong>独立处理:</strong> 每个工作线程都拥有自己独立的字典缓冲区 (<code>TDictBuf</code>) 和编码器 (<code>TTuzCode</code>)，从而避免了线程间的锁竞争，实现了高度并行的压缩处理。</li><li><strong>有序结果提交:</strong> 由于线程完成任务的顺序是不确定的，代码采用了一个<strong>有序写入</strong>机制 (<code>finishWork</code> 函数，在多线程控制器 <code>TMt</code> 中实现)。当一个线程完成压缩后，它会尝试提交结果。如果它所处理的 clip 正是下一个需要被写入输出流的块，则直接写入；否则，它会将结果暂存到一个按顺序排序的链表中，等待轮到它时再由其他线程或主线程写入。这个机制确保了即使工作线程乱序完成，最终的压缩产物依然是正确、连续的。</li></ul></li><li><p><strong>设计优点</strong></p><ul><li><strong>内存效率:</strong> 分块处理策略避免了将整个文件加载到内存中，使得压缩超大文件成为可能。</li><li><strong>高可伸缩性:</strong> 多线程架构能充分利用现代多核 CPU 的计算能力，在处理大文件时显著提升压缩速度。</li><li><strong>灵活性:</strong> <code>tuz_TCompressProps</code> 结构体允许调用者根据需求（例如，速度优先还是压缩率优先）灵活调整字典大小、线程数等关键参数。</li><li><strong>自适应优化:</strong> 压缩结束时对字典大小的动态更新是一个锦上添花的优化，体现了设计的精细。</li></ul></li></ul><h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a><strong>代码解析</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Tuz 压缩主函数。</span></span><br><span class="line"><span class="comment"> * @param out_code          压缩数据的输出流。</span></span><br><span class="line"><span class="comment"> * @param data              原始数据的输入流。</span></span><br><span class="line"><span class="comment"> * @param props             压缩参数配置，可为 NULL 使用默认值。</span></span><br><span class="line"><span class="comment"> * @return hpatch_StreamPos_t 返回压缩后的总大小。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">hpatch_StreamPos_t <span class="title function_">tuz_compress</span><span class="params">(<span class="type">const</span> hpatch_TStreamOutput* out_code,<span class="type">const</span> hpatch_TStreamInput* data,</span></span><br><span class="line"><span class="params">                                <span class="type">const</span> tuz_TCompressProps* props)</span>&#123;</span><br><span class="line">    <span class="comment">// --- 1. 参数校验与初始化 ---</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// checkv 是一个校验宏，确保输入输出流有效。</span></span><br><span class="line">    checkv(out_code&amp;&amp;(out_code-&gt;write));</span><br><span class="line">    checkv(data&amp;&amp;(data-&gt;read));</span><br><span class="line">    <span class="keyword">if</span> (props)&#123; <span class="comment">// 如果用户传入了自定义配置，则校验其合法性。</span></span><br><span class="line">        checkv((props-&gt;dictSize&gt;=<span class="number">1</span>)&amp;(props-&gt;dictSize&lt;=tuz_kMaxOfDictSize)); <span class="comment">// 字典大小范围</span></span><br><span class="line">        checkv(props-&gt;dictSize==(<span class="type">tuz_size_t</span>)props-&gt;dictSize); <span class="comment">// 字典大小类型</span></span><br><span class="line">        checkv(props-&gt;maxSaveLength==(<span class="type">tuz_length_t</span>)props-&gt;maxSaveLength); <span class="comment">// 匹配长度类型</span></span><br><span class="line">        checkv((props-&gt;maxSaveLength&gt;=tuz_kMinOfMaxSaveLength)&amp;&amp;(props-&gt;maxSaveLength&lt;=tuz_kMaxOfMaxSaveLength)); <span class="comment">// 匹配长度范围</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 若 props 为空，使用默认配置；否则，拷贝一份到 selfProps。</span></span><br><span class="line">    tuz_TCompressProps selfProps=(props)?*props:tuz_kDefaultCompressProps;</span><br><span class="line">    <span class="comment">// 优化：如果设定的字典大小超过了原始数据大小，则将其调整为原始数据大小，因为更大的字典是无用的。</span></span><br><span class="line">    <span class="keyword">if</span> (selfProps.dictSize&gt;data-&gt;streamSize)&#123;</span><br><span class="line">        selfProps.dictSize=(<span class="type">size_t</span>)(data-&gt;streamSize);</span><br><span class="line">        <span class="keyword">if</span> (selfProps.dictSize==<span class="number">0</span>) <span class="comment">// 字典大小至少为1，以防数据为空。</span></span><br><span class="line">            selfProps.dictSize=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    hpatch_StreamPos_t cur_out_pos=<span class="number">0</span>; <span class="comment">// 记录当前在输出流中的写入位置。</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;tuz_byte&gt; code;       <span class="comment">// 一个临时的字节缓冲区，用于暂存生成的压缩码。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// --- 2. 写入文件头 ---</span></span><br><span class="line">    &#123;<span class="comment">//head 作用域块</span></span><br><span class="line">        assert(code.empty()); <span class="comment">// 确保缓冲区是空的。</span></span><br><span class="line">        <span class="comment">// 创建一个编码器实例，它会将编码结果写入 code 缓冲区。</span></span><br><span class="line">        TTuzCode <span class="title function_">coder</span><span class="params">(code,selfProps.isNeedLiteralLine)</span>; </span><br><span class="line">checkv(selfProps.dictSize==(<span class="type">tuz_size_t</span>)selfProps.dictSize);</span><br><span class="line">        checkv(selfProps.maxSaveLength==(<span class="type">tuz_length_t</span>)selfProps.maxSaveLength);</span><br><span class="line">        <span class="comment">// 将字典大小编码并存入 code 缓冲区。</span></span><br><span class="line">        coder.outDictSize(selfProps.dictSize);</span><br><span class="line">        <span class="comment">// 将 code 缓冲区中的头部数据写入到输出流。</span></span><br><span class="line">        _flush_code(out_code,cur_out_pos,code);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 3. 计算分块(clip)大小和线程数 ---</span></span><br><span class="line">    <span class="type">size_t</span> curDictSizeMax=tuz_kMinOfDictSize; <span class="comment">// 用于记录压缩全程实际用到的最大字典大小。</span></span><br><span class="line">    hpatch_StreamPos_t clipSize; <span class="comment">// 每个数据块的大小。</span></span><br><span class="line">    <span class="type">size_t</span> threadNum=(props)?props-&gt;threadNum:<span class="number">1</span>; <span class="comment">// 从 props 获取线程数，若 props 为空则默认为1。</span></span><br><span class="line">    &#123; <span class="comment">// 作用域块，用于计算 clipSize</span></span><br><span class="line">        <span class="comment">// 这是一个启发式算法，初步将 clipSize 设为字典大小的 1/3 左右。</span></span><br><span class="line">        clipSize=((hpatch_StreamPos_t)selfProps.dictSize+<span class="number">1</span>)/<span class="number">3</span>;</span><br><span class="line">        <span class="comment">// 限制 clipSize 在一个合理的最小和最大值之间。</span></span><br><span class="line">        <span class="keyword">if</span> (clipSize&lt;kMinBestClipSize) clipSize=kMinBestClipSize;</span><br><span class="line">        <span class="keyword">if</span> (clipSize&gt;kMaxBestClipSize) clipSize=kMaxBestClipSize;</span><br><span class="line">        <span class="comment">// 根据文件总大小和初步的 clipSize，计算总共需要多少个 clip。</span></span><br><span class="line">        hpatch_StreamPos_t clipCount=(data-&gt;streamSize+clipSize)/clipSize;</span><br><span class="line">        <span class="comment">// 再反过来根据 clip 数量，计算出更均匀、能整除的 clipSize。</span></span><br><span class="line">        clipSize=(data-&gt;streamSize+clipCount<span class="number">-1</span>)/clipCount;</span><br><span class="line">        <span class="comment">// 优化：线程数不能超过 clip 的数量，否则多余的线程将没有工作。</span></span><br><span class="line">        <span class="keyword">if</span> (threadNum&gt;clipCount) threadNum=(<span class="type">size_t</span>)clipCount;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// --- 4. 根据线程数选择执行路径 (多线程或单线程) ---</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (_IS_USED_MULTITHREAD) <span class="comment">// 仅在启用多线程编译时，此代码块有效。</span></span></span><br><span class="line">    <span class="keyword">if</span> (threadNum&gt;<span class="number">1</span>)&#123; <span class="comment">// **多线程执行路径**</span></span><br><span class="line">        TMt <span class="title function_">mt</span><span class="params">(out_code,data)</span>; <span class="comment">// 初始化多线程控制器。</span></span><br><span class="line">        <span class="comment">// 设置控制器的各种状态。</span></span><br><span class="line">        mt.selfProps=selfProps;</span><br><span class="line">        mt.clipSize=clipSize;</span><br><span class="line">        mt.curWorkClipPos=<span class="number">0</span>;</span><br><span class="line">        mt.curOutedClipPos=<span class="number">0</span>;</span><br><span class="line">        mt.curWritePos=cur_out_pos;</span><br><span class="line">        mt.curDictSizeMax=curDictSizeMax;</span><br><span class="line">        mt.workBufList=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 创建一个 TWorkBuf 对象池（大小略多于线程数，用于缓冲），并将其放入工作通道中等待线程领取。</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TWorkBuf&gt; _codeList;</span><br><span class="line">        _codeList.resize(threadNum+<span class="number">1</span>+threadNum/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i=<span class="number">0</span>;i&lt;_codeList.size();++i)</span><br><span class="line">            checkv(mt.work_chan.send(&amp;_codeList[i],<span class="literal">true</span>));</span><br><span class="line">        <span class="comment">// 启动工作线程池，每个线程执行 _tuz_compress_mt 函数。</span></span><br><span class="line">        mt.start_threads((<span class="type">int</span>)threadNum,_tuz_compress_mt,&amp;mt,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程在此等待所有工作线程执行完毕。</span></span><br><span class="line">        mt.wait_all_thread_end();</span><br><span class="line">        checkv(!mt.is_on_error()); <span class="comment">// 检查执行过程中是否有错误发生。</span></span><br><span class="line">        checkv(mt.curOutedClipPos==data-&gt;streamSize); <span class="comment">// 确认所有数据都已被处理和输出。</span></span><br><span class="line">        <span class="comment">// 从控制器获取最终的 curDictSizeMax 和 cur_out_pos 状态。</span></span><br><span class="line">        curDictSizeMax=mt.curDictSizeMax;</span><br><span class="line">        cur_out_pos=mt.curWritePos;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#123; <span class="comment">// **单线程执行路径**</span></span><br><span class="line">        TDictBuf dict_buf; <span class="comment">// 单线程模式下，全程共享一个字典缓冲区。</span></span><br><span class="line">        <span class="comment">// 循环处理每一个 clip，直到整个数据流结束。</span></span><br><span class="line">        <span class="keyword">for</span> (hpatch_StreamPos_t clipBegin=<span class="number">0</span>;<span class="literal">true</span>;clipBegin+=clipSize) &#123;</span><br><span class="line">            hpatch_StreamPos_t clipEnd=clipBegin+clipSize;</span><br><span class="line">            <span class="type">bool</span> isToStreamEnd=(clipEnd&gt;=data-&gt;streamSize);</span><br><span class="line">            <span class="keyword">if</span> (isToStreamEnd) clipEnd=data-&gt;streamSize; <span class="comment">// 确保最后一个 clip 不会越界。</span></span><br><span class="line"></span><br><span class="line">            assert(code.empty());</span><br><span class="line">            TTuzCode <span class="title function_">coder</span><span class="params">(code,selfProps.isNeedLiteralLine)</span>;</span><br><span class="line">            <span class="keyword">if</span> (clipBegin&lt;clipEnd)&#123;</span><br><span class="line">                <span class="comment">// 调用核心压缩逻辑处理当前 clip。</span></span><br><span class="line">                compress_clip(coder,data,clipBegin,clipEnd,selfProps,dict_buf);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 根据是否为最后一个 clip，向流中输出不同的控制码。</span></span><br><span class="line">            <span class="keyword">if</span> (!isToStreamEnd)</span><br><span class="line">                coder.outCtrl_clipEnd();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                coder.outCtrl_streamEnd();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 跟踪并更新实际使用到的最大字典大小。</span></span><br><span class="line">            curDictSizeMax=<span class="built_in">std</span>::max(curDictSizeMax,coder.getCurDictSizeMax());</span><br><span class="line">            <span class="comment">// 将当前 clip 压缩后的数据刷新到输出流。</span></span><br><span class="line">            _flush_code(out_code,cur_out_pos,code);</span><br><span class="line">            <span class="keyword">if</span> (isToStreamEnd) <span class="keyword">break</span>; <span class="comment">// 如果已到数据末尾，则退出循环。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 5. 更新文件头中的字典大小 (优化) ---</span></span><br><span class="line">    &#123;<span class="comment">//update dictSize</span></span><br><span class="line">        checkv(curDictSizeMax&lt;=selfProps.dictSize);</span><br><span class="line">        <span class="comment">// 如果实际使用的最大字典大小 小于 文件头中最初记录的值。</span></span><br><span class="line">        <span class="keyword">if</span> (curDictSizeMax&lt;selfProps.dictSize)&#123;</span><br><span class="line">            assert(code.empty());</span><br><span class="line">            TTuzCode <span class="title function_">coder</span><span class="params">(code,selfProps.isNeedLiteralLine)</span>;</span><br><span class="line">            <span class="comment">// 重新编码一个更小的、精确的字典大小。</span></span><br><span class="line">            coder.outDictSize(curDictSizeMax);</span><br><span class="line">            hpatch_StreamPos_t dict_out_pos=<span class="number">0</span>; <span class="comment">// 设定写入位置为0，即覆盖原文件头。</span></span><br><span class="line">            _flush_code(out_code,dict_out_pos,code);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回压缩后的总字节数。</span></span><br><span class="line">    <span class="keyword">return</span> cur_out_pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="tinyuz-compress-tuz-enc-private-tuz-enc-clip-cpp"><a href="#tinyuz-compress-tuz-enc-private-tuz-enc-clip-cpp" class="headerlink" title="tinyuz\compress\tuz_enc_private\tuz_enc_clip.cpp"></a>tinyuz\compress\tuz_enc_private\tuz_enc_clip.cpp</h1><h2 id="compress-clip-Tuz-数据块压缩核心逻辑"><a href="#compress-clip-Tuz-数据块压缩核心逻辑" class="headerlink" title="compress_clip Tuz 数据块压缩核心逻辑"></a>compress_clip <strong>Tuz 数据块压缩核心逻辑</strong></h2><ul><li>作为 <code>tuz_compress</code> 调用的核心工作函数，负责对单个数据块（clip）执行实际的 LZ77-style 压缩算法。</li></ul><h3 id="原理与设计思路解析-1"><a href="#原理与设计思路解析-1" class="headerlink" title="原理与设计思路解析"></a><strong>原理与设计思路解析</strong></h3><p><code>compress_clip</code> 函数是 Tuz 压缩算法的心脏。它接收一个明确的数据范围（<code>clipBegin</code> 到 <code>clipEnd</code>），并利用一个“滑动窗口”（由 <code>TDictBuf</code> 维护）作为字典来查找和编码重复的数据序列。</p><ul><li><p><strong>核心原理: 滑动窗口压缩 (Sliding Window)</strong><br>函数的核心思想是在一个连续的内存缓冲区中进行操作。这个缓冲区不仅包含当前需要压缩的数据块（clip），还包含了紧接在该数据块之前的、作为“字典”使用的数据。</p><ol><li><strong>数据准备:</strong> 在压缩开始前，函数会创建一个足够大的内存缓冲区 <code>data_buf</code>。它首先计算出需要的字典数据的起始位置 <code>dictBeginPos</code>，然后将从 <code>dictBeginPos</code> 到 <code>clipEnd</code> 的所有数据一次性读入这个缓冲区。</li><li><strong>高效读取:</strong> 为了提高效率，这里有一个重要的优化。如果前一个 clip 处理后留下的字典数据（存储在 <code>dict_buf</code> 中）与当前 clip 所需的字典有重叠，它会通过 <code>memmove</code> 将这部分重叠数据移动到新缓冲区的起始位置，然后只从输入流中读取剩余的新数据。这避免了对同一数据区域的重复读取。</li><li><strong>迭代匹配:</strong> 函数使用一个 <code>TMatch</code> 对象，从当前 clip 的起始位置开始，逐字节地向后扫描 (<code>cur</code> 指针)。在每个位置，<code>matcher.match()</code> 会在 <code>cur</code> 指针之前的整个字典+已压缩区域中，寻找与当前位置开始的数据序列最长的匹配项。</li><li><strong>两种编码输出:</strong><ul><li><strong>字面量 (Literals):</strong> 如果在 <code>cur</code> 位置<strong>没有找到</strong>足够长的匹配项，<code>cur</code> 指针就向后移动一个字节。从上一个匹配结束的位置 (<code>back</code> 指针) 到当前 <code>cur</code> 指针之间的所有字节，都构成了“字面量”序列，即无法被压缩的原始数据。</li><li><strong>字典引用 (References):</strong> 如果<strong>找到了</strong>一个匹配项，那么之前累积的字面量序列（<code>back</code> 到 <code>cur</code> 之间的数据）会首先被输出。然后，找到的匹配项会被编码成一个**(匹配长度, 字典距离)**的引用对，并输出到压缩流。最后，<code>cur</code> 指针会一次性跳过整个匹配的长度。</li></ul></li><li><strong>字典“滑动”:</strong> 当一个 clip 处理完毕后，它本身就变成了历史数据。函数会执行“滑动”操作：保留 <code>data_buf</code> 中尾部的、大小等于字典大小的数据，并将其移动到缓冲区的开头。这部分数据将作为<strong>下一个 clip</strong> 的字典。这个过程由 <code>update dict</code> 代码块完成，它更新 <code>dict_buf</code> 的状态，为下一次调用 <code>compress_clip</code> 做好了准备。</li></ol></li><li><p><strong>设计优点</strong></p><ul><li><strong>高效性:</strong> 将字典和待压缩数据全部置于一个连续的内存块中，使得匹配查找操作可以极快地进行，避免了频繁的 I&#x2F;O 操作。</li><li><strong>内存可控:</strong> 滑动窗口机制确保了内存使用量是可控的，其上限大致为“字典大小 + clip大小”，而与被压缩文件的总大小无关。</li><li><strong>模块化:</strong> 将具体的压缩匹配逻辑封装在 <code>compress_clip</code> 中，使得上层的 <code>tuz_compress</code> 函数可以专注于数据流的划分、多线程调度等宏观任务，实现了关注点分离。</li></ul></li></ul><h3 id="代码解析-1"><a href="#代码解析-1" class="headerlink" title="代码解析"></a><strong>代码解析</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">namespace _tuz_private&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 输出一段连续的、未匹配的字面量数据。</span></span><br><span class="line"><span class="comment">     * @param back            字面量数据的起始指针。</span></span><br><span class="line"><span class="comment">     * @param unmatched_len   字面量数据的长度。</span></span><br><span class="line"><span class="comment">     * @param coder           编码器实例，用于输出。</span></span><br><span class="line"><span class="comment">     * @param props           压缩配置，主要用于获取 maxSaveLength。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">static</span> <span class="type">void</span> _outData(<span class="type">const</span> tuz_byte* back,<span class="type">size_t</span> unmatched_len,</span><br><span class="line">                         _tuz_private::TTuzCode&amp; coder,<span class="type">const</span> tuz_TCompressProps&amp; props)&#123;</span><br><span class="line">        <span class="comment">// 由于编码器可能对一次性输出的长度有限制(maxSaveLength)，</span></span><br><span class="line">        <span class="comment">// 这里使用循环来确保超长的数据也能被正确分块输出。</span></span><br><span class="line">        <span class="keyword">while</span> (unmatched_len)&#123;</span><br><span class="line">            <span class="type">size_t</span> len=(unmatched_len&lt;=props.maxSaveLength)?unmatched_len:props.maxSaveLength;</span><br><span class="line">            coder.outData(back,back+len); <span class="comment">// 调用编码器输出一个数据块。</span></span><br><span class="line">            back+=len;</span><br><span class="line">            unmatched_len-=len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 对单个数据块 (clip) 执行压缩。</span></span><br><span class="line"><span class="comment"> * @param coder      编码器实例，所有压缩结果（字面量或引用）都通过它输出。</span></span><br><span class="line"><span class="comment"> * @param data       原始数据输入流。</span></span><br><span class="line"><span class="comment"> * @param clipBegin  当前数据块在整个流中的起始位置。</span></span><br><span class="line"><span class="comment"> * @param clipEnd    当前数据块在整个流中的结束位置。</span></span><br><span class="line"><span class="comment"> * @param props      压缩参数配置。</span></span><br><span class="line"><span class="comment"> * @param dict_buf   字典缓冲区，用于在不同 clip 调用之间传递和维护字典数据。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">compress_clip</span><span class="params">(TTuzCode&amp; coder,<span class="type">const</span> hpatch_TStreamInput* data,hpatch_StreamPos_t clipBegin,</span></span><br><span class="line"><span class="params">                   hpatch_StreamPos_t clipEnd,<span class="type">const</span> tuz_TCompressProps&amp; props,TDictBuf&amp; dict_buf)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// --- 1. 准备内存缓冲区，用于存放 字典 + 当前clip ---</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;tuz_byte&gt;&amp; <span class="title function_">data_buf</span><span class="params">(dict_buf.dictBuf)</span>; <span class="comment">// 使用传入的字典缓冲区。</span></span><br><span class="line">    hpatch_StreamPos_t dictBeginPos; <span class="comment">// 字典在整个数据流中的起始位置。</span></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> dictSizeBack=data_buf.size(); <span class="comment">// 记录进入函数时，缓冲区中已有的旧字典数据大小。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 计算字典的起始位置。不能早于文件头，最多向前追溯 dictSize 个字节。</span></span><br><span class="line">        dictBeginPos=(clipBegin&lt;=props.dictSize)?<span class="number">0</span>:(clipBegin-props.dictSize);</span><br><span class="line">        <span class="comment">// 计算需要的总内存大小 = (clipEnd - dictBeginPos)。</span></span><br><span class="line">        hpatch_StreamPos_t _mem_size=clipEnd-dictBeginPos;</span><br><span class="line">        checkv(_mem_size==(<span class="type">size_t</span>)_mem_size); <span class="comment">// 确保大小没有溢出 size_t。</span></span><br><span class="line">        checkv(_mem_size&gt;=data_buf.size()); <span class="comment">// 新大小必须不小于旧大小。</span></span><br><span class="line">        <span class="comment">// 将缓冲区调整到所需大小。</span></span><br><span class="line">        data_buf.resize((<span class="type">size_t</span>)_mem_size);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// --- 2. 从输入流读取数据到缓冲区 (滑动窗口优化) ---</span></span><br><span class="line">    &#123;<span class="comment">//read data</span></span><br><span class="line">        hpatch_StreamPos_t readPos=dictBeginPos; <span class="comment">// 计划从字典起始位置开始读取。</span></span><br><span class="line">        <span class="comment">// 如果上一个 clip 留下的字典数据 (dict_buf.dictEndPos) 在我们要读的范围之内...</span></span><br><span class="line">        <span class="keyword">if</span> (dict_buf.dictEndPos&gt;readPos)&#123;</span><br><span class="line">            checkv(dict_buf.dictEndPos&lt;=clipBegin);</span><br><span class="line">            <span class="type">size_t</span> movLen=(<span class="type">size_t</span>)(dict_buf.dictEndPos-readPos); <span class="comment">// 计算重叠数据的长度。</span></span><br><span class="line">            checkv(dictSizeBack&gt;=movLen);</span><br><span class="line">            <span class="keyword">if</span> (dictSizeBack-movLen&gt;<span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 【优化】将上一次的旧字典数据中需要保留的部分，移动到缓冲区的正确位置。</span></span><br><span class="line">                memmove(data_buf.data(),data_buf.data()+dictSizeBack-movLen,movLen);</span><br><span class="line">            readPos=dict_buf.dictEndPos; <span class="comment">// 更新读取位置，只需读取后面新的数据即可。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从流中读取剩余需要的数据，填充到缓冲区的后半部分。</span></span><br><span class="line">        checkv(data-&gt;read(data,readPos,data_buf.data()+(<span class="type">size_t</span>)(readPos-dictBeginPos),data_buf.data()+data_buf.size()));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// --- 3. 执行核心的匹配与编码循环 ---</span></span><br><span class="line">    <span class="comment">// 创建匹配器实例，它将在 data_buf 中进行查找。</span></span><br><span class="line">    TMatch   <span class="title function_">matcher</span><span class="params">(data_buf.data(),data_buf.data()+data_buf.size(),coder,props)</span>;</span><br><span class="line">    &#123;<span class="comment">//match loop</span></span><br><span class="line">        <span class="type">const</span> tuz_byte* end=data_buf.data()+data_buf.size();</span><br><span class="line">        <span class="comment">// `cur` 是当前扫描指针，指向 clip 在缓冲区中的起始位置。</span></span><br><span class="line">        <span class="type">const</span> tuz_byte* cur=end-(clipEnd-clipBegin);</span><br><span class="line">        <span class="comment">// `back` 指针用于标记当前未匹配的字面量序列的开始位置。</span></span><br><span class="line">        <span class="type">const</span> tuz_byte* back=cur;</span><br><span class="line">        <span class="keyword">while</span> (cur!=end)&#123; <span class="comment">// 循环直到处理完整个 clip。</span></span><br><span class="line">            <span class="type">const</span> tuz_byte*     matched;</span><br><span class="line">            <span class="type">size_t</span>              match_len;</span><br><span class="line">            <span class="comment">// 尝试在当前 `cur` 位置进行匹配。</span></span><br><span class="line">            <span class="keyword">if</span> (matcher.match(&amp;matched,&amp;match_len,cur))&#123;</span><br><span class="line">                <span class="comment">// **分支1: 找到匹配**</span></span><br><span class="line">                checkv(matched&lt;cur); <span class="comment">// 匹配位置必须在当前位置之前。</span></span><br><span class="line">                checkv(matched&gt;=data_buf.data()); <span class="comment">// 匹配位置不能越界。</span></span><br><span class="line">                checkv(cur+match_len&lt;=end); <span class="comment">// 匹配长度不能越界。</span></span><br><span class="line">                checkv(match_len&gt;=tuz_kMinDictMatchLen);</span><br><span class="line">                checkv(match_len&lt;=props.maxSaveLength);</span><br><span class="line">                <span class="comment">// 计算从上个匹配点到当前点之间的字面量长度。</span></span><br><span class="line">                <span class="type">const</span> <span class="type">size_t</span> unmatched_len=(cur-back);</span><br><span class="line">                <span class="keyword">if</span> (unmatched_len&gt;<span class="number">0</span>)</span><br><span class="line">                    _outData(back,unmatched_len,coder,props); <span class="comment">// 输出这段字面量。</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 计算匹配位置相对于当前位置的距离（字典位置）。</span></span><br><span class="line">                <span class="type">size_t</span> dict_pos=(cur-matched)<span class="number">-1</span>;</span><br><span class="line">                checkv(dict_pos&lt;props.dictSize);</span><br><span class="line">                <span class="comment">// 调用编码器输出 (长度, 距离) 引用。</span></span><br><span class="line">                coder.outDict(match_len,dict_pos);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 向前跳过整个匹配的长度。</span></span><br><span class="line">                cur+=match_len;</span><br><span class="line">                back=cur; <span class="comment">// 重置字面量起始点。</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// **分支2: 未找到匹配**</span></span><br><span class="line">                <span class="comment">// 将当前字节视为字面量的一部分，仅移动指针。</span></span><br><span class="line">                ++cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 循环结束后，处理可能遗留的最后一段字面量。</span></span><br><span class="line">        <span class="type">const</span> <span class="type">size_t</span> unmatched_len=(cur-back);</span><br><span class="line">        <span class="keyword">if</span> (unmatched_len&gt;<span class="number">0</span>)</span><br><span class="line">            _outData(back,unmatched_len,coder,props);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// --- 4. 更新字典，为处理下一个 clip 做准备 (滑动窗口) ---</span></span><br><span class="line">    &#123; <span class="comment">//update dict</span></span><br><span class="line">        <span class="comment">// 计算下一个 clip 需要的字典大小。</span></span><br><span class="line">        <span class="type">size_t</span> newDictSize=(props.dictSize&lt;=clipEnd)?props.dictSize:(<span class="type">size_t</span>)clipEnd;</span><br><span class="line">        checkv(data_buf.size()&gt;=newDictSize);</span><br><span class="line">        dict_buf.dictEndPos=clipEnd; <span class="comment">// 更新字典在流中的结束位置。</span></span><br><span class="line">        <span class="keyword">if</span> (data_buf.size()&gt;newDictSize)&#123;</span><br><span class="line">            <span class="comment">// 将当前处理完的数据的尾部 (即新的字典内容) 移动到缓冲区的开头。</span></span><br><span class="line">            memmove(data_buf.data(),data_buf.data()+(data_buf.size()-newDictSize),newDictSize);</span><br><span class="line">            <span class="comment">// 缩小缓冲区，释放不再需要的内存。</span></span><br><span class="line">            data_buf.resize(newDictSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="tinyuz-decompress-tuz-dec-c"><a href="#tinyuz-decompress-tuz-dec-c" class="headerlink" title="tinyuz\decompress\tuz_dec.c"></a>tinyuz\decompress\tuz_dec.c</h1><h2 id="tuz-TStream-read-dict-size-Tuz-文件头解析：读取字典大小"><a href="#tuz-TStream-read-dict-size-Tuz-文件头解析：读取字典大小" class="headerlink" title="tuz_TStream_read_dict_size Tuz 文件头解析：读取字典大小"></a>tuz_TStream_read_dict_size <strong>Tuz 文件头解析：读取字典大小</strong></h2><h3 id="原理与设计思路解析-2"><a href="#原理与设计思路解析-2" class="headerlink" title="原理与设计思路解析"></a><strong>原理与设计思路解析</strong></h3><p><code>tuz_TStream_read_dict_size</code> 函数是任何 Tuz 解压操作的第一步。它的职责单一且至关重要：读取文件最开头的几个字节，并将它们转换成一个整数，这个整数代表了解压过程所需要的字典缓冲区的大小。</p><ul><li><p><strong>固定长度头部 (Fixed-Length Header)</strong><br>Tuz 格式规定，压缩流的起始位置固定存储着字典的大小值。这个值占用的字节数由一个编译时常量 <code>tuz_kDictSizeSavedBytes</code> 决定。这种设计使得头部解析非常快速和简单。</p></li><li><p><strong>I&#x2F;O 抽象 (I&#x2F;O Abstraction)</strong><br>为了让解压库能够适应不同的输入源（例如，从磁盘文件、内存缓冲区或网络流读取），此函数的设计并没有直接调用 <code>fread</code> 等具体的 I&#x2F;O 函数。相反，它接受一个函数指针 <code>read_code</code> 作为参数。调用者必须提供一个符合 <code>tuz_TInputStream_read</code> 签名的函数，<code>tuz_TStream_read_dict_size</code> 会通过这个回调函数来完成实际的字节读取。这是一种典型的接口与实现分离的设计，增强了代码的通用性和可移植性。</p></li><li><p><strong>小端序编码 (Little-Endian Encoding)</strong><br>从文件中读取的字节数组需要被转换成一个多字节的整数。该函数遵循<strong>小端序 (Little-Endian)</strong> 的字节序约定。这意味着字节数组中的第一个字节 (<code>saved[0]</code>) 是整数的最低有效位字节 (Least Significant Byte, LSB)，第二个字节 (<code>saved[1]</code>) 是次低位，以此类推。</p></li><li><p><strong>编译时优化 (Compile-Time Optimization)</strong><br>代码中使用了 <code>#if</code>&#x2F;<code>#elif</code> 预处理指令，而不是运行时的 <code>switch</code> 或 <code>if</code> 语句。这是因为字典大小占用的字节数 <code>tuz_kDictSizeSavedBytes</code> 是一个在编译时就确定的常量。通过使用预处理器，编译器只会将与该常量值匹配的代码块编译进最终的程序中，从而生成更小、更快的机器码。例如，如果 <code>tuz_kDictSizeSavedBytes</code> 被定义为 <code>4</code>，那么所有其他分支（<code>==1</code>, <code>==2</code>, <code>==3</code>）的代码都不会出现在最终的可执行文件中。</p></li></ul><h3 id="代码解析-2"><a href="#代码解析-2" class="headerlink" title="代码解析"></a><strong>代码解析</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 从 Tuz 压缩流的开头读取并解析出字典大小。</span></span><br><span class="line"><span class="comment"> * @param inputStream   输入流的句柄。</span></span><br><span class="line"><span class="comment"> * @param read_code     用于从输入流读取数据的函数指针（回调函数）。</span></span><br><span class="line"><span class="comment"> * @return tuz_size_t   成功则返回解析出的字典大小（一个正整数），失败则返回 0。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">tuz_size_t</span> <span class="title function_">tuz_TStream_read_dict_size</span><span class="params">(tuz_TInputStreamHandle inputStream,tuz_TInputStream_read read_code)</span>&#123;</span><br><span class="line">    <span class="comment">// `v` 被初始化为要读取的字节数，这个值之后会被 read_code 函数更新为实际读取的字节数。</span></span><br><span class="line">    <span class="type">tuz_size_t</span> v=tuz_kDictSizeSavedBytes;</span><br><span class="line">    <span class="comment">// `saved` 是一个临时缓冲区，用于存放从流中读取的原始字节。</span></span><br><span class="line">    tuz_byte   saved[tuz_kDictSizeSavedBytes];</span><br><span class="line">    <span class="comment">// 断言，确保调用者提供了一个有效的读取函数。</span></span><br><span class="line">    assert(read_code!=<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用回调函数读取数据，并检查是否成功读取了预期的字节数。</span></span><br><span class="line">    <span class="keyword">if</span> ((read_code(inputStream,saved,&amp;v))&amp;&amp;(v==tuz_kDictSizeSavedBytes))&#123;</span><br><span class="line">        <span class="comment">// --- 核心逻辑：根据预设的字节数，将字节数组（小端序）转换为整数 ---</span></span><br><span class="line">        </span><br><span class="line">        <span class="meta">#<span class="keyword">if</span> (tuz_kDictSizeSavedBytes==1) <span class="comment">// 如果字典大小只用1个字节存储</span></span></span><br><span class="line">            v=saved[<span class="number">0</span>];</span><br><span class="line">            assert(v&gt;<span class="number">0</span>); <span class="comment">// 字典大小必须为正数。</span></span><br><span class="line">        <span class="meta">#<span class="keyword">elif</span> (tuz_kDictSizeSavedBytes==2) <span class="comment">// 如果用2个字节存储</span></span></span><br><span class="line">            <span class="comment">// saved[0] 是低8位。</span></span><br><span class="line">            <span class="comment">// saved[1] 左移8位后成为高8位，然后通过按位或(|)与 saved[0] 合并。</span></span><br><span class="line">            v=saved[<span class="number">0</span>]|(((<span class="type">tuz_size_t</span>)saved[<span class="number">1</span>])&lt;&lt;<span class="number">8</span>);</span><br><span class="line">            <span class="comment">// 断言检查：v必须为正，且通过右移操作可以还原出原始的 saved[1] 字节。</span></span><br><span class="line">            assert((v&gt;<span class="number">0</span>)&amp;(((v&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xFF</span>)==saved[<span class="number">1</span>]));</span><br><span class="line">        <span class="meta">#<span class="keyword">elif</span> (tuz_kDictSizeSavedBytes==3) <span class="comment">// 如果用3个字节存储</span></span></span><br><span class="line">            v=saved[<span class="number">0</span>]|(((<span class="type">tuz_size_t</span>)saved[<span class="number">1</span>])&lt;&lt;<span class="number">8</span>)|(((<span class="type">tuz_size_t</span>)saved[<span class="number">2</span>])&lt;&lt;<span class="number">16</span>);</span><br><span class="line">            assert((v&gt;<span class="number">0</span>)&amp;(((v&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xFF</span>)==saved[<span class="number">1</span>])&amp;((v&gt;&gt;<span class="number">16</span>)==saved[<span class="number">2</span>]));</span><br><span class="line">        <span class="meta">#<span class="keyword">elif</span> (tuz_kDictSizeSavedBytes==4) <span class="comment">// 如果用4个字节存储</span></span></span><br><span class="line">            v=saved[<span class="number">0</span>]|(((<span class="type">tuz_size_t</span>)saved[<span class="number">1</span>])&lt;&lt;<span class="number">8</span>)|(((<span class="type">tuz_size_t</span>)saved[<span class="number">2</span>])&lt;&lt;<span class="number">16</span>)|(((<span class="type">tuz_size_t</span>)saved[<span class="number">3</span>])&lt;&lt;<span class="number">24</span>);</span><br><span class="line">            assert((v&gt;<span class="number">0</span>)&amp;(((v&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xFF</span>)==saved[<span class="number">1</span>])&amp;(((v&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xFF</span>)==saved[<span class="number">2</span>])&amp;((v&gt;&gt;<span class="number">24</span>)==saved[<span class="number">3</span>]));</span><br><span class="line">        <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="meta">#   <span class="keyword">error</span> unsupport tuz_kDictSizeSavedBytes <span class="comment">// 如果配置了不支持的字节数，编译将失败。</span></span></span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回成功转换后的字典大小。</span></span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">// 如果读取失败或读取的字节数不足</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回0表示错误。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="tuz-TStream-decompress-partial-Tuz-流式解压核心状态机"><a href="#tuz-TStream-decompress-partial-Tuz-流式解压核心状态机" class="headerlink" title="tuz_TStream_decompress_partial Tuz 流式解压核心状态机"></a>tuz_TStream_decompress_partial <strong>Tuz 流式解压核心状态机</strong></h2><ul><li>作为流式解压模型的核心，此函数负责执行实际的解压工作。它的设计精髓在于作为一个<strong>可重入 (Re-entrant) 的状态机</strong>，能够根据提供的输出缓冲区大小，解压部分或全部数据，并在暂停后能从断点处精确恢复。</li></ul><h3 id="原理与设计思路解析-3"><a href="#原理与设计思路解析-3" class="headerlink" title="原理与设计思路解析"></a><strong>原理与设计思路解析</strong></h3><p><code>tuz_TStream_decompress_partial</code> 的设计核心是一个基于 <code>goto</code> 和状态变量的、高度优化的主循环。它模拟了一个状态机，可以在几个核心状态之间切换：<strong>“从字典复制”</strong>、<strong>“从输入流复制字面量”</strong>（可选编译）、以及**“解析新指令”**。</p><ul><li><p><strong>状态机设计 (State Machine Design)</strong><br>函数的所有内部状态（例如，还需从字典复制多少字节、上一次的匹配距离是多少等）都保存在 <code>tuz_TStream* self</code> 结构体中。这使得函数调用是无状态的，两次调用之间所有的上下文都由 <code>self</code> 携带。</p><ul><li><strong>状态1: 从字典复制 (<code>copyDict_cmp_process</code>)</strong>: 当 <code>self-&gt;_state.dictType_len &gt; 0</code> 时，函数处于此状态。它的任务就是循环地从环形字典中读取字节，写入输出区，直到 <code>dictType_len</code> 减为0或者输出缓冲区 <code>cur_out_data</code> 已满。</li><li><strong>状态2: 复制字面量 (<code>copyLiteral_cmp_process</code>)</strong>: 仅在 <code>tuz_isNeedLiteralLine</code> 宏启用时存在。当 <code>self-&gt;_state.literalType_len &gt; 0</code> 时，函数处于此状态。它直接从压缩输入流中读取原始字节，写入输出区。</li><li><strong>状态3: 解析新指令 (<code>type_process</code>)</strong>: 当没有任何复制任务时，函数进入此状态。这是状态机的决策中心，它会从位流中读取并解析下一个指令。</li></ul></li><li><p><strong>部分解压 (Partial Decompression) 的实现</strong><br>此函数的最大特点是能够“干多少活，给多少空间”。</p><ol><li><strong>输出驱动 (Output-Driven):</strong> 在每个状态的循环中，第一件事就是检查输出缓冲区是否已满 (<code>cur_out_data &lt; out_data_end</code>)。</li><li><strong>暂停与恢复:</strong> 一旦输出缓冲区满了，循环就会通过 <code>break</code> 语句退出。因为所有的进度（如 <code>dictType_len</code> 剩余长度、输入流的当前位置、位流缓冲区的状态等）都完整地保存在 <code>self</code> 结构体中，所以当外部调用者清空或更换输出缓冲区并再次调用此函数时，它能无缝地从上次 <code>break</code> 的地方继续执行。</li><li><strong>指令回退 (<code>_cache_push_1bit</code>)</strong>: 一个精巧的设计是，当在“解析新指令”状态下准备处理一个字面量，却发现输出缓冲区已满时，它会调用 <code>_cache_push_1bit</code> 将刚刚读出的那个决定性的类型比特“推”回位流缓冲区。这确保了下次函数被调用时，能重新读到这个比特，做出和这次完全一样的决策，保证了状态的一致性。</li></ol></li><li><p><strong>设计优点</strong></p><ul><li><strong>极低的内存占用:</strong> 无需一次性为整个解压后的文件分配内存，只需要一个固定大小的字典和一个可由用户控制大小的输出缓冲区。</li><li><strong>高度灵活:</strong> 调用者可以根据系统资源情况，决定每次解压多大的数据块，非常适合内存受限的嵌入式系统或处理流式数据。</li><li><strong>高性能:</strong> 使用 <code>goto</code> 来直接跳转到对应的处理逻辑块，避免了传统 <code>switch</code> 语句或多次 <code>if-else</code> 判断可能带来的开销，使得在主循环内的状态切换非常快。</li></ul></li></ul><h3 id="代码解析-3"><a href="#代码解析-3" class="headerlink" title="代码解析"></a><strong>代码解析</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 执行部分流式解压。</span></span><br><span class="line"><span class="comment"> * @param self           指向 Tuz 解压流状态机的指针。</span></span><br><span class="line"><span class="comment"> * @param cur_out_data   指向输出缓冲区的起始位置。</span></span><br><span class="line"><span class="comment"> * @param data_size      输入时表示缓冲区大小，函数返回时表示实际解压出的数据大小。</span></span><br><span class="line"><span class="comment"> * @return tuz_TResult   返回解压结果，如 tuz_OK, tuz_STREAM_END 等。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">tuz_TResult <span class="title function_">tuz_TStream_decompress_partial</span><span class="params">(tuz_TStream* self,tuz_byte* cur_out_data,<span class="type">tuz_size_t</span>* data_size)</span>&#123;</span><br><span class="line">    <span class="comment">// 计算输出缓冲区的末尾指针，用于边界检查。</span></span><br><span class="line">    tuz_byte* <span class="type">const</span> out_data_end=cur_out_data+(*data_size);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __RUN_MEM_SAFE_CHECK</span></span><br><span class="line">    <span class="type">const</span> tuz_BOOL isNeedOut=(cur_out_data&lt;out_data_end);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 主解码循环，这是一个无限循环，依靠内部的 break 或 return 退出。</span></span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">      <span class="comment">// --- 状态1: 正在从字典复制数据 ---</span></span><br><span class="line">      copyDict_cmp_process:</span><br><span class="line">        <span class="keyword">if</span> (self-&gt;_state.dictType_len)&#123; <span class="comment">// 检查是否有待复制的字典数据。</span></span><br><span class="line">            <span class="keyword">if</span> (cur_out_data&lt;out_data_end)&#123; <span class="comment">// 检查输出缓冲区是否已满。</span></span><br><span class="line">                <span class="type">const</span> tuz_byte bdata=_dict_read_byte(self); <span class="comment">// 从环形字典读取一个字节。</span></span><br><span class="line">                _dict_write_byte(self,bdata);              <span class="comment">// 将该字节写回字典（实现滑动窗口）。</span></span><br><span class="line">                *cur_out_data++=bdata;                     <span class="comment">// 将字节写入输出缓冲区。</span></span><br><span class="line">                self-&gt;_state.dictType_len--;               <span class="comment">// 待复制长度减一。</span></span><br><span class="line">                <span class="keyword">goto</span> copyDict_cmp_process; <span class="comment">// 跳转回循环开始，继续复制下一个字节。</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 输出缓冲区已满，退出主循环，暂停解压。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">#<span class="keyword">if</span> tuz_isNeedLiteralLine <span class="comment">// 这部分代码仅在特定编译选项下生效。</span></span></span><br><span class="line">      <span class="comment">// --- 状态2: 正在从输入流复制字面量行 ---</span></span><br><span class="line">      copyLiteral_cmp_process:</span><br><span class="line">        <span class="keyword">if</span> (self-&gt;_state.literalType_len)&#123;</span><br><span class="line">            <span class="keyword">if</span> (cur_out_data&lt;out_data_end)&#123;</span><br><span class="line">                <span class="type">const</span> tuz_byte bdata=_cache_read_1byte(&amp;self-&gt;_code_cache); <span class="comment">// 直接从输入流缓存读字节。</span></span><br><span class="line">                _dict_write_byte(self,bdata); <span class="comment">// 写入字典。</span></span><br><span class="line">                *cur_out_data++=bdata;        <span class="comment">// 写入输出。</span></span><br><span class="line">                self-&gt;_state.literalType_len--;</span><br><span class="line">                <span class="keyword">goto</span> copyLiteral_cmp_process; <span class="comment">// 继续复制。</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 输出缓冲区已满。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// --- 状态3: 读取并解析新的类型码 ---</span></span><br><span class="line">    type_process:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 从位流中读取1个比特作为类型标志。</span></span><br><span class="line">            <span class="keyword">if</span> (_cache_read_1bit(self)==tuz_codeType_dict)&#123;</span><br><span class="line">                <span class="comment">// **分支 A: 类型为 字典引用 或 控制码**</span></span><br><span class="line">                <span class="type">tuz_size_t</span> saved_len=_cache_unpack_len(self); <span class="comment">// 解码长度。</span></span><br><span class="line">                <span class="type">tuz_size_t</span> saved_dict_pos;</span><br><span class="line">                <span class="comment">// 检查是否是“使用上一次距离”的优化编码 (1个比特)。</span></span><br><span class="line">                <span class="keyword">if</span> ((self-&gt;_state.isHaveData_back)&amp;&amp;(_cache_read_1bit(self)))&#123;</span><br><span class="line">                    saved_dict_pos=self-&gt;_state.dict_pos_back;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    saved_dict_pos=_cache_unpack_dict_pos(self); <span class="comment">// 解码完整的距离。</span></span><br><span class="line">                    <span class="keyword">if</span> (saved_dict_pos&gt;tuz_kBigPosForLen) ++saved_len; <span class="comment">// 一个特殊优化。</span></span><br><span class="line">                &#125;</span><br><span class="line">                self-&gt;_state.isHaveData_back=tuz_FALSE;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (saved_dict_pos)&#123; <span class="comment">// **这是一个字典匹配 (距离 &gt; 0)**</span></span><br><span class="line">                    self-&gt;_state.dict_pos_back=saved_dict_pos; <span class="comment">// 保存本次距离，以备下次使用。</span></span><br><span class="line">                    self-&gt;_state.dictType_len=saved_len+tuz_kMinDictMatchLen; <span class="comment">// 设置待复制总长度。</span></span><br><span class="line">                    <span class="comment">// 将解码出的相对距离转换为在环形字典中的绝对偏移。</span></span><br><span class="line">                    saved_dict_pos=(self-&gt;_dict.dict_size-saved_dict_pos);</span><br><span class="line">                    self-&gt;_state.dictType_pos=saved_dict_pos;</span><br><span class="line">                    <span class="comment">// 跳转到主循环开头，进入“从字典复制”状态。</span></span><br><span class="line">                    <span class="keyword">continue</span>; </span><br><span class="line">                &#125;<span class="keyword">else</span>&#123; <span class="comment">// **这是一个控制码 (距离 == 0)**</span></span><br><span class="line">                  <span class="meta">#<span class="keyword">if</span> tuz_isNeedLiteralLine</span></span><br><span class="line">                    <span class="keyword">if</span> (tuz_ctrlType_literalLine==saved_len)&#123;</span><br><span class="line">                        self-&gt;_state.isHaveData_back=tuz_TRUE;</span><br><span class="line">                        self-&gt;_state.literalType_len=_cache_unpack_pos_len(self)+tuz_kMinLiteralLen;</span><br><span class="line">                        <span class="keyword">continue</span>; <span class="comment">// 跳转到主循环开头，进入“复制字面量”状态。</span></span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">                    self-&gt;_state.dict_pos_back=<span class="number">1</span>; <span class="comment">// 重置“上一次距离”。</span></span><br><span class="line">                    self-&gt;_state.type_count=<span class="number">0</span>;    <span class="comment">// 控制码后是对齐的，重置位流缓冲。</span></span><br><span class="line">                    <span class="keyword">if</span> (tuz_ctrlType_clipEnd==saved_len)&#123; <span class="comment">// clip 结束标志。</span></span><br><span class="line">                        <span class="keyword">goto</span> type_process; <span class="comment">// 忽略，直接去解析下一个指令。</span></span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (tuz_ctrlType_streamEnd==saved_len)&#123; <span class="comment">// 流结束标志。</span></span><br><span class="line">                        <span class="comment">// 更新 data_size 为实际输出的字节数。</span></span><br><span class="line">                        (*data_size)-=(<span class="type">tuz_size_t</span>)(out_data_end-cur_out_data);</span><br><span class="line">                        <span class="keyword">return</span> tuz_STREAM_END; <span class="comment">// 解压成功结束。</span></span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">// 遇到了未知的控制码，返回错误。</span></span><br><span class="line">                        <span class="keyword">return</span> _cache_success_finish(&amp;self-&gt;_code_cache)?</span><br><span class="line">                                    tuz_CTRLTYPE_UNKNOW_ERROR:tuz_READ_CODE_ERROR;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// **分支 B: 类型为 字面量**</span></span><br><span class="line">                <span class="keyword">if</span> (cur_out_data&lt;out_data_end)&#123; <span class="comment">// 检查输出缓冲区是否已满。</span></span><br><span class="line">                    <span class="type">const</span> tuz_byte bdata=_cache_read_1byte(&amp;self-&gt;_code_cache); <span class="comment">// 从输入流读一个字节。</span></span><br><span class="line">                    _dict_write_byte(self,bdata); <span class="comment">// 写入字典。</span></span><br><span class="line">                    *cur_out_data++=bdata;      <span class="comment">// 写入输出。</span></span><br><span class="line">                    self-&gt;_state.isHaveData_back=tuz_TRUE;</span><br><span class="line">                    <span class="keyword">goto</span> type_process; <span class="comment">// 继续解析下一个指令。</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 输出缓冲区已满，将刚读的类型比特“退回”到位流缓冲。</span></span><br><span class="line">                    _cache_push_1bit(self,tuz_codeType_data);</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// 暂停解压。</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//end for</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 函数退出前的处理 ---</span></span><br><span class="line"><span class="comment">//return_process:</span></span><br><span class="line">    &#123;</span><br><span class="line">        assert(cur_out_data==out_data_end); <span class="comment">// 正常退出循环时，输出缓冲区必然是满的。</span></span><br><span class="line">        <span class="comment">// 如果输入流已经结束，但还有未完成的操作，说明压缩数据有误。</span></span><br><span class="line">        <span class="keyword">if</span> (!_cache_success_finish(&amp;self-&gt;_code_cache))</span><br><span class="line">            <span class="keyword">return</span> tuz_READ_CODE_ERROR;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据编译时安全检查选项返回结果。</span></span><br><span class="line">        <span class="meta">#<span class="keyword">ifdef</span> __RUN_MEM_SAFE_CHECK</span></span><br><span class="line">            <span class="keyword">return</span> isNeedOut?tuz_OK:tuz_OUT_SIZE_OR_CODE_ERROR;</span><br><span class="line">        <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            <span class="keyword">return</span> tuz_OK; <span class="comment">// 返回OK，表示成功填满了输出缓冲区。</span></span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;tinyuz-compress-tuz-enc-cpp&quot;&gt;&lt;a href=&quot;#tinyuz-compress-tuz-enc-cpp&quot; class=&quot;headerlink&quot; title=&quot;tinyuz&#92;compress&#92;tuz_enc.c</summary>
      
    
    
    
    <category term="hpatch" scheme="https://wdfk-prog.space/categories/hpatch/"/>
    
    
    <category term="hpatch" scheme="https://wdfk-prog.space/tags/hpatch/"/>
    
  </entry>
  
</feed>
